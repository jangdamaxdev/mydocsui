# Introduction

Nuxt is a free and [open-source framework](https://github.com/nuxt/nuxt){rel="nofollow"} with an intuitive and extendable way to create type-safe, performant and production-grade full-stack web applications and websites with [Vue.js](https://vuejs.org){rel="nofollow"}.

We made everything so you can start writing `.vue` files from the beginning while enjoying hot module replacement in development and a performant application in production with server-side rendering by default.

Nuxt has no vendor lock-in, allowing you to deploy your application [**everywhere, even on the edge**](https://nuxt.com/blog/nuxt-on-the-edge).

::tip
If you want to play around with Nuxt in your browser, you can [try it out in one of our online sandboxes](https://nuxt.com/docs/getting-started/installation#play-online).
::

## Automation and Conventions

Nuxt uses conventions and an opinionated directory structure to automate repetitive tasks and allow developers to focus on pushing features. The configuration file can still customize and override its default behaviors.

- **File-based routing:** define routes based on the structure of your [`app/pages/` directory](https://nuxt.com/docs/guide/directory-structure/app/pages). This can make it easier to organize your application and avoid the need for manual route configuration.
- **Code splitting:** Nuxt automatically splits your code into smaller chunks, which can help reduce the initial load time of your application.
- **Server-side rendering out of the box:** Nuxt comes with built-in SSR capabilities, so you don't have to set up a separate server yourself.
- **Auto-imports:** write Vue composables and components in their respective directories and use them without having to import them with the benefits of tree-shaking and optimized JS bundles.
- **Data-fetching utilities:** Nuxt provides composables to handle SSR-compatible data fetching as well as different strategies.
- **Zero-config TypeScript support:** write type-safe code without having to learn TypeScript with our auto-generated types and `tsconfig.json`.
- **Configured build tools:** we use [Vite](https://vite.dev){rel="nofollow"} by default to support hot module replacement (HMR) in development and bundling your code for production with best-practices baked-in.

Nuxt takes care of these and provides both frontend and backend functionality so you can focus on what matters: **creating your web application**.

## Server-Side Rendering

Nuxt comes with built-in server-side rendering (SSR) capabilities by default, without having to configure a server yourself, which has many benefits for web applications:

- **Faster initial page load time:** Nuxt sends a fully rendered HTML page to the browser, which can be displayed immediately. This can provide a faster perceived page load time and a better user experience (UX), especially on slower networks or devices.
- **Improved SEO:** search engines can better index SSR pages because the HTML content is available immediately, rather than requiring JavaScript to render the content on the client-side.
- **Better performance on low-powered devices:** it reduces the amount of JavaScript that needs to be downloaded and executed on the client-side, which can be beneficial for low-powered devices that may struggle with processing heavy JavaScript applications.
- **Better accessibility:** the content is immediately available on the initial page load, improving accessibility for users who rely on screen readers or other assistive technologies.
- **Easier caching:** pages can be cached on the server-side, which can further improve performance by reducing the amount of time it takes to generate and send the content to the client.

Overall, server-side rendering can provide a faster and more efficient user experience, as well as improve search engine optimization and accessibility.

As Nuxt is a versatile framework, it gives you the possibility to statically render your whole application to a static hosting with `nuxt generate`,
disable SSR globally with the `ssr: false` option or leverage hybrid rendering by setting up the `routeRules` option.

::read-more
---
title: Nuxt rendering modes
to: https://nuxt.com/docs/guide/concepts/rendering
---
::

### Server engine

The Nuxt server engine [Nitro](https://nitro.build/){rel="nofollow"} unlocks new full-stack capabilities.

In development, it uses Rollup and Node.js workers for your server code and context isolation. It also generates your server API by reading files in `server/api/` and server middleware from `server/middleware/`.

In production, Nitro builds your app and server into one universal `.output` directory. This output is light: minified and removed from any Node.js modules (except polyfills). You can deploy this output on any system supporting JavaScript, from Node.js, Serverless, Workers, Edge-side rendering or purely static.

::read-more
---
title: Nuxt server engine
to: https://nuxt.com/docs/guide/concepts/server-engine
---
::

### Production-ready

A Nuxt application can be deployed on a Node or Deno server, pre-rendered to be hosted in static environments, or deployed to serverless and edge providers.

::read-more
---
title: Deployment section
to: https://nuxt.com/docs/getting-started/deployment
---
::

### Modular

A module system allows you to extend Nuxt with custom features and integrations with third-party services.

::read-more
---
title: Nuxt Modules Concept
to: https://nuxt.com/docs/guide/concepts/modules
---
::

### Architecture

Nuxt is composed of different [core packages](https://github.com/nuxt/nuxt/tree/main/packages){rel="nofollow"}:

- Core engine: [nuxt](https://github.com/nuxt/nuxt/tree/main/packages/nuxt){rel="nofollow"}
- Bundlers: [@nuxt/vite-builder](https://github.com/nuxt/nuxt/tree/main/packages/vite){rel="nofollow"}, [@nuxt/rspack-builder](https://github.com/nuxt/nuxt/tree/main/packages/rspack){rel="nofollow"} and [@nuxt/webpack-builder](https://github.com/nuxt/nuxt/tree/main/packages/webpack){rel="nofollow"}
- Command line interface: [@nuxt/cli](https://github.com/nuxt/cli){rel="nofollow"}
- Server engine: [nitro](https://github.com/nitrojs/nitro){rel="nofollow"}
- Development kit: [@nuxt/kit](https://github.com/nuxt/nuxt/tree/main/packages/kit){rel="nofollow"}

We recommend reading each concept to have a full vision of Nuxt capabilities and the scope of each package.


# Installation

## Play Online

If you just want to play around with Nuxt in your browser without setting up a project, you can use one of our online sandboxes:

::card-group
  :::card
  ---
  icon: i-simple-icons-stackblitz
  target: _blank
  title: Open on StackBlitz
  to: https://nuxt.new/s/v4
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-codesandbox
  target: _blank
  title: Open on CodeSandbox
  to: https://nuxt.new/c/v4
  ---
  :::
::

Or follow the steps below to set up a new Nuxt project on your computer.

## New Project

#### Prerequisites

- **Node.js** - [`20.x`](https://nodejs.org/en){rel="nofollow"} or newer (but we recommend the [active LTS release](https://github.com/nodejs/release#release-schedule){rel="nofollow"})
- **Text editor** - There is no IDE requirement, but we recommend [Visual Studio Code](https://code.visualstudio.com/){rel="nofollow"} with the [official Vue extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar){rel="nofollow"} (previously known as Volar) or [WebStorm](https://www.jetbrains.com/webstorm/){rel="nofollow"}, which, along with [other JetBrains IDEs](https://www.jetbrains.com/ides/){rel="nofollow"}, offers great Nuxt support right out-of-the-box.
- **Terminal** - In order to run Nuxt commands

::note
Additional notes for an optimal setup:

- **Node.js**: Make sure to use an even numbered version (18, 20, etc)
- **Nuxtr**: Install the community-developed [Nuxtr extension](https://marketplace.visualstudio.com/items?itemName=Nuxtr.nuxtr-vscode){rel="nofollow"}
- **WSL**: If you are using Windows and experience slow HMR, you may want to try using [WSL (Windows Subsystem for Linux)](https://docs.microsoft.com/en-us/windows/wsl/install){rel="nofollow"} which may solve some performance issues.
::

Open a terminal (if you're using [Visual Studio Code](https://code.visualstudio.com){rel="nofollow"}, you can open an [integrated terminal](https://code.visualstudio.com/docs/editor/integrated-terminal){rel="nofollow"}) and use the following command to create a new starter project:

::code-group{sync="pm"}
```bash [npm]
npm create nuxt@latest <project-name>
```

```bash [yarn]
yarn create nuxt@latest <project-name>
```

```bash [pnpm]
pnpm create nuxt@latest <project-name>
```

```bash [bun]
bun create nuxt@latest <project-name>
```

```bash [deno]
deno -A npm:create-nuxt@latest <project-name>
```
::

::tip
Alternatively, you can find other starters or themes by opening [nuxt.new](https://nuxt.new){rel="nofollow"} and following the instructions there.
::

Open your project folder in Visual Studio Code:

```bash [Terminal]
code <project-name>
```

Or change directory into your new project from your terminal:

```bash
cd <project-name>
```

## Development Server

Now you'll be able to start your Nuxt app in development mode:

::code-group{sync="pm"}
```bash [npm]
npm run dev -- -o
```

```bash [yarn]
yarn dev --open
```

```bash [pnpm]
pnpm dev -o
```

```bash [bun]
bun run dev -o

# To use the Bun runtime during development
# bun --bun run dev -o
```

```bash [deno]
deno run dev -o
```
::

::tip{icon="i-lucide-circle-check"}
Well done! A browser window should automatically open for <http://localhost:3000>{rel="nofollow"}.
::

## Next Steps

Now that you've created your Nuxt project, you are ready to start building your application.

::read-more{title="Nuxt Concepts" to="https://nuxt.com/docs/guide/concepts"}
::


# Configuration

By default, Nuxt is configured to cover most use cases. The [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file can override or extend this default configuration.

## Nuxt Configuration

The [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file is located at the root of a Nuxt project and can override or extend the application's behavior.

A minimal configuration file exports the `defineNuxtConfig` function containing an object with your configuration. The `defineNuxtConfig` helper is globally available without import.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  // My Nuxt config
})
```

This file will often be mentioned in the documentation, for example to add custom scripts, register modules or change rendering modes.

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config"}
Every option is described in the **Configuration Reference**.
::

::note
You don't have to use TypeScript to build an application with Nuxt. However, it is strongly recommended to use the `.ts` extension for the `nuxt.config` file. This way you can benefit from hints in your IDE to avoid typos and mistakes while editing your configuration.
::

### Environment Overrides

You can configure fully typed, per-environment overrides in your nuxt.config

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  $production: {
    routeRules: {
      '/**': { isr: true }
    }
  },
  $development: {
    //
  },
  $env: {
    staging: {
      // 
    }
  },
})
```

To select an environment when running a Nuxt CLI command, simply pass the name to the `--envName` flag, like so: `nuxt build --envName staging`.

To learn more about the mechanism behind these overrides, please refer to the `c12` documentation on [environment-specific configuration](https://github.com/unjs/c12?tab=readme-ov-file#environment-specific-configuration){rel="nofollow"}.

::video-accordion
---
title: Watch a video from Alexander Lichter about the env-aware nuxt.config.ts
video-id: DFZI2iVCrNc
---
::

::note
If you're authoring layers, you can also use the `$meta` key to provide metadata that you or the consumers of your layer might use.
::

### Environment Variables and Private Tokens

The `runtimeConfig` API exposes values like environment variables to the rest of your application. By default, these keys are only available server-side. The keys within `runtimeConfig.public` and `runtimeConfig.app` (which is used by Nuxt internally) are also available client-side.

Those values should be defined in `nuxt.config` and can be overridden using environment variables.

::code-group
```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  runtimeConfig: {
    // The private keys which are only available server-side
    apiSecret: '123',
    // Keys within public are also exposed client-side
    public: {
      apiBase: '/api'
    }
  }
})
```

```ini [.env]
# This will override the value of apiSecret
NUXT_API_SECRET=api_secret_token
```
::

These variables are exposed to the rest of your application using the [`useRuntimeConfig()`](https://nuxt.com/docs/api/composables/use-runtime-config) composable.

```vue [app/pages/index.vue]
<script setup lang="ts">
const runtimeConfig = useRuntimeConfig()
</script>
```

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## App Configuration

The `app.config.ts` file, located in the source directory (by default `app/`), is used to expose public variables that can be determined at build time. Contrary to the `runtimeConfig` option, these cannot be overridden using environment variables.

A minimal configuration file exports the `defineAppConfig` function containing an object with your configuration. The `defineAppConfig` helper is globally available without import.

```ts [app.config.ts]
export default defineAppConfig({
  title: 'Hello Nuxt',
  theme: {
    dark: true,
    colors: {
      primary: '#ff0000'
    }
  }
})
```

These variables are exposed to the rest of your application using the [`useAppConfig`](https://nuxt.com/docs/api/composables/use-app-config) composable.

```vue [app/pages/index.vue]
<script setup lang="ts">
const appConfig = useAppConfig()
</script>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
::

## `runtimeConfig` vs. `app.config`

As stated above, `runtimeConfig` and `app.config` are both used to expose variables to the rest of your application. To determine whether you should use one or the other, here are some guidelines:

- `runtimeConfig`: Private or public tokens that need to be specified after build using environment variables.
- `app.config`: Public tokens that are determined at build time, website configuration such as theme variant, title and any project config that are not sensitive.

| Feature                   | `runtimeConfig` | `app.config` |
| ------------------------- | --------------- | ------------ |
| Client Side               | Hydrated        | Bundled      |
| Environment Variables     | ✅ Yes           | ❌ No         |
| Reactive                  | ✅ Yes           | ✅ Yes        |
| Types support             | ✅ Partial       | ✅ Yes        |
| Configuration per Request | ❌ No            | ✅ Yes        |
| Hot Module Replacement    | ❌ No            | ✅ Yes        |
| Non primitive JS types    | ❌ No            | ✅ Yes        |

## External Configuration Files

Nuxt uses [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file as the single source of truth for configurations and skips reading external configuration files. During the course of building your project, you may have a need to configure those. The following table highlights common configurations and, where applicable, how they can be configured with Nuxt.

| Name                                              | Config File             | How To Configure                                                                      |
| ------------------------------------------------- | ----------------------- | ------------------------------------------------------------------------------------- |
| [Nitro](https://nitro.build){rel="nofollow"}      | ~~`nitro.config.ts`~~   | Use [`nitro`](https://nuxt.com/docs/api/nuxt-config#nitro) key in `nuxt.config`       |
| [PostCSS](https://postcss.org){rel="nofollow"}    | ~~`postcss.config.js`~~ | Use [`postcss`](https://nuxt.com/docs/api/nuxt-config#postcss) key in `nuxt.config`   |
| [Vite](https://vite.dev){rel="nofollow"}          | ~~`vite.config.ts`~~    | Use [`vite`](https://nuxt.com/docs/api/nuxt-config#vite) key in `nuxt.config`         |
| [webpack](https://webpack.js.org){rel="nofollow"} | ~~`webpack.config.ts`~~ | Use [`webpack`](https://nuxt.com/docs/api/nuxt-config#webpack-1) key in `nuxt.config` |

Here is a list of other common config files:

| Name                                                         | Config File           | How To Configure                                                                              |
| ------------------------------------------------------------ | --------------------- | --------------------------------------------------------------------------------------------- |
| [TypeScript](https://www.typescriptlang.org){rel="nofollow"} | `tsconfig.json`       | [More Info](https://nuxt.com/docs/guide/concepts/typescript#nuxttsconfigjson)                 |
| [ESLint](https://eslint.org){rel="nofollow"}                 | `eslint.config.js`    | [More Info](https://eslint.org/docs/latest/use/configure/configuration-files){rel="nofollow"} |
| [Prettier](https://prettier.io){rel="nofollow"}              | `prettier.config.js`  | [More Info](https://prettier.io/docs/en/configuration.html){rel="nofollow"}                   |
| [Stylelint](https://stylelint.io){rel="nofollow"}            | `stylelint.config.js` | [More Info](https://stylelint.io/user-guide/configure){rel="nofollow"}                        |
| [TailwindCSS](https://tailwindcss.com){rel="nofollow"}       | `tailwind.config.js`  | [More Info](https://tailwindcss.nuxtjs.org/tailwindcss/configuration){rel="nofollow"}         |
| [Vitest](https://vitest.dev){rel="nofollow"}                 | `vitest.config.ts`    | [More Info](https://vitest.dev/config/){rel="nofollow"}                                       |

## Vue Configuration

### With Vite

If you need to pass options to `@vitejs/plugin-vue` or `@vitejs/plugin-vue-jsx`, you can do this in your `nuxt.config` file.

- `vite.vue` for `@vitejs/plugin-vue`. Check [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue){rel="nofollow"}.
- `vite.vueJsx` for `@vitejs/plugin-vue-jsx`. Check [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  vite: {
    vue: {
      customElement: true
    },
    vueJsx: {
      mergeProps: true
    }
  }
})
```

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config#vue"}
::

### With webpack

If you use webpack and need to configure `vue-loader`, you can do this using `webpack.loaders.vue` key inside your `nuxt.config` file. The available options are [defined here](https://github.com/vuejs/vue-loader/blob/main/src/index.ts#L32-L62){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  webpack: {
    loaders: {
      vue: {
        hotReload: true,
      }
    }
  }
})
```

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config#loaders"}
::

### Enabling Experimental Vue Features

You may need to enable experimental features in Vue, such as `propsDestructure`. Nuxt provides an easy way to do that in `nuxt.config.ts`, no matter which builder you are using:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  vue: {
    propsDestructure: true
  }
})
```

#### experimental `reactivityTransform` migration from Vue 3.4 and Nuxt 3.9

Since Nuxt 3.9 and Vue 3.4, `reactivityTransform` has been moved from Vue to Vue Macros which has a [Nuxt integration](https://vue-macros.dev/guide/nuxt-integration.html){rel="nofollow"}.

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config#vue-1"}
::


# Views

## `app.vue`

![The app.vue file is the entry point of your application](https://nuxt.com/assets/docs/getting-started/views/app.svg)

By default, Nuxt will treat this file as the **entrypoint** and render its content for every route of the application.

```vue [app/app.vue]
<template>
  <div>
   <h1>Welcome to the homepage</h1>
  </div>
</template>
```

::tip
If you are familiar with Vue, you might wonder where `main.js` is (the file that normally creates a Vue app). Nuxt does this behind the scene.
::

## Components

![Components are reusable pieces of UI](https://nuxt.com/assets/docs/getting-started/views/components.svg)

Most components are reusable pieces of the user interface, like buttons and menus. In Nuxt, you can create these components in the [`app/components/`](https://nuxt.com/docs/guide/directory-structure/app/components) directory, and they will be automatically available across your application without having to explicitly import them.

::code-group
```vue [app/app.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component.
    </AppAlert>
  </div>
</template>
```

```vue [app/components/AppAlert.vue]
<template>
  <span>
    <slot />
  </span>
</template>
```
::

## Pages

![Pages are views tied to a specific route](https://nuxt.com/assets/docs/getting-started/views/pages.svg)

Pages represent views for each specific route pattern. Every file in the [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory represents a different route displaying its content.

To use pages, create an `app/pages/index.vue` file and add `<NuxtPage />` component to the [`app/app.vue`](https://nuxt.com/docs/guide/directory-structure/app) (or remove `app/app.vue` for default entry). You can now create more pages and their corresponding routes by adding new files in the [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory.

::code-group
```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component
    </AppAlert>
  </div>
</template>
```

```vue [app/pages/about.vue]
<template>
  <section>
    <p>This page will be displayed at the /about route.</p>
  </section>
</template>
```
::

::read-more
---
title: Routing Section
to: https://nuxt.com/docs/getting-started/routing
---
::

## Layouts

![Layouts are wrapper around pages](https://nuxt.com/assets/docs/getting-started/views/layouts.svg)

Layouts are wrappers around pages that contain a common User Interface for several pages, such as header and footer displays. Layouts are Vue files using `<slot />` components to display the **page** content. The `app/layouts/default.vue` file will be used by default. Custom layouts can be set as part of your page metadata.

::note
If you only have a single layout in your application, we recommend using [`app/app.vue`](https://nuxt.com/docs/guide/directory-structure/app) with [`<NuxtPage />`](https://nuxt.com/docs/api/components/nuxt-page) instead.
::

::code-group
```vue [app/app.vue]
<template>
  <div>
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>
```

```vue [app/layouts/default.vue]
<template>
  <div>
    <AppHeader />
    <slot />
    <AppFooter />
  </div>
</template>
```

```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component
    </AppAlert>
  </div>
</template>
```

```vue [app/pages/about.vue]
<template>
  <section>
    <p>This page will be displayed at the /about route.</p>
  </section>
</template>
```
::

If you want to create more layouts and learn how to use them in your pages, find more information in the [Layouts section](https://nuxt.com/docs/guide/directory-structure/app/layouts).

## Advanced: Extending the HTML Template

::note
If you only need to modify the `<head>`, you can refer to the [SEO and meta section](https://nuxt.com/docs/getting-started/seo-meta).
::

You can have full control over the HTML template by adding a Nitro plugin that registers a hook.
The callback function of the `render:html` hook allows you to mutate the HTML before it is sent to the client.

```ts [server/plugins/extend-html.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:html', (html, { event }) => {
    // This will be an object representation of the html template.
    console.log(html)
    html.head.push(`<meta name="description" content="My custom description" />`)
  })
  // You can also intercept the response here.
  nitroApp.hooks.hook('render:response', (response, { event }) => { console.log(response) })
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/hooks"}
::


# Assets

Nuxt uses two directories to handle assets like stylesheets, fonts or images.

- The [`public/`](https://nuxt.com/docs/guide/directory-structure/public) directory content is served at the server root as-is.
- The [`app/assets/`](https://nuxt.com/docs/guide/directory-structure/app/assets) directory contains by convention every asset that you want the build tool (Vite or webpack) to process.

## Public Directory

The [`public/`](https://nuxt.com/docs/guide/directory-structure/public) directory is used as a public server for static assets publicly available at a defined URL of your application.

You can get a file in the [`public/`](https://nuxt.com/docs/guide/directory-structure/public) directory from your application's code or from a browser by the root URL `/`.

### Example

For example, referencing an image file in the `public/img/` directory, available at the static URL `/img/nuxt.png`:

```vue [app/app.vue]
<template>
  <img src="/img/nuxt.png" alt="Discover Nuxt" />
</template>
```

## Assets Directory

Nuxt uses [Vite](https://vite.dev/guide/assets.html){rel="nofollow"} (default) or [webpack](https://webpack.js.org/guides/asset-management){rel="nofollow"} to build and bundle your application. The main function of these build tools is to process JavaScript files, but they can be extended through [plugins](https://vite.dev/plugins){rel="nofollow"} (for Vite) or [loaders](https://webpack.js.org/loaders){rel="nofollow"} (for webpack) to process other kinds of assets, like stylesheets, fonts or SVGs. This step transforms the original file, mainly for performance or caching purposes (such as stylesheet minification or browser cache invalidation).

By convention, Nuxt uses the [`app/assets/`](https://nuxt.com/docs/guide/directory-structure/app/assets) directory to store these files but there is no auto-scan functionality for this directory, and you can use any other name for it.

In your application's code, you can reference a file located in the [`app/assets/`](https://nuxt.com/docs/guide/directory-structure/app/assets) directory by using the `~/assets/` path.

### Example

For example, referencing an image file that will be processed if a build tool is configured to handle this file extension:

```vue [app/app.vue]
<template>
  <img src="~/assets/img/nuxt.png" alt="Discover Nuxt" />
</template>
```

::note
Nuxt won't serve files in the [`app/assets/`](https://nuxt.com/docs/guide/directory-structure/app/assets) directory at a static URL like `/assets/my-file.png`. If you need a static URL, use the [`public/`](https://nuxt.com/#public-directory) directory.
::


# Styling

Nuxt is highly flexible when it comes to styling. Write your own styles, or reference local and external stylesheets.
You can use CSS preprocessors, CSS frameworks, UI libraries and Nuxt modules to style your application.

## Local Stylesheets

If you're writing local stylesheets, the natural place to put them is the [`app/assets/` directory](https://nuxt.com/docs/guide/directory-structure/app/assets).

### Importing Within Components

You can import stylesheets in your pages, layouts and components directly.
You can use a JavaScript import, or a CSS [`@import` statement](https://developer.mozilla.org/en-US/docs/Web/CSS/@import){rel="nofollow"}.

```vue [app/pages/index.vue]
<script>
// Use a static import for server-side compatibility
import '~/assets/css/first.css'

// Caution: Dynamic imports are not server-side compatible
import('~/assets/css/first.css')
</script>

<style>
@import url("~/assets/css/second.css");
</style>
```

::tip
The stylesheets will be inlined in the HTML rendered by Nuxt.
::

### The CSS Property

You can also use the `css` property in the Nuxt configuration.
The natural place for your stylesheets is the [`app/assets/` directory](https://nuxt.com/docs/guide/directory-structure/app/assets). You can then reference its path and Nuxt will include it to all the pages of your application.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/css/main.css']
})
```

::tip
The stylesheets will be inlined in the HTML rendered by Nuxt, injected globally and present in all pages.
::

### Working With Fonts

Place your local fonts files in your `public/` directory, for example in `public/fonts`. You can then reference them in your stylesheets using `url()`.

```css [assets/css/main.css]
@font-face {
  font-family: 'FarAwayGalaxy';
  src: url('/fonts/FarAwayGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
```

Then reference your fonts by name in your stylesheets, pages or components:

```vue
<style>
h1 {
  font-family: 'FarAwayGalaxy', sans-serif;
}
</style>
```

### Stylesheets Distributed Through NPM

You can also reference stylesheets that are distributed through npm. Let's use the popular `animate.css` library as an example.

::code-group{sync="pm"}
```bash [npm]
npm install animate.css
```

```bash [yarn]
yarn add animate.css
```

```bash [pnpm]
pnpm install animate.css
```

```bash [bun]
bun install animate.css
```
::

Then you can reference it directly in your pages, layouts and components:

```vue [app/app.vue]
<script>
import 'animate.css'
</script>

<style>
@import url("animate.css");
</style>
```

The package can also be referenced as a string in the css property of your Nuxt configuration.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['animate.css']
})
```

## External Stylesheets

You can include external stylesheets in your application by adding a link element in the head section of your nuxt.config file. You can achieve this result using different methods. Note that local stylesheets can also be included this way.

You can manipulate the head with the [`app.head`](https://nuxt.com/docs/api/nuxt-config#head) property of your Nuxt configuration:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    head: {
      link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
    }
  }
})
```

### Dynamically Adding Stylesheets

You can use the useHead composable to dynamically set a value in your head in your code.

::read-more{to="https://nuxt.com/docs/api/composables/use-head"}
::

```ts twoslash
useHead({
  link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
})
```

Nuxt uses `unhead` under the hood, and you can refer to [its full documentation](https://unhead.unjs.io){rel="nofollow"}.

### Modifying The Rendered Head With A Nitro Plugin

If you need more advanced control, you can intercept the rendered html with a hook and modify the head programmatically.

Create a plugin in `~/server/plugins/my-plugin.ts` like this:

```ts [server/plugins/my-plugin.ts]
export default defineNitroPlugin((nitro) => {
  nitro.hooks.hook('render:html', (html) => {
    html.head.push('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">')
  })
})
```

External stylesheets are render-blocking resources: they must be loaded and processed before the browser renders the page. Web pages that contain unnecessarily large styles take longer to render. You can read more about it on [web.dev](https://web.dev/defer-non-critical-css){rel="nofollow"}.

## Using Preprocessors

To use a preprocessor like SCSS, Sass, Less or Stylus, install it first.

::code-group
```bash [Sass & SCSS]
npm install -D sass
```

```bash [Less]
npm install -D less
```

```bash [Stylus]
npm install -D stylus
```
::

The natural place to write your stylesheets is the `app/assets` directory.
You can then import your source files in your `app.vue` (or layouts files) using your preprocessor's syntax.

```vue [app/pages/app.vue]
<style lang="scss">
@use "~/assets/scss/main.scss";
</style>
```

Alternatively, you can use the `css` property of your Nuxt configuration.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  css: ['~/assets/scss/main.scss']
})
```

::tip
In both cases, the compiled stylesheets will be inlined in the HTML rendered by Nuxt.
::

If you need to inject code in pre-processed files, like a [Sass partial](https://sass-lang.com/documentation/at-rules/use#partials){rel="nofollow"} with color variables, you can do so with the Vite [preprocessors options](https://vite.dev/config/shared-options.html#css-preprocessoroptions){rel="nofollow"}.

Create some partials in your `app/assets` directory:

::code-group{sync="preprocessor"}
```scss [assets/_colors.scss]
$primary: #49240F;
$secondary: #E4A79D;
```

```sass [assets/_colors.sass]
$primary: #49240F
$secondary: #E4A79D
```
::

Then in your `nuxt.config` :

::code-group
```ts [SCSS] twoslash
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "~/assets/_colors.scss" as *;'
        }
      }
    }
  }
})
```

```ts [SASS] twoslash
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        sass: {
          additionalData: '@use "~/assets/_colors.sass" as *\n'
        }
      }
    }
  }
})
```
::

Nuxt uses Vite by default. If you wish to use webpack instead, refer to each preprocessor loader [documentation](https://webpack.js.org/loaders/sass-loader){rel="nofollow"}.

### Preprocessor Workers (Experimental)

Vite has made available an [experimental option](https://vite.dev/config/shared-options.html#css-preprocessormaxworkers){rel="nofollow"} which can speed up using preprocessors.

You can enable this in your `nuxt.config`:

```ts

export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorMaxWorkers: true // number of CPUs minus 1
    }
  }
})
```

::note
This is an experimental option and you should refer to the Vite documentation and [provide feedback](https://github.com/vitejs/vite/discussions/15835){rel="nofollow"}.
::

## Single File Components (SFC) Styling

One of the best things about Vue and SFC is how great it is at naturally dealing with styling. You can directly write CSS or preprocessor code in the style block of your components file, therefore you will have fantastic developer experience without having to use something like CSS-in-JS. However if you wish to use CSS-in-JS, you can find 3rd party libraries and modules that support it, such as [pinceau](https://github.com/Tahul/pinceau){rel="nofollow"}.

You can refer to the [Vue docs](https://vuejs.org/api/sfc-css-features.html){rel="nofollow"} for a comprehensive reference about styling components in SFC.

### Class And Style Bindings

You can leverage Vue SFC features to style your components with class and style attributes.

::code-group
```vue [Ref and Reactive]
<script setup lang="ts">
const isActive = ref(true)
const hasError = ref(false)
const classObject = reactive({
  active: true,
  'text-danger': false
})
</script>

<template>
  <div class="static" :class="{ active: isActive, 'text-danger': hasError }"></div>
  <div :class="classObject"></div>
</template>
```

```vue [Computed]
<script setup lang="ts">
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
</script>

<template>
  <div :class="classObject"></div>
</template>
```

```vue [Array]
<script setup lang="ts">
const isActive = ref(true)
const errorClass = ref('text-danger')
</script>

<template>
  <div :class="[{ active: isActive }, errorClass]"></div>
</template>
```

```vue [Style]
<script setup lang="ts">
const activeColor = ref('red')
const fontSize = ref(30)
const styleObject = reactive({ color: 'red', fontSize: '13px' })
</script>

<template>
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
  <div :style="[baseStyles, overridingStyles]"></div>
  <div :style="styleObject"></div>
</template>
```
::

Refer to the [Vue docs](https://vuejs.org/guide/essentials/class-and-style.html){rel="nofollow"} for more information.

### Dynamic Styles With `v-bind`

You can reference JavaScript variable and expression within your style blocks with the v-bind function.
The binding will be dynamic, meaning that if the variable value changes, the style will be updated.

```vue
<script setup lang="ts">
const color = ref("red")
</script>

<template>
  <div class="text">hello</div>
</template>

<style>
.text {
  color: v-bind(color);
}
</style>
```

### Scoped Styles

The scoped attribute allows you to style components in isolation. The styles declared with this attribute will only apply to this component.

```vue
<template>
  <div class="example">hi</div>
</template>

<style scoped>
.example {
  color: red;
}
</style>
```

### CSS Modules

You can use [CSS Modules](https://github.com/css-modules/css-modules){rel="nofollow"} with the module attribute. Access it with the injected `$style` variable.

```vue
<template>
  <p :class="$style.red">This should be red</p>
</template>

<style module>
.red {
  color: red;
}
</style>
```

### Preprocessors Support

SFC style blocks support preprocessor syntax. Vite comes with built-in support for .scss, .sass, .less, .styl and .stylus files without configuration. You just need to install them first, and they will be available directly in SFC with the lang attribute.

::code-group
```vue [SCSS]
<style lang="scss">
  /* Write scss here */
</style>
```

```vue [Sass]
<style lang="sass">
  /* Write sass here */
</style>
```

```vue [LESS]
<style lang="less">
  /* Write less here */
</style>
```

```vue [Stylus]
<style lang="stylus">
  /* Write stylus here */
</style>
```
::

You can refer to the [Vite CSS docs](https://vite.dev/guide/features.html#css){rel="nofollow"} and the [@vitejs/plugin-vue docs](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue){rel="nofollow"}.
For webpack users, refer to the [vue loader docs](https://vue-loader.vuejs.org){rel="nofollow"}.

## Using PostCSS

Nuxt comes with postcss built-in. You can configure it in your `nuxt.config` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  postcss: {
    plugins: {
      'postcss-nested': {},
      'postcss-custom-media': {}
    }
  }
})
```

For proper syntax highlighting in SFC, you can use the postcss lang attribute.

```vue
<style lang="postcss">
  /* Write postcss here */
</style>
```

By default, Nuxt comes with the following plugins already pre-configured:

- [postcss-import](https://github.com/postcss/postcss-import){rel="nofollow"}: Improves the `@import` rule
- [postcss-url](https://github.com/postcss/postcss-url){rel="nofollow"}: Transforms `url()` statements
- [autoprefixer](https://github.com/postcss/autoprefixer){rel="nofollow"}: Automatically adds vendor prefixes
- [cssnano](https://cssnano.github.io/cssnano){rel="nofollow"}: Minification and purge

## Leveraging Layouts For Multiple Styles

If you need to style different parts of your application completely differently, you can use layouts.
Use different styles for different layouts.

```vue
<template>
  <div class="default-layout">
    <h1>Default Layout</h1>
    <slot />
  </div>
</template>

<style>
.default-layout {
  color: red;
}
</style>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/layouts"}
::

## Third Party Libraries And Modules

Nuxt isn't opinionated when it comes to styling and provides you with a wide variety of options. You can use any styling tool that you want, such as popular libraries like [UnoCSS](https://unocss.dev){rel="nofollow"} or [Tailwind CSS](https://tailwindcss.com){rel="nofollow"}.

The community and the Nuxt team have developed plenty of Nuxt modules to make the integration easier.
You can discover them on the [modules section](https://nuxt.com/modules) of the website.
Here are a few modules to help you get started:

- [UnoCSS](https://nuxt.com/modules/unocss): Instant on-demand atomic CSS engine
- [Tailwind CSS](https://nuxt.com/modules/tailwindcss): Utility-first CSS framework
- [Fontaine](https://github.com/nuxt-modules/fontaine){rel="nofollow"}: Font metric fallback
- [Pinceau](https://github.com/Tahul/pinceau){rel="nofollow"}: Adaptable styling framework
- [Nuxt UI](https://ui.nuxt.com){rel="nofollow"}: A UI Library for Modern Web Apps
- [Panda CSS](https://panda-css.com/docs/installation/nuxt){rel="nofollow"}: CSS-in-JS engine that generates atomic CSS at build time

Nuxt modules provide you with a good developer experience out of the box, but remember that if your favorite tool doesn't have a module, it doesn't mean that you can't use it with Nuxt! You can configure it yourself for your own project. Depending on the tool, you might need to use a [Nuxt plugin](https://nuxt.com/docs/guide/directory-structure/plugins) and/or [make your own module](https://nuxt.com/docs/guide/going-further/modules). Share them with the [community](https://nuxt.com/modules) if you do!

### Easily Load Webfonts

You can use [the Nuxt Google Fonts module](https://github.com/nuxt-modules/google-fonts){rel="nofollow"} to load Google Fonts.

If you are using [UnoCSS](https://unocss.dev/integrations/nuxt){rel="nofollow"}, note that it comes with a [web fonts presets](https://unocss.dev/presets/web-fonts){rel="nofollow"} to conveniently load fonts from common providers, including Google Fonts and more.

## Advanced

### Transitions

Nuxt comes with the same `<Transition>` element that Vue has, and also has support for the experimental [View Transitions API](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental).

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

### Font Advanced Optimization

We would recommend using [Fontaine](https://github.com/nuxt-modules/fontaine){rel="nofollow"} to reduce your [CLS](https://web.dev/cls){rel="nofollow"}. If you need something more advanced, consider creating a Nuxt module to extend the build process or the Nuxt runtime.

::tip
Always remember to take advantage of the various tools and techniques available in the Web ecosystem at large to make styling your application easier and more efficient. Whether you're using native CSS, a preprocessor, postcss, a UI library or a module, Nuxt has got you covered. Happy styling!
::

### LCP Advanced Optimizations

You can do the following to speed-up the download of your global CSS files:

- Use a CDN so the files are physically closer to your users
- Compress your assets, ideally using Brotli
- Use HTTP2/HTTP3 for delivery
- Host your assets on the same domain (do not use a different subdomain)

Most of these things should be done for you automatically if you're using modern platforms like Cloudflare, Netlify or Vercel.
You can find an LCP optimization guide on [web.dev](https://web.dev/optimize-lcp){rel="nofollow"}.

If all of your CSS is inlined by Nuxt, you can (experimentally) completely stop external CSS files from being referenced in your rendered HTML.
You can achieve that with a hook, that you can place in a module, or in your Nuxt configuration file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'build:manifest': (manifest) => {
      // find the app entry, css list
      const css = Object.values(manifest).find(options => options.isEntry)?.css
      if (css) {
        // start from the end of the array and go to the beginning
        for (let i = css.length - 1; i >= 0; i--) {
          // if it starts with 'entry', remove it from the list
          if (css[i].startsWith('entry')) css.splice(i, 1)
        }
      }
    },
  },
})
```


# Routing

One core feature of Nuxt is the file system router. Every Vue file inside the [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory creates a corresponding URL (or route) that displays the contents of the file. By using dynamic imports for each page, Nuxt leverages code-splitting to ship the minimum amount of JavaScript for the requested route.

## Pages

Nuxt routing is based on [vue-router](https://router.vuejs.org){rel="nofollow"} and generates the routes from every component created in the [`app/pages/` directory](https://nuxt.com/docs/guide/directory-structure/app/pages), based on their filename.

This file system routing uses naming conventions to create dynamic and nested routes:

::code-group
```bash [Directory Structure]
-| pages/
---| about.vue
---| index.vue
---| posts/
-----| [id].vue
```

```json [Generated Router File]
{
  "routes": [
    {
      "path": "/about",
      "component": "pages/about.vue"
    },
    {
      "path": "/",
      "component": "pages/index.vue"
    },
    {
      "path": "/posts/:id",
      "component": "pages/posts/[id].vue"
    }
  ]
}
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/pages"}
::

## Navigation

The [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link) component links pages between them. It renders an `<a>` tag with the `href` attribute set to the route of the page. Once the application is hydrated, page transitions are performed in JavaScript by updating the browser URL. This prevents full-page refreshes and allows for animated transitions.

When a [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link) enters the viewport on the client side, Nuxt will automatically prefetch components and payload (generated pages) of the linked pages ahead of time, resulting in faster navigation.

```vue [app/pages/index.vue]
<template>
  <header>
    <nav>
      <ul>
        <li><NuxtLink to="/about">About</NuxtLink></li>
        <li><NuxtLink to="/posts/1">Post 1</NuxtLink></li>
        <li><NuxtLink to="/posts/2">Post 2</NuxtLink></li>
      </ul>
    </nav>
  </header>
</template>
```

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
::

## Route Parameters

The [`useRoute()`](https://nuxt.com/docs/api/composables/use-route) composable can be used in a `<script setup>` block or a `setup()` method of a Vue component to access the current route details.

```vue [pages/posts/[id\\].vue] twoslash
<script setup lang="ts">
const route = useRoute()

// When accessing /posts/1, route.params.id will be 1
console.log(route.params.id)
</script>
```

::read-more{to="https://nuxt.com/docs/api/composables/use-route"}
::

## Route Middleware

Nuxt provides a customizable route middleware framework you can use throughout your application, ideal for extracting code that you want to run before navigating to a particular route.

::note
Route middleware runs within the Vue part of your Nuxt app. Despite the similar name, they are completely different from server middleware, which are run in the Nitro server part of your app.
::

There are three kinds of route middleware:

1. Anonymous (or inline) route middleware, which are defined directly in the pages where they are used.
2. Named route middleware, which are placed in the [`app/middleware/`](https://nuxt.com/docs/guide/directory-structure/app/middleware) directory and will be automatically loaded via asynchronous import when used on a page. (**Note**: The route middleware name is normalized to kebab-case, so `someMiddleware` becomes `some-middleware`.)
3. Global route middleware, which are placed in the [`app/middleware/`](https://nuxt.com/docs/guide/directory-structure/app/middleware) directory (with a `.global` suffix) and will be automatically run on every route change.

Example of an `auth` middleware protecting the `/dashboard` page:

::code-group
```ts [middleware/auth.ts] twoslash
function isAuthenticated(): boolean { return false }
// ---cut---
export default defineNuxtRouteMiddleware((to, from) => {
  // isAuthenticated() is an example method verifying if a user is authenticated
  if (isAuthenticated() === false) {
    return navigateTo('/login')
  }
})
```

```vue [pages/dashboard.vue] twoslash
<script setup lang="ts">
definePageMeta({
  middleware: 'auth'
})
</script>

<template>
  <h1>Welcome to your dashboard</h1>
</template>
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/middleware"}
::

## Route Validation

Nuxt offers route validation via the `validate` property in [`definePageMeta()`](https://nuxt.com/docs/api/utils/define-page-meta) in each page you wish to validate.

The `validate` property accepts the `route` as an argument. You can return a boolean value to determine whether or not this is a valid route to be rendered with this page. If you return `false`, this will cause a 404 error. You can also directly return an object with `statusCode`/`statusMessage` to customize the error returned.

If you have a more complex use case, then you can use anonymous route middleware instead.

```vue [pages/posts/[id\\].vue] twoslash
<script setup lang="ts">
definePageMeta({
  validate: async (route) => {
    // Check if the id is made up of digits
    return typeof route.params.id === 'string' && /^\d+$/.test(route.params.id)
  }
})
</script>
```

::read-more{to="https://nuxt.com/docs/api/utils/define-page-meta"}
::


# SEO and Meta

Nuxt head tag management is powered by [Unhead](https://unhead.unjs.io){rel="nofollow"}. It provides sensible defaults, several powerful composables
and numerous configuration options to manage your app's head and SEO meta tags.

## Nuxt Config

Providing an [`app.head`](https://nuxt.com/docs/api/nuxt-config#head) property in your [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) allows you to statically customize the head for your entire app.

::important
This method does not allow you to provide reactive data. We recommend using `useHead()` in `app.vue`.
::

It's good practice to set tags here that won't change such as your site title default, language and favicon.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    head: {
      title: 'Nuxt', // default fallback title
      htmlAttrs: {
        lang: 'en',
      },
      link: [
        { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' },
      ]
    }
  }
})
```

You can also provide any of the keys listed below in [Types](https://nuxt.com/#types).

### Defaults Tags

Some tags are provided by Nuxt by default to ensure your website works well out of the box.

- `viewport`: `width=device-width, initial-scale=1`
- `charset`: `utf-8`

While most sites won't need to override these defaults, you can update them using the keyed shortcuts.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    head: {
      // update Nuxt defaults
      charset: 'utf-16',
      viewport: 'width=device-width, initial-scale=1, maximum-scale=1',
    }
  }
})
```

## `useHead`

The [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable function supports reactive input, allowing you to manage your head tags programmatically.

```vue [app/app.vue] twoslash
<script setup lang="ts">
useHead({
  title: 'My App',
  meta: [
    { name: 'description', content: 'My amazing site.' }
  ],
  bodyAttrs: {
    class: 'test'
  },
  script: [ { innerHTML: 'console.log(\'Hello world\')' } ]
})
</script>
```

We recommend taking a look at the [`useHead`](https://nuxt.com/docs/api/composables/use-head) and [`useHeadSafe`](https://nuxt.com/docs/api/composables/use-head-safe) composables.

## `useSeoMeta`

The [`useSeoMeta`](https://nuxt.com/docs/api/composables/use-seo-meta) composable lets you define your site's SEO meta tags as an object with full type safety.

This helps you avoid typos and common mistakes, such as using `name` instead of `property`.

```vue [app/app.vue] twoslash
<script setup lang="ts">
useSeoMeta({
  title: 'My Amazing Site',
  ogTitle: 'My Amazing Site',
  description: 'This is my amazing site, let me tell you all about it.',
  ogDescription: 'This is my amazing site, let me tell you all about it.',
  ogImage: 'https://example.com/image.png',
  twitterCard: 'summary_large_image',
})
</script>
```

::read-more{to="https://nuxt.com/docs/api/composables/use-seo-meta"}
::

## Components

While using [`useHead`](https://nuxt.com/docs/api/composables/use-head) is recommended in all cases, you may have a personal preference for defining your head tags in your template using components.

Nuxt provides the following components for this purpose: `<Title>`, `<Base>`, `<NoScript>`, `<Style>`, `<Meta>`, `<Link>`, `<Body>`, `<Html>` and `<Head>`. Note
the capitalization of these components ensuring we don't use invalid native HTML tags.

`<Head>` and `<Body>` can accept nested meta tags (for aesthetic reasons) but this does not affect *where* the nested meta tags are rendered in the final HTML.

```vue [app/app.vue]
<script setup lang="ts">
const title = ref('Hello World')
</script>

<template>
  <div>
    <Head>
      <Title>{{ title }}</Title>
      <Meta name="description" :content="title" />
      <Style>
      body { background-color: green; }
      </Style>
    </Head>

    <h1>{{ title }}</h1>
  </div>
</template>
```

It's suggested to wrap your components in either a `<Head>` or `<Html>` components as tags will be deduped more intuitively.

## Types

Below are the non-reactive types used for [`useHead`](https://nuxt.com/docs/api/composables/use-head), [`app.head`](https://nuxt.com/docs/api/nuxt-config#head) and components.

```ts
interface MetaObject {
  title?: string
  titleTemplate?: string | ((title?: string) => string)
  templateParams?: Record<string, string | Record<string, string>>
  base?: Base
  link?: Link[]
  meta?: Meta[]
  style?: Style[]
  script?: Script[]
  noscript?: Noscript[];
  htmlAttrs?: HtmlAttributes;
  bodyAttrs?: BodyAttributes;
}
```

See [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/schema.ts){rel="nofollow"} for more detailed types.

## Features

### Reactivity

Reactivity is supported on all properties, by providing a computed value, a getter, or a reactive object.

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
const description = ref('My amazing site.')

useHead({
  meta: [
    { name: 'description', content: description }
  ],
})
</script>
```

```vue [useSeoMeta] twoslash
<script setup lang="ts">
const description = ref('My amazing site.')

useSeoMeta({
  description
})
</script>
```

```vue [app/Components]
<script setup lang="ts">
const description = ref('My amazing site.')
</script>

<template>
  <div>
    <Meta name="description" :content="description" />
  </div>
</template>
```
::

### Title Template

You can use the `titleTemplate` option to provide a dynamic template for customizing the title of your site. For example, you could add the name of your site to the title of every page.

The `titleTemplate` can either be a string, where `%s` is replaced with the title, or a function.

If you want to use a function (for full control), then this cannot be set in your `nuxt.config`. It is recommended instead to set it within your `app.vue` file where it will apply to all pages on your site:

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} - Site Title` : 'Site Title';
  }
})
</script>
```
::

Now, if you set the title to `My Page` with [`useHead`](https://nuxt.com/docs/api/composables/use-head) on another page of your site, the title would appear as 'My Page - Site Title' in the browser tab. You could also pass `null` to default to 'Site Title'.

### Template Params

You can use `templateParams` to provide additional placeholders in your `titleTemplate` besides the default `%s`. This allows for more dynamic title generation.

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} %separator %siteName` : '%siteName';
  },
  templateParams: {
    siteName: 'Site Title',
    separator: '-'
  }
})
</script>
```
::

### Body Tags

You can use the `tagPosition: 'bodyClose'` option on applicable tags to append them to the end of the `<body>` tag.

For example:

```vue twoslash
<script setup lang="ts">
useHead({
  script: [
    {
      src: 'https://third-party-script.com',
      // valid options are: 'head' | 'bodyClose' | 'bodyOpen'
      tagPosition: 'bodyClose'
    }
  ]
})
</script>
```

## Examples

### With `definePageMeta`

Within your [`app/pages/` directory](https://nuxt.com/docs/guide/directory-structure/app/pages), you can use `definePageMeta` along with [`useHead`](https://nuxt.com/docs/api/composables/use-head) to set metadata based on the current route.

For example, you can first set the current page title (this is extracted at build time via a macro, so it can't be set dynamically):

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  title: 'Some Page'
})
</script>
```

And then in your layout file, you might use the route's metadata you have previously set:

```vue [layouts/default.vue] twoslash
<script setup lang="ts">
const route = useRoute()

useHead({
  meta: [{ property: 'og:title', content: `App Name - ${route.meta.title}` }]
})
</script>
```

::link-example{to="https://nuxt.com/docs/examples/features/meta-tags"}
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/pages/#page-metadata
---
::

### Dynamic Title

In the example below, `titleTemplate` is set either as a string with the `%s` placeholder or as a `function`, which allows greater flexibility in setting the page title dynamically for each route of your Nuxt app:

```vue [app/app.vue] twoslash
<script setup lang="ts">
useHead({
  // as a string,
  // where `%s` is replaced with the title
  titleTemplate: '%s - Site Title',
})
</script>
```

```vue [app/app.vue] twoslash
<script setup lang="ts">
useHead({
  // or as a function
  titleTemplate: (productCategory) => {
    return productCategory
      ? `${productCategory} - Site Title`
      : 'Site Title'
  }
})
</script>
```

`nuxt.config` is also used as an alternative way of setting the page title. However, `nuxt.config` does not allow the page title to be dynamic. Therefore, it is recommended to use `titleTemplate` in the `app.vue` file to add a dynamic title, which is then applied to all routes of your Nuxt app.

### External CSS

The example below shows how you might enable Google Fonts using either the `link` property of the [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable or using the `<Link>` component:

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
useHead({
  link: [
    {
      rel: 'preconnect',
      href: 'https://fonts.googleapis.com'
    },
    {
      rel: 'stylesheet',
      href: 'https://fonts.googleapis.com/css2?family=Roboto&display=swap',
      crossorigin: ''
    }
  ]
})
</script>
```

```vue [app/Components]
<template>
  <div>
    <Link rel="preconnect" href="https://fonts.googleapis.com" />
    <Link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" crossorigin="" />
  </div>
</template>
```
::


# Transitions

::note
Nuxt leverages Vue's [`<Transition>`](https://vuejs.org/guide/built-ins/transition.html#the-transition-component){rel="nofollow"} component to apply transitions between pages and layouts.
::

## Page Transitions

You can enable page transitions to apply an automatic transition for all your [pages](https://nuxt.com/docs/guide/directory-structure/app/pages).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: { name: 'page', mode: 'out-in' }
  }
})
```

::note
If you are changing layouts as well as page, the page transition you set here will not run. Instead, you should set a [layout transition](https://nuxt.com/docs/getting-started/transitions#layout-transitions).
::

To start adding transition between your pages, add the following CSS to your [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app):

::code-group
```vue [app/app.vue]
<template>
  <NuxtPage />
</template>

<style>
.page-enter-active,
.page-leave-active {
  transition: all 0.4s;
}
.page-enter-from,
.page-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
```

```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [app/pages/about.vue]
<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```
::

This produces the following result when navigating between pages:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665061349/nuxt3/nuxt3-page-transitions_umwvmh.jpg"}

To set a different transition for a page, set the `pageTransition` key in [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) of the page:

::code-group
```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'rotate'
  }
})
</script>
```

```vue [app/app.vue]
<template>
  <NuxtPage />
</template>

<style>
/* ... */
.rotate-enter-active,
.rotate-leave-active {
  transition: all 0.4s;
}
.rotate-enter-from,
.rotate-leave-to {
  opacity: 0;
  transform: rotate3d(1, 1, 1, 15deg);
}
</style>
```
::

Moving to the about page will add the 3d rotation effect:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665063233/nuxt3/nuxt3-page-transitions-cutom.jpg"}

## Layout Transitions

You can enable layout transitions to apply an automatic transition for all your [layouts](https://nuxt.com/docs/guide/directory-structure/app/layouts).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    layoutTransition: { name: 'layout', mode: 'out-in' }
  }
})
```

To start adding transition between your pages and layouts, add the following CSS to your [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app):

::code-group
```vue [app/app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>

<style>
.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}
.layout-enter-from,
.layout-leave-to {
  filter: grayscale(1);
}
</style>
```

```vue [app/layouts/default.vue]
<template>
  <div>
    <pre>default layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: lightgreen;
}
</style>
```

```vue [app/layouts/orange.vue]
<template>
  <div>
    <pre>orange layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: #eebb90;
  padding: 20px;
  height: 100vh;
}
</style>
```

```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [app/pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'orange'
})
</script>

<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```
::

This produces the following result when navigating between pages:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665065289/nuxt3/nuxt3-layouts-transitions_c9hwlx.jpg"}

Similar to `pageTransition`, you can apply a custom `layoutTransition` to the page component using `definePageMeta`:

```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  layout: 'orange',
  layoutTransition: {
    name: 'slide-in'
  }
})
</script>
```

## Global Settings

You can customize these default transition names globally using `nuxt.config`.

Both `pageTransition` and `layoutTransition` keys accept [`TransitionProps`](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"} as JSON serializable values where you can pass the `name`, `mode` and other valid transition-props of the custom CSS transition.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: {
      name: 'fade',
      mode: 'out-in' // default
    },
    layoutTransition: {
      name: 'slide',
      mode: 'out-in' // default
    }
  }
})
```

::warning
If you change the `name` property, you also have to rename the CSS classes accordingly.
::

To override the global transition property, use the `definePageMeta` to define page or layout transitions for a single Nuxt page and override any page or layout transitions that are defined globally in `nuxt.config` file.

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'bounce',
    mode: 'out-in' // default
  }
})
</script>
```

## Disable Transitions

`pageTransition` and `layoutTransition` can be disabled for a specific route:

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: false,
  layoutTransition: false
})
</script>
```

Or globally in the `nuxt.config`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: false,
    layoutTransition: false
  }
})
```

## JavaScript Hooks

For advanced use-cases, you can use JavaScript hooks to create highly dynamic and custom transitions for your Nuxt pages.

This way presents perfect use-cases for JavaScript animation libraries such as [GSAP](https://gsap.com){rel="nofollow"}.

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'custom-flip',
    mode: 'out-in',
    onBeforeEnter: (el) => {
      console.log('Before enter...')
    },
    onEnter: (el, done) => {},
    onAfterEnter: (el) => {}
  }
})
</script>
```

::tip
Learn more about additional [JavaScript hooks](https://vuejs.org/guide/built-ins/transition.html#javascript-hooks){rel="nofollow"} available in the `Transition` component.
::

## Dynamic Transitions

To apply dynamic transitions using conditional logic, you can leverage inline [middleware](https://nuxt.com/docs/guide/directory-structure/app/middleware) to assign a different transition name to `to.meta.pageTransition`.

::code-group
```vue [pages/[id\\].vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'slide-right',
    mode: 'out-in'
  },
  middleware (to, from) {
    if (to.meta.pageTransition && typeof to.meta.pageTransition !== 'boolean')
      to.meta.pageTransition.name = +to.params.id! > +from.params.id! ? 'slide-left' : 'slide-right'
  }
})
</script>

<template>
  <h1>#{{ $route.params.id }}</h1>
</template>

<style>
.slide-left-enter-active,
.slide-left-leave-active,
.slide-right-enter-active,
.slide-right-leave-active {
  transition: all 0.2s;
}
.slide-left-enter-from {
  opacity: 0;
  transform: translate(50px, 0);
}
.slide-left-leave-to {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-enter-from {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-leave-to {
  opacity: 0;
  transform: translate(50px, 0);
}
</style>
```

```vue [app/layouts/default.vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => Number(route.params.id || 1))
const prev = computed(() => '/' + (id.value - 1))
const next = computed(() => '/' + (id.value + 1))
</script>

<template>
  <div>
    <slot />
    <div v-if="$route.params.id">
      <NuxtLink :to="prev">⬅️</NuxtLink> |
      <NuxtLink :to="next">➡️</NuxtLink>
    </div>
  </div>
</template>
```
::

The page now applies the `slide-left` transition when going to the next id and `slide-right` for the previous:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665069410/nuxt3/nuxt-dynamic-page-transitions.jpg"}

## Transition with NuxtPage

When `<NuxtPage />` is used in `app.vue`, transitions can be configured with the `transition` prop to activate transitions globally.

```vue [app/app.vue]
<template>
  <div>
    <NuxtLayout>
      <NuxtPage :transition="{
        name: 'bounce',
        mode: 'out-in'
      }" />
    </NuxtLayout>
  </div>
</template>
```

::note
Remember, this page transition cannot be overridden with `definePageMeta` on individual pages.
::

## View Transitions API (experimental)

Nuxt ships with an experimental implementation of the [**View Transitions API**](https://developer.chrome.com/docs/web-platform/view-transitions){rel="nofollow"} (see [MDN](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API){rel="nofollow"}). This is an exciting new way to implement native browser transitions which (among other things) have the ability to transition between unrelated elements on different pages.

You can check a demo on <https://nuxt-view-transitions.surge.sh>{rel="nofollow"} and the [source on StackBlitz](https://stackblitz.com/edit/nuxt-view-transitions){rel="nofollow"}.

The Nuxt integration is under active development, but can be enabled with the `experimental.viewTransition` option in your configuration file:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    viewTransition: true
  }
})
```

The possible values are: `false`, `true`, or `'always'`.

If set to true, Nuxt will not apply transitions if the user's browser matches `prefers-reduced-motion: reduce` (recommended). If set to `always`, Nuxt will always apply the transition and it is up to you to respect the user's preference.

By default, view transitions are enabled for all [pages](https://nuxt.com/docs/guide/directory-structure/app/pages), but you can set a different global default.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    // Disable view transitions globally, and opt-in on a per page basis
    viewTransition: false
  },
})
```

It is possible to override the default `viewTransition` value for a page by setting the `viewTransition` key in [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) of the page:

```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  viewTransition: false
})
</script>
```

::warning
Overriding view transitions on a per-page basis will only have an effect if you have enabled the `experimental.viewTransition` option.
::

If you are also using Vue transitions like `pageTransition` and `layoutTransition` (see above) to achieve the same result as the new View Transitions API, then you may wish to *disable* Vue transitions if the user's browser supports the newer, native web API. You can do this by creating `~/middleware/disable-vue-transitions.global.ts` with the following contents:

```ts
export default defineNuxtRouteMiddleware(to => {
  if (import.meta.server || !document.startViewTransition) { return }

  // Disable built-in Vue transitions
  to.meta.pageTransition = false
  to.meta.layoutTransition = false
})
```

### Known Issues

- If you perform data fetching within your page setup functions, you may wish to reconsider using this feature for the moment. (By design, View Transitions completely freeze DOM updates whilst they are taking place.) We're looking at restricting the View Transition to the final moments before `<Suspense>` resolves, but in the interim you may want to consider carefully whether to adopt this feature if this describes you.


# Data Fetching

Nuxt comes with two composables and a built-in library to perform data-fetching in browser or server environments: `useFetch`, [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) and `$fetch`.

In a nutshell:

- [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) is the simplest way to make a network request.
- [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) is a wrapper around `$fetch` that fetches data only once in [universal rendering](https://nuxt.com/docs/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) is similar to `useFetch` but offers more fine-grained control.

Both `useFetch` and `useAsyncData` share a common set of options and patterns that we will detail in the last sections.

## The need for `useFetch` and `useAsyncData`

Nuxt is a framework which can run isomorphic (or universal) code in both server and client environments. If the [`$fetch` function](https://nuxt.com/docs/api/utils/dollarfetch) is used to perform data fetching in the setup function of a Vue component, this may cause data to be fetched twice, once on the server (to render the HTML) and once again on the client (when the HTML is hydrated). This can cause hydration issues, increase the time to interactivity and cause unpredictable behavior.

The [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) and [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) composables solve this problem by ensuring that if an API call is made on the server, the data is forwarded to the client in the payload.

The payload is a JavaScript object accessible through [`useNuxtApp().payload`](https://nuxt.com/docs/api/composables/use-nuxt-app#payload). It is used on the client to avoid refetching the same data when the code is executed in the browser [during hydration](https://nuxt.com/docs/guide/concepts/rendering#universal-rendering).

::tip
Use the [Nuxt DevTools](https://devtools.nuxt.com){rel="nofollow"} to inspect this data in the **Payload tab**.
::

```vue [app/app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit() {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // My form data
    }
  })
}
</script>

<template>
  <div v-if="data == undefined">
    No data
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- form input tags -->
    </form>
  </div>
</template>
```

In the example above, `useFetch` would make sure that the request would occur in the server and is properly forwarded to the browser. `$fetch` has no such mechanism and is a better option to use when the request is solely made from the browser.

### Suspense

Nuxt uses Vue's [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense){rel="nofollow"} component under the hood to prevent navigation before every async data is available to the view. The data fetching composables can help you leverage this feature and use what suits best on a per-call basis.

::note
You can add the [`<NuxtLoadingIndicator>`](https://nuxt.com/docs/api/components/nuxt-loading-indicator) to add a progress bar between page navigations.
::

## `$fetch`

Nuxt includes the [ofetch](https://github.com/unjs/ofetch){rel="nofollow"} library, and is auto-imported as the `$fetch` alias globally across your application.

```vue [pages/todos.vue] twoslash
<script setup lang="ts">
async function addTodo() {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // My todo data
    }
  })
}
</script>
```

::warning
Beware that using only `$fetch` will not provide [network calls de-duplication and navigation prevention](https://nuxt.com/#the-need-for-usefetch-and-useasyncdata). :br
It is recommended to use `$fetch` for client-side interactions (event-based) or combined with [`useAsyncData`](https://nuxt.com/#useasyncdata) when fetching the initial component data.
::

::read-more{to="https://nuxt.com/docs/api/utils/dollarfetch"}
Read more about `$fetch`.
::

### Pass Client Headers to the API

When calling `useFetch` on the server, Nuxt will use [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) to proxy client headers and cookies (with the exception of headers not meant to be forwarded, like `host`).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo');
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

Alternatively, the example below shows how to use [`useRequestHeaders`](https://nuxt.com/docs/api/composables/use-request-headers) to access and send cookies to the API from a server-side request (originating on the client). Using an isomorphic `$fetch` call, we ensure that the API endpoint has access to the same `cookie` header originally sent by the user's browser. This is only necessary if you aren't using `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser() {
  return await $fetch('/api/me', { headers })
}
</script>
```

::tip
You can also use [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) to proxy headers to the call automatically.
::

::caution
Be very careful before proxying headers to an external API and just include headers that you need. Not all headers are safe to be bypassed and might introduce unwanted behavior. Here is a list of common headers that are NOT to be proxied:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`
::

## `useFetch`

The [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) composable uses `$fetch` under-the-hood to make SSR-safe network calls in the setup function.

```vue [app/app.vue] twoslash
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Page visits: {{ count }}</p>
</template>
```

This composable is a wrapper around the [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) composable and `$fetch` utility.

::video-accordion
---
title: Watch a video from Alexander Lichter to avoid using useFetch the wrong way
video-id: njsGVmcWviY
---
::

::read-more{to="https://nuxt.com/docs/api/composables/use-fetch"}
::

::link-example{to="https://nuxt.com/docs/examples/features/data-fetching"}
::

## `useAsyncData`

The `useAsyncData` composable is responsible for wrapping async logic and returning the result once it is resolved.

::tip
`useFetch(url)` is nearly equivalent to `useAsyncData(url, () => event.$fetch(url))`. :br
It's developer experience sugar for the most common use case. (You can find out more about `event.fetch` at [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch).)
::

::video-accordion
---
title: Watch a video from Alexander Lichter to dig deeper into the difference
  between useFetch and useAsyncData
video-id: 0X-aOpSGabA
---
::

There are some cases when using the [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) composable is not appropriate, for example when a CMS or a third-party provide their own query layer. In this case, you can use [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) to wrap your calls and still keep the benefits provided by the composable.

```vue [app/pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// This is also possible:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

::note
The first argument of [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) is a unique key used to cache the response of the second argument, the querying function. This key can be ignored by directly passing the querying function, the key will be auto-generated.
:br :br
Since the autogenerated key only takes into account the file and line where `useAsyncData` is invoked, it is recommended to always create your own key to avoid unwanted behavior, like when you are creating your own custom composable wrapping `useAsyncData`.
:br :br
Setting a key can be useful to share the same data between components using [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data) or to [refresh specific data](https://nuxt.com/docs/api/utils/refresh-nuxt-data#refresh-specific-data).
::

```vue [app/pages/users/[id\\].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

The `useAsyncData` composable is a great way to wrap and wait for multiple `$fetch` requests to be completed, and then process the results.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async () => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons'),
    $fetch('/cart/offers')
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

::note
`useAsyncData` is for fetching and caching data, not triggering side effects like calling Pinia actions, as this can cause unintended behavior such as repeated executions with nullish values. If you need to trigger side effects, use the [`callOnce`](https://nuxt.com/docs/api/utils/call-once) utility to do so.

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// you can't do this
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```
::

::read-more{to="https://nuxt.com/docs/api/composables/use-async-data"}
Read more about `useAsyncData`.
::

## Return Values

`useFetch` and `useAsyncData` have the same return values listed below.

- `data`: the result of the asynchronous function that is passed in.
- `refresh`/`execute`: a function that can be used to refresh the data returned by the `handler` function.
- `clear`: a function that can be used to set `data` to `undefined` (or the value of `options.default()` if provided), set `error` to `undefined`, set `status` to `idle`, and mark any currently pending requests as cancelled.
- `error`: an error object if the data fetching failed.
- `status`: a string indicating the status of the data request (`"idle"`, `"pending"`, `"success"`, `"error"`).

::note
`data`, `error` and `status` are Vue refs accessible with `.value` in `<script setup>`
::

By default, Nuxt waits until a `refresh` is finished before it can be executed again.

::note
If you have not fetched data on the server (for example, with `server: false`), then the data *will not* be fetched until hydration completes. This means even if you await `useFetch` on client-side, `data` will remain null within `<script setup>`.
::

## Options

[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) and [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) return the same object type and accept a common set of options as their last argument. They can help you control the composables behavior, such as navigation blocking, caching or execution.

### Lazy

By default, data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue's Suspense. This feature can be ignored on client-side navigation with the `lazy` option. In that case, you will have to manually handle loading state using the `status` value.

```vue [app/app.vue] twoslash
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true
})
</script>

<template>
  <!-- you will need to handle a loading state -->
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

You can alternatively use [`useLazyFetch`](https://nuxt.com/docs/api/composables/use-lazy-fetch) and `useLazyAsyncData` as convenient methods to perform the same.

```vue twoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

::read-more{to="https://nuxt.com/docs/api/composables/use-lazy-fetch"}
Read more about `useLazyFetch`.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-lazy-async-data"}
Read more about `useLazyAsyncData`.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on blocking vs. non-blocking (lazy) requests
video-id: "1022000555"
---
::

### Client-only fetching

By default, data fetching composables will perform their asynchronous function on both client and server environments. Set the `server` option to `false` to only perform the call on the client-side. On initial load, the data will not be fetched before hydration is complete so you have to handle a pending state, though on subsequent client-side navigation the data will be awaited before loading the page.

Combined with the `lazy` option, this can be useful for data that is not needed on the first render (for example, non-SEO sensitive data).

```ts twoslash
/* This call is performed before hydration */
const articles = await useFetch('/api/article')

/* This call will only be performed on the client */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false
})
```

The `useFetch` composable is meant to be invoked in setup method or called directly at the top level of a function in lifecycle hooks, otherwise you should use [`$fetch` method](https://nuxt.com/#fetch).

### Minimize payload size

The `pick` option helps you to minimize the payload size stored in your HTML document by only selecting the fields that you want returned from the composables.

```vue
<script setup lang="ts">
/* only pick the fields used in your template */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description']
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

If you need more control or map over several objects, you can use the `transform` function to alter the result of the query.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  }
})
```

::note
Both `pick` and `transform` don't prevent the unwanted data from being fetched initially. But they will prevent unwanted data from being added to the payload transferred from server to client.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on minimizing payload size
video-id: "1026410430"
---
::

### Caching and refetching

#### Keys

[`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) and [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) use keys to prevent refetching the same data.

- [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) uses the provided URL as a key. Alternatively, a `key` value can be provided in the `options` object passed as a last argument.
- [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) uses its first argument as a key if it is a string. If the first argument is the handler function that performs the query, then a key that is unique to the file name and line number of the instance of `useAsyncData` will be generated for you.

::tip
To get the cached data by key, you can use [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data)
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on caching data with the key option
video-id: "1026410044"
---
::

#### Shared State and Option Consistency

When multiple components use the same key with `useAsyncData` or `useFetch`, they will share the same `data`, `error` and `status` refs. This ensures consistency across components but requires some options to be consistent.

The following options **must be consistent** across all calls with the same key:

- `handler` function
- `deep` option
- `transform` function
- `pick` array
- `getCachedData` function
- `default` value

```ts
// ❌ This will trigger a development warning
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
```

The following options **can safely differ** without triggering warnings:

- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ This is allowed
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: true })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: false })
```

If you need independent instances, use different keys:

```ts
// These are completely independent instances
const { data: users1 } = useAsyncData('users-1', () => $fetch('/api/users'))
const { data: users2 } = useAsyncData('users-2', () => $fetch('/api/users'))
```

#### Reactive Keys

You can use computed refs, plain refs or getter functions as keys, allowing for dynamic data fetching that automatically updates when dependencies change:

```ts
// Using a computed property as a key
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value)
)

// When userId changes, the data will be automatically refetched
// and the old data will be cleaned up if no other components use it
userId.value = '456'
```

#### Refresh and execute

If you want to fetch or refresh data manually, use the `execute` or `refresh` function provided by the composables.

```vue twoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">Refresh data</button>
  </div>
</template>
```

The `execute` function is an alias for `refresh` that works in exactly the same way but is more semantic for cases when the fetch is [not immediate](https://nuxt.com/#not-immediate).

::tip
To globally refetch or invalidate cached data, see [`clearNuxtData`](https://nuxt.com/docs/api/utils/clear-nuxt-data) and [`refreshNuxtData`](https://nuxt.com/docs/api/utils/refresh-nuxt-data).
::

#### Clear

If you want to clear the data provided, for whatever reason, without needing to know the specific key to pass to `clearNuxtData`, you can use the `clear` function provided by the composables.

```vue twoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') clear()
})
</script>
```

#### Watch

To re-run your fetching function each time other reactive values in your application change, use the `watch` option. You can use it for one or multiple *watchable* elements.

```vue twoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Changing the id will trigger a refetch */
  watch: [id]
})
</script>
```

Note that **watching a reactive value won't change the URL fetched**. For example, this will keep fetching the same initial ID of the user because the URL is constructed at the moment the function is invoked.

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id]
})
</script>
```

If you need to change the URL based on a reactive value, you may want to use a [computed URL](https://nuxt.com/#computed-url) instead.

#### Computed URL

Sometimes you may need to compute a URL from reactive values, and refresh the data each time these change. Instead of juggling your way around, you can attach each param as a reactive value. Nuxt will automatically use the reactive value and re-fetch each time it changes.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id
  }
})
</script>
```

In the case of more complex URL construction, you may use a callback as a [computed getter](https://vuejs.org/guide/essentials/computed.html){rel="nofollow"} that returns the URL string.

Every time a dependency changes, the data will be fetched using the newly constructed URL. Combine this with [not-immediate](https://nuxt.com/#not-immediate), and you can wait until the reactive element changes before fetching.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false
})

const pending = computed(() => status.value === 'pending');
</script>

<template>
  <div>
    <!-- disable the input while fetching -->
    <input v-model="id" type="number" :disabled="pending"/>

    <div v-if="status === 'idle'">
      Type an user ID
    </div>

    <div v-else-if="pending">
      Loading ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

If you need to force a refresh when other reactive values change, you can also [watch other values](https://nuxt.com/#watch).

### Not immediate

The `useFetch` composable will start fetching data the moment is invoked. You may prevent this by setting `immediate: false`, for example, to wait for user interaction.

With that, you will need both the `status` to handle the fetch lifecycle, and `execute` to start the data fetch.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/comments', {
  immediate: false
})
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">Get data</button>
  </div>

  <div v-else-if="status === 'pending'">
    Loading comments...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

For finer control, the `status` variable can be:

- `idle` when the fetch hasn't started
- `pending` when a fetch has started but not yet completed
- `error` when the fetch fails
- `success` when the fetch is completed successfully

## Passing Headers and Cookies

When we call `$fetch` in the browser, user headers like `cookie` will be directly sent to the API.

Normally, during server-side-rendering, due to security considerations, the `$fetch` wouldn't include the user's browser cookies, nor pass on cookies from the fetch response.

However, when calling `useFetch` with a relative URL on the server, Nuxt will use [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) to proxy headers and cookies (with the exception of headers not meant to be forwarded, like `host`).

### Pass Cookies From Server-side API Calls on SSR Response

If you want to pass on/proxy cookies in the other direction, from an internal request back to the client, you will need to handle this yourself.

```ts [app/composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Get the response from the server endpoint */
  const res = await $fetch.raw(url)
  /* Get the cookies from the response */
  const cookies = res.headers.getSetCookie()
  /* Attach each cookie to our incoming Request */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  /* Return the data of the response */
  return res._data
}
```

```vue
<script setup lang="ts">
// This composable will automatically pass cookies to the client
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Options API Support

Nuxt provides a way to perform `asyncData` fetching within the Options API. You must wrap your component definition within `defineNuxtComponent` for this to work.

```vue
<script>
export default defineNuxtComponent({
  /* Use the fetchKey option to provide a unique key */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

::note
Using `<script setup>` or `<script setup lang="ts">` are the recommended way of declaring Vue components in Nuxt.
::

::read-more{to="https://nuxt.com/docs/api/utils/define-nuxt-component"}
::

## Serializing Data From Server to Client

When using `useAsyncData` and `useLazyAsyncData` to transfer data fetched on server to the client (as well as anything else that utilizes [the Nuxt payload](https://nuxt.com/docs/api/composables/use-nuxt-app#payload)), the payload is serialized with [`devalue`](https://github.com/Rich-Harris/devalue){rel="nofollow"}. This allows us to transfer not just basic JSON but also to serialize and revive/deserialize more advanced kinds of data, such as regular expressions, Dates, Map and Set, `ref`, `reactive`, `shallowRef`, `shallowReactive` and `NuxtError` - and more.

It is also possible to define your own serializer/deserializer for types that are not supported by Nuxt. You can read more in the [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app#payload) docs.

::note
Note that this *does not apply* to data passed from your server routes when fetched with `$fetch` or `useFetch` - see the next section for more information.
::

## Serializing Data From API Routes

When fetching data from the `server` directory, the response is serialized using `JSON.stringify`. However, since serialization is limited to only JavaScript primitive types, Nuxt does its best to convert the return type of `$fetch` and [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) to match the actual value.

::read-more
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description
---
Learn more about `JSON.stringify` limitations.
::

### Example

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app/app.vue]
<script setup lang="ts">
// Type of `data` is inferred as string even though we returned a Date object
const { data } = await useFetch('/api/foo')
</script>
```

### Custom serializer function

To customize the serialization behavior, you can define a `toJSON` function on your returned object. If you define a `toJSON` method, Nuxt will respect the return type of the function and will not try to convert the types.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON() {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})

```

```vue [app/app.vue]
<script setup lang="ts">
// Type of `data` is inferred as
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Using an alternative serializer

Nuxt does not currently support an alternative serializer to `JSON.stringify`. However, you can return your payload as a normal string and utilize the `toJSON` method to maintain type safety.

In the example below, we use [superjson](https://github.com/blitz-js/superjson){rel="nofollow"} as our serializer.

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Workaround the type conversion
    toJSON() {
      return this
    }
  }

  // Serialize the output to string, using superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app/app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Recipes

### Consuming SSE (Server-Sent Events) via POST request

::tip
If you're consuming SSE via GET request, you can use [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource){rel="nofollow"} or VueUse composable [`useEventSource`](https://vueuse.org/core/useEventSource/){rel="nofollow"}.
::

When consuming SSE via POST request, you need to handle the connection manually. Here's how you can do it:

```ts
// Make a POST request to the SSE endpoint
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: "Hello AI, how are you?",
  },
  responseType: 'stream',
})

// Create a new ReadableStream from the response with TextDecoderStream to get the data as text
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

// Read the chunk of data as we get it
while (true) {
  const { value, done } = await reader.read()

  if (done)
    break

  console.log('Received:', value)
}
```

### Making parallel requests

When requests don't rely on each other, you can make them in parallel with `Promise.all()` to boost performance.

```ts
const { data } = await useAsyncData(() => {
  return Promise.all([
    $fetch("/api/comments/"), 
    $fetch("/api/author/12")
  ]);
});

const comments = computed(() => data.value?.[0]);
const author = computed(() => data.value?.[1]);
```

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on parallel data fetching
video-id: "1024262536"
---
::


# State Management

Nuxt provides the [`useState`](https://nuxt.com/docs/api/composables/use-state) composable to create a reactive and SSR-friendly shared state across components.

[`useState`](https://nuxt.com/docs/api/composables/use-state) is an SSR-friendly [`ref`](https://vuejs.org/api/reactivity-core.html#ref){rel="nofollow"} replacement. Its value will be preserved after server-side rendering (during client-side hydration) and shared across all components using a unique key.

::video-accordion
---
title: Watch a video from Alexander Lichter about why and when to use useState
video-id: mv0WcBABcIk
---
::

::important
Because the data inside [`useState`](https://nuxt.com/docs/api/composables/use-state) will be serialized to JSON, it is important that it does not contain anything that cannot be serialized, such as classes, functions or symbols.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-state"}
Read more about `useState` composable.
::

## Best Practices

::warning
Never define `const state = ref()` outside of `<script setup>` or `setup()` function. :br
For example, doing `export myState = ref({})` would result in state shared across requests on the server and can lead to memory leaks.
::

::tip{icon="i-lucide-circle-check"}
Instead use `const useX = () => useState('x')`
::

## Examples

### Basic Usage

In this example, we use a component-local counter state. Any other component that uses `useState('counter')` shares the same reactive state.

```vue [app/app.vue] twoslash
<script setup lang="ts">
const counter = useState('counter', () => Math.round(Math.random() * 1000))
</script>

<template>
  <div>
    Counter: {{ counter }}
    <button @click="counter++">
      +
    </button>
    <button @click="counter--">
      -
    </button>
  </div>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/features/state-management"}
::

::note
To globally invalidate cached state, see [`clearNuxtState`](https://nuxt.com/docs/api/utils/clear-nuxt-state) util.
::

### Initializing State

Most of the time, you will want to initialize your state with data that resolves asynchronously. You can use the [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) component with the [`callOnce`](https://nuxt.com/docs/api/utils/call-once) util to do so.

```vue [app/app.vue] twoslash
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

::tip
This is similar to the [`nuxtServerInit` action](https://v2.nuxt.com/docs/directory-structure/store/#the-nuxtserverinit-action){rel="nofollow"} in Nuxt 2, which allows filling the initial state of your store server-side before rendering the page.
::

::read-more{to="https://nuxt.com/docs/api/utils/call-once"}
::

### Usage with Pinia

In this example, we leverage the [Pinia module](https://nuxt.com/modules/pinia) to create a global store and use it across the app.

::important
Make sure to install the Pinia module with `npx nuxt module add pinia` or follow the [module's installation steps](https://pinia.vuejs.org/ssr/nuxt.html#Installation){rel="nofollow"}.
::

::code-group
```ts [app/stores/website.ts]
export const useWebsiteStore = defineStore('websiteStore', {
  state: () => ({
    name: '',
    description: ''
  }),
  actions: {
    async fetch() {
      const infos = await $fetch('https://api.nuxt.com/modules/pinia')

      this.name = infos.name
      this.description = infos.description
    }
  }
})
```

```vue [app/app.vue]
<script setup lang="ts">
const website = useWebsiteStore()

await callOnce(website.fetch)
</script>

<template>
  <main>
    <h1>{{ website.name }}</h1>
    <p>{{ website.description }}</p>
  </main>
</template>
```
::

## Advanced Usage

::code-group
```ts [app/composables/locale.ts]
import type { Ref } from 'vue'

export const useLocale = () => {
  return useState<string>('locale', () => useDefaultLocale().value)
}

export const useDefaultLocale = (fallback = 'en-US') => {
  const locale = ref(fallback)
  if (import.meta.server) {
    const reqLocale = useRequestHeaders()['accept-language']?.split(',')[0]
    if (reqLocale) {
      locale.value = reqLocale
    }
  } else if (import.meta.client) {
    const navLang = navigator.language
    if (navLang) {
      locale.value = navLang
    }
  }
  return locale
}

export const useLocales = () => {
  const locale = useLocale()
  const locales = ref([
    'en-US',
    'en-GB',
    ...
    'ja-JP-u-ca-japanese'
  ])
  if (!locales.value.includes(locale.value)) {
    locales.value.unshift(locale.value)
  }
  return locales
}

export const useLocaleDate = (date: Ref<Date> | Date, locale = useLocale()) => {
  return computed(() => new Intl.DateTimeFormat(locale.value, { dateStyle: 'full' }).format(unref(date)))
}
```

```vue [app/app.vue]
<script setup lang="ts">
const locales = useLocales()
const locale = useLocale()
const date = useLocaleDate(new Date('2016-10-26'))
</script>

<template>
  <div>
    <h1>Nuxt birthday</h1>
    <p>{{ date }}</p>
    <label for="locale-chooser">Preview a different locale</label>
    <select id="locale-chooser" v-model="locale">
      <option v-for="loc of locales" :key="loc" :value="loc">
        {{ loc }}
      </option>
    </select>
  </div>
</template>
```
::

::link-example{to="https://nuxt.com/docs/examples/advanced/locale"}
::

## Shared State

By using [auto-imported composables](https://nuxt.com/docs/guide/directory-structure/app/composables) we can define global type-safe states and import them across the app.

```ts [composables/states.ts] twoslash
export const useColor = () => useState<string>('color', () => 'pink')
```

```vue [app/app.vue]
<script setup lang="ts">
// ---cut-start---
const useColor = () => useState<string>('color', () => 'pink')
// ---cut-end---
const color = useColor() // Same as useState('color')
</script>

<template>
  <p>Current color: {{ color }}</p>
</template>
```

::video-accordion
---
title: Watch a video from Daniel Roe on how to deal with global state and SSR in Nuxt
video-id: dZSNW07sO-A
---
::

## Using third-party libraries

Nuxt **used to rely** on the Vuex library to provide global state management. If you are migrating from Nuxt 2, please head to [the migration guide](https://nuxt.com/docs/migration/configuration#vuex).

Nuxt is not opinionated about state management, so feel free to choose the right solution for your needs. There are multiple integrations with the most popular state management libraries, including:

- [Pinia](https://nuxt.com/modules/pinia) - the official Vue recommendation
- [Harlem](https://nuxt.com/modules/harlem) - immutable global state management
- [XState](https://nuxt.com/modules/xstate) - state machine approach with tools for visualizing and testing your state logic


# Error Handling

Nuxt is a full-stack framework, which means there are several sources of unpreventable user runtime errors that can happen in different contexts:

- Errors during the Vue rendering lifecycle (SSR & CSR)
- Server and client startup errors (SSR + CSR)
- Errors during Nitro server lifecycle ([`server/`](https://nuxt.com/docs/guide/directory-structure/server) directory)
- Errors downloading JS chunks

::tip
**SSR** stands for **Server-Side Rendering** and **CSR** for **Client-Side Rendering**.
::

## Vue Errors

You can hook into Vue errors using [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"}.

In addition, Nuxt provides a [`vue:error`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) hook that will be called if any errors propagate up to the top level.

If you are using an error reporting framework, you can provide a global handler through [`vueApp.config.errorHandler`](https://vuejs.org/api/application.html#app-config-errorhandler){rel="nofollow"}. It will receive all Vue errors, even if they are handled.

```ts [plugins/error-handler.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.config.errorHandler = (error, instance, info) => {
    // handle error, e.g. report to a service
  }

  // Also possible
  nuxtApp.hook('vue:error', (error, instance, info) => {
    // handle error, e.g. report to a service
  })
})
```

::note
Note that the `vue:error` hook is based on [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"} lifecycle hook.
::

## Startup Errors

Nuxt will call the `app:error` hook if there are any errors in starting your Nuxt application.

This includes:

- running [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins)
- processing `app:created` and `app:beforeMount` hooks
- rendering your Vue app to HTML (during SSR)
- mounting the app (on client-side), though you should handle this case with `onErrorCaptured` or with `vue:error`
- processing the `app:mounted` hook

## Nitro Server Errors

You cannot currently define a server-side handler for these errors, but can render an error page, see the [Render an Error Page](https://nuxt.com/#error-page) section.

## Errors with JS Chunks

You might encounter chunk loading errors due to a network connectivity failure or a new deployment (which invalidates your old, hashed JS chunk URLs). Nuxt provides built-in support for handling chunk loading errors by performing a hard reload when a chunk fails to load during route navigation.

You can change this behavior by setting `experimental.emitRouteChunkError` to `false` (to disable hooking into these errors at all) or to `manual` if you want to handle them yourself. If you want to handle chunk loading errors manually, you can check out the [the automatic implementation](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/plugins/chunk-reload.client.ts){rel="nofollow"} for ideas.

## Error Page

::note
When Nuxt encounters a fatal error (any unhandled error on the server, or an error created with `fatal: true` on the client) it will either render a JSON response (if requested with `Accept: application/json` header) or trigger a full-screen error page.
::

An error may occur during the server lifecycle when:

- processing your Nuxt plugins
- rendering your Vue app into HTML
- a server API route throws an error

It can also occur on the client side when:

- processing your Nuxt plugins
- before mounting the application (`app:beforeMount` hook)
- mounting your app if the error was not handled with `onErrorCaptured` or `vue:error` hook
- the Vue app is initialized and mounted in browser (`app:mounted`).

::read-more{to="https://nuxt.com/docs/api/advanced/hooks"}
Discover all the Nuxt lifecycle hooks.
::

Customize the default error page by adding `~/error.vue` in the source directory of your application, alongside `app.vue`.

```vue [error.vue]
<script setup lang="ts">
import type { NuxtError } from '#app'

const props = defineProps({
  error: Object as () => NuxtError
})

const handleError = () => clearError({ redirect: '/' })
</script>

<template>
  <div>
    <h2>{{ error?.statusCode }}</h2>
    <button @click="handleError">Clear errors</button>
  </div>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/error"}
Read more about `error.vue` and its uses.
::

For custom errors we highly recommend using `onErrorCaptured` composable that can be called in a page/component setup function or `vue:error` runtime nuxt hook that can be configured in a nuxt plugin.

```ts [plugins/error-handler.ts] twoslash
export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.hook('vue:error', (err) => {
    //
  })
})
```

When you are ready to remove the error page, you can call the [`clearError`](https://nuxt.com/docs/api/utils/clear-error) helper function, which takes an optional path to redirect to (for example, if you want to navigate to a 'safe' page).

::important
Make sure to check before using anything dependent on Nuxt plugins, such as `$route` or `useRouter`, as if a plugin threw an error, then it won't be re-run until you clear the error.
::

::note
Rendering an error page is an entirely separate page load, meaning any registered middleware will run again. You can use [`useError`](https://nuxt.com/#useerror) in middleware to check if an error is being handled.
::

::note
If you are running on Node 16 and you set any cookies when rendering your error page, they will [overwrite cookies previously set](https://github.com/nuxt/nuxt/pull/20585){rel="nofollow"}. We recommend using a newer version of Node as Node 16 reached end-of-life in September 2023.
::

## Error Utils

### `useError`

```ts [TS Signature]
function useError (): Ref<Error | { url, statusCode, statusMessage, message, description, data }>
```

This function will return the global Nuxt error that is being handled.

::read-more{to="https://nuxt.com/docs/api/composables/use-error"}
Read more about `useError` composable.
::

### `createError`

```ts [TS Signature]
function createError (err: string | { cause, data, message, name, stack, statusCode, statusMessage, fatal }): Error
```

Create an error object with additional metadata. You can pass a string to be set as the error `message` or an object containing error properties. It is usable in both the Vue and Server portions of your app, and is meant to be thrown.

If you throw an error created with `createError`:

- on server-side, it will trigger a full-screen error page which you can clear with [`clearError`](https://nuxt.com/#clearerror).
- on client-side, it will throw a non-fatal error for you to handle. If you need to trigger a full-screen error page, then you can do this by setting `fatal: true`.

```vue [pages/movies/[slug\\].vue] twoslash
<script setup lang="ts">
const route = useRoute()
const { data } = await useFetch(`/api/movies/${route.params.slug}`)

if (!data.value) {
  throw createError({
    statusCode: 404,
    statusMessage: 'Page Not Found'
  })
}
</script>
```

::read-more{to="https://nuxt.com/docs/api/utils/create-error"}
Read more about `createError` util.
::

### `showError`

```ts [TS Signature]
function showError (err: string | Error | { statusCode, statusMessage }): Error
```

You can call this function at any point on client-side, or (on server side) directly within middleware, plugins or `setup()` functions. It will trigger a full-screen error page which you can clear with [`clearError`](https://nuxt.com/#clearerror).

It is recommended instead to use `throw createError()`.

::read-more{to="https://nuxt.com/docs/api/utils/show-error"}
Read more about `showError` util.
::

### `clearError`

```ts [TS Signature]
function clearError (options?: { redirect?: string }): Promise<void>
```

This function will clear the currently handled Nuxt error. It also takes an optional path to redirect to (for example, if you want to navigate to a 'safe' page).

::read-more{to="https://nuxt.com/docs/api/utils/clear-error"}
Read more about `clearError` util.
::

## Render Error in Component

Nuxt also provides a [`<NuxtErrorBoundary>`](https://nuxt.com/docs/api/components/nuxt-error-boundary) component that allows you to handle client-side errors within your app, without replacing your entire site with an error page.

This component is responsible for handling errors that occur within its default slot. On client-side, it will prevent the error from bubbling up to the top level, and will render the `#error` slot instead.

The `#error` slot will receive `error` as a prop. (If you set `error = null` it will trigger re-rendering the default slot; you'll need to ensure that the error is fully resolved first or the error slot will just be rendered a second time.)

::tip
If you navigate to another route, the error will be cleared automatically.
::

```vue [app/pages/index.vue]
<template>
  <!-- some content -->
  <NuxtErrorBoundary @error="someErrorLogger">
    <!-- You use the default slot to render your content -->
    <template #error="{ error, clearError }">
      You can display the error locally here: {{ error }}
      <button @click="clearError">
        This will clear the error.
      </button>
    </template>
  </NuxtErrorBoundary>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/advanced/error-handling"}
::


# Server

::read-more{to="https://nuxt.com/docs/guide/directory-structure/server"}
::

## Powered by Nitro

![Server engine](https://nuxt.com/assets/docs/getting-started/server.svg)

Nuxt's server is [Nitro](https://github.com/nitrojs/nitro){rel="nofollow"}. It was originally created for Nuxt but is now part of [UnJS](https://unjs.io){rel="nofollow"} and open for other frameworks - and can even be used on its own.

Using Nitro gives Nuxt superpowers:

- Full control of the server-side part of your app
- Universal deployment on any provider (many zero-config)
- Hybrid rendering

Nitro is internally using [h3](https://github.com/h3js/h3){rel="nofollow"}, a minimal H(TTP) framework built for high performance and portability.

::video-accordion
---
title: Watch a video from Alexander Lichter to understand the responsibilities
  of Nuxt and Nitro in your application
video-id: DkvgJa-X31k
---
::

## Server Endpoints & Middleware

You can easily manage the server-only part of your Nuxt app, from API endpoints to middleware.

Both endpoints and middleware can be defined like this:

```ts [server/api/test.ts] twoslash
export default defineEventHandler(async (event) => {
  // ... Do whatever you want here
})
```

And you can directly return `text`, `json`, `html` or even a `stream`.

Out-of-the-box, it supports **hot module replacement** and **auto-import** like the other parts of your Nuxt application.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/server"}
::

## Universal Deployment

Nitro offers the ability to deploy your Nuxt app anywhere, from a bare metal server to the edge network, with a start time of just a few milliseconds. That's fast!

::read-more{to="https://nuxt.com/blog/nuxt-on-the-edge"}
::

There are more than 15 presets to build your Nuxt app for different cloud providers and servers, including:

- [Cloudflare Workers](https://workers.cloudflare.com){rel="nofollow"}
- [Netlify Functions](https://www.netlify.com/products/functions){rel="nofollow"}
- [Vercel Edge Network](https://vercel.com/docs/edge-network){rel="nofollow"}

Or for other runtimes:

::card-group
  :::card{icon="i-logos-deno" target="_blank" title="Deno" to="https://deno.land"}
  :::

  :::card{icon="i-logos-bun" target="_blank" title="Bun" to="https://bun.sh"}
  :::
::

::read-more{to="https://nuxt.com/docs/getting-started/deployment"}
::

## Hybrid Rendering

Nitro has a powerful feature called `routeRules` which allows you to define a set of rules to customize how each route of your Nuxt app is rendered (and more).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  routeRules: {
    // Generated at build time for SEO purpose
    '/': { prerender: true },
    // Cached for 1 hour
    '/api/*': { cache: { maxAge: 60 * 60 } },
    // Redirection to avoid 404
    '/old-page': {
      redirect: { to: '/new-page', statusCode: 302 }
    }
    // ...
  }
})
```

::read-more
---
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
Learn about all available route rules are available to customize the rendering mode of your routes.
::

In addition, there are some route rules (for example, `ssr`, `appMiddleware`, and `noScripts`) that are Nuxt specific to change the behavior when rendering your pages to HTML.

Some route rules (`appMiddleware`, `redirect` and `prerender`) also affect client-side behavior.

Nitro is used to build the app for server side rendering, as well as pre-rendering.

::read-more{to="https://nuxt.com/docs/guide/concepts/rendering"}
::


# Layers

One of the core features of Nuxt is the layers and extending support. You can extend a default Nuxt application to reuse components, utils, and configuration. The layers structure is almost identical to a standard Nuxt application which makes them easy to author and maintain.

## Use Cases

- Share reusable configuration presets across projects using `nuxt.config` and `app.config`
- Create a component library using [`app/components/`](https://nuxt.com/docs/guide/directory-structure/app/components) directory
- Create utility and composable library using [`app/composables/`](https://nuxt.com/docs/guide/directory-structure/app/composables) and [`app/utils/`](https://nuxt.com/docs/guide/directory-structure/app/utils) directories
- Create Nuxt module presets
- Share standard setup across projects
- Create Nuxt themes
- Enhance code organization by implementing a modular architecture and support Domain-Driven Design (DDD) pattern in large scale projects.

## Usage

By default, any layers within your project in the `~~/layers` directory will be automatically registered as layers in your project.

::note
Layer auto-registration was introduced in Nuxt v3.12.0.
::

In addition, named layer aliases to the `srcDir` of each of these layers will automatically be created. For example, you will be able to access the `~~/layers/test` layer via `#layers/test`.

::note
Named layer aliases were introduced in Nuxt v3.16.0.
::

In addition, you can extend from a layer by adding the [extends](https://nuxt.com/docs/api/nuxt-config#extends) property to your [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    '../base',                     // Extend from a local layer
    '@my-themes/awesome',          // Extend from an installed npm package
    'github:my-themes/awesome#v1', // Extend from a git repository
  ]
})
```

You can also pass an authentication token if you are extending from a private GitHub repository:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // per layer configuration
    ['github:my-themes/private-awesome', { auth: process.env.GITHUB_TOKEN }]
  ]
})
```

::tip
You can override a layer's alias by specifying it in the options next to the layer source.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    [
      'github:my-themes/awesome',
      { 
        meta: {
          name: 'my-awesome-theme',
        },
      },
    ],
  ]
})
```
::

Nuxt uses [unjs/c12](https://c12.unjs.io){rel="nofollow"} and [unjs/giget](https://giget.unjs.io){rel="nofollow"} for extending remote layers. Check the documentation for more information and all available options.

## Layer Priority

When using multiple layers, it's important to understand how they override each other:

1. **Layers in `extends`** - earlier entries have higher priority (first overrides second)
2. **Auto-scanned local layers** from `~~/layers` directory in alphabetical order (Z overrides A)
3. **Your project** has the highest priority in the stack - it will always override other layers

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    '../base',                     // Highest priority (among extends)
    '@my-themes/awesome',          // Medium priority
    'github:my-themes/awesome#v1', // Lower priority
  ]
  // Your project has the highest priority
})
```

This means if multiple layers define the same component, configuration, or file, the one with higher priority will be used.

::read-more{to="https://nuxt.com/docs/guide/going-further/layers"}
Read more about layers in the **Layer Author Guide**.
::

::video-accordion
---
title: Watch a video from Learn Vue about Nuxt Layers
video-id: lnFCM7c9f7I
---
::

::video-accordion
---
title: Watch a video from Alexander Lichter about Nuxt Layers
video-id: fr5yo3aVkfA
---
::

## Examples

::card-group
  :::card
  ---
  icon: i-simple-icons-github
  target: _blank
  title: Content Wind
  to: https://github.com/Atinux/content-wind
  ---
  A lightweight Nuxt theme to build a Markdown driven website. Powered by Nuxt Content, TailwindCSS and Iconify.
  :::
::


# Prerendering

Nuxt allows for select pages from your application to be rendered at build time. Nuxt will serve the prebuilt pages when requested instead of generating them on the fly.

::read-more
---
title: Nuxt rendering modes
to: https://nuxt.com/docs/guide/concepts/rendering
---
::

## Crawl-based Pre-rendering

Use the [`nuxt generate` command](https://nuxt.com/docs/api/commands/generate) to build and pre-render your application using the [Nitro](https://nuxt.com/docs/guide/concepts/server-engine) crawler. This command is similar to `nuxt build` with the `nitro.static` option set to `true`, or running `nuxt build --prerender`.

This will build your site, stand up a nuxt instance, and, by default, prerender the root page `/` along with any of your site's pages it links to, any of your site's pages they link to, and so on.

::code-group{sync="pm"}
```bash [npm]
npx nuxt generate
```

```bash [yarn]
yarn nuxt generate
```

```bash [pnpm]
pnpm nuxt generate
```

```bash [bun]
bun x nuxt generate
```
::

You can now deploy the `.output/public` directory to any static hosting service or preview it locally with `npx serve .output/public`.

Working of the Nitro crawler:

1. Load the HTML of your application's root route (`/`), any non-dynamic pages in your `~/pages` directory, and any other routes in the `nitro.prerender.routes` array.
2. Save the HTML and `payload.json` to the `~/.output/public/` directory to be served statically.
3. Find all anchor tags (`<a href="...">`) in the HTML to navigate to other routes.
4. Repeat steps 1-3 for each anchor tag found until there are no more anchor tags to crawl.

This is important to understand since pages that are not linked to a discoverable page can't be pre-rendered automatically.

::read-more{to="https://nuxt.com/docs/api/commands/generate#nuxt-generate"}
Read more about the `nuxt generate` command.
::

### Selective Pre-rendering

You can manually specify routes that [Nitro](https://nuxt.com/docs/guide/concepts/server-engine) will fetch and pre-render during the build or ignore routes that you don't want to pre-render like `/dynamic` in the `nuxt.config` file:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  nitro: {
    prerender: {
      routes: ["/user/1", "/user/2"],
      ignore: ["/dynamic"],
    },
  },
});
```

You can combine this with the `crawlLinks` option to pre-render a set of routes that the crawler can't discover like your `/sitemap.xml` or `/robots.txt`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  nitro: {
    prerender: {
      crawlLinks: true,
      routes: ["/sitemap.xml", "/robots.txt"],
    },
  },
});
```

Setting `nitro.prerender` to `true` is similar to `nitro.prerender.crawlLinks` to `true`.

::read-more{to="https://nitro.build/config#prerender"}
Read more about pre-rendering in the Nitro documentation.
::

Lastly, you can manually configure this using routeRules.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  routeRules: {
    // Set prerender to true to configure it to be prerendered
    "/rss.xml": { prerender: true },
    // Set it to false to configure it to be skipped for prerendering
    "/this-DOES-NOT-get-prerendered": { prerender: false },
    // Everything under /blog gets prerendered as long as it
    // is linked to from another page
    "/blog/**": { prerender: true },
  },
});
```

::read-more{to="https://nitro.build/config#routerules"}
Read more about Nitro's `routeRules` configuration.
::

As a shorthand, you can also configure this in a page file using [`defineRouteRules`](https://nuxt.com/docs/api/utils/define-route-rules).

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#inlinerouterules
---
This feature is experimental and in order to use it you must enable the `experimental.inlineRouteRules` option in your `nuxt.config`.
::

```vue [app/pages/index.vue]
<script setup>
// Or set at the page level
defineRouteRules({
  prerender: true,
});
</script>

<template>
  <div>
    <h1>Homepage</h1>
    <p>Pre-rendered at build time</p>
  </div>
</template>
```

This will be translated to:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    "/": { prerender: true },
  },
});
```

## Runtime Prerender Configuration

### `prerenderRoutes`

You can use this at runtime within a [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context) to add more routes for Nitro to prerender.

```vue [app/pages/index.vue]
<script setup>
prerenderRoutes(["/some/other/url"]);
prerenderRoutes("/api/content/article/my-article");
</script>

<template>
  <div>
    <h1>This will register other routes for prerendering when prerendered</h1>
  </div>
</template>
```

::read-more
---
title: prerenderRoutes
to: https://nuxt.com/docs/api/utils/prerender-routes
---
::

### `prerender:routes` Nuxt hook

This is called before prerendering for additional routes to be registered.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    async "prerender:routes"(ctx) {
      const { pages } = await fetch("https://api.some-cms.com/pages").then(
        (res) => res.json(),
      );
      for (const page of pages) {
        ctx.routes.add(`/${page.name}`);
      }
    },
  },
});
```

### `prerender:generate` Nitro hook

This is called for each route during prerendering. You can use this for fine-grained handling of each route that gets prerendered.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    hooks: {
      "prerender:generate"(route) {
        if (route.route?.includes("private")) {
          route.skip = true;
        }
      },
    },
  },
});
```


# Deployment

A Nuxt application can be deployed on a Node.js server, pre-rendered for static hosting, or deployed to serverless or edge (CDN) environments.

::tip
If you are looking for a list of cloud providers that support Nuxt, see the [Hosting providers](https://nuxt.com/deploy) section.
::

## Node.js Server

Discover the Node.js server preset with Nitro to deploy on any Node hosting.

- **Default output format** if none is specified or auto-detected :br
- Loads only the required chunks to render the request for optimal cold start timing :br
- Useful for deploying Nuxt apps to any Node.js hosting

### Entry Point

When running `nuxt build` with the Node server preset, the result will be an entry point that launches a ready-to-run Node server.

```bash [Terminal]
node .output/server/index.mjs
```

This will launch your production Nuxt server that listens on port 3000 by default.

It respects the following runtime environment variables:

- `NITRO_PORT` or `PORT` (defaults to `3000`)
- `NITRO_HOST` or `HOST` (defaults to `'0.0.0.0'`)
- `NITRO_SSL_CERT` and `NITRO_SSL_KEY` - if both are present, this will launch the server in HTTPS mode. In the vast majority of cases, this should not be used other than for testing, and the Nitro server should be run behind a reverse proxy like nginx or Cloudflare which terminates SSL.

### PM2

[PM2](https://pm2.keymetrics.io/){rel="nofollow"} (Process Manager 2) is a fast and easy solution for hosting your Nuxt application on your server or VM.

To use `pm2`, use an `ecosystem.config.cjs`:

```ts [ecosystem.config.cjs]
module.exports = {
  apps: [
    {
      name: 'NuxtAppName',
      port: '3000',
      exec_mode: 'cluster',
      instances: 'max',
      script: './.output/server/index.mjs'
    }
  ]
}
```

### Cluster Mode

You can use `NITRO_PRESET=node_cluster` in order to leverage multi-process performance using Node.js [cluster](https://nodejs.org/dist/latest/docs/api/cluster.html){rel="nofollow"} module.

By default, the workload gets distributed to the workers with the round robin strategy.

### Learn More

::read-more
---
title: the Nitro documentation for node-server preset
to: https://nitro.build/deploy/runtimes/node
---
::

::video-accordion
---
title: Watch Daniel Roe's short video on the topic
video-id: 0x1H6K5yOfs
---
::

## Static Hosting

There are two ways to deploy a Nuxt application to any static hosting services:

- Static site generation (SSG) with `ssr: true` pre-renders routes of your application at build time. (This is the default behavior when running `nuxt generate`.) It will also generate `/200.html` and `/404.html` single-page app fallback pages, which can render dynamic routes or 404 errors on the client (though you may need to configure this on your static host).
- Alternatively, you can prerender your site with `ssr: false` (static single-page app). This will produce HTML pages with an empty `<div id="__nuxt"></div>` where your Vue app would normally be rendered. You will lose many SEO benefits of prerendering your site, so it is suggested instead to use [`<ClientOnly>`](https://nuxt.com/docs/api/components/client-only) to wrap the portions of your site that cannot be server rendered (if any).

::read-more
---
title: Nuxt prerendering
to: https://nuxt.com/docs/getting-started/prerendering
---
::

### Client-side Only Rendering

If you don't want to pre-render your routes, another way of using static hosting is to set the `ssr` property to `false` in the `nuxt.config` file. The `nuxt generate` command will then output an `.output/public/index.html` entrypoint and JavaScript bundles like a classic client-side Vue.js application.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  ssr: false
})
```

## Hosting Providers

Nuxt can be deployed to several cloud providers with a minimal amount of configuration:

::read-more{to="https://nuxt.com/deploy"}
::

## Presets

In addition to Node.js servers and static hosting services, a Nuxt project can be deployed with several well-tested presets and minimal amount of configuration.

You can explicitly set the desired preset in the [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file:

```js [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  nitro: {
    preset: 'node-server'
  }
})
```

... or use the `NITRO_PRESET` environment variable when running `nuxt build`:

```bash [Terminal]
NITRO_PRESET=node-server nuxt build
```

🔎 Check [the Nitro deployment](https://nitro.build/deploy){rel="nofollow"} for all possible deployment presets and providers.

## CDN Proxy

In most cases, Nuxt can work with third-party content that is not generated or created by Nuxt itself. But sometimes such content can cause problems, especially Cloudflare's "Minification and Security Options".

Accordingly, you should make sure that the following options are unchecked / disabled in Cloudflare. Otherwise, unnecessary re-rendering or hydration errors could impact your production application.

1. Speed > Optimization > Content Optimization > Disable "Rocket Loader™"
2. Speed > Optimization > Image Optimization > Disable "Mirage"
3. Scrape Shield > Disable "Email Address Obfuscation"

With these settings, you can be sure that Cloudflare won't inject scripts into your Nuxt application that may cause unwanted side effects.

::tip
Their location on the Cloudflare dashboard sometimes changes so don't hesitate to look around.
::


# Testing

::tip
If you are a module author, you can find more specific information in the [Module Author's guide](https://nuxt.com/docs/guide/going-further/modules#testing).
::

Nuxt offers first-class support for end-to-end and unit testing of your Nuxt application via `@nuxt/test-utils`, a library of test utilities and configuration that currently powers the [tests we use on Nuxt itself](https://github.com/nuxt/nuxt/tree/main/test){rel="nofollow"} and tests throughout the module ecosystem.

::video-accordion
---
title: Watch a video from Alexander Lichter about getting started with
  @nuxt/test-utils
video-id: yGzwk9xi9gU
---
::

## Installation

In order to allow you to manage your other testing dependencies, `@nuxt/test-utils` ships with various optional peer dependencies. For example:

- you can choose between `happy-dom` and `jsdom` for a runtime Nuxt environment
- you can choose between `vitest`, `cucumber`, `jest` and `playwright` for end-to-end test runners
- `playwright-core` is only required if you wish to use the built-in browser testing utilities (and are not using `@playwright/test` as your test runner)

::code-group{sync="pm"}
```bash [npm]
npm i --save-dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```

```bash [yarn]
yarn add --dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```

```bash [pnpm]
pnpm add -D @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```

```bash [bun]
bun add --dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```
::

## Unit Testing

We currently ship an environment for unit testing code that needs a [Nuxt](https://nuxt.com){rel="nofollow"} runtime environment. It currently &#x2A;only has support for `vitest`* (although contribution to add other runtimes would be welcome).

### Setup

1. Add `@nuxt/test-utils/module` to your `nuxt.config` file (optional). It adds a Vitest integration to your Nuxt DevTools which supports running your unit tests in development.
   ```ts twoslash
   export default defineNuxtConfig({
     modules: [
       '@nuxt/test-utils/module'
     ]
   })
   ```
2. Create a `vitest.config.ts` with the following content:
   ```ts twoslash
   import { defineConfig } from 'vitest/config'
   import { defineVitestProject } from '@nuxt/test-utils/config'

   export default defineConfig({
     test: {
       projects: [
         {
           test: {
             name: 'unit',
             include: ['test/{e2e,unit}/*.{test,spec}.ts'],
             environment: 'node',
           },
         },
         await defineVitestProject({
           test: {
             name: 'nuxt',
             include: ['test/nuxt/*.{test,spec}.ts'],
             environment: 'nuxt',
           },
         }),
       ],
     },
   })
   ```

::tip
When importing `@nuxt/test-utils` in your vitest config, It is necessary to have `"type": "module"` specified in your `package.json` or rename your vitest config file appropriately.

> i.e., `vitest.config.m{ts,js}`.
::

::tip
It is possible to set environment variables for testing by using the `.env.test` file.
::

### Using a Nuxt Runtime Environment

Using [Vitest projects](https://vitest.dev/guide/projects.html#test-projects){rel="nofollow"}, you have fine-grained control over which tests run in which environment:

- **Unit tests**: Place regular unit tests in `test/unit/` - these run in a Node environment for speed
- **Nuxt tests**: Place tests that rely on the Nuxt runtime environment in `test/nuxt/` - these will run within a Nuxt runtime environment

#### Alternative: Simple Setup

If you prefer a simpler setup and want all tests to run in the Nuxt environment, you can use the basic configuration:

```ts twoslash
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    environment: 'nuxt',
    // you can optionally set Nuxt-specific environment options
    // environmentOptions: {
    //   nuxt: {
    //     rootDir: fileURLToPath(new URL('./playground', import.meta.url)),
    //     domEnvironment: 'happy-dom', // 'happy-dom' (default) or 'jsdom'
    //     overrides: {
    //       // other Nuxt config you want to pass
    //     }
    //   }
    // }
  }
})
```

If you're using the simple setup with `environment: 'nuxt'` by default, you can opt *out* of the [Nuxt environment](https://vitest.dev/guide/environment.html#test-environment){rel="nofollow"} per test file as needed.

```ts twoslash
// @vitest-environment node
import { test } from 'vitest'

test('my test', () => {
  // ... test without Nuxt environment!
})
```

::warning
This approach is not recommended as it creates a hybrid environment where Nuxt Vite plugins run but the Nuxt entry and `nuxtApp` are not initialized. This can lead to hard-to-debug errors.
::

### Organizing Your Tests

With the project-based setup, you might organize your tests as follows:

```bash [Directory structure]
test/
├── e2e/
│   └── ssr.test.ts
├── nuxt/
│   ├── components.test.ts
│   └── composables.test.ts
├── unit/
│   └── utils.test.ts
```

You can of course opt for any test structure, but keeping the Nuxt runtime environment separated from Nuxt end-to-end tests is important for test stability.

#### Running Tests

With the project setup, you can run different test suites:

```bash
# Run all tests
npx vitest

# Run only unit tests
npx vitest --project unit

# Run only Nuxt tests
npx vitest --project nuxt

# Run tests in watch mode
npx vitest --watch
```

::warning
When you run your tests within the Nuxt environment, they will be running in a [`happy-dom`](https://github.com/capricorn86/happy-dom){rel="nofollow"} or [`jsdom`](https://github.com/jsdom/jsdom){rel="nofollow"} environment. Before your tests run, a global Nuxt app will be initialized (including, for example, running any plugins or code you've defined in your `app.vue`).

This means you should take particular care not to mutate the global state in your tests (or, if you need to, to reset it afterwards).
::

### 🎭 Built-In Mocks

`@nuxt/test-utils` provides some built-in mocks for the DOM environment.

#### `intersectionObserver`

Default `true`, creates a dummy class without any functionality for the IntersectionObserver API

#### `indexedDB`

Default `false`, uses [`fake-indexeddb`](https://github.com/dumbmatter/fakeIndexedDB){rel="nofollow"} to create a functional mock of the IndexedDB API

These can be configured in the `environmentOptions` section of your `vitest.config.ts` file:

```ts twoslash
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    environmentOptions: {
      nuxt: {
        mock: {
          intersectionObserver: true,
          indexedDb: true,
        }
      }
    }
  }
})
```

### 🛠️ Helpers

`@nuxt/test-utils` provides a number of helpers to make testing Nuxt apps easier.

#### `mountSuspended`

`mountSuspended` allows you to mount any Vue component within the Nuxt environment, allowing async setup and access to injections from your Nuxt plugins.

::note
Under the hood, `mountSuspended` wraps `mount` from `@vue/test-utils`, so you can check out [the Vue Test Utils documentation](https://test-utils.vuejs.org/guide/){rel="nofollow"} for more on the options you can pass, and how to use this utility.
::

For example:

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
import type { Component } from 'vue'
declare module '#components' {
  export const SomeComponent: Component
}
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { mountSuspended } from '@nuxt/test-utils/runtime'
import { SomeComponent } from '#components'

it('can mount some component', async () => {
    const component = await mountSuspended(SomeComponent)
    expect(component.text()).toMatchInlineSnapshot(
        '"This is an auto-imported component"'
    )
})

```

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { mountSuspended } from '@nuxt/test-utils/runtime'
import App from '~/app.vue'

// tests/App.nuxt.spec.ts
it('can also mount an app', async () => {
    const component = await mountSuspended(App, { route: '/test' })
    expect(component.html()).toMatchInlineSnapshot(`
      "<div>This is an auto-imported component</div>
      <div> I am a global component </div>
      <div>/</div>
      <a href="/test"> Test link </a>"
    `)
})
```

#### `renderSuspended`

`renderSuspended` allows you to render any Vue component within the Nuxt environment using `@testing-library/vue`, allowing async setup and access to injections from your Nuxt plugins.

This should be used together with utilities from Testing Library, e.g. `screen` and `fireEvent`. Install [@testing-library/vue](https://testing-library.com/docs/vue-testing-library/intro){rel="nofollow"} in your project to use these.

Additionally, Testing Library also relies on testing globals for cleanup. You should turn these on in your [Vitest config](https://vitest.dev/config/#globals){rel="nofollow"}.

The passed in component will be rendered inside a `<div id="test-wrapper"></div>`.

Examples:

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
import type { Component } from 'vue'
declare module '#components' {
  export const SomeComponent: Component
}
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { renderSuspended } from '@nuxt/test-utils/runtime'
import { SomeComponent } from '#components'
import { screen } from '@testing-library/vue'

it('can render some component', async () => {
  await renderSuspended(SomeComponent)
  expect(screen.getByText('This is an auto-imported component')).toBeDefined()
})
```

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
// ---cut---
// tests/App.nuxt.spec.ts
import { renderSuspended } from '@nuxt/test-utils/runtime'
import App from '~/app.vue'

it('can also render an app', async () => {
  const html = await renderSuspended(App, { route: '/test' })
  expect(html).toMatchInlineSnapshot(`
    "<div id="test-wrapper">
      <div>This is an auto-imported component</div>
      <div> I am a global component </div>
      <div>Index page</div><a href="/test"> Test link </a>
    </div>"
  `)
})
```

#### `mockNuxtImport`

`mockNuxtImport` allows you to mock Nuxt's auto import functionality. For example, to mock `useStorage`, you can do so like this:

```ts twoslash
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

mockNuxtImport('useStorage', () => {
  return () => {
    return { value: 'mocked storage' }
  }
})

// your tests here
```

::note
`mockNuxtImport` can only be used once per mocked import per test file. It is actually a macro that gets transformed to `vi.mock` and `vi.mock` is hoisted, as described [in the Vitest docs](https://vitest.dev/api/vi.html#vi-mock){rel="nofollow"}.
::

If you need to mock a Nuxt import and provide different implementations between tests, you can do it by creating and exposing your mocks using [`vi.hoisted`](https://vitest.dev/api/vi.html#vi-hoisted){rel="nofollow"}, and then use those mocks in `mockNuxtImport`. You then have access to the mocked imports, and can change the implementation between tests. Be careful to [restore mocks](https://vitest.dev/api/mock.html#mockrestore){rel="nofollow"} before or after each test to undo mock state changes between runs.

```ts twoslash
import { vi } from 'vitest'
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

const { useStorageMock } = vi.hoisted(() => {
  return {
    useStorageMock: vi.fn(() => {
      return { value: 'mocked storage'}
    })
  }
})

mockNuxtImport('useStorage', () => {
  return useStorageMock
})

// Then, inside a test
useStorageMock.mockImplementation(() => {
  return { value: 'something else' }
})
```

#### `mockComponent`

`mockComponent` allows you to mock Nuxt's component.
The first argument can be the component name in PascalCase, or the relative path of the component.
The second argument is a factory function that returns the mocked component.

For example, to mock `MyComponent`, you can:

```ts twoslash
import { mockComponent } from '@nuxt/test-utils/runtime'

mockComponent('MyComponent', {
  props: {
    value: String
  },
  setup(props) {
    // ...
  }
})

// relative path or alias also works
mockComponent('~/components/my-component.vue', async () => {
  // or a factory function
  return defineComponent({
    setup(props) {
      // ...
    }
  })
})

// or you can use SFC for redirecting to a mock component
mockComponent('MyComponent', () => import('./MockComponent.vue'))

// your tests here
```

> **Note**: You can't reference local variables in the factory function since they are hoisted. If you need to access Vue APIs or other variables, you need to import them in your factory function.

```ts twoslash
import { mockComponent } from '@nuxt/test-utils/runtime'

mockComponent('MyComponent', async () => {
  const { ref, h } = await import('vue')

  return defineComponent({
    setup(props) {
      const counter = ref(0)
      return () => h('div', null, counter.value)
    }
  })
})
```

#### `registerEndpoint`

`registerEndpoint` allows you create Nitro endpoint that returns mocked data. It can come in handy if you want to test a component that makes requests to API to display some data.

The first argument is the endpoint name (e.g. `/test/`).
The second argument is a factory function that returns the mocked data.

For example, to mock `/test/` endpoint, you can do:

```ts twoslash
import { registerEndpoint } from '@nuxt/test-utils/runtime'

registerEndpoint('/test/', () => ({
  test: 'test-field'
}))
```

By default, your request will be made using the `GET` method. You may use another method by setting an object as the second argument instead of a function.

```ts twoslash
import { registerEndpoint } from '@nuxt/test-utils/runtime'

registerEndpoint('/test/', {
  method: 'POST',
  handler: () => ({ test: 'test-field' })
})
```

> **Note**: If your requests in a component go to an external API, you can use `baseURL` and then make it empty using [Nuxt Environment Override Config](https://nuxt.com/docs/getting-started/configuration#environment-overrides) (`$test`) so all your requests will go to Nitro server.

#### Conflict with End-To-End Testing

`@nuxt/test-utils/runtime` and `@nuxt/test-utils/e2e` need to run in different testing environments and so can't be used in the same file.

If you would like to use both the end-to-end and unit testing functionality of `@nuxt/test-utils`, you can split your tests into separate files. You then either specify a test environment per-file with the special `// @vitest-environment nuxt` comment, or name your runtime unit test files with the `.nuxt.spec.ts` extension.

`app.nuxt.spec.ts`

```ts twoslash
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

mockNuxtImport('useStorage', () => {
  return () => {
    return { value: 'mocked storage' }
  }
})

```

`app.e2e.spec.ts`

```ts twoslash
import { setup, $fetch } from '@nuxt/test-utils/e2e'

await setup({
  setupTimeout: 10000,
})

// ...
```

### Using `@vue/test-utils`

If you prefer to use `@vue/test-utils` on its own for unit testing in Nuxt, and you are only testing components which do not rely on Nuxt composables, auto-imports or context, you can follow these steps to set it up.

1. Install the needed dependencies :code-group[```bash \[npm\]
   npm i --save-dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ``````bash \[yarn\]
   yarn add --dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ``````bash \[pnpm\]
   pnpm add -D vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ``````bash \[bun\]
   bun add --dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ```]{sync="pm"}
2. Create a `vitest.config.ts` with the following content:
   ```ts
   import { defineConfig } from 'vitest/config'
   import vue from '@vitejs/plugin-vue'

   export default defineConfig({
     plugins: [vue()],
     test: {
       environment: 'happy-dom',
     },
   });
   ```
3. Add a new command for test in your `package.json`
   ```json
   "scripts": {
     "build": "nuxt build",
     "dev": "nuxt dev",
     ...
     "test": "vitest"
   },
   ```
4. Create a simple `<HelloWorld>` component `app/components/HelloWorld.vue` with the following content:
   ```vue
   <template>
     <p>Hello world</p>
   </template>
   ```
5. Create a simple unit test for this newly created component `~/components/HelloWorld.spec.ts`
   ```ts twoslash
   import { describe, it, expect } from 'vitest'
   import { mount } from '@vue/test-utils'

   import HelloWorld from './HelloWorld.vue'

   describe('HelloWorld', () => {
     it('component renders Hello world properly', () => {
       const wrapper = mount(HelloWorld)
       expect(wrapper.text()).toContain('Hello world')
     })
   })
   ```
6. Run vitest command :code-group[```bash \[npm\]
   npm run test
   ``````bash \[yarn\]
   yarn test
   ``````bash \[pnpm\]
   pnpm run test
   ``````bash \[bun\]
   bun run test
   ```]{sync="pm"}

Congratulations, you're all set to start unit testing with `@vue/test-utils` in Nuxt! Happy testing!

## End-To-End Testing

For end-to-end testing, we support [Vitest](https://github.com/vitest-dev/vitest){rel="nofollow"}, [Jest](https://jestjs.io){rel="nofollow"}, [Cucumber](https://cucumber.io/){rel="nofollow"} and [Playwright](https://playwright.dev/){rel="nofollow"} as test runners.

### Setup

In each `describe` block where you are taking advantage of the `@nuxt/test-utils/e2e` helper methods, you will need to set up the test context before beginning.

```ts [test/my-test.spec.ts] twoslash
import { describe, test } from 'vitest'
import { setup, $fetch } from '@nuxt/test-utils/e2e'

describe('My test', async () => {
  await setup({
    // test context options
  })

  test('my test', () => {
    // ...
  })
})
```

Behind the scenes, `setup` performs a number of tasks in `beforeAll`, `beforeEach`, `afterEach` and `afterAll` to set up the Nuxt test environment correctly.

Please use the options below for the `setup` method.

#### Nuxt Config

- `rootDir`: Path to a directory with a Nuxt app to be put under test.

  - Type: `string`
  - Default: `'.'`
- `configFile`: Name of the configuration file.

  - Type: `string`
  - Default: `'nuxt.config'`

#### Timings

- `setupTimeout`: The amount of time (in milliseconds) to allow for `setupTest` to complete its work (which could include building or generating files for a Nuxt application, depending on the options that are passed).
  - Type: `number`
  - Default: `120000` or `240000` on windows
- `teardownTimeout`: The amount of time (in milliseconds) to allow tearing down the test environment, such as closing the browser.
  - Type: `number`
  - Default: `30000`

#### Features

- `build`: Whether to run a separate build step.
  - Type: `boolean`
  - Default: `true` (`false` if `browser` or `server` is disabled, or if a `host` is provided)
- `server`: Whether to launch a server to respond to requests in the test suite.
  - Type: `boolean`
  - Default: `true` (`false` if a `host` is provided)
- `port`: If provided, set the launched test server port to the value.
  - Type: `number | undefined`
  - Default: `undefined`
- `host`: If provided, a URL to use as the test target instead of building and running a new server. Useful for running "real" end-to-end tests against a deployed version of your application, or against an already running local server (which may provide a significant reduction in test execution timings). See the [target host end-to-end example below](https://nuxt.com/#target-host-end-to-end-example).
  - Type: `string`
  - Default: `undefined`
- `browser`: Under the hood, Nuxt test utils uses [`playwright`](https://playwright.dev){rel="nofollow"} to carry out browser testing. If this option is set, a browser will be launched and can be controlled in the subsequent test suite.
  - Type: `boolean`
  - Default: `false`
- `browserOptions`
  - Type: `object` with the following properties

    - `type`: The type of browser to launch - either `chromium`, `firefox` or `webkit`
    - `launch`: `object` of options that will be passed to playwright when launching the browser. See [full API reference](https://playwright.dev/docs/api/class-browsertype#browser-type-launch){rel="nofollow"}.
- `runner`: Specify the runner for the test suite. Currently, [Vitest](https://vitest.dev){rel="nofollow"} is recommended.
  - Type: `'vitest' | 'jest' | 'cucumber'`
  - Default: `'vitest'`

##### Target `host` end-to-end example

A common use-case for end-to-end testing is running the tests against a deployed application running in the same environment typically used for Production.

For local development or automated deploy pipelines, testing against a separate local server can be more efficient and is typically faster than allowing the test framework to rebuild between tests.

To utilize a separate target host for end-to-end tests, simply provide the `host` property of the `setup` function with the desired URL.

```ts
import { setup, createPage } from '@nuxt/test-utils/e2e'
import { describe, it, expect } from 'vitest'

describe('login page', async () => {
  await setup({
    host: 'http://localhost:8787',
  })

  it('displays the email and password fields', async () => {
    const page = await createPage('/login')
    expect(await page.getByTestId('email').isVisible()).toBe(true)
    expect(await page.getByTestId('password').isVisible()).toBe(true)
  })
})
```

### APIs

#### `$fetch(url)`

Get the HTML of a server-rendered page.

```ts twoslash
import { $fetch } from '@nuxt/test-utils/e2e'

const html = await $fetch('/')
```

#### `fetch(url)`

Get the response of a server-rendered page.

```ts twoslash
import { fetch } from '@nuxt/test-utils/e2e'

const res = await fetch('/')
const { body, headers } = res
```

#### `url(path)`

Get the full URL for a given page (including the port the test server is running on.)

```ts twoslash
import { url } from '@nuxt/test-utils/e2e'

const pageUrl = url('/page')
// 'http://localhost:6840/page'
```

### Testing in a Browser

We provide built-in support using Playwright within `@nuxt/test-utils`, either programmatically or via the Playwright test runner.

#### `createPage(url)`

Within `vitest`, `jest` or `cucumber`, you can create a configured Playwright browser instance with `createPage`, and (optionally) point it at a path from the running server. You can find out more about the API methods available from [in the Playwright documentation](https://playwright.dev/docs/api/class-page){rel="nofollow"}.

```ts twoslash
import { createPage } from '@nuxt/test-utils/e2e'

const page = await createPage('/page')
// you can access all the Playwright APIs from the `page` variable
```

#### Testing with Playwright Test Runner

We also provide first-class support for testing Nuxt within [the Playwright test runner](https://playwright.dev/docs/intro){rel="nofollow"}.

::code-group{sync="pm"}
```bash [npm]
npm i --save-dev @playwright/test @nuxt/test-utils
```

```bash [yarn]
yarn add --dev @playwright/test @nuxt/test-utils
```

```bash [pnpm]
pnpm add -D @playwright/test @nuxt/test-utils
```

```bash [bun]
bun add --dev @playwright/test @nuxt/test-utils
```
::

You can provide global Nuxt configuration, with the same configuration details as the `setup()` function mentioned earlier in this section.

```ts [playwright.config.ts]
import { fileURLToPath } from 'node:url'
import { defineConfig, devices } from '@playwright/test'
import type { ConfigOptions } from '@nuxt/test-utils/playwright'

export default defineConfig<ConfigOptions>({
  use: {
    nuxt: {
      rootDir: fileURLToPath(new URL('.', import.meta.url))
    }
  },
  // ...
})
```

::read-more
---
target: _blank
title: See full example config
to: https://github.com/nuxt/test-utils/blob/main/examples/app-playwright/playwright.config.ts
---
::

Your test file should then use `expect` and `test` directly from `@nuxt/test-utils/playwright`:

```ts [tests/example.test.ts]
import { expect, test } from '@nuxt/test-utils/playwright'

test('test', async ({ page, goto }) => {
  await goto('/', { waitUntil: 'hydration' })
  await expect(page.getByRole('heading')).toHaveText('Welcome to Playwright!')
})
```

You can alternatively configure your Nuxt server directly within your test file:

```ts [tests/example.test.ts]
import { expect, test } from '@nuxt/test-utils/playwright'

test.use({
  nuxt: {
    rootDir: fileURLToPath(new URL('..', import.meta.url))
  }
})

test('test', async ({ page, goto }) => {
  await goto('/', { waitUntil: 'hydration' })
  await expect(page.getByRole('heading')).toHaveText('Welcome to Playwright!')
})
```


# Upgrade Guide

## Upgrading Nuxt

### Latest release

To upgrade Nuxt to the [latest release](https://github.com/nuxt/nuxt/releases){rel="nofollow"}, use the `nuxt upgrade` command.

::code-group{sync="pm"}
```bash [npm]
npx nuxt upgrade
```

```bash [yarn]
yarn nuxt upgrade
```

```bash [pnpm]
pnpm nuxt upgrade
```

```bash [bun]
bun x nuxt upgrade
```
::

### Nightly Release Channel

To use the latest Nuxt build and test features before their release, read about the [nightly release channel](https://nuxt.com/docs/guide/going-further/nightly-release-channel) guide.

## Migrating to Nuxt 4

Nuxt 4 includes significant improvements and changes. This guide will help you migrate your existing Nuxt 3 application to Nuxt 4.

First, upgrade to Nuxt 4:

::code-group{sync="pm"}
```bash [npm]
npm install nuxt@^4.0.0
```

```bash [yarn]
yarn add nuxt@^4.0.0
```

```bash [pnpm]
pnpm add nuxt@^4.0.0
```

```bash [bun]
bun add nuxt@^4.0.0
```
::

After upgrading, most Nuxt 4 behaviors are now the default. However, some features can still be configured if you need to maintain backward compatibility during your migration.

The following sections detail the key changes and migrations needed when upgrading to Nuxt 4.

Breaking or significant changes are documented below along with migration steps and available configuration options.

### Migrating Using Codemods

To facilitate the upgrade process, we have collaborated with the [Codemod](https://github.com/codemod-com/codemod){rel="nofollow"} team to automate many migration steps with some open-source codemods.

::note
If you encounter any issues, please report them to the Codemod team with `npx codemod feedback` 🙏
::

For a complete list of Nuxt 4 codemods, detailed information on each, their source, and various ways to run them, visit the [Codemod Registry](https://go.codemod.com/codemod-registry){rel="nofollow"}.

You can run all the codemods mentioned in this guide using the following `codemod` recipe:

::code-group
```bash [npm]
npx codemod@latest nuxt/4/migration-recipe
```

```bash [yarn]
yarn dlx codemod@latest nuxt/4/migration-recipe
```

```bash [pnpm]
pnpm dlx codemod@latest nuxt/4/migration-recipe
```

```bash [bun]
bun x codemod@latest nuxt/4/migration-recipe
```
::

This command will execute all codemods in sequence, with the option to deselect any that you do not wish to run. Each codemod is also listed below alongside its respective change and can be executed independently.

### New Directory Structure

🚦 **Impact Level**: Significant

Nuxt now defaults to a new directory structure, with backwards compatibility (so if Nuxt detects you are using the old structure, such as with a top-level `app/pages/` directory, this new structure will not apply).

👉 [See full RFC](https://github.com/nuxt/nuxt/issues/26444){rel="nofollow"}

#### What Changed

- the new Nuxt default `srcDir` is `app/` by default, and most things are resolved from there.
- `serverDir` now defaults to `<rootDir>/server` rather than `<srcDir>/server`
- `layers/`, `modules/` and `public/` are resolved relative to `<rootDir>` by default
- if using [Nuxt Content v2.13+](https://github.com/nuxt/content/pull/2649){rel="nofollow"}, `content/` is resolved relative to `<rootDir>`
- a new `dir.app` is added, which is the directory we look for `router.options.ts` and `spa-loading-template.html` - this defaults to `<srcDir>/`

An example v4 folder structure.

```sh
.output/
.nuxt/
app/
  assets/
  components/
  composables/
  layouts/
  middleware/
  pages/
  plugins/
  utils/
  app.config.ts
  app.vue
  router.options.ts
content/
layers/
modules/
node_modules/
public/
shared/
server/
  api/
  middleware/
  plugins/
  routes/
  utils/
nuxt.config.ts
```

::note
With this new structure, the `~` alias now points to the `app/` directory by default (your `srcDir`). This means `~/components` resolves to `app/components/`, `~/pages` to `app/pages/`, etc.
::

👉 For more details, see the [PR implementing this change](https://github.com/nuxt/nuxt/pull/27029){rel="nofollow"}.

#### Reasons for Change

1. **Performance** - placing all your code in the root of your repo causes issues with `.git/` and `node_modules/` folders being scanned/included by FS watchers which can significantly delay startup on non-Mac OSes.
2. **IDE type-safety** - `server/` and the rest of your app are running in two entirely different contexts with different global imports available, and making sure `server/` isn't *inside* the same folder as the rest of your app is a big first step to ensuring you get good auto-completes in your IDE.

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on the new directory structure
video-id: "1031028378"
---
::

#### Migration Steps

1. Create a new directory called `app/`.
2. Move your `assets/`, `components/`, `composables/`, `app/layouts/`, `app/middleware/`, `app/pages/`, `app/plugins/` and `utils/` folders under it, as well as `app.vue`, `error.vue`, `app.config.ts`. If you have an `app/router-options.ts` or `app/spa-loading-template.html`, these paths remain the same.
3. Make sure your `nuxt.config.ts`, `content/`, `layers/`, `modules/`, `public/` and `server/` folders remain outside the `app/` folder, in the root of your project.
4. Remember to update any third-party configuration files to work with the new directory structure, such as your `tailwindcss` or `eslint` configuration (if required - `@nuxtjs/tailwindcss` should automatically configure `tailwindcss` correctly).

::tip
You can automate this migration by running `npx codemod@latest nuxt/4/file-structure`
::

However, migration is *not required*. If you wish to keep your current folder structure, Nuxt should auto-detect it. (If it does not, please raise an issue.) The one exception is that if you *already* have a custom `srcDir`. In this case, you should be aware that your `modules/`, `public/` and `server/` folders will be resolved from your `rootDir` rather than from your custom `srcDir`. You can override this by configuring `dir.modules`, `dir.public` and `serverDir` if you need to.

You can also force a v3 folder structure with the following configuration:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // This reverts the new srcDir default from `app` back to your root directory
  srcDir: '.',
  // This specifies the directory prefix for `router.options.ts` and `spa-loading-template.html`
  dir: {
    app: 'app'
  }
})
```

### Singleton Data Fetching Layer

🚦 **Impact Level**: Moderate

#### What Changed

Nuxt's data fetching system (`useAsyncData` and `useFetch`) has been significantly reorganized for better performance and consistency:

1. **Shared refs for the same key**: All calls to `useAsyncData` or `useFetch` with the same key now share the same `data`, `error` and `status` refs. This means that it is important that all calls with an explicit key must not have conflicting `deep`, `transform`, `pick`, `getCachedData` or `default` options.
2. **More control over `getCachedData`**: The `getCachedData` function is now called every time data is fetched, even if this is caused by a watcher or calling `refreshNuxtData`. (Previously, new data was always fetched and this function was not called in these cases.) To allow more control over when to use cached data and when to refetch, the function now receives a context object with the cause of the request.
3. **Reactive key support**: You can now use computed refs, plain refs or getter functions as keys, which enables automatic data refetching (and stores data separately).
4. **Data cleanup**: When the last component using data fetched with `useAsyncData` is unmounted, Nuxt will remove that data to avoid ever-growing memory usage.

#### Reasons for Change

These changes have been made to improve memory usage and increase consistency with loading states across calls of `useAsyncData`.

#### Migration Steps

1. **Check for inconsistent options**: Review any components using the same key with different options or fetch functions.
   ```ts
   // This will now trigger a warning
   const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
   const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
   ```
   :brIt may be beneficial to extract any calls to `useAsyncData` that share an explicit key (and have custom options) into their own composable:
   ```ts [app/composables/useUserData.ts]
   export function useUserData(userId: string) {
     return useAsyncData(
       `user-${userId}`,
       () => fetchUser(userId),
       { 
         deep: true,
         transform: (user) => ({ ...user, lastAccessed: new Date() })
       }
     )
   }
   ```
2. **Update `getCachedData` implementations**:
   ```diff
   useAsyncData('key', fetchFunction, {
   -  getCachedData: (key, nuxtApp) => {
   -    return cachedData[key]
   -  }
   +  getCachedData: (key, nuxtApp, ctx) => {
   +    // ctx.cause - can be 'initial' | 'refresh:hook' | 'refresh:manual' | 'watch'
   +    
   +    // Example: Don't use cache on manual refresh
   +    if (ctx.cause === 'refresh:manual') return undefined
   +    
   +    return cachedData[key]
   +  }
   })
   ```

Alternatively, for now, you can disable this behaviour with:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    granularCachedData: false,
    purgeCachedData: false
  }
})
```

### Corrected Module Loading Order in Layers

🚦 **Impact Level**: Minimal

#### What Changed

The order in which modules are loaded when using [Nuxt layers](https://nuxt.com/docs/guide/going-further/layers) has been corrected. Previously, modules from the project root were loaded before modules from extended layers, which was the reverse of the expected behavior.

Now modules are loaded in the correct order:

1. **Layer modules first** (in extend order - deeper layers first)
2. **Project modules last** (highest priority)

This affects both:

- Modules defined in the `modules` array in `nuxt.config.ts`
- Auto-discovered modules from the `modules/` directory

#### Reasons for Change

This change ensures that:

- Extended layers have lower priority than the consuming project
- Module execution order matches the intuitive layer inheritance pattern
- Module configuration and hooks work as expected in multi-layer setups

#### Migration Steps

**Most projects will not need changes**, as this corrects the loading order to match expected behavior.

However, if your project was relying on the previous incorrect order, you may need to:

1. **Review module dependencies**: Check if any modules depend on specific loading order
2. **Adjust module configuration**: If modules were configured to work around the incorrect order
3. **Test thoroughly**: Ensure all functionality works as expected with the corrected order

Example of the new correct order:

```ts
// Layer: my-layer/nuxt.config.ts
export default defineNuxtConfig({
  modules: ['layer-module-1', 'layer-module-2']
})

// Project: nuxt.config.ts
export default defineNuxtConfig({
  extends: ['./my-layer'],
  modules: ['project-module-1', 'project-module-2']
})

// Loading order (corrected):
// 1. layer-module-1
// 2. layer-module-2  
// 3. project-module-1 (can override layer modules)
// 4. project-module-2 (can override layer modules)
```

If you encounter issues with module order dependencies due to needing to register a hook, consider using the [`modules:done` hook](https://nuxt.com/docs/guide/going-further/modules#custom-hooks) for modules that need to call a hook. This is run after all other modules have been loaded, which means it is safe to use.

👉 See [PR #31507](https://github.com/nuxt/nuxt/pull/31507){rel="nofollow"} and [issue #25719](https://github.com/nuxt/nuxt/issues/25719){rel="nofollow"} for more details.

### Deduplication of Route Metadata

🚦 **Impact Level**: Minimal

#### What Changed

It's possible to set some route metadata using `definePageMeta`, such as the `name`, `path`, and so on. Previously these were available both on the route and on route metadata (for example, `route.name` and `route.meta.name`).

Now, they are only accessible on the route object.

#### Reasons for Change

This is a result of enabling `experimental.scanPageMeta` by default, and is a performance optimization.

#### Migration Steps

The migration should be straightforward:

```diff
  const route = useRoute()
  
- console.log(route.meta.name)
+ console.log(route.name)
```

### Normalized Component Names

🚦 **Impact Level**: Moderate

Vue will now generate component names that match the Nuxt pattern for component naming.

#### What Changed

By default, if you haven't set it manually, Vue will assign a component name that matches
the filename of the component.

```bash [Directory structure]
├─ components/
├─── SomeFolder/
├───── MyComponent.vue
```

In this case, the component name would be `MyComponent`, as far as Vue is concerned. If you wanted to use `<KeepAlive>` with it, or identify it in the Vue DevTools, you would need to use this name.

But in order to auto-import it, you would need to use `SomeFolderMyComponent`.

With this change, these two values will match, and Vue will generate a component name that matches the Nuxt pattern for component naming.

#### Migration Steps

Ensure that you use the updated name in any tests which use `findComponent` from `@vue/test-utils` and in any `<KeepAlive>` which depends on the name of your component.

Alternatively, for now, you can disable this behaviour with:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

### Unhead v2

🚦 **Impact Level**: Minimal

#### What Changed

[Unhead](https://unhead.unjs.io/){rel="nofollow"}, used to generate `<head>` tags, has been updated to version 2. While mostly compatible it includes several breaking changes
for lower-level APIs.

- Removed props: `vmid`, `hid`, `children`, `body`.
- Promise input no longer supported.
- Tags are now sorted using Capo.js by default.

#### Migration Steps

The above changes should have minimal impact on your app.

If you have issues you should verify:

- You're not using any of the removed props.

```diff
useHead({
  meta: [{ 
    name: 'description', 
    // meta tags don't need a vmid, or a key    
-   vmid: 'description' 
-   hid: 'description'
  }]
})
```

- If you're using [Template Params](https://unhead.unjs.io/docs/head/guides/plugins/template-params){rel="nofollow"} or [Alias Tag Sorting](https://unhead.unjs.io/docs/head/guides/plugins/alias-sorting){rel="nofollow"}, you will need to explicitly opt in to these features now.

```ts
import { TemplateParamsPlugin, AliasSortingPlugin } from '@unhead/vue/plugins'

export default defineNuxtPlugin({
  setup() {
    const unhead = injectHead()
    unhead.use(TemplateParamsPlugin)
    unhead.use(AliasSortingPlugin)
  }
})
```

While not required it's recommended to update any imports from `@unhead/vue` to `#imports` or `nuxt/app`.

```diff
-import { useHead } from '@unhead/vue'
+import { useHead } from '#imports'
```

If you still have issues you may revert to the v1 behavior by enabling the `head.legacy` config.

```ts
export default defineNuxtConfig({
  unhead: {
    legacy: true,
  }
})
```

### New DOM Location for SPA Loading Screen

🚦 **Impact Level**: Minimal

#### What Changed

When rendering a client-only page (with `ssr: false`), we optionally render a loading screen (from `~/app/spa-loading-template.html` - note that this has also changed to `~/spa-loading-template.html` in Nuxt 4), within the Nuxt app root:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Now, we default to rendering the template alongside the Nuxt app root:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

#### Reasons for Change

This allows the spa loading template to remain in the DOM until the Vue app suspense resolves, preventing a flash of white.

#### Migration Steps

If you were targeting the spa loading template with CSS or `document.queryElement` you will need to update your selectors. For this purpose you can use the new `app.spaLoaderTag` and `app.spaLoaderAttrs` configuration options.

Alternatively, you can revert to the previous behaviour with:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    spaLoadingTemplateLocation: 'within',
  }
})
```

### Parsed `error.data`

🚦 **Impact Level**: Minimal

It was possible to throw an error with a `data` property, but this was not parsed. Now, it is parsed and made available in the `error` object. Although a fix, this is technically a breaking change if you were relying on the previous behavior and parsing it manually.

#### Migration Steps

Update your custom `error.vue` to remove any additional parsing of `error.data`:

```diff
  <script setup lang="ts">
  import type { NuxtError } from '#app'

  const props = defineProps({
    error: Object as () => NuxtError
  })

- const data = JSON.parse(error.data)
+ const data = error.data
  </script>
```

### More Granular Inline Styles

🚦 **Impact Level**: Moderate

Nuxt will now only inline styles for Vue components, not global CSS.

#### What Changed

Previously, Nuxt would inline all CSS, including global styles, and remove `<link>` elements to separate CSS files. Now, Nuxt will only do this for Vue components (which previously produced separate chunks of CSS). We think this is a better balance of reducing separate network requests (just as before, there will not be separate requests for individual `.css` files per-page or per-component on the initial load), as well as allowing caching of a single global CSS file and reducing the document download size of the initial request.

#### Migration Steps

This feature is fully configurable and you can revert to the previous behavior by setting `inlineStyles: true` to inline global CSS as well as per-component CSS.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  features: {
    inlineStyles: true
  }
})
```

### Scan Page Meta After Resolution

🚦 **Impact Level**: Minimal

#### What Changed

We now scan page metadata (defined in `definePageMeta`) *after* calling the `pages:extend` hook rather than before.

#### Reasons for Change

This was to allow scanning metadata for pages that users wanted to add in `pages:extend`. We still offer an opportunity to change or override page metadata in a new `pages:resolved` hook.

#### Migration Steps

If you want to override page metadata, do that in `pages:resolved` rather than in `pages:extend`.

```diff
  export default defineNuxtConfig({
    hooks: {
-     'pages:extend'(pages) {
+     'pages:resolved'(pages) {
        const myPage = pages.find(page => page.path === '/')
        myPage.meta ||= {}
        myPage.meta.layout = 'overridden-layout'
      }
    }
  })
```

Alternatively, you can revert to the previous behaviour with:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: true
  }
})
```

### Shared Prerender Data

🚦 **Impact Level**: Medium

#### What Changed

We enabled a previously experimental feature to share data from `useAsyncData` and `useFetch` calls, across different pages. See [original PR](https://github.com/nuxt/nuxt/pull/24894){rel="nofollow"}.

#### Reasons for Change

This feature automatically shares payload *data* between pages that are prerendered. This can result in a significant performance improvement when prerendering sites that use `useAsyncData` or `useFetch` and fetch the same data in different pages.

For example, if your site requires a `useFetch` call for every page (for example, to get navigation data for a menu, or site settings from a CMS), this data would only be fetched once when prerendering the first page that uses it, and then cached for use when prerendering other pages.

#### Migration Steps

Make sure that any unique key of your data is always resolvable to the same data. For example, if you are using `useAsyncData` to fetch data related to a particular page, you should provide a key that uniquely matches that data. (`useFetch` should do this automatically for you.)

```ts [app/pages/test/[slug\\].vue]
// This would be unsafe in a dynamic page (e.g. `[slug].vue`) because the route slug makes a difference
// to the data fetched, but Nuxt can't know that because it's not reflected in the key.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Instead, you should use a key that uniquely identifies the data fetched.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

Alternatively, you can disable this feature with:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

### Default `data` and `error` values in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

#### What Changed

`data` and `error` objects returned from `useAsyncData` will now default to `undefined`.

#### Reasons for Change

Previously `data` was initialized to `null` but reset in `clearNuxtData` to `undefined`. `error` was initialized to `null`. This change is to bring greater consistency.

#### Migration Steps

If you were checking if `data.value` or `error.value` were `null`, you can update these checks to check for `undefined` instead.

::tip
You can automate this step by running `npx codemod@latest nuxt/4/default-data-error-value`
::

If you encounter any issues you can revert back to the previous behavior with:

```ts [nuxt.config.ts] twoslash
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    defaults: {
      useAsyncData: {
        value: 'null',
        errorValue: 'null'
      }
    }
  }
})
```

Please report an issue if you are doing this, as we do not plan to keep this as configurable.

### Removal of deprecated `boolean` values for `dedupe` option when calling `refresh` in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

#### What Changed

Previously it was possible to pass `dedupe: boolean` to `refresh`. These were aliases of `cancel` (`true`) and `defer` (`false`).

```ts [app/app.vue] twoslash
// @errors: 2322
const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt!' }))

async function refreshData () {
  await refresh({ dedupe: true })
}
```

#### Reasons for Change

These aliases were removed, for greater clarity.

The issue came up when adding `dedupe` as an option to `useAsyncData`, and we removed the boolean values as they ended up being *opposites*.

`refresh({ dedupe: false })` meant **do not *cancel* existing requests in favour of this new one**. But passing `dedupe: true` within the options of `useAsyncData` means &#x2A;*do not make any new requests if there is an existing pending request.** (See [PR](https://github.com/nuxt/nuxt/pull/24564#pullrequestreview-1764584361){rel="nofollow"}.)

#### Migration Steps

The migration should be straightforward:

```diff
  const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))
  
  async function refreshData () {
-   await refresh({ dedupe: true })
+   await refresh({ dedupe: 'cancel' })

-   await refresh({ dedupe: false })
+   await refresh({ dedupe: 'defer' })
  }
```

::tip
You can automate this step by running `npx codemod@latest nuxt/4/deprecated-dedupe-value`
::

### Respect defaults when clearing `data` in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

#### What Changed

If you provide a custom `default` value for `useAsyncData`, this will now be used when calling `clear` or `clearNuxtData` and it will be reset to its default value rather than simply unset.

#### Reasons for Change

Often users set an appropriately empty value, such as an empty array, to avoid the need to check for `null`/`undefined` when iterating over it. This should be respected when resetting/clearing the data.

### Alignment of `pending` value in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Medium

The `pending` object returned from `useAsyncData`, `useFetch`, `useLazyAsyncData` and `useLazyFetch` is now a computed property that is `true` only when `status` is also pending.

#### What Changed

Now, when `immediate: false` is passed, `pending` will be `false` until the first request is made. This is a change from the previous behavior, where `pending` was always `true` until the first request was made.

#### Reasons for Change

This aligns the meaning of `pending` with the `status` property, which is also `pending` when the request is in progress.

#### Migration Steps

If you rely on the `pending` property, ensure that your logic accounts for the new behavior where `pending` will only be `true` when the status is also pending.

```diff
  <template>
-   <div v-if="!pending">
+   <div v-if="status === 'success'">
      <p>Data: {{ data }}</p>
    </div>
    <div v-else>
      <p>Loading...</p>
    </div>
  </template>
  <script setup lang="ts">
  const { data, pending, execute, status } = await useAsyncData(() => fetch('/api/data'), {
    immediate: false
  })
  onMounted(() => execute())
  </script>
```

Alternatively, you can temporarily revert to the previous behavior with:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: true
  }
})
```

### Key Change Behavior in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Medium

#### What Changed

When using reactive keys in `useAsyncData` or `useFetch`, Nuxt automatically refetches data when the key changes. When `immediate: false` is set, `useAsyncData` will only fetch data when the key changes if the data has already been fetched once.

Previously, `useFetch` had slightly different behavior. It would always fetch data when the key changed.

Now, `useFetch` and `useAsyncData` behave consistently - by only fetch data when the key changes if the data has already been fetched once.

#### Reasons for Change

This ensures consistent behavior between `useAsyncData` and `useFetch`, and prevents unexpected fetches. If you have set `immediate: false`, then you must call `refresh` or `execute` or data will never be fetched in `useFetch` or `useAsyncData`.

#### Migration Steps

This change should generally improve the expected behavior, but if you were expecting changing the key or options of a non-immediate `useFetch`, you now will need to trigger it manually the first time.

```diff
  const id = ref('123')
  const { data, execute } = await useFetch('/api/test', {
    query: { id },
    immediate: false
  )
+ watch(id, () => execute(), { once: true })
```

To opt out of this behavior:

```ts
// Or globally in your Nuxt config
export default defineNuxtConfig({
  experimental: {
    alwaysRunFetchOnKeyChange: true
  }
})
```

### Shallow Data Reactivity in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

The `data` object returned from `useAsyncData`, `useFetch`, `useLazyAsyncData` and `useLazyFetch` is now a `shallowRef` rather than a `ref`.

#### What Changed

When new data is fetched, anything depending on `data` will still be reactive because the entire object is replaced. But if your code changes a property *within* that data structure, this will not trigger any reactivity in your app.

#### Reasons for Change

This brings a **significant** performance improvement for deeply nested objects and arrays because Vue does not need to watch every single property/array for modification. In most cases, `data` should also be immutable.

#### Migration Steps

In most cases, no migration steps are required, but if you rely on the reactivity of the data object then you have two options:

1. You can granularly opt in to deep reactivity on a per-composable basis:

   ```diff
   - const { data } = useFetch('/api/test')
   + const { data } = useFetch('/api/test', { deep: true })
   ```
2. You can change the default behavior on a project-wide basis (not recommended):

   ```ts [nuxt.config.ts] twoslash
   export default defineNuxtConfig({
     experimental: {
       defaults: {
         useAsyncData: {
           deep: true
         }
       }
     }
   })
   ```

::tip
If you need to, you can automate this step by running `npx codemod@latest nuxt/4/shallow-function-reactivity`
::

### Absolute Watch Paths in `builder:watch`

🚦 **Impact Level**: Minimal

#### What Changed

The Nuxt `builder:watch` hook now emits a path which is absolute rather than relative to your project `srcDir`.

#### Reasons for Change

This allows us to support watching paths which are outside your `srcDir`, and offers better support for layers and other more complex patterns.

#### Migration Steps

We have already proactively migrated the public Nuxt modules which we are aware use this hook. See [issue #25339](https://github.com/nuxt/nuxt/issues/25339){rel="nofollow"}.

However, if you are a module author using the `builder:watch` hook and wishing to remain backwards/forwards compatible, you can use the following code to ensure that your code works the same in both Nuxt v3 and Nuxt v4:

```diff
+ import { relative, resolve } from 'node:fs'
  // ...
  nuxt.hook('builder:watch', async (event, path) => {
+   path = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, path))
    // ...
  })
```

::tip
You can automate this step by running `npx codemod@latest nuxt/4/absolute-watch-path`
::

### Removal of `window.__NUXT__` object

#### What Changed

We are removing the global `window.__NUXT__` object after the app finishes hydration.

#### Reasons for Change

This opens the way to multi-app patterns ([#21635](https://github.com/nuxt/nuxt/issues/21635){rel="nofollow"}) and enables us to focus on a single way to access Nuxt app data - `useNuxtApp()`.

#### Migration Steps

The data is still available, but can be accessed with `useNuxtApp().payload`:

```diff
- console.log(window.__NUXT__)
+ console.log(useNuxtApp().payload)
```

### Directory index scanning

🚦 **Impact Level**: Medium

#### What Changed

Child folders in your `app/middleware/` folder are also scanned for `index` files and these are now also registered as middleware in your project.

#### Reasons for Change

Nuxt scans a number of folders automatically, including `app/middleware/` and `app/plugins/`.

Child folders in your `app/plugins/` folder are scanned for `index` files and we wanted to make this behavior consistent between scanned directories.

#### Migration Steps

Probably no migration is necessary but if you wish to revert to previous behavior you can add a hook to filter out these middleware:

```ts
export default defineNuxtConfig({
  hooks: {
    'app:resolve'(app) {
      app.middleware = app.middleware.filter(mw => !/\/index\.[^/]+$/.test(mw.path))
    }
  }
})
```

### Template Compilation Changes

🚦 **Impact Level**: Minimal

#### What Changed

Previously, Nuxt used `lodash/template` to compile templates located on the file system using the `.ejs` file format/syntax.

In addition, we provided some template utilities (`serialize`, `importName`, `importSources`) which could be used for code-generation within these templates, which are now being removed.

#### Reasons for Change

In Nuxt v3 we moved to a 'virtual' syntax with a `getContents()` function which is much more flexible and performant.

In addition, `lodash/template` has had a succession of security issues. These do not really apply to Nuxt projects because it is being used at build-time, not runtime, and by trusted code. However, they still appear in security audits. Moreover, `lodash` is a hefty dependency and is unused by most projects.

Finally, providing code serialization functions directly within Nuxt is not ideal. Instead, we maintain projects like [unjs/knitwork](http://github.com/unjs/knitwork){rel="nofollow"} which can be dependencies of your project, and where security issues can be reported/resolved directly without requiring an upgrade of Nuxt itself.

#### Migration Steps

We have raised PRs to update modules using EJS syntax, but if you need to do this yourself, you have three backwards/forwards-compatible alternatives:

- Moving your string interpolation logic directly into `getContents()`.
- Using a custom function to handle the replacement, such as in <https://github.com/nuxt-modules/color-mode/pull/240>{rel="nofollow"}.
- Use `es-toolkit/compat` (a drop-in replacement for lodash template), as a dependency of *your* project rather than Nuxt:

```diff
+ import { readFileSync } from 'node:fs'
+ import { template } from 'es-toolkit/compat'
  // ...
  addTemplate({
    fileName: 'appinsights-vue.js'
    options: { /* some options */ },
-   src: resolver.resolve('./runtime/plugin.ejs'),
+   getContents({ options }) {
+     const contents = readFileSync(resolver.resolve('./runtime/plugin.ejs'), 'utf-8')
+     return template(contents)({ options })
+   },
  })
```

Finally, if you are using the template utilities (`serialize`, `importName`, `importSources`), you can replace them as follows with utilities from `knitwork`:

```ts
import { genDynamicImport, genImport, genSafeVariableName } from 'knitwork'

const serialize = (data: any) => JSON.stringify(data, null, 2).replace(/"{(.+)}"(?=,?$)/gm, r => JSON.parse(r).replace(/^{(.*)}$/, '$1'))

const importSources = (sources: string | string[], { lazy = false } = {}) => {
  return toArray(sources).map((src) => {
    if (lazy) {
      return `const ${genSafeVariableName(src)} = ${genDynamicImport(src, { comment: `webpackChunkName: ${JSON.stringify(src)}` })}`
    }
    return genImport(src, genSafeVariableName(src))
  }).join('\n')
}

const importName = genSafeVariableName
```

::tip
You can automate this step by running `npx codemod@latest nuxt/4/template-compilation-changes`
::

### Default TypeScript Configuration Changes

🚦 **Impact Level**: Minimal

#### What Changed

`compilerOptions.noUncheckedIndexedAccess` is now `true` instead of `false`.

#### Reasons for Change

This change is a follow up to a prior [3.12 config update](https://github.com/nuxt/nuxt/pull/27485){rel="nofollow"} where we improved our defaults, mostly adhering to [TotalTypeScript's recommendations](https://www.totaltypescript.com/tsconfig-cheat-sheet){rel="nofollow"}.

#### Migration Steps

There are two approaches:

1. Run a typecheck on your app and fix any new errors (recommended).
2. Override the new default in your `nuxt.config.ts`:
   ```ts
   export default defineNuxtConfig({
     typescript: {
       tsConfig: {
         compilerOptions: {
           noUncheckedIndexedAccess: false
         }
       }
     }
   })
   ```

### TypeScript Configuration Splitting

🚦 **Impact Level**: Minimal

#### What Changed

Nuxt now generates separate TypeScript configurations for different contexts to provide better type-checking experiences:

1. **New TypeScript configuration files**: Nuxt now generates additional TypeScript configurations:
   - `.nuxt/tsconfig.app.json` - For your app code (Vue components, composables, etc.)
   - `.nuxt/tsconfig.server.json` - For your server-side code (Nitro/server directory)
   - `.nuxt/tsconfig.node.json` - For your build-time code (modules, `nuxt.config.ts`, etc.)
   - `.nuxt/tsconfig.shared.json` - For code shared between app and server contexts (like types and non-environment specific utilities)
   - `.nuxt/tsconfig.json` - Legacy configuration for backward compatibility
2. **Backward compatibility**: Existing projects that extend `.nuxt/tsconfig.json` will continue to work as before.
3. **Opt-in project references**: New projects or those wanting better type checking can adopt TypeScript's project references feature.
4. **Context-specific type checking**: Each context now has appropriate compiler options and includes/excludes for its specific environment.
5. **New `typescript.nodeTsConfig` option**: You can now customize the TypeScript configuration for Node.js build-time code.

#### Reasons for Change

This change provides several benefits:

1. **Better type safety**: Each context (app, server, build-time) gets appropriate type checking with context-specific globals and APIs.
2. **Improved IDE experience**: Better IntelliSense and error reporting for different parts of your codebase.
3. **Cleaner separation**: Server code won't incorrectly suggest client-side APIs and vice versa.
4. **Performance**: TypeScript can more efficiently check code with properly scoped configurations.

For example, auto-imports are not available in your `nuxt.config.ts` (but previously this was not flagged by TypeScript). And while IDEs recognized the separate context hinted by `tsconfig.json` in your `server/` directory, this was not reflected in type-checking (requiring a separate step).

#### Migration Steps

**No migration is required** - existing projects will continue to work as before.

However, to take advantage of improved type checking, you can opt in to the new project references approach:

1. **Update your root `tsconfig.json`** to use project references:
   ```json
   {
     "files": [],
     "references": [
       { "path": "./.nuxt/tsconfig.app.json" },
       { "path": "./.nuxt/tsconfig.server.json" },
       { "path": "./.nuxt/tsconfig.shared.json" },
       { "path": "./.nuxt/tsconfig.node.json" }
     ]
   }
   ```
2. **Remove any manual server `tsconfig.json`** files (like `server/tsconfig.json`) that extended `.nuxt/tsconfig.server.json`.
3. **Update your type checking scripts** to use the build flag for project references:
   ```diff
   - "typecheck": "nuxt prepare && vue-tsc --noEmit"
   + "typecheck": "nuxt prepare && vue-tsc -b --noEmit"
   ```
4. **Move all type augmentations into their appropriate context**:
   - If you are augmenting types for the app context, move the files to the `app/` directory.
   - If you are augmenting types for the server context, move the files to the `server/` directory.
   - If you are augmenting types that are **shared between the app and server**, move the files to the `shared/` directory.
   :warning[Augmenting types from outside the `app/`, `server/`, or `shared/` directories will not work with the new project references setup.]
5. **Configure Node.js TypeScript options** if needed:
   ```ts
   export default defineNuxtConfig({
     typescript: {
       // Customize app/server TypeScript config
       tsConfig: {
         compilerOptions: {
           strict: true
         }
       },
       // Customize build-time TypeScript config  
       nodeTsConfig: {
         compilerOptions: {
           strict: true
         }
       }
     }
   })
   ```
6. **Update any CI/build scripts** that run TypeScript checking to ensure they use the new project references approach.

The new configuration provides better type safety and IntelliSense for projects that opt in, while maintaining full backward compatibility for existing setups.

### Removal of Experimental Features

🚦 **Impact Level**: Minimal

#### What Changed

Four experimental features are no longer configurable in Nuxt 4:

- `experimental.treeshakeClientOnly` will be `true` (default since v3.0)
- `experimental.configSchema` will be `true` (default since v3.3)
- `experimental.polyfillVueUseHead` will be `false` (default since v3.4)
- `experimental.respectNoSSRHeader` will be `false` (default since v3.4)
- `vite.devBundler` is no longer configurable - it will use `vite-node` by default

#### Reasons for Change

These options have been set to their current values for some time and we do not have a reason to believe that they need to remain configurable.

#### Migration Steps

- `polyfillVueUseHead` is implementable in user-land with [this plugin](https://github.com/nuxt/nuxt/blob/f209158352b09d1986aa320e29ff36353b91c358/packages/nuxt/src/head/runtime/plugins/vueuse-head-polyfill.ts#L10-L11){rel="nofollow"}
- `respectNoSSRHeader`is implementable in user-land with [server middleware](https://github.com/nuxt/nuxt/blob/c660b39447f0d5b8790c0826092638d321cd6821/packages/nuxt/src/core/runtime/nitro/no-ssr.ts#L8-L9){rel="nofollow"}

### Removal of Top-Level `generate` Configuration

🚦 **Impact Level**: Minimal

#### What Changed

The top-level `generate` configuration option is no longer available in Nuxt 4. This includes all of its properties:

- `generate.exclude` - for excluding routes from prerendering
- `generate.routes` - for specifying routes to prerender

#### Reasons for Change

The top level `generate` configuration was a holdover from Nuxt 2. We've supported `nitro.prerender` for a while now, and it is the preferred way to configure prerendering in Nuxt 3+.

#### Migration Steps

Replace `generate` configuration with the corresponding `nitro.prerender` options:

```diff
export default defineNuxtConfig({
- generate: {
-   exclude: ['/admin', '/private'],
-   routes: ['/sitemap.xml', '/robots.txt']
- }
+ nitro: {
+   prerender: {
+     ignore: ['/admin', '/private'],
+     routes: ['/sitemap.xml', '/robots.txt']
+   }
+ }
})
```

::read-more{to="https://nitro.build/config#prerender"}
Read more about Nitro's prerender configuration options.
::

## Nuxt 2 vs. Nuxt 3+

In the table below, there is a quick comparison between 3 versions of Nuxt:

| Feature / Version       | Nuxt 2     | Nuxt Bridge | Nuxt 3+    |
| ----------------------- | ---------- | ----------- | ---------- |
| Vue                     | 2          | 2           | 3          |
| Stability               | 😊 Stable  | 😊 Stable   | 😊 Stable  |
| Performance             | 🏎 Fast    | ✈️ Faster   | 🚀 Fastest |
| Nitro Engine            | ❌          | ✅           | ✅          |
| ESM support             | 🌙 Partial | 👍 Better   | ✅          |
| TypeScript              | ☑️ Opt-in  | 🚧 Partial  | ✅          |
| Composition API         | ❌          | 🚧 Partial  | ✅          |
| Options API             | ✅          | ✅           | ✅          |
| Components Auto Import  | ✅          | ✅           | ✅          |
| `<script setup>` syntax | ❌          | 🚧 Partial  | ✅          |
| Auto Imports            | ❌          | ✅           | ✅          |
| webpack                 | 4          | 4           | 5          |
| Vite                    | ⚠️ Partial | 🚧 Partial  | ✅          |
| Nuxt CLI                | ❌ Old      | ✅ nuxt      | ✅ nuxt     |
| Static sites            | ✅          | ✅           | ✅          |

## Nuxt 2 to Nuxt 3+

The migration guide provides a step-by-step comparison of Nuxt 2 features to Nuxt 3+ features and guidance to adapt your current application.

::read-more{to="https://nuxt.com/docs/migration/overview"}
Check out the **guide to migrating from Nuxt 2 to Nuxt 3**.
::

## Nuxt 2 to Nuxt Bridge

If you prefer to progressively migrate your Nuxt 2 application to Nuxt 3, you can use Nuxt Bridge. Nuxt Bridge is a compatibility layer that allows you to use Nuxt 3+ features in Nuxt 2 with an opt-in mechanism.

::read-more{to="https://nuxt.com/docs/bridge/overview"}
**Migrate from Nuxt 2 to Nuxt Bridge**
::


# Nuxt Guide

::card-group{.sm:grid-cols-1}
  :::card
  ---
  icon: i-lucide-medal
  title: Key Concepts
  to: https://nuxt.com/docs/guide/concepts
  ---
  Discover the main concepts behind Nuxt, from auto-import, hybrid rendering to its TypeScript support.
  :::

  :::card
  ---
  icon: i-lucide-folders
  title: Directory Structure
  to: https://nuxt.com/docs/guide/directory-structure
  ---
  Learn about Nuxt directory structure and what benefits each directory or file offers.
  :::

  :::card
  ---
  icon: i-lucide-star
  title: Going Further
  to: https://nuxt.com/docs/guide/going-further
  ---
  Master Nuxt with advanced concepts like experimental features, hooks, modules, and more.
  :::

  :::card
  ---
  icon: i-lucide-book-open
  title: Recipes
  to: https://nuxt.com/docs/guide/recipes
  ---
  Find solutions to common problems and learn how to implement them in your Nuxt project.
  :::

  :::card
  ---
  icon: i-lucide-square-check
  title: Best Practices
  to: https://nuxt.com/docs/guide/best-practices
  ---
  Learn about best practices when developing with Nuxt
  :::
::


# Auto-imports

Nuxt auto-imports components, composables and [Vue.js APIs](https://vuejs.org/api){rel="nofollow"} to use across your application without explicitly importing them.

```vue [app/app.vue] twoslash
<script setup lang="ts">
const count = ref(1) // ref is auto-imported
</script>
```

Thanks to its opinionated directory structure, Nuxt can auto-import your [`app/components/`](https://nuxt.com/docs/guide/directory-structure/app/components), [`app/composables/`](https://nuxt.com/docs/guide/directory-structure/app/composables) and [`app/utils/`](https://nuxt.com/docs/guide/directory-structure/app/utils).

Contrary to a classic global declaration, Nuxt preserves typings, IDEs completions and hints, and **only includes what is used in your production code**.

::note
In the docs, every function that is not explicitly imported is auto-imported by Nuxt and can be used as-is in your code. You can find a reference for auto-imported components, composables and utilities in the [API section](https://nuxt.com/docs/api).
::

::note
In the [`server`](https://nuxt.com/docs/guide/directory-structure/server) directory, Nuxt auto-imports exported functions and variables from `server/utils/`.
::

::note
You can also auto-import functions exported from custom folders or third-party packages by configuring the [`imports`](https://nuxt.com/docs/api/nuxt-config#imports) section of your `nuxt.config` file.
::

## Built-in Auto-imports

Nuxt auto-imports functions and composables to perform [data fetching](https://nuxt.com/docs/getting-started/data-fetching), get access to the [app context](https://nuxt.com/docs/api/composables/use-nuxt-app) and [runtime config](https://nuxt.com/docs/guide/going-further/runtime-config), manage [state](https://nuxt.com/docs/getting-started/state-management) or define components and plugins.

```vue twoslash
<script setup lang="ts">
/* useFetch() is auto-imported */
const { data, refresh, status } = await useFetch('/api/hello')
</script>
```

Vue exposes Reactivity APIs like `ref` or `computed`, as well as lifecycle hooks and helpers that are auto-imported by Nuxt.

```vue twoslash
<script setup lang="ts">
/* ref() and computed() are auto-imported */
const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Vue and Nuxt Composables

When you are using the built-in Composition API composables provided by Vue and Nuxt, be aware that many of them rely on being called in the right *context*.

During a component lifecycle, Vue tracks the temporary instance of the current component (and similarly, Nuxt tracks a temporary instance of `nuxtApp`) via a global variable, and then unsets it in the same tick. This is essential when server rendering, both to avoid cross-request state pollution (leaking a shared reference between two users) and to avoid leakage between different components.

That means that (with very few exceptions) you cannot use them outside a Nuxt plugin, Nuxt route middleware or Vue setup function. On top of that, you must use them synchronously - that is, you cannot use `await` before calling a composable, except within `<script setup>` blocks, within the setup function of a component declared with `defineNuxtComponent`, in `defineNuxtPlugin` or in `defineNuxtRouteMiddleware`, where we perform a transform to keep the synchronous context even after the `await`.

If you get an error message like `Nuxt instance is unavailable` then it probably means you are calling a Nuxt composable in the wrong place in the Vue or Nuxt lifecycle.

::video-accordion
---
title: Watch a video from Alexander Lichter about avoiding the 'Nuxt instance is
  unavailable' error
video-id: ofuKRZLtOdY
---
::

::tip
When using a composable that requires the Nuxt context inside a non-SFC component, you need to wrap your component with `defineNuxtComponent` instead of `defineComponent`
::

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#asynccontext
---
Checkout the `asyncContext` experimental feature to use Nuxt composables in async functions.
::

::read-more
---
target: _blank
to: https://github.com/nuxt/nuxt/issues/14269#issuecomment-1397352832
---
See the full explanation in this GitHub comment.
::

**Example of breaking code:**

```ts [composables/example.ts] twoslash
// trying to access runtime config outside a composable
const config = useRuntimeConfig()

export const useMyComposable = () => {
  // accessing runtime config here
}
```

**Example of working code:**

```ts [composables/example.ts] twoslash
export const useMyComposable = () => {
  // Because your composable is called in the right place in the lifecycle,
  // useRuntimeConfig will work here
  const config = useRuntimeConfig()

  // ...
}
```

## Directory-based Auto-imports

Nuxt directly auto-imports files created in defined directories:

- `app/components/` for [Vue components](https://nuxt.com/docs/guide/directory-structure/app/components).
- `app/composables/` for [Vue composables](https://nuxt.com/docs/guide/directory-structure/app/composables).
- `app/utils/` for helper functions and other utilities.

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

::warning
**Auto-imported `ref` and `computed` won't be unwrapped in a component `<template>`.** :br
This is due to how Vue works with refs that aren't top-level to the template. You can read more about it [in the Vue documentation](https://vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-when-unwrapping-in-templates){rel="nofollow"}.
::

### Explicit Imports

Nuxt exposes every auto-import with the `#imports` alias that can be used to make the import explicit if needed:

```vue
<script setup lang="ts">
import { ref, computed } from '#imports'

const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Disabling Auto-imports

If you want to disable auto-importing composables and utilities, you can set `imports.autoImport` to `false` in the `nuxt.config` file.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  imports: {
    autoImport: false
  }
})
```

This will disable auto-imports completely but it's still possible to use [explicit imports](https://nuxt.com/#explicit-imports) from `#imports`.

### Partially Disabling Auto-imports

If you want framework-specific functions like `ref` to remain auto-imported but wish to disable auto-imports for your own code (e.g., custom composables), you can set the `imports.scan` option to `false` in your `nuxt.config.ts` file:

```ts
export default defineNuxtConfig({
  imports: {
    scan: false
  }
})
```

With this configuration:

- Framework functions like `ref`, `computed`, or `watch` will still work without needing manual imports.
- Custom code, such as composables, will need to be manually imported in your files.

::warning
**Caution:** This setup has certain limitations:

- If you structure your project with layers, you will need to explicitly import the composables from each layer, rather than relying on auto-imports.
- This breaks the layer system’s override feature. If you use `imports.scan: false`, ensure you understand this side-effect and adjust your architecture accordingly.
::

## Auto-imported Components

Nuxt also automatically imports components from your `~/components` directory, although this is configured separately from auto-importing composables and utility functions.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/components"}
::

To disable auto-importing components from your own `~/components` directory, you can set `components.dirs` to an empty array (though note that this will not affect components added by modules).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: {
    dirs: []
  }
})
```

## Auto-import from Third-Party Packages

Nuxt also allows auto-importing from third-party packages.

::tip
If you are using the Nuxt module for that package, it is likely that the module has already configured auto-imports for that package.
::

For example, you could enable the auto-import of the `useI18n` composable from the `vue-i18n` package like this:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  imports: {
    presets: [
      {
        from: 'vue-i18n',
        imports: ['useI18n']
      }
    ]
  }
})
```

::video-accordion
---
title: Watch a video from Alexander Lichter on how to easily set up custom auto
  imports
video-id: FT2LQJ2NvVI
---
::


# Nuxt Lifecycle

The goal of this chapter is to provide a high-level overview of the different parts of the framework, their execution order, and how they work together.

## Server

On the server, the following steps are executed for every initial request to your application:

### Step 1: Setup Nitro Server and Nitro Plugins (Once)

Nuxt is powered by [Nitro](https://nitro.build/){rel="nofollow"}, a modern server engine.

When Nitro starts, it initializes and executes the plugins under the `/server/plugins` directory. These plugins can:

- Capture and handle application-wide errors.
- Register hooks that execute when Nitro shuts down.
- Register hooks for request lifecycle events, such as modifying responses.

::callout{icon="i-lucide-lightbulb"}
Nitro plugins are executed only once when the server starts. In a serverless environment, the server boots on each incoming request, and so do the Nitro plugins. However, they are not awaited.
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/server#server-plugins
---
::

### Step 2: Nitro Server Middleware

After initializing the Nitro server, middleware under `server/middleware/` is executed for every request. Middleware can be used for tasks such as authentication, logging, or request transformation.

::warning
Returning a value from middleware will terminate the request and send the returned value as the response. This behavior should generally be avoided to ensure proper request handling!
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/server#server-middleware
---
::

### Step 3: Initialize Nuxt and Execute Nuxt App Plugins

The Vue and Nuxt instances are created first. Afterward, Nuxt executes its server plugins. This includes:

- Built-in plugins, such as Vue Router and `unhead`.
- Custom plugins located in the `app/plugins/` directory, including those without a suffix (e.g., `myPlugin.ts`) and those with the `.server` suffix (e.g., `myServerPlugin.server.ts`).

Plugins execute in a specific order and may have dependencies on one another. For more details, including execution order and parallelism, refer to the [Plugins documentation](https://nuxt.com/docs/guide/directory-structure/plugins).

::callout{icon="i-lucide-lightbulb"}
After this step, Nuxt calls the [`app:created`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) hook, which can be used to execute additional logic.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

### Step 4: Route Validation

After initializing plugins and before executing middleware, Nuxt calls the `validate` method if it is defined in the `definePageMeta` function. The `validate` method, which can be synchronous or asynchronous, is often used to validate dynamic route parameters.

- The `validate` function should return `true` if the parameters are valid.
- If validation fails, it should return `false` or an object containing a `statusCode` and/or `statusMessage` to terminate the request.

For more information, see the [Route Validation documentation](https://nuxt.com/docs/getting-started/routing#route-validation).

::read-more{to="https://nuxt.com/docs/getting-started/routing#route-validation"}
::

### Step 5: Execute Nuxt App Middleware

Middleware allows you to run code before navigating to a particular route. It is often used for tasks such as authentication, redirection, or logging.

In Nuxt, there are three types of middleware:

- **Global route middleware**
- **Named route middleware**
- **Anonymous (or inline) route middleware**

Nuxt executes all global middleware on the initial page load (both on server and client) and then again before any client-side navigation. Named and anonymous middleware are executed only on the routes specified in the middleware property of the page(route) meta defined in the corresponding page components.

For details about each type and examples, see the [Middleware documentation](https://nuxt.com/docs/guide/directory-structure/app/middleware).

Any redirection on the server will result in a `Location:` header being sent to the browser; the browser then makes a fresh request to this new location. All application state will be reset when this happens, unless persisted in a cookie.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/middleware"}
::

### Step 6: Render Page and Components

Nuxt renders the page and its components and fetches any required data with `useFetch` and `useAsyncData` during this step. Since there are no dynamic updates and no DOM operations occur on the server, Vue lifecycle hooks such as `onBeforeMount`, `onMounted`, and subsequent hooks are **NOT** executed during SSR.

By default, Vue pauses dependency tracking during SSR for better performance.

::callout{icon="i-lucide-lightbulb"}
There is no reactivity on the server side because Vue SSR renders the app top-down as static HTML, making it impossible to go back and modify content that has already been rendered.
::

::important
You should avoid code that produces side effects that need cleanup in root scope of `<script setup>`. An example of such side effects is setting up timers with `setInterval`. In client-side only code we may setup a timer and then tear it down in `onBeforeUnmount` or `onUnmounted`. However, because the unmount hooks will never be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into `onMounted` instead.
::

::tip{icon="i-lucide-video" target="_blank" to="https://youtu.be/dZSNW07sO-A"}
Watch a video from Daniel Roe explaining Server Rendering and Global State.
::

### Step 7: Generate HTML Output

After all required data is fetched and the components are rendered, Nuxt combines the rendered components with settings from `unhead` to generate a complete HTML document. This HTML, along with the associated data, is then sent back to the client to complete the SSR process.

::callout{icon="i-lucide-lightbulb"}
After rendering the Vue application to HTML, Nuxt calls the [`app:rendered`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) hook.
::

::callout{icon="i-lucide-lightbulb"}
Before finalizing and sending the HTML, Nitro will call the [`render:html`](https://nuxt.com/docs/api/advanced/hooks#nitro-app-hooks-runtime-server-side) hook. This hook allows you to manipulate the generated HTML, such as injecting additional scripts or modifying meta tags.
::

## Client (browser)

This part of the lifecycle is fully executed in the browser, no matter which Nuxt mode you've chosen.

### Step 1: Initialize Nuxt and Execute Nuxt App Plugins

This step is similar to the server-side execution and includes both built-in and custom plugins.

Custom plugins in the `app/plugins/` directory, such as those without a suffix (e.g., `myPlugin.ts`) and with the `.client` suffix (e.g., `myClientPlugin.client.ts`), are executed on the client side.

::callout{icon="i-lucide-lightbulb"}
After this step, Nuxt calls the [`app:created`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) hook, which can be used to execute additional logic.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

### Step 2: Route Validation

This step is the same as the server-side execution and includes the `validate` method if defined in the `definePageMeta` function.

### Step 3: Execute Nuxt App Middleware

Nuxt middleware runs on both the server and the client. If you want certain code to run in specific environments, consider splitting it by using `import.meta.client` for the client and `import.meta.server` for the server.

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/middleware#when-middleware-runs
---
::

### Step 4: Mount Vue Application and Hydration

Calling `app.mount('#__nuxt')` mounts the Vue application to the DOM. If the application uses SSR or SSG mode, Vue performs a hydration step to make the client-side application interactive. During hydration, Vue recreates the application (excluding [Server Components](https://nuxt.com/docs/guide/directory-structure/app/components#server-components)), matches each component to its corresponding DOM nodes, and attaches DOM event listeners.

To ensure proper hydration, it's important to maintain consistency between the data on the server and the client. For API requests, it is recommended to use `useAsyncData`, `useFetch`, or other SSR-friendly composables. These methods ensure that the data fetched on the server side is reused during hydration, avoiding repeated requests. Any new requests should only be triggered after hydration, preventing hydration errors.

::callout{icon="i-lucide-lightbulb"}
Before mounting the Vue application, Nuxt calls the [`app:beforeMount`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) hook.
::

::callout{icon="i-lucide-lightbulb"}
After mounting the Vue application, Nuxt calls the [`app:mounted`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) hook.
::

### Step 5: Vue Lifecycle

Unlike on the server, the browser executes the full [Vue lifecycle](https://vuejs.org/guide/essentials/lifecycle){rel="nofollow"}.


# Vue.js Development

Nuxt integrates Vue 3, the new major release of Vue that enables new patterns for Nuxt users.

::note
While an in-depth knowledge of Vue is not required to use Nuxt, we recommend that you read the documentation and go through some of the examples on [vuejs.org](https://vuejs.org){rel="nofollow"}.
::

Nuxt has always used Vue as a frontend framework.

We chose to build Nuxt on top of Vue for these reasons:

- The reactivity model of Vue, where a change in data automatically triggers a change in the interface.
- The component-based templating, while keeping HTML as the common language of the web, enables intuitive patterns to keep your interface consistent, yet powerful.
- From small projects to large web applications, Vue keeps performing well at scale to ensure that your application keeps delivering value to your users.

## Vue with Nuxt

### Single File Components

[Vue’s single-file components](https://vuejs.org/guide/scaling-up/sfc.html){rel="nofollow"} (SFC or `*.vue` files) encapsulate the markup (`<template>`), logic (`<script>`) and styling (`<style>`) of a Vue component. Nuxt provides a zero-config experience for SFCs with [Hot Module Replacement](https://vite.dev/guide/features.html#hot-module-replacement){rel="nofollow"} that offers a seamless developer experience.

### Auto-imports

Every Vue component created in the [`app/components/`](https://nuxt.com/docs/guide/directory-structure/app/components) directory of a Nuxt project will be available in your project without having to import it. If a component is not used anywhere, your production’s code will not include it.

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::

### Vue Router

Most applications need multiple pages and a way to navigate between them. This is called **routing**. Nuxt uses an [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory and naming conventions to directly create routes mapped to your files using the official [Vue Router library](https://router.vuejs.org){rel="nofollow"}.

::read-more{to="https://nuxt.com/docs/getting-started/routing"}
::

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

## Differences with Nuxt 2 / Vue 2

Nuxt 3+ is based on Vue 3. The new major Vue version introduces several changes that Nuxt takes advantage of:

- Better performance
- Composition API
- TypeScript support

### Faster Rendering

The Vue Virtual DOM (VDOM) has been rewritten from the ground up and allows for better rendering performance. On top of that, when working with compiled Single-File Components, the Vue compiler can further optimize them at build time by separating static and dynamic markup.

This results in faster first rendering (component creation) and updates, and less memory usage. In Nuxt 3, it enables faster server-side rendering as well.

### Smaller Bundle

With Vue 3 and Nuxt 3, a focus has been put on bundle size reduction. With version 3, most of Vue’s functionality, including template directives and built-in components, is tree-shakable. Your production bundle will not include them if you don’t use them.

This way, a minimal Vue 3 application can be reduced to 12 kb gzipped.

### Composition API

The only way to provide data and logic to components in Vue 2 was through the Options API, which allows you to return data and methods to a template with pre-defined properties like `data` and `methods`:

```vue twoslash
<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  methods: {
    increment(){
      this.count++
    }
  }
}
</script>
```

The [Composition API](https://vuejs.org/guide/extras/composition-api-faq.html){rel="nofollow"} introduced in Vue 3 is not a replacement of the Options API, but it enables better logic reuse throughout an application, and is a more natural way to group code by concern in complex components.

Used with the `setup` keyword in the `<script>` definition, here is the above component rewritten with Composition API and Nuxt 3’s auto-imported Reactivity APIs:

```vue [components/Counter.vue] twoslash
<script setup lang="ts">
const count = ref(0)
const increment = () => count.value++
</script>
```

The goal of Nuxt is to provide a great developer experience around the Composition API.

- Use auto-imported [Reactivity functions](https://vuejs.org/api/reactivity-core.html){rel="nofollow"} from Vue and Nuxt [built-in composables](https://nuxt.com/docs/api/composables/use-async-data).
- Write your own auto-imported reusable functions in the [`app/composables/` directory](https://nuxt.com/docs/guide/directory-structure/app/composables).

### TypeScript Support

Both Vue 3 and Nuxt 3+ are written in TypeScript. A fully typed codebase prevents mistakes and documents APIs usage. This doesn’t mean that you have to write your application in TypeScript to take advantage of it. With Nuxt 3, you can opt-in by renaming your file from `.js` to `.ts` , or add `<script setup lang="ts">` in a component.

::read-more{to="https://nuxt.com/docs/guide/concepts/typescript"}
Read the details about TypeScript in Nuxt
::


# Rendering Modes

Nuxt supports different rendering modes, [universal rendering](https://nuxt.com/#universal-rendering), [client-side rendering](https://nuxt.com/#client-side-rendering) but also offers [hybrid-rendering](https://nuxt.com/#hybrid-rendering) and the possibility to render your application on [CDN Edge Servers](https://nuxt.com/#edge-side-rendering).

Both the browser and server can interpret JavaScript code to turn Vue.js components into HTML elements. This step is called **rendering**. Nuxt supports both **universal** and **client-side** rendering. The two approaches have benefits and downsides that we will cover.

By default, Nuxt uses **universal rendering** to provide better user experience, performance and to optimize search engine indexing, but you can switch rendering modes in [one line of configuration](https://nuxt.com/docs/api/nuxt-config#ssr).

## Universal Rendering

This step is similar to traditional **server-side rendering** performed by PHP or Ruby applications. When the browser requests a URL with universal rendering enabled, Nuxt runs the JavaScript (Vue.js) code in a server environment and returns a fully rendered HTML page to the browser. Nuxt may also return a fully rendered HTML page from a cache if the page was generated in advance. Users immediately get the entirety of the initial content of the application, contrary to client-side rendering.

Once the HTML document has been downloaded, the browser interprets this and Vue.js takes control of the document. The same JavaScript code that once ran on the server runs on the client (browser) **again** in the background now enabling interactivity (hence **Universal rendering**) by binding its listeners to the HTML. This is called **Hydration**. When hydration is complete, the page can enjoy benefits such as dynamic interfaces and page transitions.

Universal rendering allows a Nuxt application to provide quick page load times while preserving the benefits of client-side rendering. Furthermore, as the content is already present in the HTML document, crawlers can index it without overhead.

![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](https://nuxt.com/assets/docs/concepts/rendering/ssr.svg)

**What's server-rendered and what's client-rendered?**

It is normal to ask which parts of a Vue file runs on the server and/or the client in universal rendering mode.

```vue [app/app.vue]
<script setup lang="ts">
const counter = ref(0); // executes in server and client environments

const handleClick = () => {
  counter.value++; // executes only in a client environment
};
</script>

<template>
  <div>
    <p>Count: {{ counter }}</p>
    <button @click="handleClick">Increment</button>
  </div>
</template>
```

On the initial request, the `counter` ref is initialized in the server since it is rendered inside the `<p>` tag. The contents of `handleClick` is never executed here. During hydration in the browser, the `counter` ref is re-initialized. The `handleClick` finally binds itself to the button; Therefore it is reasonable to deduce that the body of `handleClick` will always run in a browser environment.

[Middlewares](https://nuxt.com/docs/guide/directory-structure/app/middleware) and [pages](https://nuxt.com/docs/guide/directory-structure/app/pages) run in the server and on the client during hydration. [Plugins](https://nuxt.com/docs/guide/directory-structure/plugins) can be rendered on the server or client or both. [Components](https://nuxt.com/docs/guide/directory-structure/app/components) can be forced to run on the client only as well. [Composables](https://nuxt.com/docs/guide/directory-structure/app/composables) and [utilities](https://nuxt.com/docs/guide/directory-structure/app/utils) are rendered based on the context of their usage.

**Benefits of server-side rendering:**

- **Performance**: Users can get immediate access to the page's content because browsers can display static content much faster than JavaScript-generated content. At the same time, Nuxt preserves the interactivity of a web application during the hydration process.
- **Search Engine Optimization**: Universal rendering delivers the entire HTML content of the page to the browser as a classic server application. Web crawlers can directly index the page's content, which makes Universal rendering a great choice for any content that you want to index quickly.

**Downsides of server-side rendering:**

- **Development constraints:** Server and browser environments don't provide the same APIs, and it can be tricky to write code that can run on both sides seamlessly. Fortunately, Nuxt provides guidelines and specific variables to help you determine where a piece of code is executed.
- **Cost:** A server needs to be running in order to render pages on the fly. This adds a monthly cost like any traditional server. However, the server calls are highly reduced thanks to universal rendering with the browser taking over on client-side navigation. A cost reduction is possible by leveraging [edge-side-rendering](https://nuxt.com/#edge-side-rendering).

Universal rendering is very versatile and can fit almost any use case, and is especially appropriate for any content-oriented websites: &#x2A;*blogs, marketing websites, portfolios, e-commerce sites, and marketplaces.**

::tip
For more examples about writing Vue code without hydration mismatch, see [the Vue docs](https://vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch){rel="nofollow"}.
::

::important
When importing a library that relies on browser APIs and has side effects, make sure the component importing it is only called client-side. Bundlers do not treeshake imports of modules containing side effects.
::

## Client-Side Rendering

Out of the box, a traditional Vue.js application is rendered in the browser (or **client**). Then, Vue.js generates HTML elements after the browser downloads and parses all the JavaScript code containing the instructions to create the current interface.

![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](https://nuxt.com/assets/docs/concepts/rendering/csr.svg)

**Benefits of client-side rendering:**

- **Development speed**: When working entirely on the client-side, we don't have to worry about the server compatibility of the code, for example, by using browser-only APIs like the `window` object.
- **Cheaper:** Running a server adds a cost of infrastructure as you would need to run on a platform that supports JavaScript. We can host client-only applications on any static server with HTML, CSS, and JavaScript files.
- **Offline:** Because code entirely runs in the browser, it can nicely keep working while the internet is unavailable.

**Downsides of client-side rendering:**

- **Performance**: The user has to wait for the browser to download, parse and run JavaScript files. Depending on the network for the download part and the user's device for the parsing and execution, this can take some time and impact the user's experience.
- **Search Engine Optimization**: Indexing and updating the content delivered via client-side rendering takes more time than with a server-rendered HTML document. This is related to the performance drawback we discussed, as search engine crawlers won't wait for the interface to be fully rendered on their first try to index the page. Your content will take more time to show and update in search results pages with pure client-side rendering.

Client-side rendering is a good choice for heavily interactive **web applications** that don't need indexing or whose users visit frequently. It can leverage browser caching to skip the download phase on subsequent visits, such as **SaaS, back-office applications, or online games**.

You can enable client-side only rendering with Nuxt in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false
})
```

::note
If you do use `ssr: false`, you should also place an HTML file in `~/spa-loading-template.html` with some HTML you would like to use to render a loading screen that will be rendered until your app is hydrated.

  :::read-more
  ---
  title: SPA Loading Template
  to: https://nuxt.com/docs/api/configuration/nuxt-config#spaloadingtemplate
  ---
  :::
::

::video-accordion
---
title: Watch a video from Alexander Lichter about Building a plain SPA with Nuxt
video-id: 7Lr0QTP1Ro8
---
::

### Deploying a Static Client-Rendered App

If you deploy your app to [static hosting](https://nuxt.com/docs/getting-started/deployment#static-hosting) with the `nuxt generate` or `nuxt build --prerender` commands, then by default, Nuxt will render every page as a separate static HTML file.

::warning
If you prerender your app with the `nuxt generate` or `nuxt build --prerender` commands, then you will not be able to use any server endpoints as no server will be included in your output folder. If you need server functionality, use `nuxt build` instead.
::

If you are using purely client-side rendering, then this might be unnecessary. You might only need a single `index.html` file, plus `200.html` and `404.html` fallbacks, which you can tell your static web host to serve up for all requests.

In order to achieve this we can change how the routes are prerendered. Just add this to [your hooks](https://nuxt.com/docs/api/advanced/hooks#nuxt-hooks-build-time) in your `nuxt.config.ts`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  hooks: {
    'prerender:routes' ({ routes }) {
      routes.clear() // Do not generate any routes (except the defaults)
    }
  },
})
```

This will produce three files:

- `index.html`
- `200.html`
- `404.html`

The `200.html` and `404.html` might be useful for the hosting provider you are using.

#### Skipping Client Fallback Generation

When prerendering a client-rendered app, Nuxt will generate `index.html`, `200.html` and `404.html` files by default. However, if you need to prevent any (or all) of these files from being generated in your build, you can use the `'prerender:generate'` hook from [Nitro](https://nuxt.com/docs/getting-started/prerendering#prerendergenerate-nitro-hook).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  ssr: false,
  nitro: {
    hooks: {
      'prerender:generate'(route) {
        const routesToSkip = ['/index.html', '/200.html', '/404.html']
        if (routesToSkip.includes(route.route)) {
          route.skip = true
        }
      }
    }
  }
})
```

## Hybrid Rendering

Hybrid rendering allows different caching rules per route using **Route Rules** and decides how the server should respond to a new request on a given URL.

Previously every route/page of a Nuxt application and server must use the same rendering mode, universal or client-side. In various cases, some pages could be generated at build time, while others should be client-side rendered. For example, think of a content website with an admin section. Every content page should be primarily static and generated once, but the admin section requires registration and behaves more like a dynamic application.

Nuxt includes route rules and hybrid rendering support. Using route rules you can define rules for a group of nuxt routes, change rendering mode or assign a cache strategy based on route!

Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using [Nitro caching layer](https://nitro.build/guide/cache){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  routeRules: {
    // Homepage pre-rendered at build time
    '/': { prerender: true },
    // Products page generated on demand, revalidates in background, cached until API response changes
    '/products': { swr: true },
    // Product pages generated on demand, revalidates in background, cached for 1 hour (3600 seconds)
    '/products/**': { swr: 3600 },
    // Blog posts page generated on demand, revalidates in background, cached on CDN for 1 hour (3600 seconds)
    '/blog': { isr: 3600 },
    // Blog post page generated on demand once until next deployment, cached on CDN
    '/blog/**': { isr: true },
    // Admin dashboard renders only on client-side
    '/admin/**': { ssr: false },
    // Add cors headers on API routes
    '/api/**': { cors: true },
    // Redirects legacy urls
    '/old-page': { redirect: '/new-page' }
  }
})
```

### Route Rules

The different properties you can use are the following:

- `redirect: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Define server-side redirects.
- `ssr: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Disables server-side rendering of the HTML for sections of your app and make them render only in the browser with `ssr: false`
- `cors: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Automatically adds cors headers with `cors: true` - you can customize the output by overriding with `headers`
- `headers: object`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Add specific headers to sections of your site - for example, your assets
- `swr: number | boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Add cache headers to the server response and cache it on the server or reverse proxy for a configurable TTL (time to live). The `node-server` preset of Nitro is able to cache the full response. When the TTL expired, the cached response will be sent while the page will be regenerated in the background. If true is used, a `stale-while-revalidate` header is added without a MaxAge.
- `isr: number | boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - The behavior is the same as `swr` except that we are able to add the response to the CDN cache on platforms that support this (currently Netlify or Vercel). If `true` is used, the content persists until the next deploy inside the CDN.
- `prerender: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Prerenders routes at build time and includes them in your build as static assets
- `noScripts: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Disables rendering of Nuxt scripts and JS resource hints for sections of your site.
- `appMiddleware: string | string[] | Record<string, boolean>`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Allows you to define middleware that should or should not run for page paths within the Vue app part of your application (that is, not your Nitro routes)

Whenever possible, route rules will be automatically applied to the deployment platform's native rules for optimal performances (Netlify and Vercel are currently supported).

::important
Note that Hybrid Rendering is not available when using [`nuxt generate`](https://nuxt.com/docs/api/commands/generate).
::

**Examples:**

::card-group
  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: Nuxt Vercel ISR
  to: https://github.com/danielroe/nuxt-vercel-isr
  ---
  Example of a Nuxt application with hybrid rendering deployed on Vercel.
  :::
::

## Edge-Side Rendering

Edge-Side Rendering (ESR) is a powerful feature introduced in Nuxt that allows the rendering of your Nuxt application closer to your users via edge servers of a Content Delivery Network (CDN). By leveraging ESR, you can ensure improved performance and reduced latency, thereby providing an enhanced user experience.

With ESR, the rendering process is pushed to the 'edge' of the network - the CDN's edge servers. Note that ESR is more a deployment target than an actual rendering mode.

When a request for a page is made, instead of going all the way to the original server, it's intercepted by the nearest edge server. This server generates the HTML for the page and sends it back to the user. This process minimizes the physical distance the data has to travel, **reducing latency and loading the page faster**.

Edge-side rendering is possible thanks to [Nitro](https://nitro.build/){rel="nofollow"}, the [server engine](https://nuxt.com/docs/guide/concepts/server-engine) that powers Nuxt. It offers cross-platform support for Node.js, Deno, Cloudflare Workers, and more.

The current platforms where you can leverage ESR are:

- [Cloudflare Pages](https://pages.cloudflare.com){rel="nofollow"} with zero configuration using the git integration and the `nuxt build` command
- [Vercel Edge Functions](https://vercel.com/features/edge-functions){rel="nofollow"} using the `nuxt build` command and `NITRO_PRESET=vercel-edge` environment variable
- [Netlify Edge Functions](https://www.netlify.com/products/#netlify-edge-functions){rel="nofollow"} using the `nuxt build` command and `NITRO_PRESET=netlify-edge` environment variable

Note that **Hybrid Rendering** can be used when using Edge-Side Rendering with route rules.

You can explore open source examples deployed on some of the platform mentioned above:

::card-group
  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: Nuxt Todos Edge
  to: https://github.com/atinux/nuxt-todos-edge
  ---
  A todos application with user authentication, SSR and SQLite.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: Atinotes
  to: https://github.com/atinux/atinotes
  ---
  An editable website with universal rendering based on Cloudflare KV.
  :::
::


# Server Engine

While building Nuxt, we created a new server engine: [Nitro](https://nitro.build/){rel="nofollow"}.

It is shipped with many features:

- Cross-platform support for Node.js, browsers, service workers and more.
- Serverless support out-of-the-box.
- API routes support.
- Automatic code-splitting and async-loaded chunks.
- Hybrid mode for static + serverless sites.
- Development server with hot module reloading.

## API Layer

Server [API endpoints](https://nuxt.com/docs/guide/directory-structure/server#api-routes) and [Middleware](https://nuxt.com/docs/guide/directory-structure/server#server-middleware) are added by Nitro that internally uses [h3](https://github.com/h3js/h3){rel="nofollow"}.

Key features include:

- Handlers can directly return objects/arrays for an automatically-handled JSON response
- Handlers can return promises, which will be awaited (`res.end()` and `next()` are also supported)
- Helper functions for body parsing, cookie handling, redirects, headers and more

Check out [the h3 docs](https://github.com/h3js/h3){rel="nofollow"} for more information.

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/server#server-routes
---
Learn more about the API layer in the `server/` directory.
::

## Direct API Calls

Nitro allows 'direct' calling of routes via the globally-available [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) helper. This will make an API call to the server if run on the browser, but will directly call the relevant function if run on the server, **saving an additional API call**.

[`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) API is using [ofetch](https://github.com/unjs/ofetch){rel="nofollow"}, with key features including:

- Automatic parsing of JSON responses (with access to raw response if needed)
- Request body and params are automatically handled, with correct `Content-Type` headers

For more information on `$fetch` features, check out [ofetch](https://github.com/unjs/ofetch){rel="nofollow"}.

## Typed API Routes

When using API routes (or middleware), Nitro will generate typings for these routes as long as you are returning a value instead of using `res.end()` to send a response.

You can access these types when using [`$fetch()`](https://nuxt.com/docs/api/utils/dollarfetch) or [`useFetch()`](https://nuxt.com/docs/api/composables/use-fetch).

## Standalone Server

Nitro produces a standalone server dist that is independent of `node_modules`.

The server in Nuxt 2 is not standalone and requires part of Nuxt core to be involved by running `nuxt start` (with the [`nuxt-start`](https://www.npmjs.com/package/nuxt-start){rel="nofollow"} or [`nuxt`](https://www.npmjs.com/package/nuxt){rel="nofollow"} distributions) or custom programmatic usage, which is fragile and prone to breakage and not suitable for serverless and service worker environments.

Nuxt generates this dist when running `nuxt build` into a [`.output`](https://nuxt.com/docs/guide/directory-structure/output) directory.

The output contains runtime code to run your Nuxt server in any environment (including experimental browser service workers!) and serve your static files, making it a true hybrid framework for the JAMstack. In addition, Nuxt implements a native storage layer, supporting multi-source drivers and local assets.

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nitrojs/nitro
---
Read more about Nitro engine on GitHub.
::


# Modules

## Exploring Nuxt Modules

When developing production-grade applications with Nuxt you might find that the framework's core functionality is not enough. Nuxt can be extended with configuration options and plugins, but maintaining these customizations across multiple projects can be tedious, repetitive and time-consuming. On the other hand, supporting every project's needs out of the box would make Nuxt very complex and hard to use.

This is one of the reasons why Nuxt provides a module system that makes it possible to extend the core. Nuxt modules are async functions that sequentially run when starting Nuxt in development mode using [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) or building a project for production with [`nuxt build`](https://nuxt.com/docs/api/commands/build). They can override templates, configure webpack loaders, add CSS libraries, and perform many other useful tasks.

Best of all, Nuxt modules can be distributed in npm packages. This makes it possible for them to be reused across projects and shared with the community, helping create an ecosystem of high-quality add-ons.

::read-more{to="https://nuxt.com/modules"}
Explore Nuxt Modules
::

## Add Nuxt Modules

Once you have installed the modules you can add them to your [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file under the `modules` property. Module developers usually provide additional steps and details for usage.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  modules: [
    // Using package name (recommended usage)
    '@nuxtjs/example',

    // Load a local module
    './modules/example',

    // Add module with inline-options
    ['./modules/example', { token: '123' }],

    // Inline module definition
    async (inlineOptions, nuxt) => { }
  ]
})
```

::warning
Nuxt modules are now build-time-only, and the `buildModules` property used in Nuxt 2 is deprecated in favor of `modules`.
::

## Create a Nuxt Module

Everyone has the opportunity to develop modules and we cannot wait to see what you will build.

::read-more
---
title: Module Author Guide
to: https://nuxt.com/docs/guide/going-further/modules
---
::


# ES Modules

This guide helps explain what ES Modules are and how to make a Nuxt app (or upstream library) compatible with ESM.

## Background

### CommonJS Modules

CommonJS (CJS) is a format introduced by Node.js that allows sharing functionality between isolated JavaScript modules ([read more](https://nodejs.org/api/modules.html){rel="nofollow"}).
You might be already familiar with this syntax:

```js
const a = require('./a')

module.exports.a = a
```

Bundlers like webpack and Rollup support this syntax and allow you to use modules written in CommonJS in the browser.

### ESM Syntax

Most of the time, when people talk about ESM vs. CJS, they are talking about a different syntax for writing [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules){rel="nofollow"}.

```js
import a from './a'

export { a }
```

Before ECMAScript Modules (ESM) became a standard (it took more than 10 years!), tooling like
[webpack](https://webpack.js.org/guides/ecma-script-modules){rel="nofollow"} and even languages like TypeScript started supporting so-called **ESM syntax**.
However, there are some key differences with actual spec; here's [a helpful explainer](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive){rel="nofollow"}.

### What is 'Native' ESM?

You may have been writing your app using ESM syntax for a long time. After all, it's natively supported by the browser, and in Nuxt 2 we compiled all the code you wrote to the appropriate format (CJS for server, ESM for browser).

When adding modules to your package, things were a little different. A sample library might expose both CJS and ESM versions, and let us pick which one we wanted:

```json
{
  "name": "sample-library",
  "main": "dist/sample-library.cjs.js",
  "module": "dist/sample-library.esm.js"
}
```

So in Nuxt 2, the bundler (webpack) would pull in the CJS file ('main') for the server build and use the ESM file ('module') for the client build.

However, in recent Node.js LTS releases, it is now possible to [use native ESM module](https://nodejs.org/api/esm.html){rel="nofollow"} within Node.js. That means that Node.js itself can process JavaScript using ESM syntax, although it doesn't do it by default. The two most common ways to enable ESM syntax are:

- set `"type": "module"` within your `package.json` and keep using `.js` extension
- use the `.mjs` file extensions (recommended)

This is what we do for Nuxt Nitro; we output a `.output/server/index.mjs` file. That tells Node.js to treat this file as a native ES module.

### What Are Valid Imports in a Node.js Context?

When you `import` a module rather than `require` it, Node.js resolves it differently. For example, when you import `sample-library`, Node.js will look not for the `main` but for the `exports` or `module` entry in that library's `package.json`.

This is also true of dynamic imports, like `const b = await import('sample-library')`.

Node supports the following kinds of imports (see [docs](https://nodejs.org/api/packages.html#determining-module-system){rel="nofollow"}):

1. files ending in `.mjs` - these are expected to use ESM syntax
2. files ending in `.cjs` - these are expected to use CJS syntax
3. files ending in `.js` - these are expected to use CJS syntax unless their `package.json` has `"type": "module"`

### What Kinds of Problems Can There Be?

For a long time module authors have been producing ESM-syntax builds but using conventions like `.esm.js` or `.es.js`, which they have added to the `module` field in their `package.json`. This hasn't been a problem until now because they have only been used by bundlers like webpack, which don't especially care about the file extension.

However, if you try to import a package with an `.esm.js` file in a Node.js ESM context, it won't work, and you'll get an error like:

```bash [Terminal]
(node:22145) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
/path/to/index.js:1

export default {}
^^^^^^

SyntaxError: Unexpected token 'export'
    at wrapSafe (internal/modules/cjs/loader.js:1001:16)
    at Module._compile (internal/modules/cjs/loader.js:1049:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    ....
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

You might also get this error if you have a named import from an ESM-syntax build that Node.js thinks is CJS:

```bash [Terminal]
file:///path/to/index.mjs:5
import { named } from 'sample-library'
         ^^^^^
SyntaxError: Named export 'named' not found. The requested module 'sample-library' is a CommonJS module, which may not support all module.exports as named exports.

CommonJS modules can always be imported via the default export, for example using:

import pkg from 'sample-library';
const { named } = pkg;

    at ModuleJob._instantiate (internal/modules/esm/module_job.js:120:21)
    at async ModuleJob.run (internal/modules/esm/module_job.js:165:5)
    at async Loader.import (internal/modules/esm/loader.js:177:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

## Troubleshooting ESM Issues

If you encounter these errors, the issue is almost certainly with the upstream library. They need to [fix their library](https://nuxt.com/#library-author-guide) to support being imported by Node.

### Transpiling Libraries

In the meantime, you can tell Nuxt not to try to import these libraries by adding them to `build.transpile`:

```ts twoslash
export default defineNuxtConfig({
  build: {
    transpile: ['sample-library']
  }
})
```

You may find that you *also* need to add other packages that are being imported by these libraries.

### Aliasing Libraries

In some cases, you may also need to manually alias the library to the CJS version, for example:

```ts twoslash
export default defineNuxtConfig({
  alias: {
    'sample-library': 'sample-library/dist/sample-library.cjs.js'
  }
})
```

### Default Exports

A dependency with CommonJS format, can use `module.exports` or `exports` to provide a default export:

```js [node_modules/cjs-pkg/index.js]
module.exports = { test: 123 }
// or
exports.test = 123
```

This normally works well if we `require` such dependency:

```js [test.cjs]
const pkg = require('cjs-pkg')

console.log(pkg) // { test: 123 }
```

[Node.js in native ESM mode](https://nodejs.org/api/esm.html#interoperability-with-commonjs){rel="nofollow"}, [typescript with `esModuleInterop` enabled](https://www.typescriptlang.org/tsconfig#esModuleInterop){rel="nofollow"} and bundlers such as webpack, provide a compatibility mechanism so that we can default import such library.
This mechanism is often referred to as "interop require default":

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { test: 123 }
```

However, because of the complexities of syntax detection and different bundle formats, there is always a chance that the interop default fails and we end up with something like this:

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { default: { test: 123 } }
```

Also when using dynamic import syntax (in both CJS and ESM files), we always have this situation:

```js
import('cjs-pkg').then(console.log) // [Module: null prototype] { default: { test: '123' } }
```

In this case, we need to manually interop the default export:

```js
// Static import
import { default as pkg } from 'cjs-pkg'

// Dynamic import
import('cjs-pkg').then(m => m.default || m).then(console.log)
```

For handling more complex situations and more safety, we recommend and internally use [mlly](https://github.com/unjs/mlly){rel="nofollow"} in Nuxt that can preserve named exports.

```js
import { interopDefault } from 'mlly'

// Assuming the shape is { default: { foo: 'bar' }, baz: 'qux' }
import myModule from 'my-module'

console.log(interopDefault(myModule)) // { foo: 'bar', baz: 'qux' }
```

## Library Author Guide

The good news is that it's relatively simple to fix issues of ESM compatibility. There are two main options:

1. **You can rename your ESM files to end with `.mjs`.**:br&#x2A;This is the recommended and simplest approach.* You may have to sort out issues with your library's dependencies and possibly with your build system, but in most cases, this should fix the problem for you. It's also recommended to rename your CJS files to end with `.cjs`, for the greatest explicitness.
2. **You can opt to make your entire library ESM-only**. :br This would mean setting `"type": "module"` in your `package.json` and ensuring that your built library uses ESM syntax. However, you may face issues with your dependencies - and this approach means your library can *only* be consumed in an ESM context.

### Migration

The initial step from CJS to ESM is updating any usage of `require` to use `import` instead:

::code-group
```js [Before]
module.exports = ...

exports.hello = ...
```

```js [After]
export default ...

export const hello = ...
```
::

::code-group
```js [Before]
const myLib = require('my-lib')
```

```js [After]
import myLib from 'my-lib'
// or
const myLib = await import('my-lib').then(lib => lib.default || lib)
```
::

In ESM Modules, unlike CJS, `require`, `require.resolve`, `__filename` and `__dirname` globals are not available
and should be replaced with `import()` and `import.meta.filename`.

::code-group
```js [Before]
import { join } from 'path'

const newDir = join(__dirname, 'new-dir')
```

```js [After]
import { fileURLToPath } from 'node:url'

const newDir = fileURLToPath(new URL('./new-dir', import.meta.url))
```
::

::code-group
```js [Before]
const someFile = require.resolve('./lib/foo.js')
```

```js [After]
import { resolvePath } from 'mlly'

const someFile = await resolvePath('my-lib', { url: import.meta.url })
```
::

### Best Practices

- Prefer named exports rather than default export. This helps reduce CJS conflicts. (see [Default exports](https://nuxt.com/#default-exports) section)
- Avoid depending on Node.js built-ins and CommonJS or Node.js-only dependencies as much as possible to make your library usable in Browsers and Edge Workers without needing Nitro polyfills.
- Use new `exports` field with conditional exports. ([read more](https://nodejs.org/api/packages.html#conditional-exports){rel="nofollow"}).

```json
{
  "exports": {
    ".": {
      "import": "./dist/mymodule.mjs"
    }
  }
}
```


# TypeScript

## Type-checking

By default, Nuxt doesn't check types when you run [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) or [`nuxt build`](https://nuxt.com/docs/api/commands/build), for performance reasons.

To enable type-checking at build or development time, install `vue-tsc` and `typescript` as development dependency:

::code-group{sync="pm"}
```bash [npm]
npm install --save-dev vue-tsc typescript
```

```bash [yarn]
yarn add --dev vue-tsc typescript
```

```bash [pnpm]
pnpm add -D vue-tsc typescript
```

```bash [bun]
bun add -D vue-tsc typescript
```
::

Then, run [`nuxt typecheck`](https://nuxt.com/docs/api/commands/typecheck) command to check your types:

```bash [Terminal]
npx nuxt typecheck
```

To enable type-checking at build or development time, you can also use the [`typescript.typeCheck`](https://nuxt.com/docs/api/nuxt-config#typecheck) option in your `nuxt.config` file:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  typescript: {
    typeCheck: true
  }
})
```

## Auto-generated Types

When you run `nuxt dev` or `nuxt build`, Nuxt generates the following files for IDE type support (and type checking):

### `.nuxt/nuxt.d.ts`

This file contains the types of any modules you are using, as well as the key types that Nuxt requires. Your IDE should recognize these types automatically.

Some of the references in the file are to files that are only generated within your `buildDir` (`.nuxt`) and therefore for full typings, you will need to run `nuxt dev` or `nuxt build`.

### `.nuxt/tsconfig.app.json`

This file contains the recommended basic TypeScript configuration for your project, including resolved aliases injected by Nuxt or modules you are using, so you can get full type support and path auto-complete for aliases like `~/file` or `#build/file`.

::note
Consider using the `imports` section of [nuxt.config](https://nuxt.com/docs/api/nuxt-config#imports) to include directories beyond the default ones. This can be useful for auto-importing types which you're using across your app.
::

[Read more about how to extend this configuration](https://nuxt.com/docs/guide/directory-structure/tsconfig).

::tip{icon="i-lucide-video" target="_blank" to="https://youtu.be/umLI7SlPygY"}
Watch a video from Daniel Roe explaining built-in Nuxt aliases.
::

::note
Nitro also [auto-generates types](https://nuxt.com/docs/guide/concepts/server-engine#typed-api-routes) for API routes. Plus, Nuxt also generates types for globally available components and [auto-imports from your composables](https://nuxt.com/docs/guide/directory-structure/app/composables), plus other core functionality.
::

::note
For backward compatibility, Nuxt still generates `./.nuxt/tsconfig.json`. However, we recommend using [TypeScript project references](https://nuxt.com/docs/guide/directory-structure/tsconfig) with the new configuration files (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) for better type safety and performance.

If you do extend from `./.nuxt/tsconfig.json`, keep in mind that all options will be overwritten by those defined in your `tsconfig.json`. Overwriting options such as `"compilerOptions.paths"` with your own configuration will lead TypeScript to not factor in the module resolutions, which can cause module resolutions such as `#imports` to not be recognized.

In case you need to extend options further, you can use the [`alias` property](https://nuxt.com/docs/api/nuxt-config#alias) within your `nuxt.config`. Nuxt will pick them up and extend the generated TypeScript configurations accordingly.
::

## Project References

Nuxt uses [TypeScript project references](https://www.typescriptlang.org/docs/handbook/project-references.html){rel="nofollow"} to improve type-checking performance and provide better IDE support. This feature allows TypeScript to break up your codebase into smaller, more manageable pieces.

### How Nuxt Uses Project References

When you run `nuxt dev` or `nuxt build`, Nuxt will generate multiple `tsconfig.json` files for different parts of your application.

- **`.nuxt/tsconfig.app.json`** - Configuration for your application code
- **`.nuxt/tsconfig.node.json`** - Configuration for your `nuxt.config` and modules
- **`.nuxt/tsconfig.server.json`** - Configuration for server-side code (when applicable)
- **`.nuxt/tsconfig.shared.json`** - For code shared between app and server contexts (like types and non-environment specific utilities)
- **`.nuxt/tsconfig.json`** - Legacy configuration for backward compatibility

Each of these files is configured to reference the appropriate dependencies and provide optimal type-checking for their specific context.

### Benefits of Project References

- **Faster builds**: TypeScript can skip rebuilding unchanged projects
- **Better IDE performance**: Your IDE can provide faster IntelliSense and error checking
- **Isolated compilation**: Errors in one part of your application don't prevent compilation of other parts
- **Clearer dependency management**: Each project explicitly declares its dependencies

::note
The project reference setup is handled automatically by Nuxt. You typically don't need to modify these configurations manually, but understanding how they work can help you troubleshoot type-checking issues.
::

### Augmenting Types with Project References

Since the project is divided into **multiple type contexts**, it's important to **augment types within the correct context** to ensure they are properly recognized.

For example, if you want to augment types for the `app` context, the augmentation file should be placed in the `app/` directory.

Similarly:

- For the `server` context, place the augmentation file in the `server/` directory.
- For types that are **shared between the app and server**, place the file in the `shared/` directory.

::warning
Augmenting types outside of these directories will not be recognized by TypeScript.
::

## Strict Checks

TypeScript comes with certain checks to give you more safety and analysis of your program.

[Strict checks](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks){rel="nofollow"} are enabled by default in Nuxt to give you greater type safety.

If you are currently converting your codebase to TypeScript, you may want to temporarily disable strict checks by setting `strict` to `false` in your `nuxt.config`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  typescript: {
    strict: false
  }
})
```


# Code Style

## ESLint

The recommended approach for Nuxt is to enable ESLint support using the [`@nuxt/eslint`](https://eslint.nuxt.com/packages/module){rel="nofollow"} module, that will setup project-aware ESLint configuration for you.

::callout{icon="i-lucide-lightbulb"}
The module is designed for the [new ESLint flat config format](https://eslint.org/docs/latest/use/configure/configuration-files-new){rel="nofollow"} with is the [default format since ESLint v9](https://eslint.org/blog/2024/04/eslint-v9.0.0-released/){rel="nofollow"}. If you are using the legacy `.eslintrc` config, you will need to [configure manually with `@nuxt/eslint-config`](https://eslint.nuxt.com/packages/config#legacy-config-format){rel="nofollow"}. We highly recommend you to migrate over the flat config to be future-proof.
::

## Quick Setup

```bash
npx nuxt module add eslint
```

Start your Nuxt app, a `eslint.config.mjs` file will be generated under your project root. You can customize it as needed.

You can learn more about the module and customizations in [Nuxt ESLint's documentation](https://eslint.nuxt.com/packages/module){rel="nofollow"}.


# .nuxt

::important
This directory should be added to your [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) file to avoid pushing the dev build output to your repository.
::

This directory is interesting if you want to learn more about the files Nuxt generates based on your directory structure.

Nuxt also provides a Virtual File System (VFS) for modules to add templates to this directory without writing them to disk.

You can explore the generated files by opening the [Nuxt DevTools](https://devtools.nuxt.com){rel="nofollow"} in development mode and navigating to the **Virtual Files** tab.

::warning
You should not touch any files inside since the whole directory will be re-created when running [`nuxt dev`](https://nuxt.com/docs/api/commands/dev).
::


# .output

::important
This directory should be added to your [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) file to avoid pushing the build output to your repository.
::

Use this directory to deploy your Nuxt application to production.

::read-more{to="https://nuxt.com/docs/getting-started/deployment"}
::

::warning
You should not touch any files inside since the whole directory will be re-created when running [`nuxt build`](https://nuxt.com/docs/api/commands/build).
::


# assets

The directory usually contains the following types of files:

- Stylesheets (CSS, SASS, etc.)
- Fonts
- Images that won't be served from the [`public/`](https://nuxt.com/docs/guide/directory-structure/public) directory.

If you want to serve assets from the server, we recommend taking a look at the [`public/`](https://nuxt.com/docs/guide/directory-structure/public) directory.

::read-more{to="https://nuxt.com/docs/getting-started/assets"}
::


# components

Nuxt automatically imports any components in this directory (along with components that are registered by any modules you may be using).

```bash [Directory Structure]
-| components/
---| AppHeader.vue
---| AppFooter.vue
```

```html [app/app.vue]
<template>
  <div>
    <AppHeader />
    <NuxtPage />
    <AppFooter />
  </div>
</template>
```

## Component Names

If you have a component in nested directories such as:

```bash [Directory Structure]
-| components/
---| base/
-----| foo/
-------| Button.vue
```

... then the component's name will be based on its own path directory and filename, with duplicate segments being removed. Therefore, the component's name will be:

```html
<BaseFooButton />
```

::note
For clarity, we recommend that the component's filename matches its name. So, in the example above, you could rename `Button.vue` to be `BaseFooButton.vue`.
::

If you want to auto-import components based only on its name, not path, then you need to set `pathPrefix` option to `false` using extended form of the configuration object:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      pathPrefix: false, // [!code ++]
    },
  ],
});
```

This registers the components using the same strategy as used in Nuxt 2. For example, `~/components/Some/MyComponent.vue` will be usable as `<MyComponent>` and not `<SomeMyComponent>`.

## Dynamic Components

If you want to use the Vue `<component :is="someComputedComponent">`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="vue"} syntax, you need to use the `resolveComponent` helper provided by Vue or import the component directly from `#components` and pass it into `is` prop.

For example:

```vue [app/pages/index.vue]
<script setup lang="ts">
import { SomeComponent } from '#components'

const MyButton = resolveComponent('MyButton')
</script>

<template>
  <component :is="clickable ? MyButton : 'div'" />
  <component :is="SomeComponent" />
</template>
```

::important
If you are using `resolveComponent` to handle dynamic components, make sure not to insert anything but the name of the component, which must be a literal string and not be or contain a variable. The string is statically analyzed at the compilation step.
::

::video-accordion
---
title: Watch Daniel Roe's short video about resolveComponent()
video-id: 4kq8E5IUM2U
---
::

Alternatively, though not recommended, you can register all your components globally, which will create async chunks for all your components and make them available throughout your application.

```diff
  export default defineNuxtConfig({
    components: {
+     global: true,
+     dirs: ['~/components']
    },
  })
```

You can also selectively register some components globally by placing them in a `~/components/global` directory, or by using a `.global.vue` suffix in the filename. As noted above, each global component is rendered in a separate chunk, so be careful not to overuse this feature.

::note
The `global` option can also be set per component directory.
::

## Dynamic Imports

To dynamically import a component (also known as lazy-loading a component) all you need to do is add the `Lazy` prefix to the component's name. This is particularly useful if the component is not always needed.

By using the `Lazy` prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.

```vue [app/pages/index.vue]
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
  </div>
</template>
```

## Delayed (or Lazy) Hydration

Lazy components are great for controlling the chunk sizes in your app, but they don't always enhance runtime performance, as they still load eagerly unless conditionally rendered. In real-world applications, some pages may include a lot of content and a lot of components, and most of the time not all of them need to be interactive as soon as the page is loaded. Having them all load eagerly can negatively impact performance.

In order to optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.

Nuxt supports this using lazy (or delayed) hydration, allowing you to control when components become interactive.

### Hydration Strategies

Nuxt provides a range of built-in hydration strategies. Only one strategy can be used per lazy component.

::note
Any prop change on a lazily hydrated component will trigger hydration immediately. (e.g., changing a prop on a component with `hydrate-never` will cause it to hydrate)
::

::warning
Currently Nuxt's built-in lazy hydration only works in single-file components (SFCs), and requires you to define the prop in the template (rather than spreading an object of props via `v-bind`). It also does not work with direct imports from `#components`.
::

#### `hydrate-on-visible`

Hydrates the component when it becomes visible in the viewport.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

::read-more
---
title: IntersectionObserver options
to: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver
---
Read more about the options for `hydrate-on-visible`.
::

::note
Under the hood, this uses Vue's built-in [`hydrateOnVisible` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-visible){rel="nofollow"}.
::

#### `hydrate-on-idle`

Hydrates the component when the browser is idle. This is suitable if you need the component to load as soon as possible, but not block the critical rendering path.

You can also pass a number which serves as a max timeout.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-idle />
  </div>
</template>
```

::note
Under the hood, this uses Vue's built-in [`hydrateOnIdle` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-idle){rel="nofollow"}.
::

#### `hydrate-on-interaction`

Hydrates the component after a specified interaction (e.g., click, mouseover).

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

If you do not pass an event or list of events, it defaults to hydrating on `pointerenter`, `click` and `focus`.

::note
Under the hood, this uses Vue's built-in [`hydrateOnInteraction` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-interaction){rel="nofollow"}.
::

#### `hydrate-on-media-query`

Hydrates the component when the window matches a media query.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-media-query="(max-width: 768px)" />
  </div>
</template>
```

::note
Under the hood, this uses Vue's built-in [`hydrateOnMediaQuery` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-media-query){rel="nofollow"}.
::

#### `hydrate-after`

Hydrates the component after a specified delay (in milliseconds).

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-after="2000" />
  </div>
</template>
```

#### `hydrate-when`

Hydrates the component based on a boolean condition.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-when="isReady" />
  </div>
</template>
<script setup lang="ts">
const isReady = ref(false)
function myFunction() {
  // trigger custom hydration strategy...
  isReady.value = true
}
</script>
```

#### `hydrate-never`

Never hydrates the component.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-never />
  </div>
</template>
```

### Listening to Hydration Events

All delayed hydration components emit a `@hydrated` event when they are hydrated.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible @hydrated="onHydrate" />
  </div>
</template>

<script setup lang="ts">
function onHydrate() {
  console.log("Component has been hydrated!")
}
</script>
```

### Caveats and Best Practices

Delayed hydration can offer performance benefits, but it's essential to use it correctly:

1. **Prioritize In-Viewport Content:** Avoid delayed hydration for critical, above-the-fold content. It's best suited for content that isn't immediately needed.
2. **Conditional Rendering:** When using `v-if="false"` on a lazy component, you might not need delayed hydration. You can just use a normal lazy component.
3. **Shared State:** Be mindful of shared state (`v-model`) across multiple components. Updating the model in one component can trigger hydration in all components bound to that model.
4. **Use Each Strategy's Intended Use Case:** Each strategy is optimized for a specific purpose.
   - `hydrate-when` is best for components that might not always need to be hydrated.
   - `hydrate-after` is for components that can wait a specific amount of time.
   - `hydrate-on-idle` is for components that can be hydrated when the browser is idle.
5. **Avoid `hydrate-never` on interactive components:** If a component requires user interaction, it should not be set to never hydrate.

## Direct Imports

You can also explicitly import components from `#components` if you want or need to bypass Nuxt's auto-importing functionality.

```vue [app/pages/index.vue]
<script setup lang="ts">
import { NuxtLink, LazyMountainsList } from '#components'

const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
    <NuxtLink to="/">Home</NuxtLink>
  </div>
</template>
```

## Custom Directories

By default, only the `~/components` directory is scanned. If you want to add other directories, or change how the components are scanned within a subfolder of this directory, you can add additional directories to the configuration:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: [
    // ~/calendar-module/components/event/Update.vue => <EventUpdate />
    { path: '~/calendar-module/components' },

    // ~/user-module/components/account/UserDeleteDialog.vue => <UserDeleteDialog />
    { path: '~/user-module/components', pathPrefix: false },

    // ~/components/special-components/Btn.vue => <SpecialBtn />
    { path: '~/components/special-components', prefix: 'Special' },

    // It's important that this comes last if you have overrides you wish to apply
    // to sub-directories of `~/components`.
    //
    // ~/components/Btn.vue => <Btn />
    // ~/components/base/Btn.vue => <BaseBtn />
    '~/components'
  ]
})
```

::note
Any nested directories need to be added first as they are scanned in order.
::

## npm Packages

If you want to auto-import components from an npm package, you can use [`addComponent`](https://nuxt.com/docs/api/kit/components#addcomponent) in a [local module](https://nuxt.com/docs/guide/directory-structure/modules) to register them.

::code-group
```ts [~/modules/register-component.ts] twoslash
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```

```vue [app/app.vue]
<template>
  <div>
    <!--  the component uses the name we specified and is auto-imported  -->
    <MyAutoImportedComponent />
  </div>
</template>
```
::

## Component Extensions

By default, any file with an extension specified in the [extensions key of `nuxt.config.ts`](https://nuxt.com/docs/api/nuxt-config#extensions) is treated as a component.
If you need to restrict the file extensions that should be registered as components, you can use the extended form of the components directory declaration and its `extensions` key:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      extensions: ['.vue'], // [!code ++]
    }
  ]
})
```

## Client Components

If a component is meant to be rendered only client-side, you can add the `.client` suffix to your component.

```bash [Directory Structure]
| components/
--| Comments.client.vue
```

```vue [app/pages/example.vue]
<template>
  <div>
    <!-- this component will only be rendered on client side -->
    <Comments />
  </div>
</template>
```

::note
This feature only works with Nuxt auto-imports and `#components` imports. Explicitly importing these components from their real paths does not convert them into client-only components.
::

::important
`.client` components are rendered only after being mounted. To access the rendered template using `onMounted()`, add `await nextTick()` in the callback of the `onMounted()` hook.
::

::read-more{to="https://nuxt.com/docs/api/components/client-only"}
You can also achieve a similar result with the `<ClientOnly>` component.
::

## Server Components

Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.

Server components can either be used on their own or paired with a [client component](https://nuxt.com/#paired-with-a-client-component).

::video-accordion
---
title: Watch Learn Vue video about Nuxt Server Components
video-id: u1yyXe86xJM
---
::

::tip
---
icon: i-lucide-newspaper
target: _blank
to: https://roe.dev/blog/nuxt-server-components
---
Read Daniel Roe's guide to Nuxt Server Components.
::

### Standalone server components

Standalone server components will always be rendered on the server, also known as Islands components.

When their props update, this will result in a network request that will update the rendered HTML in-place.

Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your nuxt.config:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    componentIslands: true
  }
})
```

Now you can register server-only components with the `.server` suffix and use them anywhere in your application automatically.

```bash [Directory Structure]
-| components/
---| HighlightedMarkdown.server.vue
```

```vue [app/pages/example.vue]
<template>
  <div>
    <!--
      this will automatically be rendered on the server, meaning your markdown parsing + highlighting
      libraries are not included in your client bundle.
     -->
    <HighlightedMarkdown markdown="# Headline" />
  </div>
</template>
```

Server-only components use [`<NuxtIsland>`](https://nuxt.com/docs/api/components/nuxt-island) under the hood, meaning that `lazy` prop and `#fallback` slot are both passed down to it.

::warning
Server components (and islands) must have a single root element. (HTML comments are considered elements as well.)
::

::warning
Props are passed to server components via URL query parameters, and are therefore limited by the possible length of a URL, so be careful not to pass enormous amounts of data to server components via props.
::

::warning
Be careful when nesting islands within other islands as each island adds some extra overhead.
::

::warning
Most features for server-only components and island components, such as slots and client components, are only available for single file components.
::

#### Client components within server components

::note
This feature needs `experimental.componentIslands.selectiveClient` within your configuration to be true.
::

You can partially hydrate a component by setting a `nuxt-client` attribute on the component you wish to be loaded client-side.

```vue [app/components/ServerWithClient.vue]
<template>
  <div>
    <HighlightedMarkdown markdown="# Headline" />
    <!-- Counter will be loaded and hydrated client-side -->
    <Counter nuxt-client :count="5" />
  </div>
</template>
```

::note
This only works within a server component. Slots for client components are working only with `experimental.componentIsland.selectiveClient` set to `'deep'` and since they are rendered server-side, they are not interactive once client-side.
::

#### Server Component Context

When rendering a server-only or island component, `<NuxtIsland>` makes a fetch request which comes back with a `NuxtIslandResponse`. (This is an internal request if rendered on the server, or a request that you can see in the network tab if it's rendering on client-side navigation.)

This means:

- A new Vue app will be created server-side to create the `NuxtIslandResponse`.
- A new 'island context' will be created while rendering the component.
- You can't access the 'island context' from the rest of your app and you can't access the context of the rest of your app from the island component. In other words, the server component or island is *isolated* from the rest of your app.
- Your plugins will run again when rendering the island, unless they have `env: { islands: false }` set (which you can do in an object-syntax plugin).

Within an island component, you can access its island context through `nuxtApp.ssrContext.islandContext`. Note that while island components are still marked as experimental, the format of this context may change.

::note
Slots can be interactive and are wrapped within a `<div>` with `display: contents;`
::

### Paired with a Client component

In this case, the `.server` + `.client` components are two 'halves' of a component and can be used in advanced use cases for separate implementations of a component on server and client side.

```bash [Directory Structure]
-| components/
---| Comments.client.vue
---| Comments.server.vue
```

```vue [app/pages/example.vue]
<template>
  <div>
    <!-- this component will render Comments.server on the server then Comments.client once mounted in the browser -->
    <Comments />
  </div>
</template>
```

## Built-In Nuxt Components

There are a number of components that Nuxt provides, including `<ClientOnly>` and `<DevOnly>`. You can read more about them in the API documentation.

::read-more{to="https://nuxt.com/docs/api"}
::

## Library Authors

Making Vue component libraries with automatic tree-shaking and component registration is super easy. ✨

You can use the [`addComponentsDir`](https://nuxt.com/docs/api/kit/components#addcomponentsdir) method provided from the `@nuxt/kit` to register your components directory in your Nuxt module.

Imagine a directory structure like this:

```bash [Directory Structure]
-| node_modules/
---| awesome-ui/
-----| components/
-------| Alert.vue
-------| Button.vue
-----| nuxt.ts
-| pages/
---| index.vue
-| nuxt.config.ts
```

Then in `awesome-ui/nuxt.ts` you can use the `addComponentsDir` hook:

```ts twoslash
import { createResolver, defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const resolver = createResolver(import.meta.url)

    // Add ./components dir to the list
    addComponentsDir({
      path: resolver.resolve('./components'),
      prefix: 'awesome',
    })
  },
})
```

That's it! Now in your project, you can import your UI library as a Nuxt module in your `nuxt.config` file:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  modules: ['awesome-ui/nuxt']
})
```

... and directly use the module components (prefixed with `awesome-`) in our `app/pages/index.vue`:

```vue
<template>
  <div>
    My <AwesomeButton>UI button</AwesomeButton>!
    <awesome-alert>Here's an alert!</awesome-alert>
  </div>
</template>
```

It will automatically import the components only if used and also support HMR when updating your components in `node_modules/awesome-ui/components/`.

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::


# composables

## Usage

**Method 1:** Using named export

```js [app/composables/useFoo.ts]
export const useFoo = () => {
  return useState('foo', () => 'bar')
}
```

**Method 2:** Using default export

```js [app/composables/use-foo.ts or composables/useFoo.ts]
// It will be available as useFoo() (camelCase of file name without extension)
export default function () {
  return useState('foo', () => 'bar')
}
```

**Usage:** You can now use auto imported composable in `.js`, `.ts` and `.vue` files

```vue [app/app.vue]
<script setup lang="ts">
const foo = useFoo()
</script>

<template>
  <div>
    {{ foo }}
  </div>
</template>
```

::note
The `app/composables/` directory in Nuxt does not provide any additional reactivity capabilities to your code. Instead, any reactivity within composables is achieved using Vue's Composition API mechanisms, such as ref and reactive. Note that reactive code is also not limited to the boundaries of the `app/composables/` directory. You are free to employ reactivity features wherever they're needed in your application.
::

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

## Types

Under the hood, Nuxt auto generates the file `.nuxt/imports.d.ts` to declare the types.

Be aware that you have to run [`nuxt prepare`](https://nuxt.com/docs/api/commands/prepare), [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) or [`nuxt build`](https://nuxt.com/docs/api/commands/build) in order to let Nuxt generate the types.

::note
If you create a composable without having the dev server running, TypeScript will throw an error, such as `Cannot find name 'useBar'.`
::

## Examples

### Nested Composables

You can use a composable within another composable using auto imports:

```js [app/composables/test.ts]
export const useFoo = () => {
  const nuxtApp = useNuxtApp()
  const bar = useBar()
}
```

### Access plugin injections

You can access [plugin injections](https://nuxt.com/docs/guide/directory-structure/plugins#providing-helpers) from composables:

```js [app/composables/test.ts]
export const useHello = () => {
  const nuxtApp = useNuxtApp()
  return nuxtApp.$hello
}
```

## How Files Are Scanned

Nuxt only scans files at the top level of the [`app/composables/` directory](https://nuxt.com/docs/guide/directory-structure/app/composables), e.g.:

```bash [Directory Structure]
-| composables/
---| index.ts     // scanned
---| useFoo.ts    // scanned
---| nested/
-----| utils.ts   // not scanned
```

Only `app/composables/index.ts` and `app/composables/useFoo.ts` would be searched for imports.

To get auto imports working for nested modules, you could either re-export them (recommended) or configure the scanner to include nested directories:

**Example:** Re-export the composables you need from the `app/composables/index.ts` file:

```ts [app/composables/index.ts]
// Enables auto import for this export
export { utils } from './nested/utils.ts'
```

**Example:** Scan nested directories inside the `app/composables/` folder:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  imports: {
    dirs: [
      // Scan top-level composables
      '~/composables',
      // ... or scan composables nested one level deep with a specific name and file extension
      '~/composables/*/index.{ts,js,mjs,mts}',
      // ... or scan all composables within given directory
      '~/composables/**'
    ]
  }
})
```


# layouts

::tip{icon="i-lucide-rocket"}
For best performance, components placed in this directory will be automatically loaded via asynchronous import when used.
::

## Enable Layouts

Layouts are enabled by adding [`<NuxtLayout>`](https://nuxt.com/docs/api/components/nuxt-layout) to your [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app):

```vue [app/app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

To use a layout:

- Set a `layout` property in your page with [definePageMeta](https://nuxt.com/docs/api/utils/define-page-meta).
- Set the `name` prop of `<NuxtLayout>`.

::note
The layout name is normalized to kebab-case, so `someLayout` becomes `some-layout`.
::

::note
If no layout is specified, `app/layouts/default.vue` will be used.
::

::important
If you only have a single layout in your application, we recommend using [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) instead.
::

::important
Unlike other components, your layouts must have a single root element to allow Nuxt to apply transitions between layout changes - and this root element cannot be a `<slot />`.
::

## Default Layout

Add a `~/layouts/default.vue`:

```vue [app/layouts/default.vue]
<template>
  <div>
    <p>Some default layout content shared across all pages</p>
    <slot />
  </div>
</template>
```

In a layout file, the content of the page will be displayed in the `<slot />` component.

## Named Layout

```bash [Directory Structure]
-| layouts/
---| default.vue
---| custom.vue
```

Then you can use the `custom` layout in your page:

```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  layout: 'custom'
})
</script>
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/pages#page-metadata
---
Learn more about `definePageMeta`.
::

You can directly override the default layout for all pages using the `name` property of [`<NuxtLayout>`](https://nuxt.com/docs/api/components/nuxt-layout):

```vue [app/app.vue]
<script setup lang="ts">
// You might choose this based on an API call or logged-in status
const layout = "custom";
</script>

<template>
  <NuxtLayout :name="layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

If you have a layout in nested directories, the layout's name will be based on its own path directory and filename, with duplicate segments being removed.

| File                              | Layout Name       |
| --------------------------------- | ----------------- |
| `~/layouts/desktop/default.vue`   | `desktop-default` |
| `~/layouts/desktop-base/base.vue` | `desktop-base`    |
| `~/layouts/desktop/index.vue`     | `desktop`         |

For clarity, we recommend that the layout's filename matches its name:

| File                                     | Layout Name       |
| ---------------------------------------- | ----------------- |
| `~/layouts/desktop/DesktopDefault.vue`   | `desktop-default` |
| `~/layouts/desktop-base/DesktopBase.vue` | `desktop-base`    |
| `~/layouts/desktop/Desktop.vue`          | `desktop`         |

::link-example{to="https://nuxt.com/docs/examples/features/layouts"}
::

## Changing the Layout Dynamically

You can also use the [`setPageLayout`](https://nuxt.com/docs/api/utils/set-page-layout) helper to change the layout dynamically:

```vue twoslash
<script setup lang="ts">
function enableCustomLayout () {
  setPageLayout('custom')
}
definePageMeta({
  layout: false,
});
</script>

<template>
  <div>
    <button @click="enableCustomLayout">Update layout</button>
  </div>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/features/layouts"}
::

## Overriding a Layout on a Per-page Basis

If you are using pages, you can take full control by setting `layout: false` and then using the `<NuxtLayout>` component within the page.

::code-group
```vue [app/pages/index.vue]
<script setup lang="ts">
definePageMeta({
  layout: false,
})
</script>

<template>
  <div>
    <NuxtLayout name="custom">
      <template #header> Some header template content. </template>

      The rest of the page
    </NuxtLayout>
  </div>
</template>
```

```vue [app/layouts/custom.vue]
<template>
  <div>
    <header>
      <slot name="header">
        Default header content
      </slot>
    </header>
    <main>
      <slot />
    </main>
  </div>
</template>
```
::

::important
If you use `<NuxtLayout>` within your pages, make sure it is not the root element (or [disable layout/page transitions](https://nuxt.com/docs/getting-started/transitions#disable-transitions)).
::


# middleware

Nuxt provides a customizable **route middleware** framework you can use throughout your application, ideal for extracting code that you want to run before navigating to a particular route.

There are three kinds of route middleware:

1. Anonymous (or inline) route middleware are defined directly within the page.
2. Named route middleware, placed in the `app/middleware/` and automatically loaded via asynchronous import when used on a page.
3. Global route middleware, placed in the `app/middleware/` with a `.global` suffix and is run on every route change.

The first two kinds of route middleware can be defined in [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta).

::note
Name of middleware are normalized to kebab-case: `myMiddleware` becomes `my-middleware`.
::

::note
Route middleware run within the Vue part of your Nuxt app. Despite the similar name, they are completely different from [server middleware](https://nuxt.com/docs/guide/directory-structure/server#server-middleware), which are run in the Nitro server part of your app.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on all 3 kinds of middleware
video-id: "761471577"
---
::

## Usage

Route middleware are navigation guards that receive the current route and the next route as arguments.

```ts [middleware/my-middleware.ts] twoslash
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.params.id === '1') {
    return abortNavigation()
  }
  // In a real app you would probably not redirect every route to `/`
  // however it is important to check `to.path` before redirecting or you
  // might get an infinite redirect loop
  if (to.path !== '/') {
    return navigateTo('/')
  }
})
```

Nuxt provides two globally available helpers that can be returned directly from the middleware.

1. [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) - Redirects to the given route
2. [`abortNavigation`](https://nuxt.com/docs/api/utils/abort-navigation) - Aborts the navigation, with an optional error message.

Unlike [navigation guards](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards){rel="nofollow"} from `vue-router`, a third `next()` argument is not passed, and **redirect or route cancellation is handled by returning a value from the middleware**.

Possible return values are:

- nothing (a simple `return` or no return at all) - does not block navigation and will move to the next middleware function, if any, or complete the route navigation
- `return navigateTo('/')` - redirects to the given path and will set the redirect code to [`302` Found](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302){rel="nofollow"} if the redirect happens on the server side
- `return navigateTo('/', { redirectCode: 301 })` - redirects to the given path and will set the redirect code to [`301` Moved Permanently](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301){rel="nofollow"} if the redirect happens on the server side
- `return abortNavigation()` - stops the current navigation
- `return abortNavigation(error)` - rejects the current navigation with an error

::read-more{to="https://nuxt.com/docs/api/utils/navigate-to"}
::

::read-more{to="https://nuxt.com/docs/api/utils/abort-navigation"}
::

::important
We recommend using the helper functions above for performing redirects or stopping navigation. Other possible return values described in [the vue-router docs](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards){rel="nofollow"} may work but there may be breaking changes in future.
::

## Middleware Order

Middleware runs in the following order:

1. Global Middleware
2. Page defined middleware order (if there are multiple middleware declared with the array syntax)

For example, assuming you have the following middleware and component:

```bash [app/middleware/ directory]
-| middleware/
---| analytics.global.ts
---| setup.global.ts
---| auth.ts
```

```vue [pages/profile.vue] twoslash
<script setup lang="ts">
definePageMeta({
  middleware: [
    function (to, from) {
      // Custom inline middleware
    },
    'auth',
  ],
});
</script>
```

You can expect the middleware to be run in the following order:

1. `analytics.global.ts`
2. `setup.global.ts`
3. Custom inline middleware
4. `auth.ts`

### Ordering Global Middleware

By default, global middleware is executed alphabetically based on the filename.

However, there may be times you want to define a specific order. For example, in the last scenario, `setup.global.ts` may need to run before `analytics.global.ts`. In that case, we recommend prefixing global middleware with 'alphabetical' numbering.

```bash [Directory structure]
-| middleware/
---| 01.setup.global.ts
---| 02.analytics.global.ts
---| auth.ts
```

::note
In case you're new to 'alphabetical' numbering, remember that filenames are sorted as strings, not as numeric values. For example, `10.new.global.ts` would come before `2.new.global.ts`. This is why the example prefixes single digit numbers with `0`.
::

## When Middleware Runs

If your site is server-rendered or generated, middleware for the initial page will be executed both when the page is rendered and then again on the client. This might be needed if your middleware needs a browser environment, such as if you have a generated site, aggressively cache responses, or want to read a value from local storage.

However, if you want to avoid this behaviour you can do so:

```ts [middleware/example.ts] twoslash
export default defineNuxtRouteMiddleware(to => {
  // skip middleware on server
  if (import.meta.server) return
  // skip middleware on client side entirely
  if (import.meta.client) return
  // or only skip middleware on initial client load
  const nuxtApp = useNuxtApp()
  if (import.meta.client && nuxtApp.isHydrating && nuxtApp.payload.serverRendered) return
})
```

This is true even if you throw an error in your middleware on the server, and an error page is rendered. The middleware will still run again in the browser.

::note
Rendering an error page is an entirely separate page load, meaning any registered middleware will run again. You can use [`useError`](https://nuxt.com/docs/getting-started/error-handling#useerror) in middleware to check if an error is being handled.
::

## Accessing Route in Middleware

Always use the `to` and `from` parameters in your middleware to access the next and previous routes. Avoid using the [`useRoute()`](https://nuxt.com/docs/api/composables/use-route) composable in this context altogether.
There is **no concept of a "current route" in middleware**, as middleware can abort a navigation or redirect to a different route. The `useRoute()` composable will always be inaccurate in this context.

::warning
Sometimes, you might call a composable that uses `useRoute()` internally, which can trigger this warning even if there is no direct call in your middleware.
This leads to the **same issue as above**, so you should structure your functions to accept the route as an argument instead when they are used in middleware.
::

::code-group
```ts [middleware/access-route.ts] twoslash
// @errors: 2304
export default defineNuxtRouteMiddleware(to => {
  // passing the route to the function to avoid calling `useRoute()` in middleware
  doSomethingWithRoute(to)
    
  // ❌ this will output a warning and is NOT recommended
  callsRouteInternally()
})
```

```ts [utils/handle-route.ts] twoslash
// providing the route as an argument so that it can be used in middleware correctly
export function doSomethingWithRoute(route = useRoute()) {
  // ...
}
```

```ts [utils/dont-do-this.ts] twoslash
// ❌ this function is not suitable for use in middleware
export function callsRouteInternally() {
    const route = useRoute()
  // ...
}
```
::

## Adding Middleware Dynamically

It is possible to add global or named route middleware manually using the [`addRouteMiddleware()`](https://nuxt.com/docs/api/utils/add-route-middleware) helper function, such as from within a plugin.

```ts twoslash
export default defineNuxtPlugin(() => {
  addRouteMiddleware('global-test', () => {
    console.log('this global middleware was added in a plugin and will be run on every route change')
  }, { global: true })

  addRouteMiddleware('named-test', () => {
    console.log('this named middleware was added in a plugin and would override any existing middleware of the same name')
  })
})
```

## Example

```bash [Directory Structure]
-| middleware/
---| auth.ts
```

In your page file, you can reference this route middleware:

```vue twoslash
<script setup lang="ts">
definePageMeta({
  middleware: ["auth"]
  // or middleware: 'auth'
})
</script>
```

Now, before navigation to that page can complete, the `auth` route middleware will be run.

::link-example{to="https://nuxt.com/docs/examples/routing/middleware"}
::

## Setting Middleware at Build Time

Instead of using `definePageMeta` on each page, you can add named route middleware within the `pages:extend` hook.

```ts [nuxt.config.ts] twoslash
import type { NuxtPage } from 'nuxt/schema'

export default defineNuxtConfig({
  hooks: {
    'pages:extend' (pages) {
      function setMiddleware (pages: NuxtPage[]) {
        for (const page of pages) {
          if (/* some condition */ true) {
            page.meta ||= {}
            // Note that this will override any middleware set in `definePageMeta` in the page
            page.meta.middleware = ['named']
          }
          if (page.children) {
            setMiddleware(page.children)
          }
        }
      }
      setMiddleware(pages)
    }
  }
})
```


# pages

::note
To reduce your application's bundle size, this directory is **optional**, meaning that [`vue-router`](https://router.vuejs.org){rel="nofollow"} won't be included if you only use [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app). To force the pages system, set `pages: true` in `nuxt.config` or have a [`router.options.ts`](https://nuxt.com/docs/guide/recipes/custom-routing#using-approuteroptions).
::

## Usage

Pages are Vue components and can have any [valid extension](https://nuxt.com/docs/api/configuration/nuxt-config#extensions) that Nuxt supports (by default `.vue`, `.js`, `.jsx`, `.mjs`, `.ts` or `.tsx`).

Nuxt will automatically create a route for every page in your `~/pages/` directory.

::code-group
```vue [app/pages/index.vue]
<template>
  <h1>Index page</h1>
</template>
```

```ts [pages/index.ts] twoslash
// https://vuejs.org/guide/extras/render-function.html
export default defineComponent({
  render () {
    return h('h1', 'Index page')
  }
})
```

```tsx [pages/index.tsx] twoslash
// https://nuxt.com/docs/examples/advanced/jsx
// https://vuejs.org/guide/extras/render-function.html#jsx-tsx
export default defineComponent({
  render () {
    return <h1>Index page</h1>
  }
})
```
::

The `app/pages/index.vue` file will be mapped to the `/` route of your application.

If you are using [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app), make sure to use the [`<NuxtPage/>`](https://nuxt.com/docs/api/components/nuxt-page) component to display the current page:

```vue [app/app.vue]
<template>
  <div>
    <!-- Markup shared across all pages, ex: NavBar -->
    <NuxtPage />
  </div>
</template>
```

Pages **must have a single root element** to allow [route transitions](https://nuxt.com/docs/getting-started/transitions) between pages. HTML comments are considered elements as well.

This means that when the route is server-rendered, or statically generated, you will be able to see its contents correctly, but when you navigate towards that route during client-side navigation the transition between routes will fail and you'll see that the route will not be rendered.

Here are some examples to illustrate what a page with a single root element looks like:

::code-group
```vue [app/pages/working.vue]
<template>
  <div>
    <!-- This page correctly has only one single root element -->
    Page content
  </div>
</template>
```

```vue [app/pages/bad-1.vue]
<template>
  <!-- This page will not render when route changes during client side navigation, because of this comment -->
  <div>Page content</div>
</template>
```

```vue [app/pages/bad-2.vue]
<template>
  <div>This page</div>
  <div>Has more than one root element</div>
  <div>And will not render when route changes during client side navigation</div>
</template>
```
::

## Dynamic Routes

If you place anything within square brackets, it will be turned into a [dynamic route](https://router.vuejs.org/guide/essentials/dynamic-matching.html){rel="nofollow"} parameter. You can mix and match multiple parameters and even non-dynamic text within a file name or directory.

If you want a parameter to be *optional*, you must enclose it in double square brackets - for example, `~/pages/[[slug]]/index.vue` or `~/pages/[[slug]].vue` will match both `/` and `/test`.

```bash [Directory Structure]
-| pages/
---| index.vue
---| users-[group]/
-----| [id].vue
```

Given the example above, you can access group/id within your component via the `$route` object:

```vue [app/pages/users-[group\\]/[id\\].vue]
<template>
  <p>{{ $route.params.group }} - {{ $route.params.id }}</p>
</template>
```

Navigating to `/users-admins/123` would render:

```html
<p>admins - 123</p>
```

If you want to access the route using Composition API, there is a global [`useRoute`](https://nuxt.com/docs/api/composables/use-route) function that will allow you to access the route just like `this.$route` in the Options API.

```vue twoslash
<script setup lang="ts">
const route = useRoute()

if (route.params.group === 'admins' && !route.params.id) {
  console.log('Warning! Make sure user is authenticated!')
}
</script>
```

::note
Named parent routes will take priority over nested dynamic routes. For the `/foo/hello` route, `~/pages/foo.vue` will take priority over `~/pages/foo/[slug].vue`. :br Use `~/pages/foo/index.vue` and `~/pages/foo/[slug].vue` to match `/foo` and `/foo/hello` with different pages,.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on dynamic routes
video-id: "754465699"
---
::

## Catch-all Route

If you need a catch-all route, you create it by using a file named like `[...slug].vue`. This will match *all* routes under that path.

```vue [app/pages/[...slug\\].vue]
<template>
  <p>{{ $route.params.slug }}</p>
</template>
```

Navigating to `/hello/world` would render:

```html
<p>["hello", "world"]</p>
```

## Nested Routes

It is possible to display [nested routes](https://next.router.vuejs.org/guide/essentials/nested-routes.html){rel="nofollow"} with `<NuxtPage>`.

Example:

```bash [Directory Structure]
-| pages/
---| parent/
-----| child.vue
---| parent.vue
```

This file tree will generate these routes:

```js
[
  {
    path: '/parent',
    component: '~/pages/parent.vue',
    name: 'parent',
    children: [
      {
        path: 'child',
        component: '~/pages/parent/child.vue',
        name: 'parent-child'
      }
    ]
  }
]
```

To display the `child.vue` component, you have to insert the `<NuxtPage>` component inside `app/pages/parent.vue`:

```vue [pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :foobar="123" />
  </div>
</template>
```

```vue [pages/parent/child.vue]
<script setup lang="ts">
const props = defineProps(['foobar'])

console.log(props.foobar)
</script>
```

### Child Route Keys

If you want more control over when the `<NuxtPage>` component is re-rendered (for example, for transitions), you can either pass a string or function via the `pageKey` prop, or you can define a `key` value via `definePageMeta`:

```vue [pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :page-key="route => route.fullPath" />
  </div>
</template>
```

Or alternatively:

```vue [pages/parent/child.vue] twoslash
<script setup lang="ts">
definePageMeta({
  key: route => route.fullPath
})
</script>
```

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::

## Route Groups

In some cases, you may want to group a set of routes together in a way which doesn't affect file-based routing. For this purpose, you can put files in a folder which is wrapped in parentheses - `(` and `)`.

For example:

```bash [Directory structure]
-| pages/
---| index.vue
---| (marketing)/
-----| about.vue
-----| contact.vue
```

This will produce `/`, `/about` and `/contact` pages in your app. The `marketing` group is ignored for purposes of your URL structure.

## Page Metadata

You might want to define metadata for each route in your app. You can do this using the `definePageMeta` macro, which will work both in `<script>` and in `<script setup>`:

```vue twoslash
<script setup lang="ts">
definePageMeta({
  title: 'My home page'
})
</script>
```

This data can then be accessed throughout the rest of your app from the `route.meta` object.

```vue twoslash
<script setup lang="ts">
const route = useRoute()

console.log(route.meta.title) // My home page
</script>
```

If you are using nested routes, the page metadata from all these routes will be merged into a single object. For more on route meta, see the [vue-router docs](https://router.vuejs.org/guide/advanced/meta.html#route-meta-fields){rel="nofollow"}.

Much like `defineEmits` or `defineProps` (see [Vue docs](https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits){rel="nofollow"}), `definePageMeta` is a **compiler macro**. It will be compiled away so you cannot reference it within your component. Instead, the metadata passed to it will be hoisted out of the component.
Therefore, the page meta object cannot reference the component. However, it can reference imported bindings, as well as locally defined **pure functions**.

::warning
Make sure not to reference any reactive data or functions that cause side effects. This can lead to unexpected behavior.
::

```vue
<script setup lang="ts">
import { someData } from '~/utils/example'

function validateIdParam(route) {
  return route.params.id && !isNaN(Number(route.params.id))
}

const title = ref('')

definePageMeta({
  validate: validateIdParam,
  someData,
  title,    // do not do this, the ref will be hoisted out of the component
})
</script>
```

### Special Metadata

Of course, you are welcome to define metadata for your own use throughout your app. But some metadata defined with `definePageMeta` has a particular purpose:

#### `alias`

You can define page aliases. They allow you to access the same page from different paths. It can be either a string or an array of strings as defined [in the vue-router documentation](https://router.vuejs.org/guide/essentials/redirect-and-alias.html#Alias){rel="nofollow"}.

#### `keepalive`

Nuxt will automatically wrap your page in [the Vue `<KeepAlive>` component](https://vuejs.org/guide/built-ins/keep-alive.html#keepalive){rel="nofollow"} if you set `keepalive: true` in your `definePageMeta`. This might be useful to do, for example, in a parent route that has dynamic child routes, if you want to preserve page state across route changes.

When your goal is to preserve state for parent routes use this syntax: `<NuxtPage keepalive />`. You can also set props to be passed to `<KeepAlive>` (see [a full list](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"}).

You can set a default value for this property [in your `nuxt.config`](https://nuxt.com/docs/api/nuxt-config#keepalive).

#### `key`

[See above](https://nuxt.com/#child-route-keys).

#### `layout`

You can define the layout used to render the route. This can be either false (to disable any layout), a string or a ref/computed, if you want to make it reactive in some way. [More about layouts](https://nuxt.com/docs/guide/directory-structure/app/layouts).

#### `layoutTransition` and `pageTransition`

You can define transition properties for the `<transition>` component that wraps your pages and layouts, or pass `false` to disable the `<transition>` wrapper for that route. You can see [a list of options that can be passed](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"} or read [more about how transitions work](https://vuejs.org/guide/built-ins/transition.html#transition){rel="nofollow"}.

You can set default values for these properties [in your `nuxt.config`](https://nuxt.com/docs/api/nuxt-config#layouttransition).

#### `middleware`

You can define middleware to apply before loading this page. It will be merged with all the other middleware used in any matching parent/child routes. It can be a string, a function (an anonymous/inlined middleware function following [the global before guard pattern](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards){rel="nofollow"}), or an array of strings/functions. [More about named middleware](https://nuxt.com/docs/guide/directory-structure/app/middleware).

#### `name`

You may define a name for this page's route.

#### `path`

You may define a path matcher, if you have a more complex pattern than can be expressed with the file name. See [the `vue-router` docs](https://router.vuejs.org/guide/essentials/route-matching-syntax.html#custom-regex-in-params){rel="nofollow"} for more information.

#### `props`

Allows accessing the route `params` as props passed to the page component. See [the `vue-router` docs](https://router.vuejs.org/guide/essentials/passing-props){rel="nofollow"} for more information.

### Typing Custom Metadata

If you add custom metadata for your pages, you may wish to do so in a type-safe way. It is possible to augment the type of the object accepted by `definePageMeta`:

```ts [index.d.ts]
declare module '#app' {
  interface PageMeta {
    pageType?: string
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

## Navigation

To navigate between pages of your app, you should use the [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link) component.

This component is included with Nuxt and therefore you don't have to import it as you do with other components.

A simple link to the `index.vue` page in your `app/pages` folder:

```vue
<template>
  <NuxtLink to="/">Home page</NuxtLink>
</template>
```

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
Learn more about `<NuxtLink>` usage.
::

## Programmatic Navigation

Nuxt allows programmatic navigation through the `navigateTo()` utility method. Using this utility method, you will be able to programmatically navigate the user in your app. This is great for taking input from the user and navigating them dynamically throughout your application. In this example, we have a simple method called `navigate()` that gets called when the user submits a search form.

::note
Make sure to always `await` on `navigateTo` or chain its result by returning from functions.
::

```vue twoslash
<script setup lang="ts">
const name = ref('');
const type = ref(1);

function navigate(){
  return navigateTo({
    path: '/search',
    query: {
      name: name.value,
      type: type.value
    }
  })
}
</script>
```

## Client-Only Pages

You can define a page as [client only](https://nuxt.com/docs/guide/directory-structure/app/components#client-components) by giving it a `.client.vue` suffix. None of the content of this page will be rendered on the server.

## Server-Only Pages

You can define a page as [server only](https://nuxt.com/docs/guide/directory-structure/app/components#server-components) by giving it a `.server.vue` suffix. While you will be able to navigate to the page using client-side navigation, controlled by `vue-router`, it will be rendered with a server component automatically, meaning the code required to render the page will not be in your client-side bundle.

::warning
Server-only pages must have a single root element. (HTML comments are considered elements as well.)
::

## Custom Routing

As your app gets bigger and more complex, your routing might require more flexibility. For this reason, Nuxt directly exposes the router, routes and router options for customization in different ways.

::read-more{to="https://nuxt.com/docs/guide/recipes/custom-routing"}
::

## Multiple Pages Directories

By default, all your pages should be in one `app/pages` directory at the root of your project.

However, you can use [Nuxt Layers](https://nuxt.com/docs/getting-started/layers) to create groupings of your app's pages:

```bash [Directory Structure]
-| some-app/
---| nuxt.config.ts
---| pages/
-----| app-page.vue
-| nuxt.config.ts
```

```ts [some-app/nuxt.config.ts] twoslash
// some-app/nuxt.config.ts
export default defineNuxtConfig({
})
```

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  extends: ['./some-app'],
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/layers"}
::


# plugins

Nuxt automatically reads the files in the `app/plugins/` directory and loads them at the creation of the Vue application.

::note
All plugins inside are auto-registered, you don't need to add them to your `nuxt.config` separately.
::

::note
You can use `.server` or `.client` suffix in the file name to load a plugin only on the server or client side.
::

## Registered Plugins

Only files at the top level of the directory (or index files within any subdirectories) will be auto-registered as plugins.

```bash [Directory structure]
-| plugins/
---| foo.ts      // scanned
---| bar/
-----| baz.ts    // not scanned
-----| foz.vue   // not scanned
-----| index.ts  // currently scanned but deprecated
```

Only `foo.ts` and `bar/index.ts` would be registered.

To add plugins in subdirectories, you can use the [`app/plugins`](https://nuxt.com/docs/api/nuxt-config#plugins-1) option in `nuxt.config.ts`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  plugins: [
    '~/plugins/bar/baz',
    '~/plugins/bar/foz'
  ]
})
```

## Creating Plugins

The only argument passed to a plugin is [`nuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app).

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin(nuxtApp => {
  // Doing something with nuxtApp
})
```

### Object Syntax Plugins

It is also possible to define a plugin using an object syntax, for more advanced use cases. For example:

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin({
  name: 'my-plugin',
  enforce: 'pre', // or 'post'
  async setup (nuxtApp) {
    // this is the equivalent of a normal functional plugin
  },
  hooks: {
    // You can directly register Nuxt app runtime hooks here
    'app:created'() {
      const nuxtApp = useNuxtApp()
      // do something in the hook
    }
  },
  env: {
    // Set this value to `false` if you don't want the plugin to run when rendering server-only or island components.
    islands: true
  }
})
```

::video-accordion
---
title: Watch a video from Alexander Lichter about the Object Syntax for Nuxt plugins
video-id: 2aXZyXB1QGQ
---
::

::note
If you are using the object-syntax, the properties are statically analyzed to produce a more optimized build. So you should not define them at runtime. :br
For example, setting `enforce: import.meta.server ? 'pre' : 'post'` would defeat any future optimization Nuxt is able to do for your plugins.
Nuxt does statically pre-load any hook listeners when using object-syntax, allowing you to define hooks without needing to worry about order of plugin registration.
::

## Registration Order

You can control the order in which plugins are registered by prefixing with 'alphabetical' numbering to the file names.

```bash [Directory structure]
plugins/
 | - 01.myPlugin.ts
 | - 02.myOtherPlugin.ts
```

In this example, `02.myOtherPlugin.ts` will be able to access anything that was injected by `01.myPlugin.ts`.

This is useful in situations where you have a plugin that depends on another plugin.

::note
In case you're new to 'alphabetical' numbering, remember that filenames are sorted as strings, not as numeric values. For example, `10.myPlugin.ts` would come before `2.myOtherPlugin.ts`. This is why the example prefixes single digit numbers with `0`.
::

## Loading Strategy

### Parallel Plugins

By default, Nuxt loads plugins sequentially. You can define a plugin as `parallel` so Nuxt won't wait until the end of the plugin's execution before loading the next plugin.

```ts [plugins/my-plugin.ts] twoslash
export default defineNuxtPlugin({
  name: 'my-plugin',
  parallel: true,
  async setup (nuxtApp) {
    // the next plugin will be executed immediately
  }
})
```

### Plugins With Dependencies

If a plugin needs to wait for another plugin before it runs, you can add the plugin's name to the `dependsOn` array.

```ts [plugins/depending-on-my-plugin.ts] twoslash
export default defineNuxtPlugin({
  name: 'depends-on-my-plugin',
  dependsOn: ['my-plugin'],
  async setup (nuxtApp) {
    // this plugin will wait for the end of `my-plugin`'s execution before it runs
  }
})
```

## Using Composables

You can use [composables](https://nuxt.com/docs/guide/directory-structure/app/composables) as well as [utils](https://nuxt.com/docs/guide/directory-structure/app/utils) within Nuxt plugins:

```ts [app/plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const foo = useFoo()
})
```

However, keep in mind there are some limitations and differences:

::important
**If a composable depends on another plugin registered later, it might not work.** :br

Plugins are called in order sequentially and before everything else. You might use a composable that depends on another plugin which has not been called yet.
::

::important
**If a composable depends on the Vue.js lifecycle, it won't work.** :br

Normally, Vue.js composables are bound to the current component instance while plugins are only bound to [`nuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) instance.
::

## Providing Helpers

If you would like to provide a helper on the [`NuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) instance, return it from the plugin under a `provide` key.

::code-group
```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin(() => {
  return {
    provide: {
      hello: (msg: string) => `Hello ${msg}!`
    }
  }
})
```

```ts [plugins/hello-object-syntax.ts] twoslash
export default defineNuxtPlugin({
  name: 'hello',
  setup () {
    return {
      provide: {
        hello: (msg: string) => `Hello ${msg}!`
      }
    }
  }
})
```
::

You can then use the helper in your components:

```vue [app/components/Hello.vue]
<script setup lang="ts">
// alternatively, you can also use it here
const { $hello } = useNuxtApp()
</script>

<template>
  <div>
    {{ $hello('world') }}
  </div>
</template>
```

::important
Note that we highly recommend using [`composables`](https://nuxt.com/docs/guide/directory-structure/app/composables) instead of providing helpers to avoid polluting the global namespace and keep your main bundle entry small.
::

::warning
**If your plugin provides a `ref` or `computed`, it will not be unwrapped in a component `<template>`.** :br
This is due to how Vue works with refs that aren't top-level to the template. You can read more about it [in the Vue documentation](https://vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-when-unwrapping-in-templates){rel="nofollow"}.
::

## Typing Plugins

If you return your helpers from the plugin, they will be typed automatically; you'll find them typed for the return of `useNuxtApp()` and within your templates.

::note
If you need to use a provided helper *within* another plugin, you can call [`useNuxtApp()`](https://nuxt.com/docs/api/composables/use-nuxt-app) to get the typed version. But in general, this should be avoided unless you are certain of the plugins' order.
::

For advanced use-cases, you can declare the type of injected properties like this:

```ts [index.d.ts]
declare module '#app' {
  interface NuxtApp {
    $hello (msg: string): string
  }
}

declare module 'vue' {
  interface ComponentCustomProperties {
    $hello (msg: string): string
  }
}

export {}
```

::note
If you are using WebStorm, you may need to augment `@vue/runtime-core` until [this issue](https://youtrack.jetbrains.com/issue/WEB-59818/VUE-TypeScript-WS-PS-does-not-correctly-display-type-of-globally-injected-properties){rel="nofollow"} is resolved.
::

## Vue Plugins

If you want to use Vue plugins, like [vue-gtag](https://github.com/MatteoGabriele/vue-gtag){rel="nofollow"} to add Google Analytics tags, you can use a Nuxt plugin to do so.

First, install the Vue plugin dependency:

::code-group{sync="pm"}
```bash [npm]
npm install --save-dev vue-gtag-next
```

```bash [yarn]
yarn add --dev vue-gtag-next
```

```bash [pnpm]
pnpm add -D vue-gtag-next
```

```bash [bun]
bun add -D vue-gtag-next
```
::

Then create a plugin file:

```ts [app/plugins/vue-gtag.client.ts]
import VueGtag, { trackRouter } from 'vue-gtag-next'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(VueGtag, {
    property: {
      id: 'GA_MEASUREMENT_ID'
    }
  })
  trackRouter(useRouter())
})
```

## Vue Directives

Similarly, you can register a custom Vue directive in a plugin.

```ts [plugins/my-directive.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.directive('focus', {
    mounted (el) {
      el.focus()
    },
    getSSRProps (binding, vnode) {
      // you can provide SSR-specific props here
      return {}
    }
  })
})
```

::warning
If you register a Vue directive, you *must* register it on both client and server side unless you are only using it when rendering one side. If the directive only makes sense from a client side, you can always move it to `~/plugins/my-directive.client.ts` and provide a 'stub' directive for the server in `~/plugins/my-directive.server.ts`.
::

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Custom Directives on Vue Docs
to: https://vuejs.org/guide/reusability/custom-directives.html
---
::


# utils

The main purpose of the [`app/utils/` directory](https://nuxt.com/docs/guide/directory-structure/app/utils) is to allow a semantic distinction between your Vue composables and other auto-imported utility functions.

## Usage

**Method 1:** Using named export

```ts [utils/index.ts] twoslash
export const { format: formatNumber } = Intl.NumberFormat('en-GB', {
  notation: 'compact',
  maximumFractionDigits: 1
})
```

**Method 2:** Using default export

```ts [utils/random-entry.ts or utils/randomEntry.ts] twoslash
// It will be available as randomEntry() (camelCase of file name without extension)
export default function (arr: Array<any>) {
  return arr[Math.floor(Math.random() * arr.length)]
}
```

You can now use auto imported utility functions in `.js`, `.ts` and `.vue` files

```vue [app/app.vue]
<template>
  <p>{{ formatNumber(1234) }}</p>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

::tip
The way `app/utils/` auto-imports work and are scanned is identical to the [`app/composables/`](https://nuxt.com/docs/guide/directory-structure/app/composables) directory.
::

::important
These utils are only available within the Vue part of your app. :br
Only `server/utils` are auto-imported in the [`server/`](https://nuxt.com/docs/guide/directory-structure/server#server-utilities) directory.
::


# app.vue

::tip
If you have a `app/pages/` directory, the `app.vue` file is optional. Nuxt will automatically include a default `app.vue`, but you can still add your own to customize the structure and content as needed.
::

## Usage

### Minimal Usage

With Nuxt, the [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory is optional. If it is not present, Nuxt will not include the [vue-router](https://router.vuejs.org){rel="nofollow"} dependency. This is useful when building a landing page or an application that does not require routing.

```vue [app/app.vue]
<template>
  <h1>Hello World!</h1>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/hello-world"}
::

### Usage with Pages

When you have a [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory, you need to use the [`<NuxtPage>`](https://nuxt.com/docs/api/components/nuxt-page) component to display the current page:

```vue [app/app.vue]
<template>
  <NuxtPage />
</template>
```

You can also define the common structure of your application directly in `app.vue`. This is useful when you want to include global elements such as a header or footer:

```vue [app/app.vue]
<template>
  <header>
    Header content
  </header>
  <NuxtPage />
  <footer>
    Footer content
  </footer>
</template>
```

::note
Remember that `app.vue` acts as the main component of your Nuxt application. Anything you add to it (JS and CSS) will be global and included in every page.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/pages"}
Learn more about how to structure your pages using the `app/pages/` directory.
::

### Usage with Layouts

When your application requires different layouts for different pages, you can use the `app/layouts/` directory with the [`<NuxtLayout>`](https://nuxt.com/docs/api/components/nuxt-layout) component. This allows you to define multiple layouts and apply them per page.

```vue [app/app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/layouts"}
Learn more about how to structure your layouts using the `app/layouts/` directory.
::


# app.config.ts

Nuxt provides an `app.config` config file to expose reactive configuration within your application with the ability to update it at runtime within lifecycle or using a nuxt plugin and editing it with HMR (hot-module-replacement).

You can easily provide runtime app configuration using `app.config.ts` file. It can have either of `.ts`, `.js`, or `.mjs` extensions.

```ts [app.config.ts] twoslash
export default defineAppConfig({
  foo: 'bar'
})
```

::caution
Do not put any secret values inside `app.config` file. It is exposed to the user client bundle.
::

::note
When configuring a custom [`srcDir`](https://nuxt.com/docs/api/nuxt-config#srcdir), make sure to place the `app.config` file at the root of the new `srcDir` path.
::

## Usage

To expose config and environment variables to the rest of your app, you will need to define configuration in `app.config` file.

```ts [app.config.ts] twoslash
export default defineAppConfig({
  theme: {
    primaryColor: '#ababab'
  }
})
```

We can now universally access `theme` both when server-rendering the page and in the browser using [`useAppConfig`](https://nuxt.com/docs/api/composables/use-app-config) composable.

```vue [app/pages/index.vue]
<script setup lang="ts">
const appConfig = useAppConfig()

console.log(appConfig.theme)
</script>
```

The [`updateAppConfig`](https://nuxt.com/docs/api/utils/update-app-config) utility can be used to update the `app.config` at runtime.

```vue [app/pages/index.vue]
<script setup>
const appConfig = useAppConfig() // { foo: 'bar' }

const newAppConfig = { foo: 'baz' }

updateAppConfig(newAppConfig)

console.log(appConfig) // { foo: 'baz' }
</script>
```

::read-more{to="https://nuxt.com/docs/api/utils/update-app-config"}
Read more about the `updateAppConfig` utility.
::

## Typing App Config

Nuxt tries to automatically generate a TypeScript interface from provided app config so you won't have to type it yourself.

However, there are some cases where you might want to type it yourself. There are two possible things you might want to type.

### App Config Input

`AppConfigInput` might be used by module authors who are declaring what valid *input* options are when setting app config. This will not affect the type of `useAppConfig()`.

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface AppConfigInput {
    /** Theme configuration */
    theme?: {
      /** Primary app color */
      primaryColor?: string
    }
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

### App Config Output

If you want to type the result of calling [`useAppConfig()`](https://nuxt.com/docs/api/composables/use-app-config), then you will want to extend `AppConfig`.

::warning
Be careful when typing `AppConfig` as you will overwrite the types Nuxt infers from your actually defined app config.
::

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface AppConfig {
    // This will entirely replace the existing inferred `theme` property
    theme: {
      // You might want to type this value to add more specific types than Nuxt can infer,
      // such as string literal types
      primaryColor?: 'red' | 'blue'
    }
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

## Merging Strategy

Nuxt uses a custom merging strategy for the `AppConfig` within [the layers](https://nuxt.com/docs/getting-started/layers) of your application.

This strategy is implemented using a [Function Merger](https://github.com/unjs/defu#function-merger){rel="nofollow"}, which allows defining a custom merging strategy for every key in `app.config` that has an array as value.

::note
The function merger can only be used in the extended layers and not the main `app.config` in project.
::

Here's an example of how you can use:

::code-group
```ts [layer/app.config.ts] twoslash
export default defineAppConfig({
  // Default array value
  array: ['hello'],
})
```

```ts [app.config.ts] twoslash
export default defineAppConfig({
  // Overwrite default array value by using a merger function
  array: () => ['bonjour'],
})
```
::

## Known Limitations

As of Nuxt v3.3, the `app.config.ts` file is shared with Nitro, which results in the following limitations:

1. You cannot import Vue components directly in `app.config.ts`.
2. Some auto-imports are not available in the Nitro context.

These limitations occur because Nitro processes the app config without full Vue component support.

While it's possible to use Vite plugins in the Nitro config as a workaround, this approach is not recommended:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    vite: {
      plugins: [vue()]
    }
  }
})
```

::warning
Using this workaround may lead to unexpected behavior and bugs. The Vue plugin is one of many that are not available in the Nitro context.
::

Related issues:

- [Issue #19858](https://github.com/nuxt/nuxt/issues/19858){rel="nofollow"}
- [Issue #19854](https://github.com/nuxt/nuxt/issues/19854){rel="nofollow"}

::note
Nitro v3 will resolve these limitations by removing support for the app config.
You can track the progress in [this pull request](https://github.com/nitrojs/nitro/pull/2521){rel="nofollow"}.
::


# error.vue

During the lifespan of your application, some errors may appear unexpectedly at runtime. In such case, we can use the `error.vue` file to override the default error files and display the error nicely.

```vue [error.vue]
<script setup lang="ts">
import type { NuxtError } from '#app'

const props = defineProps({
  error: Object as () => NuxtError
})
</script>

<template>
  <div>
    <h1>{{ error.statusCode }}</h1>
    <NuxtLink to="/">Go back home</NuxtLink>
  </div>
</template>
```

::note
Although it is called an 'error page' it's not a route and shouldn't be placed in your `~/pages` directory. For the same reason, you shouldn't use `definePageMeta` within this page. That being said, you can still use layouts in the error file, by utilizing the [`NuxtLayout`](https://nuxt.com/docs/api/components/nuxt-layout) component and specifying the name of the layout.
::

The error page has a single prop - `error` which contains an error for you to handle.

The `error` object provides the following fields:

```ts
{
  statusCode: number
  fatal: boolean
  unhandled: boolean
  statusMessage?: string
  data?: unknown
  cause?: unknown
}
```

If you have an error with custom fields they will be lost; you should assign them to `data` instead:

```ts
throw createError({
  statusCode: 404,
  statusMessage: 'Page Not Found',
  data: {
    myCustomField: true
  }
})
```


# content

[Nuxt Content](https://content.nuxt.com){rel="nofollow"} reads the [`content/` directory](https://nuxt.com/docs/guide/directory-structure/content) in your project and parses `.md`, `.yml`, `.csv` and `.json` files to create a file-based CMS for your application.

- Render your content with built-in components.
- Query your content with a MongoDB-like API.
- Use your Vue components in Markdown files with the MDC syntax.
- Automatically generate your navigation.

::read-more{target="_blank" to="https://content.nuxt.com"}
Learn more in **Nuxt Content** documentation.
::

## Enable Nuxt Content

Install the `@nuxt/content` module in your project as well as adding it to your `nuxt.config.ts` with one command:

```bash [Terminal]
npx nuxt module add content
```

## Create Content

Place your markdown files inside the `content/` directory:

```md [content/index.md]
# Hello Content
```

The module automatically loads and parses them.

## Render Content

To render content pages, add a [catch-all route](https://nuxt.com/docs/guide/directory-structure/app/pages/#catch-all-route) using the [`<ContentRenderer>`](https://content.nuxt.com/docs/components/content-renderer){rel="nofollow"} component:

```vue [app/pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('content').path(route.path).first()
})
</script>

<template>
  <div>
    <header><!-- ... --></header>

    <ContentRenderer v-if="page" :value="page" />

    <footer><!-- ... --></footer>
  </div>
</template>
```

## Documentation

::tip{icon="i-lucide-book"}
Head over to <https://content.nuxt.com>{rel="nofollow"} to learn more about the Content module features, such as how to build queries and use Vue components in your Markdown files with the MDC syntax.
::


# modules

It is a good place to place any local modules you develop while building your application.

The auto-registered files patterns are:

- `modules/*/index.ts`
- `modules/*.ts`

You don't need to add those local modules to your [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) separately.

::code-group
```ts [modules/hello/index.ts] twoslash
// `nuxt/kit` is a helper subpath import you can use when defining local modules
// that means you do not need to add `@nuxt/kit` to your project's dependencies
import { createResolver, defineNuxtModule, addServerHandler } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'hello'
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    // Add an API route
    addServerHandler({
      route: '/api/hello',
      handler: resolver.resolve('./runtime/api-route')
    })
  }
})
```

```ts [modules/hello/runtime/api-route.ts] twoslash
export default defineEventHandler(() => {
  return { hello: 'world' }
})
```
::

When starting Nuxt, the `hello` module will be registered and the `/api/hello` route will be available.

Modules are executed in the following sequence:

- First, the modules defined in [`nuxt.config.ts`](https://nuxt.com/docs/api/nuxt-config#modules-1) are loaded.
- Then, modules found in the `modules/` directory are executed, and they load in alphabetical order.

You can change the order of local module by adding a number to the front of each directory name:

```bash [Directory structure]
modules/
  1.first-module/
    index.ts
  2.second-module.ts
```

::read-more{to="https://nuxt.com/docs/guide/going-further/modules"}
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/creating-your-first-module-from-scratch?friend=nuxt
---
Watch Vue School video about Nuxt private modules.
::


# node_modules

The package manager ([`npm`](https://docs.npmjs.com/cli/commands/npm){rel="nofollow"} or [`yarn`](https://yarnpkg.com){rel="nofollow"} or [`pnpm`](https://pnpm.io/cli/install){rel="nofollow"} or [`bun`](https://bun.sh/package-manager){rel="nofollow"}) creates this directory to store the dependencies of your project.

::important
This directory should be added to your [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) file to avoid pushing the dependencies to your repository.
::


# public

Files contained within the `public/` directory are served at the root and are not modified by the build process. This is suitable for files that have to keep their names (e.g. `robots.txt`) *or* likely won't change (e.g. `favicon.ico`).

```bash [Directory structure]
-| public/
---| favicon.ico
---| og-image.png
---| robots.txt
```

```vue [app/app.vue]
<script setup lang="ts">
useSeoMeta({
  ogImage: '/og-image.png'
})
</script>
```

::tip{target="_blank" to="https://v2.nuxt.com/docs/directory-structure/static"}
This is known as the [`static/`] directory in Nuxt 2.
::


# server

Nuxt automatically scans files inside these directories to register API and server handlers with Hot Module Replacement (HMR) support.

```bash [Directory structure]
-| server/
---| api/
-----| hello.ts      # /api/hello
---| routes/
-----| bonjour.ts    # /bonjour
---| middleware/
-----| log.ts        # log all requests
```

Each file should export a default function defined with `defineEventHandler()` or `eventHandler()` (alias).

The handler can directly return JSON data, a `Promise`, or use `event.node.res.end()` to send a response.

```ts [server/api/hello.ts] twoslash
export default defineEventHandler((event) => {
  return {
    hello: 'world'
  }
})
```

You can now universally call this API in your pages and components:

```vue [app/pages/index.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/hello')
</script>

<template>
  <pre>{{ data }}</pre>
</template>
```

## Server Routes

Files inside the `~/server/api` are automatically prefixed with `/api` in their route.

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on API routes
video-id: "761468863"
---
::

To add server routes without `/api` prefix, put them into `~/server/routes` directory.

**Example:**

```ts [server/routes/hello.ts]
export default defineEventHandler(() => 'Hello World!')
```

Given the example above, the `/hello` route will be accessible at <http://localhost:3000/hello>{rel="nofollow"}.

::note
Note that currently server routes do not support the full functionality of dynamic routes as [pages](https://nuxt.com/docs/guide/directory-structure/app/pages#dynamic-routes) do.
::

## Server Middleware

Nuxt will automatically read in any file in the `~/server/middleware` to create server middleware for your project.

Middleware handlers will run on every request before any other server route to add or check headers, log requests, or extend the event's request object.

::note
Middleware handlers should not return anything (nor close or respond to the request) and only inspect or extend the request context or throw an error.
::

**Examples:**

```ts [server/middleware/log.ts]
export default defineEventHandler((event) => {
  console.log('New request: ' + getRequestURL(event))
})
```

```ts [server/middleware/auth.ts]
export default defineEventHandler((event) => {
  event.context.auth = { user: 123 }
})
```

## Server Plugins

Nuxt will automatically read any files in the `~/server/plugins` directory and register them as Nitro plugins. This allows extending Nitro's runtime behavior and hooking into lifecycle events.

**Example:**

```ts [server/plugins/nitroPlugin.ts]
export default defineNitroPlugin((nitroApp) => {
  console.log('Nitro plugin', nitroApp)
})
```

::read-more
---
target: _blank
title: Nitro Plugins
to: https://nitro.build/guide/plugins
---
::

## Server Utilities

Server routes are powered by [h3js/h3](https://github.com/h3js/h3){rel="nofollow"} which comes with a handy set of helpers.

::read-more
---
target: _blank
title: Available H3 Request Helpers
to: https://www.jsdocs.io/package/h3#package-index-functions
---
::

You can add more helpers yourself inside the `~/server/utils` directory.

For example, you can define a custom handler utility that wraps the original handler and performs additional operations before returning the final response.

**Example:**

```ts [server/utils/handler.ts]
import type { EventHandler, EventHandlerRequest } from 'h3'

export const defineWrappedResponseHandler = <T extends EventHandlerRequest, D> (
  handler: EventHandler<T, D>
): EventHandler<T, D> =>
  defineEventHandler<T>(async event => {
    try {
      // do something before the route handler
      const response = await handler(event)
      // do something after the route handler
      return { response }
    } catch (err) {
      // Error handling
      return { err }
    }
  })
```

## Server Types

::tip
This feature is available from Nuxt >= 3.5
::

## Recipes

### Route Parameters

Server routes can use dynamic parameters within brackets in the file name like `/api/hello/[name].ts` and be accessed via `event.context.params`.

```ts [server/api/hello/[name\\].ts]
export default defineEventHandler((event) => {
  const name = getRouterParam(event, 'name')

  return `Hello, ${name}!`
})
```

::tip{to="https://h3.dev/examples/validate-data#validate-params"}
Alternatively, use `getValidatedRouterParams` with a schema validator such as Zod for runtime and type safety.
::

You can now universally call this API on `/api/hello/nuxt` and get `Hello, nuxt!`.

### Matching HTTP Method

Handle file names can be suffixed with `.get`, `.post`, `.put`, `.delete`, ... to match request's [HTTP Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods){rel="nofollow"}.

```ts [server/api/test.get.ts]
export default defineEventHandler(() => 'Test get handler')
```

```ts [server/api/test.post.ts]
export default defineEventHandler(() => 'Test post handler')
```

Given the example above, fetching `/test` with:

- **GET** method: Returns `Test get handler`
- **POST** method: Returns `Test post handler`
- Any other method: Returns 405 error

You can also use `index.[method].ts` inside a directory for structuring your code differently, this is useful to create API namespaces.

::code-group
```ts [server/api/foo/index.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo` endpoint
})
```

```ts [server/api/foo/index.post.ts]
export default defineEventHandler((event) => {
  // handle POST requests for the `api/foo` endpoint
})
```

```ts [server/api/foo/bar.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo/bar` endpoint
})
```
::

### Catch-all Route

Catch-all routes are helpful for fallback route handling.

For example, creating a file named `~/server/api/foo/[...].ts` will register a catch-all route for all requests that do not match any route handler, such as `/api/foo/bar/baz`.

```ts [server/api/foo/[...\\].ts]
export default defineEventHandler((event) => {
  // event.context.path to get the route path: '/api/foo/bar/baz'
  // event.context.params._ to get the route segment: 'bar/baz'
  return `Default foo handler`
})
```

You can set a name for the catch-all route by using `~/server/api/foo/[...slug].ts` and access it via `event.context.params.slug`.

```ts [server/api/foo/[...slug\\].ts]
export default defineEventHandler((event) => {
  // event.context.params.slug to get the route segment: 'bar/baz'
  return `Default foo handler`
})
```

### Body Handling

```ts [server/api/submit.post.ts]
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  return { body }
})
```

::tip
---
to: https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils
---
Alternatively, use `readValidatedBody` with a schema validator such as Zod for runtime and type safety.
::

You can now universally call this API using:

```vue [app/app.vue]
<script setup lang="ts">
async function submit() {
  const { body } = await $fetch('/api/submit', {
    method: 'post',
    body: { test: 123 }
  })
}
</script>
```

::note
We are using `submit.post.ts` in the filename only to match requests with `POST` method that can accept the request body. When using `readBody` within a GET request, `readBody` will throw a `405 Method Not Allowed` HTTP error.
::

### Query Parameters

Sample query `/api/query?foo=bar&baz=qux`

```ts [server/api/query.get.ts]
export default defineEventHandler((event) => {
  const query = getQuery(event)

  return { a: query.foo, b: query.baz }
})
```

::tip
---
to: https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils
---
Alternatively, use `getValidatedQuery` with a schema validator such as Zod for runtime and type safety.
::

### Error Handling

If no errors are thrown, a status code of `200 OK` will be returned.

Any uncaught errors will return a `500 Internal Server Error` HTTP Error.

To return other error codes, throw an exception with [`createError`](https://nuxt.com/docs/api/utils/create-error):

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  const id = parseInt(event.context.params.id) as number

  if (!Number.isInteger(id)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'ID should be an integer',
    })
  }
  return 'All good'
})
```

### Status Codes

To return other status codes, use the [`setResponseStatus`](https://nuxt.com/docs/api/utils/set-response-status) utility.

For example, to return `202 Accepted`

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  setResponseStatus(event, 202)
})
```

### Runtime Config

::code-group
```ts [server/api/foo.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  const repo = await $fetch('https://api.github.com/repos/nuxt/nuxt', {
    headers: {
      Authorization: `token ${config.githubToken}`
    }
  })

  return repo
})
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    githubToken: ''
  }
})
```

```ini [.env]
NUXT_GITHUB_TOKEN='<my-super-token>'
```
::

::note
Giving the `event` as argument to `useRuntimeConfig` is optional, but it is recommended to pass it to get the runtime config overwritten by [environment variables](https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables) at runtime for server routes.
::

### Request Cookies

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```

### Forwarding Context & Headers

By default, neither the headers from the incoming request nor the request context are forwarded when
making fetch requests in server routes. You can use `event.$fetch` to forward the request context and headers when making fetch requests in server routes.

```ts [server/api/forward.ts]
export default defineEventHandler((event) => {
  return event.$fetch('/api/forwarded')
})
```

::note
Headers that are **not meant to be forwarded** will **not be included** in the request. These headers include, for example:
`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

### Awaiting Promises After Response

When handling server requests, you might need to perform asynchronous tasks that shouldn't block the response to the client (for example, caching and logging). You can use `event.waitUntil` to await a promise in the background without delaying the response.

The `event.waitUntil` method accepts a promise that will be awaited before the handler terminates, ensuring the task is completed even if the server would otherwise terminate the handler right after the response is sent. This integrates with runtime providers to leverage their native capabilities for handling asynchronous operations after the response is sent.

```ts [server/api/background-task.ts]
const timeConsumingBackgroundTask = async () => {
  await new Promise((resolve) => setTimeout(resolve, 1000))
};

export default eventHandler((event) => {
  // schedule a background task without blocking the response
  event.waitUntil(timeConsumingBackgroundTask())

  // immediately send the response to the client
  return 'done'
});
```

## Advanced Usage

### Nitro Config

You can use `nitro` key in `nuxt.config` to directly set [Nitro configuration](https://nitro.build/config){rel="nofollow"}.

::warning
This is an advanced option. Custom config can affect production deployments, as the configuration interface might change over time when Nitro is upgraded in semver-minor versions of Nuxt.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // https://nitro.build/config
  nitro: {}
})
```

::read-more{to="https://nuxt.com/docs/guide/concepts/server-engine"}
::

### Nested Router

```ts [server/api/hello/[...slug\\].ts]
import { createRouter, defineEventHandler, useBase } from 'h3'

const router = createRouter()

router.get('/test', defineEventHandler(() => 'Hello World'))

export default useBase('/api/hello', router.handler)
```

### Sending Streams

::tip
This is an experimental feature and is available in all environments.
::

```ts [server/api/foo.get.ts]
import fs from 'node:fs'
import { sendStream } from 'h3'

export default defineEventHandler((event) => {
  return sendStream(event, fs.createReadStream('/path/to/file'))
})
```

### Sending Redirect

```ts [server/api/foo.get.ts]
export default defineEventHandler(async (event) => {
  await sendRedirect(event, '/path/redirect/to', 302)
})
```

### Legacy Handler or Middleware

```ts [server/api/legacy.ts]
export default fromNodeMiddleware((req, res) => {
  res.end('Legacy handler')
})
```

::important
Legacy support is possible using [h3js/h3](https://github.com/h3js/h3){rel="nofollow"}, but it is advised to avoid legacy handlers as much as you can.
::

```ts [server/middleware/legacy.ts]
export default fromNodeMiddleware((req, res, next) => {
  console.log('Legacy middleware')
  next()
})
```

::warning
Never combine `next()` callback with a legacy middleware that is `async` or returns a `Promise`.
::

### Server Storage

Nitro provides a cross-platform [storage layer](https://nitro.build/guide/storage){rel="nofollow"}. In order to configure additional storage mount points, you can use `nitro.storage`, or [server plugins](https://nuxt.com/#server-plugins).

**Example of adding a Redis storage:**

Using `nitro.storage`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    storage: {
      redis: {
        driver: 'redis',
        /* redis connector options */
        port: 6379, // Redis port
        host: "127.0.0.1", // Redis host
        username: "", // needs Redis >= 6
        password: "",
        db: 0, // Defaults to 0
        tls: {} // tls/ssl
      }
    }
  }
})
```

Then in your API handler:

```ts [server/api/storage/test.ts]
export default defineEventHandler(async (event) => {
  // List all keys with
  const keys = await useStorage('redis').getKeys()

  // Set a key with
  await useStorage('redis').setItem('foo', 'bar')

  // Remove a key with
  await useStorage('redis').removeItem('foo')

  return {}
})
```

::read-more{target="_blank" to="https://nitro.build/guide/storage"}
Read more about Nitro Storage Layer.
::

Alternatively, you can create a storage mount point using a server plugin and runtime config:

::code-group
```ts [server/plugins/storage.ts]
import redisDriver from 'unstorage/drivers/redis'

export default defineNitroPlugin(() => {
  const storage = useStorage()

  // Dynamically pass in credentials from runtime configuration, or other sources
  const driver = redisDriver({
      base: 'redis',
      host: useRuntimeConfig().redis.host,
      port: useRuntimeConfig().redis.port,
      /* other redis connector options */
    })

  // Mount driver
  storage.mount('redis', driver)
})
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    redis: { // Default values
      host: '',
      port: 0,
      /* other redis connector options */
    }
  }
})
```
::


# shared

The `shared/` directory allows you to share code that can be used in both the Vue app and the Nitro server.

::note
The `shared/` directory is available in Nuxt v3.14+.
::

::important
Code in the `shared/` directory cannot import any Vue or Nitro code.
::

::video-accordion
---
title: Watch a video from Vue School on sharing utils and types between app and server
video-id: nnAR-MO3q5M
---
::

## Usage

**Method 1:** Named export

```ts [shared/utils/capitalize.ts] twoslash
export const capitalize = (input: string) => {
  return input[0] ? input[0].toUpperCase() + input.slice(1) : ''
}
```

**Method 2:** Default export

```ts [shared/utils/capitalize.ts] twoslash
export default function (input: string) {
  return input[0] ? input[0].toUpperCase() + input.slice(1) : ''
}
```

You can now use [auto-imported](https://nuxt.com/docs/guide/directory-structure/shared#auto-imports) utilities in your Nuxt app and `server/` directory.

```vue [app/app.vue]
<script setup lang="ts">
const hello = capitalize('hello')
</script>

<template>
  <div>
    {{ hello }}
  </div>
</template>
```

```ts [server/api/hello.get.ts]
export default defineEventHandler((event) => {
  return {
    hello: capitalize('hello')
  }
})
```

## How Files Are Scanned

Only files in the `shared/utils/` and `shared/types/` directories will be auto-imported. Files nested within subdirectories of these directories will not be auto-imported unless you add these directories to `imports.dirs` and `nitro.imports.dirs`.

::tip
The way `shared/utils` and `shared/types` auto-imports work and are scanned is identical to the [`app/composables/`](https://nuxt.com/docs/guide/directory-structure/app/composables) and [`app/utils/`](https://nuxt.com/docs/guide/directory-structure/app/utils) directories.
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/composables#how-files-are-scanned
---
::

```bash [Directory Structure]
-| shared/
---| capitalize.ts        # Not auto-imported
---| formatters
-----| lower.ts           # Not auto-imported
---| utils/
-----| lower.ts           # Auto-imported
-----| formatters
-------| upper.ts         # Not auto-imported
---| types/
-----| bar.d.ts           # Auto-imported
```

Any other files you create in the `shared/` folder must be manually imported using the `#shared` alias (automatically configured by Nuxt):

```ts
// For files directly in the shared directory
import capitalize from '#shared/capitalize'

// For files in nested directories
import lower from '#shared/formatters/lower'

// For files nested in a folder within utils
import upper from '#shared/utils/formatters/upper'
```

This alias ensures consistent imports across your application, regardless of the importing file's location.

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::


# .env

::important
This file should be added to your [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) file to avoid pushing secrets to your repository.
::

## Dev, Build and Generate Time

Nuxt CLI has built-in [dotenv](https://github.com/motdotla/dotenv){rel="nofollow"} support in development mode and when running [`nuxt build`](https://nuxt.com/docs/api/commands/build) and [`nuxt generate`](https://nuxt.com/docs/api/commands/generate).

In addition to any process environment variables, if you have a `.env` file in your project root directory, it will be automatically loaded **at dev, build and generate time**. Any environment variables set there will be accessible within your `nuxt.config` file and modules.

```ini [.env]
MY_ENV_VARIABLE=hello
```

::note
Note that removing a variable from `.env` or removing the `.env` file entirely will not unset values that have already been set.
::

## Custom File

If you want to use a different file - for example, to use `.env.local` or `.env.production` - you can do so by passing the `--dotenv` flag when using the Nuxt CLI.

```bash [Terminal]
npx nuxt dev --dotenv .env.local
```

When updating `.env` in development mode, the Nuxt instance is automatically restarted to apply new values to the `process.env`.

::important
In your application code, you should use [Runtime Config](https://nuxt.com/docs/guide/going-further/runtime-config) instead of plain env variables.
::

## Production

**After your server is built**, you are responsible for setting environment variables when you run the server.

Your `.env` files will not be read at this point. How you do this is different for every environment.

This design decision was made to ensure compatibility across various deployment environments, some of which may not have a traditional file system available, such as serverless platforms or edge networks like Cloudflare Workers.

Since `.env` files are not used in production, you must explicitly set environment variables using the tools and methods provided by your hosting environment. Here are some common approaches:

- You can pass the environment variables as arguments using the terminal: :br`$ DATABASE_HOST=mydatabaseconnectionstring node .output/server/index.mjs`
- You can set environment variables in shell configuration files like `.bashrc` or `.profile`.
- Many cloud service providers, such as Vercel, Netlify, and AWS, provide interfaces for setting environment variables via their dashboards, CLI tools or configuration files.

::important
`runtimeConfig` [won't pick up environment variables that don't start with `NUXT_` in production] (<https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables>{rel="nofollow"}).
::

## Production Preview

For local production preview purpose, we recommend using [`nuxt preview`](https://nuxt.com/docs/api/commands/preview) since using this command, the `.env` file will be loaded into `process.env` for convenience. Note that this command requires dependencies to be installed in the package directory.

Or you could pass the environment variables as arguments using the terminal. For example, on Linux or macOS:

```bash [Terminal]
DATABASE_HOST=mydatabaseconnectionstring node .output/server/index.mjs
```

Note that for a purely static site, it is not possible to set runtime configuration config after your project is prerendered.

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

::note
If you want to use environment variables set at build time but do not care about updating these down the line (or only need to update them reactively *within* your app) then `appConfig` may be a better choice. You can define `appConfig` both within your `nuxt.config` (using environment variables) and also within an `~/app.config.ts` file in your project.

  :::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
  :::
::


# .gitignore

A `.gitignore` file specifies intentionally untracked files that git should ignore.

::read-more
---
icon: i-simple-icons-git
target: _blank
title: the git documentation
to: https://git-scm.com/docs/gitignore
---
::

We recommend having a `.gitignore` file that has **at least** the following entries present:

```bash [.gitignore]
# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store

# Local env files
.env
.env.*
!.env.example
```


# .nuxtignore

The `.nuxtignore` file tells Nuxt to ignore files in your project’s root directory ([`rootDir`](https://nuxt.com/docs/api/nuxt-config#rootdir)) during the build phase.

It is subject to the same specification as [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) and `.eslintignore` files, in which each line is a glob pattern indicating which files should be ignored.

::tip
You can also configure [`ignoreOptions`](https://nuxt.com/docs/api/nuxt-config#ignoreoptions), [`ignorePrefix`](https://nuxt.com/docs/api/nuxt-config#ignoreprefix) and [`ignore`](https://nuxt.com/docs/api/nuxt-config#ignore) in your `nuxt.config` file.
::

## Usage

```bash [.nuxtignore]
# ignore layout foo.vue
app/layouts/foo.vue
# ignore layout files whose name ends with -ignore.vue
app/layouts/*-ignore.vue

# ignore page bar.vue
app/pages/bar.vue
# ignore page inside ignore folder
app/pages/ignore/*.vue

# ignore route middleware files under foo folder except foo/bar.js
app/middleware/foo/*.js
!app/middleware/foo/bar.js
```

::read-more
---
icon: i-simple-icons-git
target: _blank
title: the git documentation
to: https://git-scm.com/docs/gitignore
---
More details about the spec are in the **gitignore documentation**.
::


# .nuxtrc

The `.nuxtrc` file can be used to configure Nuxt with a flat syntax. It is based on [`unjs/rc9`](https://github.com/unjs/rc9){rel="nofollow"}.

::tip
For more advanced configurations, use [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config).
::

## Usage

```bash [.nuxtrc]
# Disable SSR
ssr=false

# Configuration for `@nuxt/devtools`
devtools.enabled=true

# Add Nuxt modules
modules[]=@nuxt/image
modules[]=nuxt-security
```

If present, the properties in the `nuxt.config` file will overwrite the properties in `.nuxtrc` file.

::note
Nuxt automatically adds a `setups` section to track module installation and upgrade state. This is used internally for [module lifecycle hooks](https://nuxt.com/docs/api/kit/modules#using-lifecycle-hooks-for-module-installation-and-upgrade) and should not be modified manually.
::

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config"}
Discover all the available options in the **Nuxt configuration** documentation.
::

## Global `.nuxtrc` File

You can also create a global `.nuxtrc` file in your home directory to apply configurations globally.

- On macOS/Linux, this file is located at:
  ```md
  ~/.nuxtrc
  ```
- On Windows, it is located at:
  ```md
  C:\Users\{username}\.nuxtrc
  ```

This global `.nuxtrc` file allows you to define default settings that apply to all Nuxt projects on your system. However, project-level `.nuxtrc` files will override these global settings, and `nuxt.config` will take precedence over both.


# nuxt.config.ts

The `nuxt.config` file extension can either be `.js`, `.ts` or `.mjs`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  // My Nuxt config
})
```

::tip
`defineNuxtConfig` helper is globally available without import.
::

You can explicitly import `defineNuxtConfig` from `nuxt/config` if you prefer:

```ts [nuxt.config.ts] twoslash
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  // My Nuxt config
})
```

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config"}
Discover all the available options in the **Nuxt configuration** documentation.
::

To ensure your configuration is up to date, Nuxt will make a full restart when detecting changes in the main configuration file, the [`.env`](https://nuxt.com/docs/guide/directory-structure/env), [`.nuxtignore`](https://nuxt.com/docs/guide/directory-structure/nuxtignore) and [`.nuxtrc`](https://nuxt.com/docs/guide/directory-structure/nuxtrc) dotfiles.


# package.json

The minimal `package.json` of your Nuxt application should looks like:

```json [package.json]
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "nuxt": "latest",
    "vue": "latest",
    "vue-router": "latest"
  }
}
```

::read-more
---
icon: i-simple-icons-npm
target: _blank
to: https://docs.npmjs.com/cli/configuring-npm/package-json
---
Read more about the `package.json` file.
::


# tsconfig.json

Nuxt [automatically generates](https://nuxt.com/docs/guide/concepts/typescript) multiple TypeScript configuration files (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, `.nuxt/tsconfig.node.json` and `.nuxt/tsconfig.shared.json`) with the resolved aliases you are using in your Nuxt project, as well as with other sensible defaults.

You can benefit from this by creating a `tsconfig.json` in the root of your project with the following content:

```json [tsconfig.json]
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
```

::note
As you need to, you can customize the contents of this file. However, it is recommended that you don't overwrite `target`, `module` and `moduleResolution`.
::

::note
If you need to customize your `paths`, this will override the auto-generated path aliases. Instead, we recommend that you add any path aliases you need to the [`alias`](https://nuxt.com/docs/api/nuxt-config#alias) property within your `nuxt.config`, where they will get picked up and added to the auto-generated `tsconfig`.
::


# Events

Using events is a great way to decouple your application and allow for more flexible and modular communication between different parts of your code. Events can have multiple listeners that do not depend on each other. For example, you may wish to send an email to your user each time an order has shipped. Instead of coupling your order processing code to your email code, you can emit an event which a listener can receive and use to dispatch an email.

The Nuxt event system is powered by [unjs/hookable](https://github.com/unjs/hookable){rel="nofollow"}, which is the same library that powers the Nuxt hooks system.

## Creating Events and Listeners

You can create your own custom events using the `hook` method:

```ts
const nuxtApp = useNuxtApp()

nuxtApp.hook('app:user:registered', payload => {
  console.log('A new user has registered!', payload)
})
```

To emit an event and notify any listeners, use `callHook`:

```ts
const nuxtApp = useNuxtApp()

await nuxtApp.callHook('app:user:registered', {
  id: 1,
  name: 'John Doe',
})
```

You can also use the payload object to enable two-way communication between the emitter and listeners. Since the payload is passed by reference, a listener can modify it to send data back to the emitter.

```ts
const nuxtApp = useNuxtApp()

nuxtApp.hook('app:user:registered', payload => {
  payload.message = 'Welcome to our app!'
})

const payload = {
  id: 1,
  name: 'John Doe',
}

await nuxtApp.callHook('app:user:registered', {
  id: 1,
  name: 'John Doe',
})

// payload.message will be 'Welcome to our app!'
```

::tip
You can inspect all events using the **Nuxt DevTools** Hooks panel.
::

::read-more{to="https://nuxt.com/docs/guide/going-further/hooks"}
Learn more about Nuxt's built-in hooks and how to extend them
::


# Experimental Features

Nuxt includes experimental features that you can enable in your configuration file.

Internally, Nuxt uses `@nuxt/schema` to define these experimental features. You can refer to the [API documentation](https://nuxt.com/docs/api/configuration/nuxt-config#experimental) or the [source code](https://github.com/nuxt/nuxt/blob/main/packages/schema/src/config/experimental.ts){rel="nofollow"} for more information.

::note
Note that these features are experimental and could be removed or modified in the future.
::

## asyncContext

Enable native async context to be accessible for nested composables in Nuxt and in Nitro. This opens the possibility to use composables inside async composables and reduce the chance to get the `Nuxt instance is unavailable` error.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    asyncContext: true
  }
})
```

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/20918
---
See full explanation on the GitHub pull-request.
::

## asyncEntry

Enables generation of an async entry point for the Vue bundle, aiding module federation support.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    asyncEntry: true
  }
})
```

## externalVue

Externalizes `vue`, `@vue/*` and `vue-router` when building.

*Enabled by default.*

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    externalVue: true
  }
})
```

::warning
This feature will likely be removed in a near future.
::

## emitRouteChunkError

Emits `app:chunkError` hook when there is an error loading vite/webpack chunks. Default behavior is to perform a reload of the new route on navigation to a new route when a chunk fails to load.

If you set this to `'automatic-immediate'` Nuxt will reload the current route immediately, instead of waiting for a navigation. This is useful for chunk errors that are not triggered by navigation, e.g., when your Nuxt app fails to load a [lazy component](https://nuxt.com/docs/guide/directory-structure/app/components#dynamic-imports). A potential downside of this behavior is undesired reloads, e.g., when your app does not need the chunk that caused the error.

You can disable automatic handling by setting this to `false`, or handle chunk errors manually by setting it to `manual`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    emitRouteChunkError: 'automatic' // or 'automatic-immediate', 'manual' or false
  }
})
```

## restoreState

Allows Nuxt app state to be restored from `sessionStorage` when reloading the page after a chunk error or manual [`reloadNuxtApp()`](https://nuxt.com/docs/api/utils/reload-nuxt-app) call.

To avoid hydration errors, it will be applied only after the Vue app has been mounted, meaning there may be a flicker on initial load.

::important
Consider carefully before enabling this as it can cause unexpected behavior,
and consider providing explicit keys to [`useState`](https://nuxt.com/docs/api/composables/use-state) as auto-generated keys may not match across builds.
::

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    restoreState: true
  }
})
```

## inlineRouteRules

Define route rules at the page level using [`defineRouteRules`](https://nuxt.com/docs/api/utils/define-route-rules).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    inlineRouteRules: true
  }
})
```

Matching route rules will be created, based on the page's `path`.

::read-more
---
icon: i-lucide-square-function
to: https://nuxt.com/docs/api/utils/define-route-rules
---
Read more in `defineRouteRules` utility.
::

::read-more
---
icon: i-lucide-medal
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
::

## renderJsonPayloads

Allows rendering of JSON payloads with support for revivifying complex types.

*Enabled by default.*

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    renderJsonPayloads: true
  }
})
```

## noVueServer

Disables Vue server renderer endpoint within Nitro.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    noVueServer: true
  }
})
```

## payloadExtraction

Enables extraction of payloads of pages generated with `nuxt generate`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    payloadExtraction: true
  }
})
```

## clientFallback

Enables the experimental [`<NuxtClientFallback>`](https://nuxt.com/docs/api/components/nuxt-client-fallback) component for rendering content on the client if there's an error in SSR.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    clientFallback: true
  }
})
```

## crossOriginPrefetch

Enables cross-origin prefetch using the Speculation Rules API.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    crossOriginPrefetch: true
  }
})
```

::read-more
---
icon: i-simple-icons-w3c
target: _blank
to: https://wicg.github.io/nav-speculation/prefetch.html
---
Read more about the **Speculation Rules API**.
::

## viewTransition

Enables View Transition API integration with client-side router.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    viewTransition: true
  }
})
```

::link-example
---
target: _blank
to: https://stackblitz.com/edit/nuxt-view-transitions?file=app.vue
---
::

::read-more
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
---
Read more about the **View Transition API**.
::

## writeEarlyHints

Enables writing of early hints when using node server.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    writeEarlyHints: true
  }
})
```

## componentIslands

Enables experimental component islands support with [`<NuxtIsland>`](https://nuxt.com/docs/api/components/nuxt-island) and `.island.vue` files.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    componentIslands: true // false or 'local+remote'
  }
})
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/components#server-components
---
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/issues/19772
---
You can follow the server components roadmap on GitHub.
::

## localLayerAliases

Resolve `~`, `~~`, `@` and `@@` aliases located within layers with respect to their layer source and root directories.

*Enabled by default.*

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    localLayerAliases: true
  }
})
```

## typedPages

Enable the new experimental typed router using [`unplugin-vue-router`](https://github.com/posva/unplugin-vue-router){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    typedPages: true
  }
})
```

Out of the box, this will enable typed usage of [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to), [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link), [`router.push()`](https://nuxt.com/docs/api/composables/use-router) and more.

You can even get typed params within a page by using `const route = useRoute('route-name')`.

::important
If you use `pnpm` without `shamefully-hoist=true`, you will need to have `unplugin-vue-router` installed as a devDependency in order for this feature to work.
::

::video-accordion
---
title: Watch a video from Daniel Roe explaining type-safe routing in Nuxt
video-id: SXk-L19gTZk
---
::

## watcher

Set an alternative watcher that will be used as the watching service for Nuxt.

Nuxt uses `chokidar-granular` by default, which will ignore top-level directories
(like `node_modules` and `.git`) that are excluded from watching.

You can set this instead to `parcel` to use `@parcel/watcher`, which may improve
performance in large projects or on Windows platforms.

You can also set this to `chokidar` to watch all files in your source directory.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    watcher: 'chokidar-granular' // 'chokidar' or 'parcel' are also options
  }
})
```

## sharedPrerenderData

Nuxt automatically shares payload *data* between pages that are prerendered. This can result in a significant performance improvement when prerendering sites that use `useAsyncData` or `useFetch` and fetch the same data in different pages.

You can disable this feature if needed.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

::video-accordion
---
title: Watch a video from Alexander Lichter about the experimental sharedPrerenderData
video-id: 1jUupYHVvrU
---
::

It is particularly important when enabling this feature to make sure that any unique key of your data
is always resolvable to the same data. For example, if you are using `useAsyncData` to fetch
data related to a particular page, you should provide a key that uniquely matches that data. (`useFetch`
should do this automatically for you.)

```ts
// This would be unsafe in a dynamic page (e.g. `[slug].vue`) because the route slug makes a difference
// to the data fetched, but Nuxt can't know that because it's not reflected in the key.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Instead, you should use a key that uniquely identifies the data fetched.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

## clientNodeCompat

With this feature, Nuxt will automatically polyfill Node.js imports in the client build using [`unenv`](https://github.com/unjs/unenv){rel="nofollow"}.

::note
To make globals like `Buffer` work in the browser, you need to manually inject them.

```ts
import { Buffer } from 'node:buffer'

globalThis.Buffer = globalThis.Buffer || Buffer
```
::

## scanPageMeta

Nuxt exposing some route metadata defined in `definePageMeta` at build-time to modules (specifically `alias`, `name`, `path`, `redirect`, `props` and `middleware`).

This only works with static or strings/arrays rather than variables or conditional assignment. See [original issue](https://github.com/nuxt/nuxt/issues/24770){rel="nofollow"} for more information and context.

By default page metadata is only scanned after all routes have been registered in `pages:extend`. Then another hook, `pages:resolved` will be called.

You can disable this feature if it causes issues in your project.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: false
  }
})
```

## cookieStore

Enables CookieStore support to listen for cookie updates (if supported by the browser) and refresh `useCookie` ref values.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    cookieStore: true
  }
})
```

::read-more
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/CookieStore
---
Read more about the **CookieStore**.
::

## buildCache

Caches Nuxt build artifacts based on a hash of the configuration and source files.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    buildCache: true
  }
})
```

When enabled, changes to the following files will trigger a full rebuild:

```bash [Directory structure]
.nuxtrc
.npmrc
package.json
package-lock.json
yarn.lock
pnpm-lock.yaml
tsconfig.json
bun.lock
bun.lockb
```

In addition, any changes to files within `srcDir` will trigger a rebuild of the Vue client/server bundle. Nitro will always be rebuilt (though work is in progress to allow Nitro to announce its cacheable artifacts and their hashes).

::note
A maximum of 10 cache tarballs are kept.
::

## extraPageMetaExtractionKeys

The `definePageMeta()` macro is a useful way to collect build-time meta about pages. Nuxt itself provides a set list of supported keys which is used to power some of the internal features such as redirects, page aliases and custom paths.

This option allows passing additional keys to extract from the page metadata when using `scanPageMeta`.

```vue
<script lang="ts" setup>
definePageMeta({
  foo: 'bar'
})
</script>
```

```ts
export default defineNuxtConfig({
  experimental: {
    extraPageMetaExtractionKeys: ['foo'],
  },
  hooks: {
    'pages:resolved' (ctx) {
      // ✅ foo is available
    },
  },
})
```

This allows modules to access additional metadata from the page metadata in the build context. If you are using this within a module, it's recommended also to [augment the `NuxtPage` types with your keys](https://nuxt.com/docs/guide/directory-structure/app/pages#typing-custom-metadata).

## normalizeComponentNames

Nuxt updates auto-generated Vue component names to match the full component name you would use to auto-import the component.

If you encounter issues, you can disable this feature.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

By default, if you haven't set it manually, Vue will assign a component name that matches
the filename of the component.

```bash [Directory structure]
├─ components/
├─── SomeFolder/
├───── MyComponent.vue
```

In this case, the component name would be `MyComponent`, as far as Vue is concerned. If you wanted to use `<KeepAlive>` with it, or identify it in the Vue DevTools, you would need to use this component.

But in order to auto-import it, you would need to use `SomeFolderMyComponent`.

By setting `experimental.normalizeComponentNames`, these two values match, and Vue will generate a component name that matches the Nuxt pattern for component naming.

## spaLoadingTemplateLocation

When rendering a client-only page (with `ssr: false`), we optionally render a loading screen (from `~/spa-loading-template.html`).

It can be set to `within`, which will render it like this:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Alternatively, you can render the template alongside the Nuxt app root by setting it to `body`:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

This avoids a white flash when hydrating a client-only page.

## browserDevtoolsTiming

Enables performance markers for Nuxt hooks in browser devtools. This adds performance markers that you can track in the Performance tab of Chromium-based browsers, which is useful for debugging and optimizing performance.

This is enabled by default in development mode. If you need to disable this feature, it is possible to do so:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    browserDevtoolsTiming: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/29922
---
See PR #29922 for implementation details.
::

::read-more
---
color: gray
icon: i-simple-icons-googlechrome
target: _blank
to: https://developer.chrome.com/docs/devtools/performance/extension#tracks
---
Learn more about Chrome DevTools Performance API.
::

## debugModuleMutation

Records mutations to `nuxt.options` in module context, helping to debug configuration changes made by modules during the Nuxt initialization phase.

This is enabled by default when `debug` mode is enabled. If you need to disable this feature, it is possible to do so:

To enable it explicitly:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    debugModuleMutation: true
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/30555
---
See PR #30555 for implementation details.
::

## lazyHydration

This enables hydration strategies for `<Lazy>` components, which improves performance by deferring hydration of components until they're needed.

Lazy hydration is enabled by default, but you can disable this feature:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    lazyHydration: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
to: https://nuxt.com/docs/guide/directory-structure/app/components#delayed-or-lazy-hydration
---
Read more about lazy hydration.
::

## templateImportResolution

Controls how imports in Nuxt templates are resolved. By default, Nuxt attempts to resolve imports in templates relative to the module that added them.

This is enabled by default, so if you're experiencing resolution conflicts in certain environments, you can disable this behavior:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    templateImportResolution: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/31175
---
See PR #31175 for implementation details.
::

## decorators

This option enables enabling decorator syntax across your entire Nuxt/Nitro app, powered by [esbuild](https://github.com/evanw/esbuild/releases/tag/v0.21.3){rel="nofollow"}.

For a long time, TypeScript has had support for decorators via `compilerOptions.experimentalDecorators`. This implementation predated the TC39 standardization process. Now, decorators are a [Stage 3 Proposal](https://github.com/tc39/proposal-decorators){rel="nofollow"}, and supported without special configuration in TS 5.0+ (see <https://github.com/microsoft/TypeScript/pull/52582>{rel="nofollow"} and <https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#decorators>{rel="nofollow"}).

Enabling `experimental.decorators` enables support for the TC39 proposal, **NOT** for TypeScript's previous `compilerOptions.experimentalDecorators` implementation.

::warning
Note that there may be changes before this finally lands in the JS standard.
::

### Usage

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    decorators: true,
  },
})
```

```ts [app/app.vue]
function something (_method: () => unknown) {
  return () => 'decorated'
}

class SomeClass {
  @something
  public someMethod () {
    return 'initial'
  }
}

const value = new SomeClass().someMethod()
// this will return 'decorated'
```

## purgeCachedData

Nuxt will automatically purge cached data from `useAsyncData` and `nuxtApp.static.data`. This helps prevent memory leaks
and ensures fresh data is loaded when needed, but it is possible to disable it:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    purgeCachedData: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/31379
---
See PR #31379 for implementation details.
::

## granularCachedData

Whether to call and use the result from `getCachedData` when refreshing data for `useAsyncData` and `useFetch` (whether by `watch`, `refreshNuxtData()`, or a manual `refresh()` call.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    granularCachedData: true
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/31373
---
See PR #31373 for implementation details.
::

## pendingWhenIdle

If set to `false`, the `pending` object returned from `useAsyncData`, `useFetch`, `useLazyAsyncData` and `useLazyFetch` will be a computed property that is `true` only when `status` is also pending.

That means that when `immediate: false` is passed, `pending` will be `false` until the first request is made.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: false
  }
})
```

## entryImportMap

By default, Nuxt improves chunk stability by using an import map to resolve the entry chunk of the bundle.

This injects an import map at the top of your `<head>` tag:

```html
<script type="importmap">{"imports":{"#entry":"/_nuxt/DC5HVSK5.js"}}</script>
```

Within the script chunks emitted by Vite, imports will be from `#entry`. This means that changes to the entry will not invalidate chunks which are otherwise unchanged.

::note
Nuxt smartly disables this feature if you have configured `vite.build.target` to include a browser that doesn't support import maps, or if you have configured `vite.build.rollupOptions.output.entryFileNames` to a value that does not include `[hash]`.
::

If you need to disable this feature you can do so:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    entryImportMap: false
  },
// or, better, simply tell vite your desired target
  // which nuxt will respect
  vite: {
    build: {
      target: 'safari13'
    },
  },
})
```


# Features

Some features of Nuxt are available on an opt-in basis, or can be disabled based on your needs.

## `features`

### inlineStyles

Inlines styles when rendering HTML. This is currently available only when using Vite.

You can also pass a function that receives the path of a Vue component and returns a boolean indicating whether to inline the styles for that component.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    inlineStyles: false // or a function to determine inlining
  }
})
```

### noScripts

Disables rendering of Nuxt scripts and JS resource hints. Can also be configured granularly within `routeRules`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    noScripts: true
  }
})
```

## `future`

There is also a `future` namespace for early opting-in to new features that will become default in a future (possibly major) version of the framework.

### compatibilityVersion

This is used for enabling early access to Nuxt features or flags.

It is not configurable yet in Nuxt 4, but once we begin merging breaking changes for v5, it will be possible to enable it.

### typescriptBundlerResolution

This enables 'Bundler' module resolution mode for TypeScript, which is the recommended setting
for frameworks like Nuxt and [Vite](https://vite.dev/guide/performance.html#reduce-resolve-operations){rel="nofollow"}.

It improves type support when using modern libraries with `exports`.

See [the original TypeScript pull request](https://github.com/microsoft/TypeScript/pull/51669){rel="nofollow"}.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    typescriptBundlerResolution: true
  }
})
```


# How Nuxt Works?

This guide helps you better understand Nuxt internals to develop new solutions and module integrations on top of Nuxt.

## The Nuxt Interface

When you start Nuxt in development mode with [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) or building a production application with [`nuxt build`](https://nuxt.com/docs/api/commands/build),
a common context will be created, referred to as `nuxt` internally. It holds normalized options merged with `nuxt.config` file,
some internal state, and a powerful [hooking system](https://nuxt.com/docs/api/advanced/hooks) powered by [unjs/hookable](https://github.com/unjs/hookable){rel="nofollow"}
allowing different components to communicate with each other. You can think of it as **Builder Core**.

This context is globally available to be used with [Nuxt Kit](https://nuxt.com/docs/guide/going-further/kit) composables.
Therefore only one instance of Nuxt is allowed to run per process.

To extend the Nuxt interface and hook into different stages of the build process, we can use [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules).

For more details, check out [the source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/core/nuxt.ts){rel="nofollow"}.

## The NuxtApp Interface

When rendering a page in the browser or on the server, a shared context will be created, referred to as `nuxtApp`.
This context keeps vue instance, runtime hooks, and internal states like ssrContext and payload for hydration.
You can think of it as **Runtime Core**.

This context can be accessed using [`useNuxtApp()`](https://nuxt.com/docs/api/composables/use-nuxt-app) composable within Nuxt plugins and `<script setup>` and vue composables.
Global usage is possible for the browser but not on the server, to avoid sharing context between users.

Since [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) throws an exception if context is currently unavailable, if your composable does not always require `nuxtApp`, you can use [`tryUseNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app#tryusenuxtapp) instead, which will return `null` instead of throwing an exception.

To extend the `nuxtApp` interface and hook into different stages or access contexts, we can use [Nuxt Plugins](https://nuxt.com/docs/guide/directory-structure/plugins).

Check [Nuxt App](https://nuxt.com/docs/api/composables/use-nuxt-app) for more information about this interface.

`nuxtApp` has the following properties:

```js
const nuxtApp = {
  vueApp, // the global Vue application: https://vuejs.org/api/application.html#application-api

  versions, // an object containing Nuxt and Vue versions

  // These let you call and add runtime NuxtApp hooks
  // https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts#L18
  hooks,
  hook,
  callHook,

  // Only accessible on server-side
  ssrContext: {
    url,
    req,
    res,
    runtimeConfig,
    noSSR,
  },

  // This will be stringified and passed from server to client
  payload: {
    serverRendered: true,
    data: {},
    state: {}
  }

  provide: (name: string, value: any) => void
}
```

For more details, check out [the source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts){rel="nofollow"}.

## Runtime Context vs. Build Context

Nuxt builds and bundles project using Node.js but also has a runtime side.

While both areas can be extended, that runtime context is isolated from build-time. Therefore, they are not supposed to share state, code, or context other than runtime configuration!

`nuxt.config` and [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules) can be used to extend the build context, and [Nuxt Plugins](https://nuxt.com/docs/guide/directory-structure/plugins) can be used to extend runtime.

When building an application for production, `nuxt build` will generate a standalone build in the `.output` directory, independent of `nuxt.config` and [Nuxt modules](https://nuxt.com/docs/guide/going-further/modules).


# Runtime Config

## Exposing

To expose config and environment variables to the rest of your app, you will need to define runtime configuration in your [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file, using the [`runtimeConfig`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig) option.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // The private keys which are only available within server-side
    apiSecret: '123',
    // Keys within public, will be also exposed to the client-side
    public: {
      apiBase: '/api'
    }
  }
})
```

When adding `apiBase` to the `runtimeConfig.public`, Nuxt adds it to each page payload. We can universally access `apiBase` in both server and browser.

```ts
const runtimeConfig = useRuntimeConfig()

console.log(runtimeConfig.apiSecret)
console.log(runtimeConfig.public.apiBase)
```

::tip
Public runtime config is accessible in Vue templates with `$config.public`.
::

### Serialization

Your runtime config will be serialized before being passed to Nitro. This means that anything that cannot be serialized and then deserialized (such as functions, Sets, Maps, and so on), should not be set in your `nuxt.config`.

Instead of passing non-serializable objects or functions into your application from your `nuxt.config`, you can place this code in a Nuxt or Nitro plugin or middleware.

### Environment Variables

The most common way to provide configuration is by using [Environment Variables](https://medium.com/chingu/an-introduction-to-environment-variables-and-how-to-use-them-f602f66d15fa){rel="nofollow"}.

::note
The Nuxt CLI has built-in support for reading your `.env` file in development, build and generate. But when you run your built server, **your `.env` file will not be read**.

  :::read-more{to="https://nuxt.com/docs/guide/directory-structure/env"}
  :::
::

Runtime config values are **automatically replaced by matching environment variables at runtime**.

There are two key requirements:

1. Your desired variables must be defined in your `nuxt.config`. This ensures that arbitrary environment variables are not exposed to your application code.
2. Only a specially-named environment variable can override a runtime config property. That is, an uppercase environment variable starting with `NUXT_` which uses `_` to separate keys and case changes.

::warning
Setting the default of `runtimeConfig` values to *differently named environment variables* (for example setting `myVar` to `process.env.OTHER_VARIABLE`) will only work during build-time and will break on runtime.
It is advised to use environment variables that match the structure of your `runtimeConfig` object.
::

::tip{icon="i-lucide-video" target="_blank" to="https://youtu.be/_FYV5WfiWvs"}
Watch a video from Alexander Lichter showcasing the top mistake developers make using runtimeConfig.
::

#### Example

```ini [.env]
NUXT_API_SECRET=api_secret_token
NUXT_PUBLIC_API_BASE=https://nuxtjs.org
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    apiSecret: '', // can be overridden by NUXT_API_SECRET environment variable
    public: {
      apiBase: '', // can be overridden by NUXT_PUBLIC_API_BASE environment variable
    }
  },
})
```

## Reading

### Vue App

Within the Vue part of your Nuxt app, you will need to call [`useRuntimeConfig()`](https://nuxt.com/docs/api/composables/use-runtime-config) to access the runtime config.

::important
The behavior is different between the client-side and server-side:

- On client-side, only keys in `runtimeConfig.public` and `runtimeConfig.app` (which is used by Nuxt internally) are available, and the object is both writable and reactive.
- On server-side, the entire runtime config is available, but it is read-only to avoid context sharing.
::

```vue [app/pages/index.vue]
<script setup lang="ts">
const config = useRuntimeConfig()

console.log('Runtime config:', config)
if (import.meta.server) {
  console.log('API secret:', config.apiSecret)
}
</script>

<template>
  <div>
    <div>Check developer console!</div>
  </div>
</template>
```

::caution
**Security note:** Be careful not to expose runtime config keys to the client-side by either rendering them or passing them to `useState`.
::

### Plugins

If you want to use the runtime config within any (custom) plugin, you can use [`useRuntimeConfig()`](https://nuxt.com/docs/api/composables/use-runtime-config) inside of your `defineNuxtPlugin` function.

```ts [app/plugins/config.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const config = useRuntimeConfig()

  console.log('API base URL:', config.public.apiBase)
});
```

### Server Routes

You can access runtime config within the server routes as well using `useRuntimeConfig`.

```ts [server/api/test.ts]
export default defineEventHandler(async (event) => {
  const { apiSecret } = useRuntimeConfig(event)
  const result = await $fetch('https://my.api.com/test', {
    headers: {
      Authorization: `Bearer ${apiSecret}`
    }
  })
  return result
})
```

::note
Giving the `event` as argument to `useRuntimeConfig` is optional, but it is recommended to pass it to get the runtime config overwritten by [environment variables](https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables) at runtime for server routes.
::

## Typing Runtime Config

Nuxt tries to automatically generate a typescript interface from provided runtime config using [unjs/untyped](https://github.com/unjs/untyped){rel="nofollow"}.

But it is also possible to type your runtime config manually:

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface RuntimeConfig {
    apiSecret: string
  }
  interface PublicRuntimeConfig {
    apiBase: string
  }
}
// It is always important to ensure you import/export something when augmenting a type
export {}
```

::note
`nuxt/schema` is provided as a convenience for end-users to access the version of the schema used by Nuxt in their project. Module authors should instead augment `@nuxt/schema`.
::


# Nightly Release Channel

Nuxt lands commits, improvements, and bug fixes every day. You can opt in to test them earlier before the next release.

After a commit is merged into the `main` branch of [nuxt/nuxt](https://github.com/nuxt/nuxt){rel="nofollow"} and **passes all tests**, we trigger an automated npm release, using GitHub Actions.

You can use these 'nightly' releases to beta test new features and changes.

The build and publishing method and quality of these 'nightly' releases are the same as stable ones. The only difference is that you should often check the GitHub repository for updates. There is a slight chance of regressions not being caught during the review process and by the automated tests. Therefore, we internally use this channel to double-check everything before each release.

::note
Features that are only available on the nightly release channel are marked with an alert in the documentation.
::

::warning
The `latest` nightly release channel is currently tracking the Nuxt v4 branch, meaning that it is particularly likely to have breaking changes right now — be careful! You can opt in to the 3.x branch nightly releases with `"nuxt": "npm:nuxt-nightly@3x"`.
::

## Opting In

Update `nuxt` dependency inside `package.json`:

```diff [package.json]
{
  "devDependencies": {
--    "nuxt": "^4.0.0"
++    "nuxt": "npm:nuxt-nightly@latest"
  }
}
```

Remove lockfile (`package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `bun.lock` or `bun.lockb`) and reinstall dependencies.

## Opting Out

Update `nuxt` dependency inside `package.json`:

```diff [package.json]
{
  "devDependencies": {
--    "nuxt": "npm:nuxt-nightly@latest"
++    "nuxt": "^4.0.0"
  }
}
```

Remove lockfile (`package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `bun.lock` or `bun.lockb`) and reinstall dependencies.

## Using Nightly `@nuxt/cli`

To try the latest version of [nuxt/cli](https://github.com/nuxt/cli){rel="nofollow"}:

```bash [Terminal]
npx @nuxt/cli-nightly@latest [command]
```

::read-more{to="https://nuxt.com/docs/api/commands"}
Read more about the available commands.
::


# Lifecycle Hooks

::tip
The hooking system is powered by [unjs/hookable](https://github.com/unjs/hookable){rel="nofollow"}.
::

## Nuxt Hooks (Build Time)

These hooks are available for [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules) and build context.

### Within `nuxt.config.ts`

```js [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    close: () => { }
  }
})
```

### Within Nuxt Modules

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async () => { })
  }
})
```

::read-more{to="https://nuxt.com/docs/api/advanced/hooks#nuxt-hooks-build-time"}
Explore all available Nuxt hooks.
::

## App Hooks (Runtime)

App hooks can be mainly used by [Nuxt Plugins](https://nuxt.com/docs/guide/directory-structure/plugins) to hook into rendering lifecycle but could also be used in Vue composables.

```js [app/plugins/test.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('page:start', () => {
    /* your code goes here */
  })
})
```

::read-more{to="https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime"}
Explore all available App hooks.
::

## Server Hooks (Runtime)

These hooks are available for [server plugins](https://nuxt.com/docs/guide/directory-structure/server#server-plugins) to hook into Nitro's runtime behavior.

```js [~/server/plugins/test.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:html', (html, { event }) => {
    console.log('render:html', html)
    html.bodyAppend.push('<hr>Appended by custom plugin')
  })

  nitroApp.hooks.hook('render:response', (response, { event }) => {
    console.log('render:response', response)
  })
})
```

::read-more
---
to: https://nuxt.com/docs/api/advanced/hooks#nitro-app-hooks-runtime-server-side
---
Learn more about available Nitro lifecycle hooks.
::

## Adding Custom Hooks

You can define your own custom hooks support by extending Nuxt's hook interfaces.

```ts
import { HookResult } from "@nuxt/schema";

declare module '#app' {
  interface RuntimeNuxtHooks {
    'your-nuxt-runtime-hook': () => HookResult
  }
  interface NuxtHooks {
    'your-nuxt-hook': () => HookResult
  }
}

declare module 'nitropack/types' {
  interface NitroRuntimeHooks {
    'your-nitro-hook': () => void;
  }
}
```


# Module Author Guide

Nuxt's [configuration](https://nuxt.com/docs/api/nuxt-config) and [hooks](https://nuxt.com/docs/guide/going-further/hooks) systems make it possible to customize every aspect of Nuxt and add any integration you might need (Vue plugins, CMS, server routes, components, logging, etc.).

**Nuxt Modules** are functions that sequentially run when starting Nuxt in development mode using `nuxt dev` or building a project for production with `nuxt build`.
With modules, you can encapsulate, properly test, and share custom solutions as npm packages without adding unnecessary boilerplate to your project, or requiring changes to Nuxt itself.

## Quick Start

We recommend you get started with Nuxt Modules using our [starter template](https://github.com/nuxt/starter/tree/module){rel="nofollow"}:

::code-group{sync="pm"}
```bash [npm]
npm create nuxt -- -t module my-module
```

```bash [yarn]
yarn create nuxt -t module my-module
```

```bash [pnpm]
pnpm create nuxt -t module my-module
```

```bash [bun]
bun create nuxt -- -t module my-module
```
::

This will create a `my-module` project with all the boilerplate necessary to develop and publish your module.

**Next steps:**

1. Open `my-module` in your IDE of choice
2. Install dependencies using your favorite package manager
3. Prepare local files for development using `npm run dev:prepare`
4. Follow this document to learn more about Nuxt Modules

### Using the Starter

Learn how to perform basic tasks with the module starter.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/navigating-the-official-starter-template?friend=nuxt
---
Watch Vue School video about Nuxt module starter template.
::

#### How to Develop

While your module source code lives inside the `src` directory, in most cases, to develop a module, you need a Nuxt application. That's what the `playground` directory is about. It's a Nuxt application you can tinker with that is already configured to run with your module.

You can interact with the playground like with any Nuxt application.

- Launch its development server with `npm run dev`, it should reload itself as you make changes to your module in the `src` directory
- Build it with `npm run dev:build`

::note
All other `nuxt` commands can be used against the `playground` directory (e.g. `nuxt <COMMAND> playground`). Feel free to declare additional `dev:*` scripts within your `package.json` referencing them for convenience.
::

#### How to Test

The module starter comes with a basic test suite:

- A linter powered by [ESLint](https://eslint.org){rel="nofollow"}, run it with `npm run lint`
- A test runner powered by [Vitest](https://vitest.dev){rel="nofollow"}, run it with `npm run test` or `npm run test:watch`

::tip
Feel free to augment this default test strategy to better suit your needs.
::

#### How to Build

Nuxt Modules come with their own builder provided by [`@nuxt/module-builder`](https://github.com/nuxt/module-builder#readme){rel="nofollow"}. This builder doesn't require any configuration on your end, supports TypeScript, and makes sure your assets are properly bundled to be distributed to other Nuxt applications.

You can build your module by running `npm run prepack`.

::tip
While building your module can be useful in some cases, most of the time you won't need to build it on your own: the `playground` takes care of it while developing, and the release script also has you covered when publishing.
::

#### How to Publish

::important
Before publishing your module to npm, makes sure you have an [npmjs.com](https://www.npmjs.com){rel="nofollow"} account and that you're authenticated to it locally with `npm login`.
::

While you can publish your module by bumping its version and using the `npm publish` command, the module starter comes with a release script that helps you make sure you publish a working version of your module to npm and more.

To use the release script, first, commit all your changes (we recommend you follow [Conventional Commits](https://www.conventionalcommits.org){rel="nofollow"} to also take advantage of automatic version bump and changelog update), then run the release script with `npm run release`.

When running the release script, the following will happen:

- First, it will run your test suite by:

  - Running the linter (`npm run lint`)
  - Running unit, integration, and e2e tests (`npm run test`)
  - Building the module (`npm run prepack`)
- Then, if your test suite went well, it will proceed to publish your module by:

  - Bumping your module version and generating a changelog according to your Conventional Commits
  - Publishing the module to npm (for that purpose, the module will be built again to ensure its updated version number is taken into account in the published artifact)
  - Pushing a git tag representing the newly published version to your git remote origin

::tip
As with other scripts, feel free to fine-tune the default `release` script in your `package.json` to better suit your needs.
::

## Developing Modules

Nuxt Modules come with a variety of powerful APIs and patterns allowing them to alter a Nuxt application in pretty much any way possible. This section teaches you how to take advantage of those.

### Module Anatomy

We can consider two kinds of Nuxt Modules:

- published modules are distributed on npm - you can see a list of some community modules on [the Nuxt website](https://nuxt.com/modules).
- "local" modules, they exist within a Nuxt project itself, either [inlined in Nuxt config](https://nuxt.com/docs/api/nuxt-config#modules) or as part of [the `modules` directory](https://nuxt.com/docs/guide/directory-structure/modules).

In either case, their anatomy is similar.

#### Module Definition

::note
When using the starter, your module definition is available at `src/module.ts`.
::

The module definition is the entry point of your module. It's what gets loaded by Nuxt when your module is referenced within a Nuxt configuration.

At a low level, a Nuxt Module definition is a simple, potentially asynchronous, function accepting inline user options and a `nuxt` object to interact with Nuxt.

```ts
export default function (inlineOptions, nuxt) {
  // You can do whatever you like here..
  console.log(inlineOptions.token) // `123`
  console.log(nuxt.options.dev) // `true` or `false`
  nuxt.hook('ready', async nuxt => {
    console.log('Nuxt is ready')
  })
}
```

You can get type-hint support for this function using the higher-level `defineNuxtModule` helper provided by [Nuxt Kit](https://nuxt.com/docs/guide/going-further/kit).

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule((options, nuxt) => {
  nuxt.hook('pages:extend', pages => {
    console.log(`Discovered ${pages.length} pages`)
  })
})
```

However, **we do not recommend** using this low-level function definition. Instead, to define a module, **we recommend** using the object-syntax with `meta` property to identify your module, especially when publishing to npm.

This helper makes writing Nuxt modules more straightforward by implementing many common patterns needed by modules, guaranteeing future compatibility and improving the experience for both module authors and users.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    // Usually the npm package name of your module
    name: '@nuxtjs/example',
    // The key in `nuxt.config` that holds your module options
    configKey: 'sample',
    // Compatibility constraints
    compatibility: {
      // Semver version of supported nuxt versions
      nuxt: '>=3.0.0'
    }
  },
  // Default configuration options for your module, can also be a function returning those
  defaults: {},
  // Shorthand sugar to register Nuxt hooks
  hooks: {},
  // Configuration for other modules - this does not ensure the module runs before
  // your module, but it allows you to change the other module's configuration before it runs
  moduleDependencies: {
    'some-module': {
      // You can specify a version constraint for the module. If the user has a different
      // version installed, Nuxt will throw an error on startup.
      version: '>=2',
      // By default moduleDependencies will be added to the list of modules to be installed
      // by Nuxt unless `optional` is set.
      optional: true,
      // Any configuration that should override `nuxt.options`.
      overrides: {},
      // Any configuration that should be set. It will override module defaults but
      // will not override any configuration set in `nuxt.options`.
      defaults: {}
    }
  },
  // The function holding your module logic, it can be asynchronous
  setup(moduleOptions, nuxt) {
    // ...
  }
})
```

Ultimately `defineNuxtModule` returns a wrapper function with the lower level `(inlineOptions, nuxt)` module signature. This wrapper function applies defaults and other necessary steps before calling your `setup` function:

- Support `defaults` and `meta.configKey` for automatically merging module options
- Type hints and automated type inference
- Add shims for basic Nuxt 2 compatibility
- Ensure module gets installed only once using a unique key computed from `meta.name` or `meta.configKey`
- Automatically register Nuxt hooks
- Automatically check for compatibility issues based on module meta
- Expose `getOptions` and `getMeta` for internal usage of Nuxt
- Ensuring backward and upward compatibility as long as the module is using `defineNuxtModule` from the latest version of `@nuxt/kit`
- Integration with module builder tooling

#### Runtime Directory

::note
When using the starter, the runtime directory is available at `src/runtime`.
::

Modules, like everything in a Nuxt configuration, aren't included in your application runtime. However, you might want your module to provide, or inject runtime code to the application it's installed on. That's what the runtime directory enables you to do.

Inside the runtime directory, you can provide any kind of assets related to the Nuxt App:

- Vue components
- Composables
- [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins)

To the [server engine](https://nuxt.com/docs/guide/concepts/server-engine), Nitro:

- API routes
- Middlewares
- Nitro plugins

Or any other kind of asset you want to inject in users' Nuxt applications:

- Stylesheets
- 3D models
- Images
- etc.

You'll then be able to inject all those assets inside the application from your [module definition](https://nuxt.com/#module-definition).

::tip
Learn more about asset injection in [the recipes section](https://nuxt.com/#recipes).
::

::warning
Published modules cannot leverage auto-imports for assets within their runtime directory. Instead, they have to import them explicitly from `#imports` or alike.
:br :br
Indeed, auto-imports are not enabled for files within `node_modules` (the location where a published module will eventually live) for performance reasons.
::

### Tooling

Modules come with a set of first-party tools to help you with their development.

#### `@nuxt/module-builder`

[Nuxt Module Builder](https://github.com/nuxt/module-builder#readme){rel="nofollow"} is a zero-configuration build tool taking care of all the heavy lifting to build and ship your module. It ensures proper compatibility of your module build artifact with Nuxt applications.

#### `@nuxt/kit`

[Nuxt Kit](https://nuxt.com/docs/guide/going-further/kit) provides composable utilities to help your module interact with Nuxt applications. It's recommended to use Nuxt Kit utilities over manual alternatives whenever possible to ensure better compatibility and code readability of your module.

::read-more{to="https://nuxt.com/docs/guide/going-further/kit"}
::

#### `@nuxt/test-utils`

[Nuxt Test Utils](https://nuxt.com/docs/getting-started/testing) is a collection of utilities to help set up and run Nuxt applications within your module tests.

### Recipes

Find here common patterns used to author modules.

#### Altering Nuxt Configuration

Nuxt configuration can be read and altered by modules. Here's an example of a module enabling an experimental feature.

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // We create the `experimental` object if it doesn't exist yet
    nuxt.options.experimental ||= {}
    nuxt.options.experimental.componentIslands = true
  }
})
```

When you need to handle more complex configuration alterations, you should consider using [defu](https://github.com/unjs/defu){rel="nofollow"}.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/extending-and-altering-nuxt-configuration-and-options?friend=nuxt
---
Watch Vue School video about altering Nuxt configuration.
::

#### Exposing Options to Runtime

Because modules aren't part of the application runtime, their options aren't either. However, in many cases, you might need access to some of these module options within your runtime code. We recommend exposing the needed config using Nuxt's [`runtimeConfig`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig).

```js
import { defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.options.runtimeConfig.public.myModule = defu(nuxt.options.runtimeConfig.public.myModule, {
      foo: options.foo
    })
  }
})
```

Note that we use [`defu`](https://github.com/unjs/defu){rel="nofollow"} to extend the public runtime configuration the user provides instead of overwriting it.

You can then access your module options in a plugin, component, the application like any other runtime configuration:

```js
const options = useRuntimeConfig().public.myModule
```

::warning
Be careful not to expose any sensitive module configuration on the public runtime config, such as private API keys, as they will end up in the public bundle.
::

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/passing-and-exposing-module-options?friend=nuxt
---
Watch Vue School video about passing and exposing Nuxt module options.
::

#### Injecting Plugins With `addPlugin`

Plugins are a common way for a module to add runtime logic. You can use the `addPlugin` utility to register them from your module.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // Create resolver to resolve relative paths
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
  }
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/kit"}
::

#### Injecting Vue Components With `addComponent`

If your module should provide Vue components, you can use the `addComponent` utility to add them as auto-imports for Nuxt to resolve.

```js
import { defineNuxtModule, addComponent } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // From the runtime directory
    addComponent({
      name: 'MySuperComponent', // name of the component to be used in vue templates
      export: 'MySuperComponent', // (optional) if the component is a named (rather than default) export
      filePath: resolver.resolve('runtime/components/MySuperComponent.vue')
    })

    // From a library
    addComponent({
      name: 'MyAwesomeComponent', // name of the component to be used in vue templates
      export: 'MyAwesomeComponent', // (optional) if the component is a named (rather than default) export
      filePath: '@vue/awesome-components'
    })
  }
})
```

Alternatively, you can add an entire directory by using `addComponentsDir`.

```ts
import { defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addComponentsDir({
      path: resolver.resolve('runtime/components')
    })
  }
})
```

#### Injecting Composables With `addImports` and `addImportsDir`

If your module should provide composables, you can use the `addImports` utility to add them as auto-imports for Nuxt to resolve.

```ts
import { defineNuxtModule, addImports, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports({
      name: 'useComposable', // name of the composable to be used
      as: 'useComposable',
      from: resolver.resolve('runtime/composables/useComposable') // path of composable
    })
  }
})
```

Alternatively, you can add an entire directory by using `addImportsDir`.

```ts
import { defineNuxtModule, addImportsDir, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImportsDir(resolver.resolve('runtime/composables'))
  }
})
```

#### Injecting Server Routes With `addServerHandler`

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello',
      handler: resolver.resolve('./runtime/server/api/hello/index.get')
    })
  }
})
```

You can also add a dynamic server route:

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello/:name',
      handler: resolver.resolve('./runtime/server/api/hello/[name].get')
    })
  }
})
```

#### Injecting Other Assets

If your module should provide other kinds of assets, they can also be injected. Here's a simple example module injecting a stylesheet through Nuxt's `css` array.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.options.css.push(resolver.resolve('./runtime/style.css'))
  }
})
```

And a more advanced one, exposing a folder of assets through [Nitro](https://nuxt.com/docs/guide/concepts/server-engine)'s `publicAssets` option:

```js
import { defineNuxtModule, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('nitro:config', async (nitroConfig) => {
      nitroConfig.publicAssets ||= []
      nitroConfig.publicAssets.push({
        dir: resolver.resolve('./runtime/public'),
        maxAge: 60 * 60 * 24 * 365 // 1 year
      })
    })
  }
})
```

#### Using Other Modules in Your Module

If your module depends on other modules, you can add them by using Nuxt Kit's `installModule` utility. For example, if you wanted to use Nuxt Tailwind in your module, you could add it as below:

```ts
import { defineNuxtModule, createResolver, installModule } from '@nuxt/kit'

export default defineNuxtModule<ModuleOptions>({
  async setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // We can inject our CSS file which includes Tailwind's directives
    nuxt.options.css.push(resolver.resolve('./runtime/assets/styles.css'))

    await installModule('@nuxtjs/tailwindcss', {
      // module configuration
      exposeConfig: true,
      config: {
        darkMode: 'class',
        content: {
          files: [
            resolver.resolve('./runtime/components/**/*.{vue,mjs,ts}'),
            resolver.resolve('./runtime/*.{mjs,js,ts}')
          ]
        }
      }
    })
  }
})
```

#### Using Hooks

[Lifecycle hooks](https://nuxt.com/docs/guide/going-further/hooks) allow you to expand almost every aspect of Nuxt. Modules can hook to them programmatically or through the `hooks` map in their definition.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  // Hook to the `app:error` hook through the `hooks` map
  hooks: {
    'app:error': (err) => {
      console.info(`This error happened: ${err}`);
    }
  },
  setup (options, nuxt) {
    // Programmatically hook to the `pages:extend` hook
    nuxt.hook('pages:extend', (pages) => {
      console.info(`Discovered ${pages.length} pages`);
    })
  }
})
```

::read-more{to="https://nuxt.com/docs/api/advanced/hooks"}
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/nuxt-lifecycle-hooks?friend=nuxt
---
Watch Vue School video about using Nuxt lifecycle hooks in modules.
::

::note
**Module cleanup**

:br

:br

If your module opens, handles, or starts a watcher, you should close it when the Nuxt lifecycle is done. The `close` hook is available for this.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async nuxt => {
      // Your custom code here
    })
  }
})
```
::

##### Custom Hooks

Modules can also define and call their own hooks, which is a powerful pattern for making your module extensible.

If you expect other modules to be able to subscribe to your module's hooks, you should call them in the `modules:done` hook. This ensures that all other modules have had a chance to be set up and register their listeners to your hook during their own `setup` function.

```ts
// my-module/module.ts
import { defineNuxtModule } from '@nuxt/kit'

export interface ModuleHooks {
  'my-module:custom-hook': (payload: { foo: string }) => void
}

export default defineNuxtModule({
  setup (options, nuxt) {
    // Call your hook in `modules:done`
    nuxt.hook('modules:done', async () => {
      const payload = { foo: 'bar' }
      await nuxt.callHook('my-module:custom-hook', payload)
    })
  }
})
```

#### Adding Templates/Virtual Files

If you need to add a virtual file that can be imported into the user's app, you can use the `addTemplate` utility.

```ts
import { defineNuxtModule, addTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // The file is added to Nuxt's internal virtual file system and can be imported from '#build/my-module-feature.mjs'
    addTemplate({
      filename: 'my-module-feature.mjs',
      getContents: () => 'export const myModuleFeature = () => "hello world !"'
    })
  }
})
```

For the server, you should use the `addServerTemplate` utility instead.

```ts
import { defineNuxtModule, addServerTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // The file is added to Nitro's virtual file system and can be imported in the server code from 'my-server-module.mjs'
    addServerTemplate({
      filename: 'my-server-module.mjs',
      getContents: () => 'export const myServerModule = () => "hello world !"'
    })
  }
})
```

#### Adding Type Declarations

You might also want to add a type declaration to the user's project (for example, to augment a Nuxt interface
or provide a global type of your own). For this, Nuxt provides the `addTypeTemplate` utility that both
writes a template to the disk and adds a reference to it in the generated `nuxt.d.ts` file.

If your module should augment types handled by Nuxt, you can use `addTypeTemplate` to perform this operation:

```js
import { defineNuxtModule, addTemplate, addTypeTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    addTypeTemplate({
      filename: 'types/my-module.d.ts',
      getContents: () => `// Generated by my-module
        interface MyModuleNitroRules {
          myModule?: { foo: 'bar' }
        }
        declare module 'nitropack/types' {
          interface NitroRouteRules extends MyModuleNitroRules {}
          interface NitroRouteConfig extends MyModuleNitroRules {}
        }
        export {}`
    })
  }
})
```

If you need more granular control, you can use the `prepare:types` hook to register a callback that will inject your types.

```ts
const template = addTemplate({ /* template options */ })
nuxt.hook('prepare:types', ({ references }) => {
  references.push({ path: template.dst })
})
```

##### Updating Templates

If you need to update your templates/virtual files, you can leverage the `updateTemplates` utility like this :

```ts
nuxt.hook('builder:watch', async (event, path) => {
  if (path.includes('my-module-feature.config')) {
    // This will reload the template that you registered
    updateTemplates({ filter: t => t.filename === 'my-module-feature.mjs' })
  }
})
```

### Testing

Testing helps ensuring your module works as expected given various setup. Find in this section how to perform various kinds of tests against your module.

#### Unit and Integration

::tip
We're still discussing and exploring how to ease unit and integration testing on Nuxt Modules.
:br :br[Check out this RFC to join the conversation](https://github.com/nuxt/nuxt/discussions/18399){rel="nofollow"}.
::

#### End to End

[Nuxt Test Utils](https://nuxt.com/docs/getting-started/testing) is the go-to library to help you test your module in an end-to-end way. Here's the workflow to adopt with it:

1. Create a Nuxt application to be used as a "fixture" inside `test/fixtures/*`
2. Setup Nuxt with this fixture inside your test file
3. Interact with the fixture using utilities from `@nuxt/test-utils` (e.g. fetching a page)
4. Perform checks related to this fixture (e.g. "HTML contains ...")
5. Repeat

In practice, the fixture:

```js [test/fixtures/ssr/nuxt.config.ts]
// 1. Create a Nuxt application to be used as a "fixture"
import MyModule from '../../../src/module'

export default defineNuxtConfig({
  ssr: true,
  modules: [
    MyModule
  ]
})
```

And its test:

```js [test/rendering.ts]
import { describe, it, expect } from 'vitest'
import { fileURLToPath } from 'node:url'
import { setup, $fetch } from '@nuxt/test-utils/e2e'

describe('ssr', async () => {
  // 2. Setup Nuxt with this fixture inside your test file
  await setup({
    rootDir: fileURLToPath(new URL('./fixtures/ssr', import.meta.url)),
  })

  it('renders the index page', async () => {
    // 3. Interact with the fixture using utilities from `@nuxt/test-utils`
    const html = await $fetch('/')

    // 4. Perform checks related to this fixture
    expect(html).toContain('<div>ssr</div>')
  })
})

// 5. Repeat
describe('csr', async () => { /* ... */ })
```

::tip
An example of such a workflow is available on [the module starter](https://github.com/nuxt/starter/blob/module/test/basic.test.ts){rel="nofollow"}.
::

#### Manual QA With Playground and Externally

Having a playground Nuxt application to test your module when developing it is really useful. [The module starter integrates one for that purpose](https://nuxt.com/#how-to-develop).

You can test your module with other Nuxt applications (applications that are not part of your module repository) locally. To do so, you can use [`npm pack`](https://docs.npmjs.com/cli/commands/npm-pack){rel="nofollow"} command, or your package manager equivalent, to create a tarball from your module. Then in your test project, you can add your module to `package.json` packages as: `"my-module": "file:/path/to/tarball.tgz"`.

After that, you should be able to reference `my-module` like in any regular project.

### Best Practices

With great power comes great responsibility. While modules are powerful, here are some best practices to keep in mind while authoring modules to keep applications performant and developer experience great.

#### Async Modules

As we've seen, Nuxt Modules can be asynchronous. For example, you may want to develop a module that needs fetching some API or calling an async function.

However, be careful with asynchronous behaviors as Nuxt will wait for your module to setup before going to the next module and starting the development server, build process, etc. Prefer deferring time-consuming logic to Nuxt hooks.

::warning
If your module takes more than **1 second** to setup, Nuxt will emit a warning about it.
::

#### Always Prefix Exposed Interfaces

Nuxt Modules should provide an explicit prefix for any exposed configuration, plugin, API, composable, or component to avoid conflict with other modules and internals.

Ideally, you should prefix them with your module's name (e.g. if your module is called `nuxt-foo`, expose `<FooButton>` and `useFooBar()` and **not** `<Button>` and `useBar()`).

#### Use Lifecycle Hooks for One-Time Setup

When your module needs to perform one-time setup tasks (like generating configuration files, setting up databases, or installing dependencies), use lifecycle hooks instead of running the logic in your main `setup` function.

```ts
import { addServerHandler, defineNuxtModule } from 'nuxt/kit'
import semver from 'semver'

export default defineNuxtModule({
  meta: {
    name: 'my-database-module',
    version: '1.0.0',
  },
  async onInstall (nuxt) {
    // One-time setup: create database schema, generate config files, etc.
    await generateDatabaseConfig(nuxt.options.rootDir)
  },
  async onUpgrade (options, nuxt, previousVersion) {
    // Handle version-specific migrations
    if (semver.lt(previousVersion, '1.0.0')) {
      await migrateLegacyData()
    }
  },
  setup (options, nuxt) {
    // Regular setup logic that runs on every build
    addServerHandler({ /* ... */ })
  },
})
```

This pattern prevents unnecessary work on every build and provides a better developer experience. See the [lifecycle hooks documentation](https://nuxt.com/docs/api/kit/modules#using-lifecycle-hooks-for-module-installation-and-upgrade) for more details.

#### Be TypeScript Friendly

Nuxt has first-class TypeScript integration for the best developer experience.

Exposing types and using TypeScript to develop modules benefits users even when not using TypeScript directly.

#### Avoid CommonJS Syntax

Nuxt relies on native ESM. Please read [Native ES Modules](https://nuxt.com/docs/guide/concepts/esm) for more information.

#### Document Module Usage

Consider documenting module usage in the readme file:

- Why use this module?
- How to use this module?
- What does this module do?

Linking to the integration website and documentation is always a good idea.

#### Provide a StackBlitz Demo or Boilerplate

It's a good practice to make a minimal reproduction with your module and [StackBlitz](https://nuxt.new/s/v4){rel="nofollow"} that you add to your module readme.

This not only provides potential users of your module a quick and easy way to experiment with the module but also an easy way for them to build minimal reproductions they can send you when they encounter issues.

#### Do Not Advertise With a Specific Nuxt Version

Nuxt, Nuxt Kit, and other new toolings are made to have both forward and backward compatibility in mind.

Please use "X for Nuxt" instead of "X for Nuxt 3" to avoid fragmentation in the ecosystem and prefer using `meta.compatibility` to set Nuxt version constraints.

#### Stick With Starter Defaults

The module starter comes with a default set of tools and configurations (e.g. ESLint configuration). If you plan on open-sourcing your module, sticking with those defaults ensures your module shares a consistent coding style with other [community modules](https://nuxt.com/modules) out there, making it easier for others to contribute.

## Ecosystem

[Nuxt Module ecosystem](https://nuxt.com/modules) represents more than 15 million monthly NPM downloads and provides extended functionalities and integrations with all sort of tools. You can be part of this ecosystem!

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/exploring-nuxt-modules-ecosystem-and-module-types?friend=nuxt
---
Watch Vue School video about Nuxt module types.
::

### Module Types

**Official modules** are modules prefixed (scoped) with `@nuxt/` (e.g. [`@nuxt/content`](https://content.nuxtjs.org){rel="nofollow"}). They are made and maintained actively by the Nuxt team. Like with the framework, contributions from the community are more than welcome to help make them better!

**Community modules** are modules prefixed (scoped) with `@nuxtjs/` (e.g. [`@nuxtjs/tailwindcss`](https://tailwindcss.nuxtjs.org){rel="nofollow"}). They are proven modules made and maintained by community members. Again, contributions are welcome from anyone.

**Third-party and other community modules** are modules (often) prefixed with `nuxt-`. Anyone can make them, using this prefix allows these modules to be discoverable on npm. This is the best starting point to draft and try an idea!

**Private or personal modules** are modules made for your own use case or company. They don't need to follow any naming rules to work with Nuxt and are often seen scoped under an npm organization (e.g. `@my-company/nuxt-auth`)

### Listing Your Community Module

Any community modules are welcome to be listed on [the module list](https://nuxt.com/modules). To be listed, [open an issue in the nuxt/modules](https://github.com/nuxt/modules/issues/new?template=module_request.yml){rel="nofollow"} repository. The Nuxt team can help you to apply best practices before listing.

### Joining `nuxt-modules` and `@nuxtjs/`

By moving your modules to [nuxt-modules](https://github.com/nuxt-modules){rel="nofollow"}, there is always someone else to help, and this way, we can join forces to make one perfect solution.

If you have an already published and working module, and want to transfer it to `nuxt-modules`, [open an issue in nuxt/modules](https://github.com/nuxt/modules/issues/new){rel="nofollow"}.

By joining `nuxt-modules` we can rename your community module under the `@nuxtjs/` scope and provide a subdomain (e.g. `my-module.nuxtjs.org`) for its documentation.


# Nuxt Kit

Nuxt Kit provides composable utilities to make interacting with [Nuxt Hooks](https://nuxt.com/docs/api/advanced/hooks), the [Nuxt Interface](https://nuxt.com/docs/guide/going-further/internals#the-nuxt-interface) and developing [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules) super easy.

::read-more{to="https://nuxt.com/docs/api/kit"}
Discover all Nuxt Kit utilities.
::

## Usage

### Install Dependency

You can install the latest Nuxt Kit by adding it to the `dependencies` section of your `package.json`. However, please consider always explicitly installing the `@nuxt/kit` package even if it is already installed by Nuxt.

::note
`@nuxt/kit` and `@nuxt/schema` are key dependencies for Nuxt. If you are installing it separately, make sure that the versions of `@nuxt/kit` and `@nuxt/schema` are equal to or greater than your `nuxt` version to avoid any unexpected behavior.
::

```json [package.json]
{
  "dependencies": {
    "@nuxt/kit": "npm:@nuxt/kit-nightly@latest"
  }
}
```

### Import Kit Utilities

```js [test.mjs]
import { useNuxt } from '@nuxt/kit'
```

::read-more{to="https://nuxt.com/docs/api/kit"}
::

::note
Nuxt Kit utilities are only available for modules and not meant to be imported in runtime (components, Vue composables, pages, plugins, or server routes).
::

Nuxt Kit is an [esm-only package](https://nuxt.com/docs/guide/concepts/esm) meaning that you **cannot** `require('@nuxt/kit')`. As a workaround, use dynamic import in the CommonJS context:

```js [test.cjs]
// This does NOT work!
// const kit = require('@nuxt/kit')
async function main() {
  const kit = await import('@nuxt/kit')
}
main()
```


# NuxtApp

In Nuxt, you can access runtime app context within composables, components and plugins.

::read-more
---
target: _blank
to: https://v2.nuxt.com/docs/internals-glossary/context#the-context
---
In Nuxt 2, this was referred to as **Nuxt context**.
::

## Nuxt App Interface

::read-more
---
to: https://nuxt.com/docs/guide/going-further/internals#the-nuxtapp-interface
---
Jump over the `NuxtApp` interface documentation.
::

## The Nuxt Context

Many composables and utilities, both built-in and user-made, may require access to the Nuxt instance. This doesn't exist everywhere on your application, because a fresh instance is created on every request.

Currently, the Nuxt context is only accessible in [plugins](https://nuxt.com/docs/guide/directory-structure/plugins), [Nuxt hooks](https://nuxt.com/docs/guide/going-further/hooks), [Nuxt middleware](https://nuxt.com/docs/guide/directory-structure/app/middleware) (if wrapped in `defineNuxtRouteMiddleware`), and [setup functions](https://vuejs.org/api/composition-api-setup.html){rel="nofollow"} (in pages and components).

If a composable is called without access to the context, you may get an error stating that 'A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function.' In that case, you can also explicitly call functions within this context by using [`nuxtApp.runWithContext`](https://nuxt.com/docs/api/composables/use-nuxt-app#runwithcontext).

## Accessing NuxtApp

Within composables, plugins and components you can access `nuxtApp` with [`useNuxtApp()`](https://nuxt.com/docs/api/composables/use-nuxt-app):

```ts [app/composables/useMyComposable.ts]
export function useMyComposable () {
  const nuxtApp = useNuxtApp()
  // access runtime nuxt app instance
}
```

If your composable does not always need `nuxtApp` or you simply want to check if it is present or not, since [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) throws an exception, you can use [`tryUseNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app#tryusenuxtapp) instead.

Plugins also receive `nuxtApp` as the first argument for convenience.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

## Providing Helpers

You can provide helpers to be usable across all composables and application. This usually happens within a Nuxt plugin.

```ts
const nuxtApp = useNuxtApp()
nuxtApp.provide('hello', (name) => `Hello ${name}!`)

console.log(nuxtApp.$hello('name')) // Prints "Hello name!"
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/plugins#providing-helpers
---
It is possible to inject helpers by returning an object with a `provide` key in plugins.
::

::read-more
---
target: _blank
to: https://v2.nuxt.com/docs/directory-structure/plugins#inject-in-root--context
---
In Nuxt 2 plugins, this was referred to as **inject function**.
::


# Authoring Nuxt Layers

Nuxt layers are a powerful feature that you can use to share and reuse partial Nuxt applications within a monorepo, or from a git repository or npm package. The layers structure is almost identical to a standard Nuxt application, which makes them easy to author and maintain.

::read-more{to="https://nuxt.com/docs/getting-started/layers"}
::

A minimal Nuxt layer directory should contain a [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file to indicate it is a layer.

```ts [base/nuxt.config.ts]
export default defineNuxtConfig({})
```

Additionally, certain other files in the layer directory will be auto-scanned and used by Nuxt for the project extending this layer.

- [`app/components/*`](https://nuxt.com/docs/guide/directory-structure/app/components) - Extend the default components
- [`app/composables/*`](https://nuxt.com/docs/guide/directory-structure/app/composables) - Extend the default composables
- [`app/layouts/*`](https://nuxt.com/docs/guide/directory-structure/app/layouts) - Extend the default layouts
- [`app/middleware/*`](https://nuxt.com/docs/guide/directory-structure/app/middleware) - Extend the default middleware
- [`app/pages/*`](https://nuxt.com/docs/guide/directory-structure/app/pages) - Extend the default pages
- [`app/plugins/*`](https://nuxt.com/docs/guide/directory-structure/plugins) - Extend the default plugins
- [`app/utils/*`](https://nuxt.com/docs/guide/directory-structure/app/utils) - Extend the default utils
- [`app/app.config.ts`](https://nuxt.com/docs/guide/directory-structure/app-config) - Extend the default app config
- [`server/*`](https://nuxt.com/docs/guide/directory-structure/server) - Extend the default server endpoints & middleware
- [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config)- Extend the default nuxt config

## Basic Example

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    './base'
  ]
})
```

```vue [app/app.vue]
  <template>
    <BaseComponent/>
  </template>
```

```ts [base/nuxt.config.ts]
  export default defineNuxtConfig({
    // Extending from base nuxt.config.ts!
    app: {
      head: {
        title: 'Extending Configs is Fun!',
        meta: [
          { name: 'description', content: 'I am using the extends feature in Nuxt!' }
        ],
      }
    }
  })
```

```vue [base/app/components/BaseComponent.vue]
  <template>
    <h1>Extending Components is Fun!</h1>
  </template>
```
::

## Layer Priority

When extending from multiple layers, it's important to understand the priority order:

1. **Layers in `extends`** - earlier entries have higher priority (first overrides second)
2. **Auto-scanned local layers** from `~~/layers` directory in alphabetical order (Z overrides A)
3. **Your project** has the highest priority in the stack - it will always override other layers

For example:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    './layers/base',      // Highest priority (among extends)
    './layers/theme',     // Medium priority  
    './layers/custom'     // Lower priority
  ]
  // Your project has the highest priority
})
```

If you also have auto-scanned layers like `~~/layers/a` and `~~/layers/z`, the complete override order would be: `base` > `theme` > `custom` > `z` > `a` > your project.

## Starter Template

To get started you can initialize a layer with the [nuxt/starter/layer template](https://github.com/nuxt/starter/tree/layer){rel="nofollow"}. This will create a basic structure you can build upon. Execute this command within the terminal to get started:

```bash [Terminal]
npm create nuxt -- --template layer nuxt-layer
```

Follow up on the README instructions for the next steps.

## Publishing Layers

You can publish and share layers by either using a remote source or an npm package.

### Git Repository

You can use a git repository to share your Nuxt layer. Some examples:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    'github:username/repoName',        // GitHub Remote Source
    'github:username/repoName/base',   // GitHub Remote Source within /base directory
    'github:username/repoName#dev',    // GitHub Remote Source from dev branch
    'github:username/repoName#v1.0.0', // GitHub Remote Source from v1.0.0 tag
    'gitlab:username/repoName',        // GitLab Remote Source example
    'bitbucket:username/repoName',     // Bitbucket Remote Source example
  ]
})
```

::tip
If you want to extend a private remote source, you need to add the environment variable `GIGET_AUTH=<token>` to provide a token.
::

::tip
If you want to extend a remote source from a self-hosted GitHub or GitLab instance, you need to supply its URL with the `GIGET_GITHUB_URL=<url>` or `GIGET_GITLAB_URL=<url>` environment variable - or directly configure it with [the `auth` option](https://github.com/unjs/c12#extending-config-layer-from-remote-sources){rel="nofollow"} in your `nuxt.config`.
::

::warning
Bear in mind that if you are extending a remote source as a layer, you will not be able to access its dependencies outside of Nuxt. For example, if the remote layer depends on an eslint plugin, this will not be usable in your eslint config. That is because these dependencies will be located in a special location (`node_modules/.c12/layer_name/node_modules/`) that is not accessible to your package manager.
::

::note
When using git remote sources, if a layer has npm dependencies and you wish to install them, you can do so by specifying `install: true` in your layer options.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    ['github:username/repoName', { install: true }]
  ]
})
```
::

### npm Package

You can publish Nuxt layers as an npm package that contains the files and dependencies you want to extend. This allows you to share your config with others, use it in multiple projects or use it privately.

To extend from an npm package, you need to make sure that the module is published to npm and installed in the user's project as a devDependency. Then you can use the module name to extend the current nuxt config:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // Node Module with scope
    '@scope/moduleName',
    // or just the module name
    'moduleName'
  ]
})
```

To publish a layer directory as an npm package, you want to make sure that the `package.json` has the correct properties filled out. This will make sure that the files are included when the package is published.

```json [package.json]
{
  "name": "my-theme",
  "version": "1.0.0",
  "type": "module",
  "main": "./nuxt.config.ts",
  "dependencies": {},
  "devDependencies": {
    "nuxt": "^3.0.0"
  }
}
```

::important
Make sure any dependency imported in the layer is **explicitly added** to the `dependencies`. The `nuxt` dependency, and anything only used for testing the layer before publishing, should remain in the `devDependencies` field.
::

Now you can proceed to publish the module to npm, either publicly or privately.

::important
When publishing the layer as a private npm package, you need to make sure you log in, to authenticate with npm to download the node module.
::

## Tips

### Named Layer Aliases

Auto-scanned layers (from your `~~/layers` directory) automatically create aliases. For example, you can access your `~~/layers/test` layer via `#layers/test`.

If you want to create named layer aliases for other layers, you can specify a name in the configuration of the layer.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  $meta: {
    name: 'example',
  },
})
```

This will produce an alias of `#layers/example` which points to your layer.

### Relative Paths and Aliases

When importing using global aliases (such as `~/` and `@/`) in a layer components and composables, note that these aliases are resolved relative to the user's project paths. As a workaround, you can **use relative paths** to import them, or use named layer aliases.

Also when using relative paths in `nuxt.config` file of a layer, (with exception of nested `extends`) they are resolved relative to user's project instead of the layer. As a workaround, use full resolved paths in `nuxt.config`:

```js [nuxt.config.ts]
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  css: [
    join(currentDir, './app/assets/main.css')
  ]
})
```

## Multi-Layer Support for Nuxt Modules

You can use the internal array `nuxt.options._layers` to support custom multi-layer handling for your modules.

```ts [modules/my-module.ts]
export default defineNuxtModule({
  setup(_options, nuxt) {
    for (const layer of nuxt.options._layers) {
      // You can check for a custom directory existence to extend for each layer
      console.log('Custom extension for', layer.cwd, layer.config)
    }
  }
})
```

**Notes:**

- Earlier items in the `_layers` array have higher priority and override later ones
- The user's project is the first item in the `_layers` array

## Going Deeper

Configuration loading and extends support is handled by [unjs/c12](https://github.com/unjs/c12){rel="nofollow"}, merged using [unjs/defu](https://github.com/unjs/defu){rel="nofollow"} and remote git sources are supported using [unjs/giget](https://github.com/unjs/giget){rel="nofollow"}. Check the docs and source code to learn more.

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/issues/13367
---
Checkout our ongoing development to bring more improvements for layers support on GitHub.
::


# Debugging

## Sourcemaps

Sourcemaps are enabled for your server build by default, and for the client build in dev mode, but you can enable them more specifically in your configuration.

```ts
export default defineNuxtConfig({
  // or sourcemap: true
  sourcemap: {
    server: true,
    client: true
  }
})
```

## Debugging with Node Inspector

You can use [Node inspector](https://nodejs.org/en/learn/getting-started/debugging){rel="nofollow"} to debug Nuxt server-side.

```bash
nuxt dev --inspect
```

This will start Nuxt in `dev` mode with debugger active. If everything is working correctly a Node.js icon will appear on your Chrome DevTools and you can attach to the debugger.

::important
Note that the Node.js and Chrome processes need to be run on the same platform. This doesn't work inside of Docker.
::

## Debugging in Your IDE

It is possible to debug your Nuxt app in your IDE while you are developing it.

### Example VS Code Debug Configuration

You may need to update the config below with a path to your web browser. For more information, visit the [VS Code documentation about debug configuration](https://go.microsoft.com/fwlink/?linkid=830387){rel="nofollow"}.

```json5
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  "version": "0.2.0",
  "configurations": [
    {
      "type": "chrome",
      "request": "launch",
      "name": "client: chrome",
      "url": "http://localhost:3000",
      // this should point to your Nuxt `srcDir`, which is `app` by default
      "webRoot": "${workspaceFolder}/app"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "server: nuxt",
      "outputCapture": "std",
      "program": "${workspaceFolder}/node_modules/nuxt/bin/nuxt.mjs",
      "args": [
        "dev"
      ],
    }
  ],
  "compounds": [
    {
      "name": "fullstack: nuxt",
      "configurations": [
        "server: nuxt",
        "client: chrome"
      ]
    }
  ]
}
```

If you prefer your usual browser extensions, add this to the *chrome* configuration above:

```json5
"userDataDir": false,
```

### Example JetBrains IDEs Debug Configuration

You can also debug your Nuxt app in JetBrains IDEs such as IntelliJ IDEA, WebStorm, or PhpStorm.

1. Create a new file in your project root directory and name it `nuxt.run.xml`.
2. Open the `nuxt.run.xml` file and paste the following debug configuration:

```html
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="client: chrome" type="JavascriptDebugType" uri="http://localhost:3000" useFirstLineBreakpoints="true">
    <method v="2" />
  </configuration>

  <configuration default="false" name="server: nuxt" type="NodeJSConfigurationType" application-parameters="dev" path-to-js-file="$PROJECT_DIR$/node_modules/nuxt/bin/nuxt.mjs" working-dir="$PROJECT_DIR$">
    <method v="2" />
  </configuration>

  <configuration default="false" name="fullstack: nuxt" type="CompoundRunConfigurationType">
    <toRun name="client: chrome" type="JavascriptDebugType" />
    <toRun name="server: nuxt" type="NodeJSConfigurationType" />
    <method v="2" />
  </configuration>
</component>
```

### Other IDEs

If you have another IDE and would like to contribute sample configuration, feel free to [open a PR](https://github.com/nuxt/nuxt/edit/main/docs/2.guide/3.going-further/9.debugging.md){rel="nofollow"}!




# Custom Routing

## Adding custom routes

In Nuxt, your routing is defined by the structure of your files inside the [app/pages directory](https://nuxt.com/docs/guide/directory-structure/app/pages). However, since it uses [vue-router](https://router.vuejs.org){rel="nofollow"} under the hood, Nuxt offers you several ways to add custom routes in your project.

### Router Config

Using [router options](https://nuxt.com/docs/guide/recipes/custom-routing#router-options), you can optionally override or extend your routes using a function that accepts the scanned routes and returns customized routes.

If it returns `null` or `undefined`, Nuxt will fall back to the default routes (useful to modify input array).

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'

export default {
  // https://router.vuejs.org/api/interfaces/routeroptions.html#routes
  routes: (_routes) => [
    {
      name: 'home',
      path: '/',
      component: () => import('~/pages/home.vue')
    }
  ],
} satisfies RouterConfig
```

::note
Nuxt will not augment any new routes you return from the `routes` function with metadata defined in `definePageMeta` of the component you provide. If you want that to happen, you should use the `pages:extend` hook which is [called at build-time](https://nuxt.com/docs/api/advanced/hooks#nuxt-hooks-build-time).
::

### Pages Hook

You can add, change or remove pages from the scanned routes with the `pages:extend` nuxt hook.

For example, to prevent creating routes for any `.ts` files:

```ts [nuxt.config.ts]
import type { NuxtPage } from '@nuxt/schema'

export default defineNuxtConfig({
  hooks: {
    'pages:extend' (pages) {
      // add a route
      pages.push({
        name: 'profile',
        path: '/profile',
        file: '~/extra-pages/profile.vue'
      })

      // remove routes
      function removePagesMatching (pattern: RegExp, pages: NuxtPage[] = []) {
        const pagesToRemove: NuxtPage[] = []
        for (const page of pages) {
          if (page.file && pattern.test(page.file)) {
            pagesToRemove.push(page)
          } else {
            removePagesMatching(pattern, page.children)
          }
        }
        for (const page of pagesToRemove) {
          pages.splice(pages.indexOf(page), 1)
        }
      }
      removePagesMatching(/\.ts$/, pages)
    }
  }
})
```

### Nuxt Module

If you plan to add a whole set of pages related with a specific functionality, you might want to use a [Nuxt module](https://nuxt.com/modules).

The [Nuxt kit](https://nuxt.com/docs/guide/going-further/kit) provides a few ways [to add routes](https://nuxt.com/docs/api/kit/pages):

- [`extendPages`](https://nuxt.com/docs/api/kit/pages#extendpages) (callback: pages => void)
- [`extendRouteRules`](https://nuxt.com/docs/api/kit/pages#extendrouterules) (route: string, rule: NitroRouteConfig, options: ExtendRouteRulesOptions)

## Router Options

On top of customizing options for [`vue-router`](https://router.vuejs.org/api/interfaces/routeroptions.html){rel="nofollow"}, Nuxt offers [additional options](https://nuxt.com/docs/api/nuxt-config#router) to customize the router.

### Using `router.options`

This is the recommended way to specify [router options](https://nuxt.com/docs/api/nuxt-config#router).

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'

export default {
} satisfies RouterConfig
```

It is possible to add more router options files by adding files within the `pages:routerOptions` hook. Later items in the array override earlier ones.

::callout
Adding a router options file in this hook will switch on page-based routing, unless `optional` is set, in which case it will only apply when page-based routing is already enabled.
::

```ts [nuxt.config.ts]
import { createResolver } from '@nuxt/kit'

export default defineNuxtConfig({
  hooks: {
    'pages:routerOptions' ({ files }) {
      const resolver = createResolver(import.meta.url)
      // add a route
      files.push({
        path: resolver.resolve('./runtime/router-options'),
        optional: true
      })
    }
  }
})
```

### Using `nuxt.config`

**Note:** Only JSON serializable [options](https://nuxt.com/docs/api/nuxt-config#router) are configurable:

- `linkActiveClass`
- `linkExactActiveClass`
- `end`
- `sensitive`
- `strict`
- `hashMode`
- `scrollBehaviorType`

```js [nuxt.config]
export default defineNuxtConfig({
  router: {
    options: {}
  }
})
```

### Hash Mode (SPA)

You can enable hash history in SPA mode using the `hashMode` [config](https://nuxt.com/docs/api/nuxt-config#router). In this mode, router uses a hash character (#) before the actual URL that is internally passed. When enabled, the **URL is never sent to the server** and **SSR is not supported**.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
  router: {
    options: {
      hashMode: true
    }
  }
})
```

### Scroll Behavior for hash links

You can optionally customize the scroll behavior for hash links. When you set the [config](https://nuxt.com/docs/api/nuxt-config#router) to be `smooth` and you load a page with a hash link (e.g. `https://example.com/blog/my-article#comments`), you will see that the browser smoothly scrolls to this anchor.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  router: {
    options: {
      scrollBehaviorType: 'smooth'
    }
  }
})
```

#### Custom History (advanced)

You can optionally override history mode using a function that accepts the base URL and returns the history mode. If it returns `null` or `undefined`, Nuxt will fallback to the default history.

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'
import { createMemoryHistory } from 'vue-router'

export default {
  // https://router.vuejs.org/api/interfaces/routeroptions.html
  history: base => import.meta.client ? createMemoryHistory(base) : null /* default */
} satisfies RouterConfig
```


# Using Vite Plugins in Nuxt

While Nuxt modules offer extensive functionality, sometimes a specific Vite plugin might meet your needs more directly.

First, we need to install the Vite plugin, for our example, we'll use `@rollup/plugin-yaml`:

::code-group{sync="pm"}
```bash [npm]
npm install @rollup/plugin-yaml
```

```bash [yarn]
yarn add @rollup/plugin-yaml
```

```bash [pnpm]
pnpm add @rollup/plugin-yaml
```

```bash [bun]
bun add @rollup/plugin-yaml
```
::

Next, we need to import and add it to our [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file:

```ts [nuxt.config.ts]
import yaml from '@rollup/plugin-yaml'

export default defineNuxtConfig({
  vite: {
    plugins: [
      yaml()
    ]
  }
})
```

Now we installed and configured our Vite plugin, we can start using YAML files directly in our project.

For example, we can have a `config.yaml` that stores configuration data and import this data in our Nuxt components:

::code-group
```yaml [data/hello.yaml]
greeting: "Hello, Nuxt with Vite!"
```

```vue [app/components/Hello.vue]
<script setup>
import config from '~/data/hello.yaml'
</script>

<template>
  <h1>{{ config.greeting }}</h1>
</template>
```
::


# Custom useFetch in Nuxt

When working with Nuxt, you might be making the frontend and fetching an external API, and you might want to set some default options for fetching from your API.

The [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) utility function (used by the [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) composable) is intentionally not globally configurable. This is important so that fetching behavior throughout your application remains consistent, and other integrations (like modules) can rely on the behavior of core utilities like `$fetch`.

However, Nuxt provides a way to create a custom fetcher for your API (or multiple fetchers if you have multiple APIs to call).

## Custom `$fetch`

Let's create a custom `$fetch` instance with a [Nuxt plugin](https://nuxt.com/docs/guide/directory-structure/plugins).

::note
`$fetch` is a configured instance of [ofetch](https://github.com/unjs/ofetch){rel="nofollow"} which supports adding the base URL of your Nuxt server as well as direct function calls during SSR (avoiding HTTP roundtrips).
::

Let's pretend here that:

- The main API is <https://api.nuxt.com>{rel="nofollow"}
- We are storing the JWT token in a session with [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils){rel="nofollow"}
- If the API responds with a `401` status code, we redirect the user to the `/login` page

```ts [app/plugins/api.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const { session } = useUserSession()

  const api = $fetch.create({
    baseURL: 'https://api.nuxt.com',
    onRequest({ request, options, error }) {
      if (session.value?.token) {
        // note that this relies on ofetch >= 1.4.0 - you may need to refresh your lockfile
        options.headers.set('Authorization', `Bearer ${session.value?.token}`)
      }
    },
    async onResponseError({ response }) {
      if (response.status === 401) {
        await nuxtApp.runWithContext(() => navigateTo('/login'))
      }
    }
  })

  // Expose to useNuxtApp().$api
  return {
    provide: {
      api
    }
  }
})
```

With this Nuxt plugin, `$api` is exposed from `useNuxtApp()` to make API calls directly from the Vue components:

```vue [app/app.vue]
<script setup>
const { $api } = useNuxtApp()
const { data: modules } = await useAsyncData('modules', () => $api('/modules'))
</script>
```

::callout
Wrapping with [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) **avoid double data fetching when doing server-side rendering** (server & client on hydration).
::

## Custom `useFetch`/`useAsyncData`

Now that `$api` has the logic we want, let's create a `useAPI` composable to replace the usage of `useAsyncData` + `$api`:

```ts [app/composables/useAPI.ts]
import type { UseFetchOptions } from 'nuxt/app'

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch(url, {
    ...options,
    $fetch: useNuxtApp().$api as typeof $fetch
  })
}
```

Let's use the new composable and have a nice and clean component:

```vue [app/app.vue]
<script setup>
const { data: modules } = await useAPI('/modules')
</script>
```

If you want to customize the type of any error returned, you can also do so:

```ts
import type { FetchError } from 'ofetch'
import type { UseFetchOptions } from 'nuxt/app'

interface CustomError {
  message: string
  statusCode: number
}

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch<T, FetchError<CustomError>>(url, {
    ...options,
    $fetch: useNuxtApp().$api
  })
}
```

::note
This example demonstrates how to use a custom `useFetch`, but the same structure is identical for a custom `useAsyncData`.
::

::link-example
---
to: https://nuxt.com/docs/examples/advanced/use-custom-fetch-composable
---
::

::video-accordion
---
title: Watch a video about custom $fetch and Repository Pattern in Nuxt
video-id: jXH8Tr-exhI
---
::

::note
We are currently discussing to find a cleaner way to let you create a custom fetcher, see <https://github.com/nuxt/nuxt/issues/14736>{rel="nofollow"}.
::


# Sessions and Authentication

## Introduction

In this recipe we'll be setting up authentication in a full-stack Nuxt app using [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils){rel="nofollow"} which provides convenient utilities for managing client-side and server-side session data.

The module uses secured & sealed cookies to store session data, so you don't need to setup a database to store session data.

## Install nuxt-auth-utils

Install the `nuxt-auth-utils` module using the `nuxt` CLI.

```bash [Terminal]
npx nuxt module add auth-utils
```

::callout
This command will install `nuxt-auth-utils` as dependency and push it in the `modules` section of our `nuxt.config.ts`
::

## Cookie Encryption Key

As `nuxt-auth-utils` uses sealed cookies to store session data, session cookies are encrypted using a secret key from the `NUXT_SESSION_PASSWORD` environment variable.

::note
If not set, this environment variable will be added to your `.env` automatically when running in development mode.
::

```ini [.env]
NUXT_SESSION_PASSWORD=a-random-password-with-at-least-32-characters
```

::important
You'll need to add this environment variable to your production environment before deploying.
::

## Login API Route

For this recipe, we'll create a simple API route to sign-in a user based on static data.

Let's create a `/api/login` API route that will accept a POST request with the email and password in the request body.

```ts [server/api/login.post.ts]
import { z } from 'zod'

const bodySchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
})

export default defineEventHandler(async (event) => {
  const { email, password } = await readValidatedBody(event, bodySchema.parse)

  if (email === 'admin@admin.com' && password === 'iamtheadmin') {
    // set the user session in the cookie
    // this server util is auto-imported by the auth-utils module
    await setUserSession(event, {
      user: {
        name: 'John Doe'
      }
    })
    return {}
  }
  throw createError({
    statusCode: 401,
    message: 'Bad credentials'
  })
})
```

::callout
Make sure to install the `zod` dependency in your project (`npm i zod`).
::

::tip{to="https://github.com/atinux/nuxt-auth-utils#server-utils"}
Read more about the `setUserSession` server helper exposed by `nuxt-auth-utils`.
::

## Login Page

The module exposes a Vue composable to know if a user is authenticated in our application:

```vue
<script setup>
const { loggedIn, session, user, clear, fetch } = useUserSession()
</script>
```

Let's create a login page with a form to submit the login data to our `/api/login` route.

```vue [app/pages/login.vue]
<script setup lang="ts">
const { loggedIn, user, fetch: refreshSession } = useUserSession()
const credentials = reactive({
  email: '',
  password: '',
})
async function login() {
  $fetch('/api/login', {
    method: 'POST',
    body: credentials
  })
  .then(async () => {
    // Refresh the session on client-side and redirect to the home page
    await refreshSession()
    await navigateTo('/')
  })
  .catch(() => alert('Bad credentials'))
}
</script>

<template>
  <form @submit.prevent="login">
    <input v-model="credentials.email" type="email" placeholder="Email" />
    <input v-model="credentials.password" type="password" placeholder="Password" />
    <button type="submit">Login</button>
  </form>
</template>
```

## Protect API Routes

Protecting server routes is key to making sure your data is safe. Client-side middleware is helpful for the user, but without server-side protection your data can still be accessed. It is critical to protect any routes with sensitive data, we should return a 401 error if the user is not logged in on those.

The `auth-utils` module provides the `requireUserSession` utility function to help make sure that users are logged in and have an active session.

Let's create an example of a `/api/user/stats` route that only authenticated users can access.

```ts [server/api/user/stats.get.ts]
export default defineEventHandler(async (event) => {
  // make sure the user is logged in
  // This will throw a 401 error if the request doesn't come from a valid user session
  const { user } = await requireUserSession(event)

  // TODO: Fetch some stats based on the user

  return {}
});
```

## Protect App Routes

Our data is safe with the server-side route in place, but without doing anything else, unauthenticated users would probably get some odd data when trying to access the `/users` page. We should create a [client-side middleware](https://nuxt.com/docs/guide/directory-structure/app/middleware){rel="nofollow"} to protect the route on the client side and redirect users to the login page.

`nuxt-auth-utils` provides a convenient `useUserSession` composable which we'll use to check if the user is logged in, and redirect them if they are not.

We'll create a middleware in the `/middleware` directory. Unlike on the server, client-side middleware is not automatically applied to all endpoints, and we'll need to specify where we want it applied.

```typescript [app/middleware/authenticated.ts]
export default defineNuxtRouteMiddleware(() => {
  const { loggedIn } = useUserSession()

  // redirect the user to the login screen if they're not authenticated
  if (!loggedIn.value) {
    return navigateTo('/login')
  }
})
```

## Home Page

Now that we have our app middleware to protect our routes, we can use it on our home page that display our authenticated user information. If the user is not authenticated, they will be redirected to the login page.

We'll use [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) to apply the middleware to the route that we want to protect.

```vue [app/pages/index.vue]
<script setup lang="ts">
definePageMeta({
  middleware: ['authenticated'],
})
  
const { user, clear: clearSession } = useUserSession()

async function logout() {
  await clearSession()
  await navigateTo('/login')
}
</script>

<template>
  <div>
    <h1>Welcome {{ user.name }}</h1>
    <button @click="logout">Logout</button>
  </div>
</template>
```

We also added a logout button to clear the session and redirect the user to the login page.

## Conclusion

We've successfully set up a very basic user authentication and session management in our Nuxt app. We've also protected sensitive routes on the server and client side to ensure that only authenticated users can access them.

As next steps, you can:

- Add authentication using the [20+ supported OAuth providers](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#supported-oauth-providers){rel="nofollow"}
- Add a database to store users, see [Nitro SQL Database](https://nitro.build/guide/database){rel="nofollow"} or [NuxtHub SQL Database](https://hub.nuxt.com/docs/features/database){rel="nofollow"}
- Let user signup with email & password using [password hashing](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#password-hashing){rel="nofollow"}
- Add support for [WebAuthn / Passkeys](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#webauthn-passkey){rel="nofollow"}

Checkout the open source [atidone repository](https://github.com/atinux/atidone){rel="nofollow"} for a full example of a Nuxt app with OAuth authentication, database and CRUD operations.


# Nuxt and hydration

When developing, you may face hydration issues. Don't ignore those warnings.

# Why is it important to fix them?

Hydration mismatches are not just warnings - they are indicators of serious problems that can break your application:

## Performance Impact

- **Increased time to interactive**: Hydration errors force Vue to re-render the entire component tree, which will increase the time for your Nuxt app to become interactive
- **Poor user experience**: Users may see content flashing or unexpected layout shifts

## Functionality Issues

- **Broken interactivity**: Event listeners may not attach properly, leaving buttons and forms non-functional
- **State inconsistencies**: Application state can become out of sync between what the user sees and what the application thinks is rendered
- **SEO problems**: Search engines may index different content than what users actually see

# How to detect them

## Development Console Warnings

Vue will log hydration mismatch warnings in the browser console during development:

![Screenshot of Vue hydration mismatch warning in the browser console](https://nuxt.com/assets/docs/best-practices/vue-console-hydration.png)

# Common reasons

## Browser-only APIs in Server Context

**Problem**: Using browser-specific APIs during server-side rendering.

```html
<template>
  <div>User preference: {{ userTheme }}</div>
</template>

<script setup>
// This will cause hydration mismatch!
// localStorage doesn't exist on the server!
const userTheme = localStorage.getItem('theme') || 'light'
</script>
```

**Solution**: You can use [`useCookie`](https://nuxt.com/docs/api/composables/use-cookie):

```html
<template>
  <div>User preference: {{ userTheme }}</div>
</template>

<script setup>
// This works on both server and client
const userTheme = useCookie('theme', { default: () => 'light' })
</script>
```

## Inconsistent Data

**Problem**: Different data between server and client.

```html
<template>
  <div>{{ Math.random() }}</div>
</template>
```

**Solution**: Use SSR-friendly state:

```html
<template>
  <div>{{ state }}</div>
</template>

<script setup>
const state = useState('random', () => Math.random())
</script>
```

## Conditional Rendering Based on Client State

**Problem**: Using client-only conditions during SSR.

```html
<template>
  <div v-if="window?.innerWidth > 768">
    Desktop content
  </div>
</template>
```

**Solution**: Use media queries or handle it client-side:

```html
<template>
  <div class="responsive-content">
    <div class="hidden md:block">Desktop content</div>
    <div class="md:hidden">Mobile content</div>
  </div>
</template>
```

## Third-party Libraries with Side Effects

**Problem**: Libraries that modify the DOM or have browser dependencies (this happens a LOT with tag managers).

```html
<script setup>
if (import.meta.client) {
    const { default: SomeBrowserLibrary } = await import('browser-only-lib')
    SomeBrowserLibrary.init()
}
</script>
```

**Solution**: Initialise libraries after hydration has completed:

```html
<script setup>
onMounted(async () => {
  const { default: SomeBrowserLibrary } = await import('browser-only-lib')
  SomeBrowserLibrary.init()
})
</script>
```

## Dynamic Content Based on Time

**Problem**: Content that changes based on current time.

```html
<template>
  <div>{{ greeting }}</div>
</template>

<script setup>
const hour = new Date().getHours()
const greeting = hour < 12 ? 'Good morning' : 'Good afternoon'
</script>
```

**Solution**: Use [`NuxtTime`](https://nuxt.com/docs/api/components/nuxt-time) component or handle it client-side:

```html
<template>
  <div>
    <NuxtTime :date="new Date()" format="HH:mm" />
  </div>
</template>
```

```html
<template>
  <div>
    <ClientOnly>
      {{ greeting }}
      <template #fallback>
        Hello!
      </template>
    </ClientOnly>
  </div>
</template>

<script setup>
const greeting = ref('Hello!')

onMounted(() => {
  const hour = new Date().getHours()
  greeting.value = hour < 12 ? 'Good morning' : 'Good afternoon'
})
</script>
```

## In summary

1. **Use SSR-friendly composables**: [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch), [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data), [`useState`](https://nuxt.com/docs/api/composables/use-state)
2. **Wrap client-only code**: Use [`ClientOnly`](https://nuxt.com/docs/api/components/client-only) component for browser-specific content
3. **Consistent data sources**: Ensure server and client uses the same data
4. **Avoid side effects in setup**: Move browser-dependent code to `onMounted`

::tip
You can read the [Vue documentation on SSR hydration mismatch](https://vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch){rel="nofollow"} for a better understanding of hydration.
::


# Nuxt performance

Nuxt comes with built-in features designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals){rel="nofollow"}. There are also multiple Nuxt core modules that assist in improving performance in specific areas. This guide outlines best practices to optimize performance of your Nuxt application.

## Built-in Features

Nuxt offers several built-in features that help you optimize performance of your website. Understanding how these features work is crucial for achieving blazingly-fast performance.

### Links

[`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link) is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)

```html
<template>
  <NuxtLink to="/about">About page</NuxtLink>
</template>

<!-- Which will render to with Vue Router & Smart Prefetching -->
<a href="/about">About page</a>
```

Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.

You can also opt for prefetching on interaction instead:

```ts
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        prefetchOn: 'interaction',
      },
    }
  }
})
```

::read-more
---
title: NuxtLink
to: https://nuxt.com/docs/api/components/nuxt-link
---
::

### Hybrid Rendering

In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered

Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:

```ts
export default defineNuxtConfig({
  routeRules: {
    '/': {
      prerender: true
    },
    '/products/**': {
      swr: 3600
    },
    '/blog': {
      isr: 3600
    },
    '/admin/**': {
      ssr: false
    },
  }
})
```

Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.

::read-more
---
title: Hybrid rendering
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
::

### Lazy Loading Components

To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is useful if the component is not always needed.

```html
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
  </div>
</template>
```

By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.

::read-more
---
title: Lazy loading components
to: https://nuxt.com/docs/guide/directory-structure/app/components#dynamic-imports
---
::

### Lazy Hydration

It is not always necessary to hydrate (or make interactive) all the components of your site on the initial load. Using lazy hydration, you can control when components can have their code loaded, which can improve the time-to-interactive metric for your app. Nuxt allows you to control when components become interactive with lazy hydration (added in Nuxt v3.16).

```html
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.

::read-more
---
title: Lazy hydration
to: https://nuxt.com/docs/guide/directory-structure/app/components#delayed-or-lazy-hydration
---
::

### Fetching data

To avoid fetching same data twice (once on the server and once on client) Nuxt provides [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) and [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data). They ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.

::read-more
---
title: Data fetching
to: https://nuxt.com/docs/getting-started/data-fetching
---
::

## Core Nuxt Modules

Apart from Nuxt's built-in features, there are also core modules maintained by the Nuxt team which help improve performance even further. These modules help handle assets such as images, custom fonts, or third party scripts.

### Images

Unoptimized images can have a significant negative impact on your website performance, specifically the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp){rel="nofollow"} score.

In Nuxt we can use [Nuxt Image](https://image.nuxt.com/){rel="nofollow"} module that is a plug-and-play image optimization for Nuxt apps. It allows resizing and transforming your images using built-in optimizer or your favorite images CDN.

::video-accordion
---
title: Watch the video by LearnVue about Nuxt Image
video-id: _UBff2eqGY0
---
::

[`<NuxtImg>`](https://nuxt.com/docs/api/components/nuxt-img) is a drop-in replacement for the native `<img>` tag that comes with following enhancements:

- Uses built-in provider to optimize local and remote images
- Converts `src` to provider optimized URLs with modern formats such as WebP or Avif
- Automatically resizes images based on `width` and `height`
- Generates responsive `sizes` when providing sizes option
- Supports native `lazy loading` as well as other `<img>` attributes

Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:

```html
<template>
  <!-- 🚨 Needs to be loaded ASAP -->
  <NuxtImg
    src="/hero-banner.jpg"
    format="webp"
    preload
    loading="eager"
    fetch-priority="high"
    width="200"
    height="100"
  />

  <!-- 🐌 Can be loaded later -->
  <NuxtImg
    src="/facebook-logo.jpg"
    format="webp"
    loading="lazy"
    fetch-priority="low"
    width="200"
    height="100"
  />
</template>
```

::read-more{title="Nuxt Image" to="https://image.nuxt.com/usage/nuxt-img"}
::

### Fonts

[Nuxt Fonts](https://fonts.nuxt.com/){rel="nofollow"} will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.

It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [fontaine](https://github.com/unjs/fontaine){rel="nofollow"}.

::video-accordion
---
title: Watch the talk by Daniel Roe about the idea behind Nuxt Fonts
video-id: D3F683UViBY
---
::

Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.

1. **Resolves fonts** – Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.
2. **Generates @font-face rules** – Injects CSS rules to load fonts from the correct sources.
3. **Proxies & caches fonts** – Rewrites URLs to `/_fonts`, downloads and caches fonts locally.
4. **Creates fallback metrics** – Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls){rel="nofollow"}).
5. **Includes fonts in build** – Bundles fonts with your project, hashing file names and setting long-lived cache headers.

It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.

### Scripts

Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp){rel="nofollow"} and Largest Contentful Paint (LCP) scores.

[Nuxt Scripts](https://scripts.nuxt.com/){rel="nofollow"} lets you load third-party scripts with better performance, privacy, security and DX.

::video-accordion
---
title: Watch the video by Alex Lichter about Nuxt Scripts
video-id: sjMqUUvH9AE
---
::

Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.

```ts
const { onLoaded, proxy } = useScriptGoogleAnalytics(
  { 
    id: 'G-1234567',
    scriptOptions: {
      trigger: 'manual',
    },
  },
)
// queue events to be sent when ga loads
proxy.gtag('config', 'UA-123456789-1')
// or wait until ga is loaded
onLoaded((gtag) => {
  // script loaded
})
```

::read-more{title="Nuxt Scripts" to="https://scripts.nuxt.com/scripts"}
::

## Profiling Tools

To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.

### Nuxi Analyze

[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.

When you see a large block in the visualization, it often signals an opportunity for optimization—whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.

Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.

### Nuxt DevTools

The [Nuxt DevTools](https://devtools.nuxt.com/){rel="nofollow"} gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.

![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)

It comes with several features we can use to measure performance of Nuxt apps:

1. **Timeline** – Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.
2. **Assets** – Displays file sizes (e.g., images) without transformations.
3. **Render Tree** – Shows connections between Vue components, scripts, and styles to optimize dynamic loading.
4. **Inspect** – Lists all files used in the Vue app with their size and evaluation time.

### Chrome DevTools

Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.

When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview){rel="nofollow"} panel, it instantly shows your local &#x2A;*Largest Contentful Paint (LCP)** and &#x2A;*Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).

If you interact with the page, it also captures &#x2A;*Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.

![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)

[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse){rel="nofollow"} audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.

![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)

Each audit has a reference document explaining why the audit is important, as well as how to fix it.

### PageSpeed Insights

[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about){rel="nofollow"} reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.

It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.

### Web Page Test

[WebPageTest](https://www.webpagetest.org/){rel="nofollow"} is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.

Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.

## Common problems

When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.

### Overusing plugins

**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.

**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.

### Unused code / dependencies

**Problem**: With the development of the project, there can be a case where there will be some unused code or a dependency. This additional functionality may not be used or needed while it will be increase the bundle size of our project.

**Solution**: Inspect your `package.json` for unused dependencies and analyze your code for unused utils/composables/functions.

### Not using Vue Performance tips

**Problem**: [Vue documentation](https://vuejs.org/guide/best-practices/performance){rel="nofollow"} lists several Performance improvements we can use in our Nuxt projects as well but as they are part of Vue documentation, developers tend to forget about it and focus on Nuxt specific improvements only - while Nuxt application is still a Vue project.

**Solution**: Use concepts such as `shallowRef`, `v-memo`, `v-once`, etc to improve performance.

### Not following patterns

**Problem**: The more people are currently working on the project, the more difficult it will be to maintain the stable codebase. Developers have a tendency to introduce new concepts they've seen in another project which can cause conflicts and problems with performance.

**Solution**: Establish rules and patterns in the project such as [Good practices and Design Patterns for Vue Composables](https://dev.to/jacobandrewsky/good-practices-and-design-patterns-for-vue-composables-24lk){rel="nofollow"}

### Trying to load everything at the same time

**Problem**: When a page is loaded and it is not correctly instructed about the order of loading elements it will result in fetching everything at the same time - which can be slow and result in bad User Experience.

**Solution**: Use concepts such as Progressive Enhancement where core webpage content is set first, then more nuanced and technically rigorous layers of presentation and features are added on top as the browser/internet connection allow.

## Useful Resources

To learn more about various techniques for improving performance, take a look at the following resources:

1. [Apply instant loading with the PRPL pattern](https://web.dev/articles/apply-instant-loading-with-prpl){rel="nofollow"}
2. [Perceived performance](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/Perceived_performance){rel="nofollow"}
3. [Understanding Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Critical_rendering_path){rel="nofollow"}


# Nuxt Plugins

Plugins in Nuxt allow you to extend your application with additional functionality. However, improper use can lead to performance bottlenecks. This guide outlines best practices to optimize your Nuxt plugins.

## Avoid costly plugin setup

A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.

## Use Composition whenever possible

Whenever possible, favor composition over plugins. Just like in Vue, many utilities and composables can be used directly without the need for a plugin. This keeps your project lightweight and improves maintainability.

## If `async`, enable `parallel`

By default, all plugins loads synchronously.
When defining asynchronous plugins, setting `parallel: true` allows multiple plugins to load concurrently, improving performance by preventing blocking operations.


# <ClientOnly>

The `<ClientOnly>` component is used for purposely rendering a component only on client side.

::note
The content of the default slot will be tree-shaken out of the server build. (This does mean that any CSS used by components within it may not be inlined when rendering the initial HTML.)
::

## Props

- `placeholderTag` | `fallbackTag`: specify a tag to be rendered server-side.
- `placeholder` | `fallback`: specify a content to be rendered server-side.

```vue
<template>
  <div>
    <Sidebar />
    <!-- The <Comment> component will only be rendered on client-side -->
    <ClientOnly fallback-tag="span" fallback="Loading comments...">
      <Comment />
    </ClientOnly>
  </div>
</template>
```

## Slots

- `#fallback`: specify a content to be rendered on the server and displayed until `<ClientOnly>` is mounted in the browser.

```vue [app/pages/example.vue]
<template>
  <div>
    <Sidebar />
    <!-- This renders the "span" element on the server side -->
    <ClientOnly fallbackTag="span">
      <!-- this component will only be rendered on client side -->
      <Comments />
      <template #fallback>
        <!-- this will be rendered on server side -->
        <p>Loading comments...</p>
      </template>
    </ClientOnly>
  </div>
</template>
```

## Examples

### Accessing HTML Elements

Components inside `<ClientOnly>` are rendered only after being mounted. To access the rendered elements in the DOM, you can watch a template ref:

```vue [app/pages/example.vue]
<script setup lang="ts">
const nuxtWelcomeRef = useTemplateRef('nuxtWelcomeRef')

// The watch will be triggered when the component is available
watch(nuxtWelcomeRef, () => {
 console.log('<NuxtWelcome /> mounted')
}, { once: true })
</script>

<template>
  <ClientOnly>
    <NuxtWelcome ref="nuxtWelcomeRef" />
  </ClientOnly>
</template>
```


# <DevOnly>

Nuxt provides the `<DevOnly>` component to render a component only during development.

The content will not be included in production builds.

```vue [app/pages/example.vue]
<template>
  <div>
    <Sidebar />
    <DevOnly>
      <!-- this component will only be rendered during development -->
      <LazyDebugBar />

      <!-- if you ever require to have a replacement during production -->
      <!-- be sure to test these using `nuxt preview` -->
      <template #fallback>
        <div><!-- empty div for flex.justify-between --></div>
      </template>
    </DevOnly>
  </div>
</template>
```

## Slots

- `#fallback`: if you ever require to have a replacement during production.

```vue
<template>
  <div>
    <Sidebar />
    <DevOnly>
      <!-- this component will only be rendered during development -->
      <LazyDebugBar />
      <!-- be sure to test these using `nuxt preview` -->
      <template #fallback>
        <div><!-- empty div for flex.justify-between --></div>
      </template>
    </DevOnly>
  </div>
</template>
```


# <NuxtClientFallback>

Nuxt provides the `<NuxtClientFallback>` component to render its content on the client if any of its children trigger an error in SSR.

::note
---
to: https://nuxt.com/docs/guide/going-further/experimental-features#clientfallback
---
This component is experimental and in order to use it you must enable the `experimental.clientFallback` option in your `nuxt.config`.
::

```vue [app/pages/example.vue]
<template>
  <div>
    <Sidebar />
    <!-- this component will be rendered on client-side -->
    <NuxtClientFallback fallback-tag="span">
      <Comments />
      <BrokeInSSR />
    </NuxtClientFallback>
  </div>
</template>
```

## Events

- `@ssr-error`: Event emitted when a child triggers an error in SSR. Note that this will only be triggered on the server.
  ```vue
  <template>
    <NuxtClientFallback @ssr-error="logSomeError">
      <!-- ... -->
    </NuxtClientFallback>
  </template>
  ```

## Props

- `placeholderTag` | `fallbackTag`: Specify a fallback tag to be rendered if the slot fails to render on the server.

  - **type**: `string`
  - **default**: `div`
- `placeholder` | `fallback`: Specify fallback content to be rendered if the slot fails to render.

  - **type**: `string`
- `keepFallback`: Keep the fallback content if it failed to render server-side.

  - **type**: `boolean`
  - **default**: `false`

```vue
  <template>
    <!-- render <span>Hello world</span> server-side if the default slot fails to render -->
    <NuxtClientFallback fallback-tag="span" fallback="Hello world">
      <BrokeInSsr />
    </NuxtClientFallback>
  </template>
```

## Slots

- `#fallback`: specify content to be displayed server-side if the slot fails to render.

```vue
<template>
  <NuxtClientFallback>
    <!-- ... -->
    <template #fallback>
      <!-- this will be rendered on server side if the default slot fails to render in ssr -->
      <p>Hello world</p>
    </template>
  </NuxtClientFallback>
</template>
```


# <NuxtPicture>

`<NuxtPicture>` is a drop-in replacement for the native `<picture>` tag.

Usage of `<NuxtPicture>` is almost identical to [`<NuxtImg>`](https://nuxt.com/docs/api/components/nuxt-img) but it also allows serving modern formats like `webp` when possible.

Learn more about the [`<picture>` tag on MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture){rel="nofollow"}.

## Setup

In order to use `<NuxtPicture>` you should install and enable the Nuxt Image module:

```bash [Terminal]
npx nuxt module add image
```

::read-more{target="_blank" to="https://image.nuxt.com/usage/nuxt-picture"}
Read more about the `<NuxtPicture>` component.
::


# <Teleport>

::warning
The `to` target of [`<Teleport>`](https://vuejs.org/guide/built-ins/teleport.html){rel="nofollow"} expects a CSS selector string or an actual DOM node. Nuxt currently has SSR support for teleports to `#teleports` only, with client-side support for other targets using a `<ClientOnly>` wrapper.
::

## Body Teleport

```vue
<template>
  <button @click="open = true">
    Open Modal
  </button>
  <Teleport to="#teleports">
    <div v-if="open" class="modal">
      <p>Hello from the modal!</p>
      <button @click="open = false">
        Close
      </button>
    </div>
  </Teleport>
</template>
```

## Client-side Teleport

```vue
<template>
  <ClientOnly>
    <Teleport to="#some-selector">
      <!-- content -->
    </Teleport>
  </ClientOnly>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/advanced/teleport"}
::


# <NuxtRouteAnnouncer>

::important
This component is available in Nuxt v3.12+.
::

## Usage

Add `<NuxtRouteAnnouncer/>` in your [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) or [`app/layouts/`](https://nuxt.com/docs/guide/directory-structure/app/layouts) to enhance accessibility by informing assistive technologies about page title changes. This ensures that navigational changes are announced to users relying on screen readers.

```vue [app/app.vue]
<template>
  <NuxtRouteAnnouncer />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

## Slots

You can pass custom HTML or components through the route announcer's default slot.

```vue
  <template>
    <NuxtRouteAnnouncer>
      <template #default="{ message }">
        <p>{{ message }} was loaded.</p>
      </template>
    </NuxtRouteAnnouncer>
  </template>
```

## Props

- `atomic`: Controls if screen readers only announce changes or the entire content. Set to true for full content readouts on updates, false for changes only. (default `false`)
- `politeness`: Sets the urgency for screen reader announcements: `off` (disable the announcement), `polite` (waits for silence), or `assertive` (interrupts immediately). (default `polite`)

::callout
This component is optional. :br
To achieve full customization, you can implement your own one based on [its source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-route-announcer.ts){rel="nofollow"}.
::

::callout
You can hook into the underlying announcer instance using [the `useRouteAnnouncer` composable](https://nuxt.com/docs/api/composables/use-route-announcer), which allows you to set a custom announcement message.
::


# <NuxtTime>

::important
This component is available in Nuxt v3.17+.
::

The `<NuxtTime>` component lets you display dates and times in a locale-friendly format with proper `<time>` HTML semantics. It ensures consistent rendering between server and client without hydration mismatches.

## Usage

You can use the `<NuxtTime>` component anywhere in your app:

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
</template>
```

## Props

### `datetime`

- Type: `Date | number | string`
- Required: `true`

The date and time value to display. You can provide:

- A `Date` object
- A timestamp (number)
- An ISO-formatted date string

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
  <NuxtTime :datetime="new Date()" />
  <NuxtTime datetime="2023-06-15T09:30:00.000Z" />
</template>
```

### `locale`

- Type: `string`
- Required: `false`
- Default: Uses the browser or server's default locale

The [BCP 47 language tag](https://datatracker.ietf.org/doc/html/rfc5646){rel="nofollow"} for formatting (e.g., 'en-US', 'fr-FR', 'ja-JP'):

```vue
<template>
  <NuxtTime :datetime="Date.now()" locale="fr-FR" />
</template>
```

### Formatting Props

The component accepts any property from the [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat){rel="nofollow"} options:

```vue
<template>
  <NuxtTime 
    :datetime="Date.now()" 
    year="numeric"
    month="long"
    day="numeric"
    hour="2-digit"
    minute="2-digit"
  />
</template>
```

This would output something like: "April 22, 2025, 08:30 AM"

### `relative`

- Type: `boolean`
- Required: `false`
- Default: `false`

Enables relative time formatting using the Intl.RelativeTimeFormat API:

```vue
<template>
  <!-- Shows something like "5 minutes ago" -->
  <NuxtTime :datetime="Date.now() - 5 * 60 * 1000" relative />
</template>
```

### Relative Time Formatting Props

When `relative` is set to `true`, the component also accepts properties from [Intl.RelativeTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat){rel="nofollow"}:

```vue
<template>
  <NuxtTime 
    :datetime="Date.now() - 3 * 24 * 60 * 60 * 1000" 
    relative 
    numeric="auto"
    style="long"
  />
</template>
```

This would output something like: "3 days ago" or "last Friday" depending on the `numeric` setting.

## Examples

### Basic Usage

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
</template>
```

### Custom Formatting

```vue
<template>
  <NuxtTime 
    :datetime="Date.now()" 
    weekday="long"
    year="numeric"
    month="short"
    day="numeric"
    hour="numeric"
    minute="numeric"
    second="numeric"
    timeZoneName="short"
  />
</template>
```

### Relative Time

```vue
<template>
  <div>
    <p>
      <NuxtTime :datetime="Date.now() - 30 * 1000" relative />
      <!-- 30 seconds ago -->
    </p>
    <p>  
      <NuxtTime :datetime="Date.now() - 45 * 60 * 1000" relative />
      <!-- 45 minutes ago -->
    </p>
    <p>
      <NuxtTime :datetime="Date.now() + 2 * 24 * 60 * 60 * 1000" relative />
      <!-- in 2 days -->
    </p>
  </div>
</template>
```

### With Custom Locale

```vue
<template>
  <div>
    <NuxtTime :datetime="Date.now()" locale="en-US" weekday="long" />
    <NuxtTime :datetime="Date.now()" locale="fr-FR" weekday="long" />
    <NuxtTime :datetime="Date.now()" locale="ja-JP" weekday="long" />
  </div>
</template>
```


# <NuxtPage>

`<NuxtPage>` is a built-in component that comes with Nuxt. It lets you display top-level or nested pages located in the [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory.

::note
`<NuxtPage>` is a wrapper around [`<RouterView>`](https://router.vuejs.org/api/interfaces/RouterViewProps.html#interface-routerviewprops){rel="nofollow"} from Vue Router. It should be used instead of `<RouterView>` because the former takes additional care of internal states. Otherwise, `useRoute()` may return incorrect paths.
::

`<NuxtPage>` includes the following components:

```vue
<template>
  <RouterView #default="{ Component }">
    <!-- Optional, when using transitions -->
    <Transition>
      <!-- Optional, when using keep-alive -->
      <KeepAlive>
        <Suspense>
          <component :is="Component" />
        </Suspense>
      </KeepAlive>
    </Transition>
  </RouterView>
</template>
```

By default, Nuxt does not enable `<Transition>` and `<KeepAlive>`. You can enable them in the nuxt.config file or by setting the `transition` and `keepalive` properties on `<NuxtPage>`. If you want to define a specific page, you can set it in `definePageMeta` in the page component.

::warning
If you enable `<Transition>` in your page component, ensure that the page has a single root element.
::

Since `<NuxtPage>` uses `<Suspense>` under the hood, the component lifecycle behavior during page changes differs from that of a typical Vue application.

In a typical Vue application, a new page component is mounted **only after** the previous one has been fully unmounted. However, in Nuxt, due to how Vue `<Suspense>` is implemented, the new page component is mounted **before** the previous one is unmounted.

## Props

- `name`: tells `<RouterView>` to render the component with the corresponding name in the matched route record's components option.

  - type: `string`
- `route`: route location that has all of its components resolved.

  - type: `RouteLocationNormalized`
- `pageKey`: control when the `NuxtPage` component is re-rendered.

  - type: `string` or `function`
- `transition`: define global transitions for all pages rendered with the `NuxtPage` component.

  - type: `boolean` or [`TransitionProps`](https://vuejs.org/api/built-in-components#transition){rel="nofollow"}
- `keepalive`: control state preservation of pages rendered with the `NuxtPage` component.

  - type: `boolean` or [`KeepAliveProps`](https://vuejs.org/api/built-in-components#keepalive){rel="nofollow"}

::tip
Nuxt automatically resolves the `name` and `route` by scanning and rendering all Vue component files found in the `/pages` directory.
::

## Example

For example, if you pass a key that never changes, the `<NuxtPage>` component will be rendered only once - when it is first mounted.

```vue [app/app.vue]
<template>
  <NuxtPage page-key="static" />
</template>
```

You can also use a dynamic key based on the current route:

```html
<NuxtPage :page-key="route => route.fullPath" />
```

::warning
Don't use `$route` object here as it can cause problems with how `<NuxtPage>` renders pages with `<Suspense>`.
::

Alternatively, `pageKey` can be passed as a `key` value via [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) from the `<script>` section of your Vue component in the `/pages` directory.

```vue [app/pages/my-page.vue]
<script setup lang="ts">
definePageMeta({
  key: route => route.fullPath
})
</script>
```

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::

## Page's Ref

To get the `ref` of a page component, access it through `ref.value.pageRef`

```vue [app/app.vue]
<script setup lang="ts">
const page = ref()

function logFoo () {
  page.value.pageRef.foo()
}
</script>

<template>
  <NuxtPage ref="page" />
</template>
```

```vue [my-page.vue]
<script setup lang="ts">
const foo = () => {
  console.log('foo method called')
}

defineExpose({
  foo,
})
</script>
```

## Custom Props

`<NuxtPage>` also accepts custom props that you may need to pass further down the hierarchy.

For example, in the below example, the value of `foobar` will be passed to the `NuxtPage` component and then to the page components.

```vue [app/app.vue]
<template>
  <NuxtPage :foobar="123" />
</template>
```

We can access the `foobar` prop in the page component:

```vue [app/pages/page.vue]
<script setup lang="ts">
const props = defineProps<{ foobar: number }>()

console.log(props.foobar) // Outputs: 123
```

If you have not defined the prop with `defineProps`, any props passed down to `NuxtPage` can still be accessed directly from the page `attrs`:

```vue [app/pages/page.vue]
<script setup lang="ts">
const attrs = useAttrs()
console.log(attrs.foobar) // Outputs: 123
</script>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/pages"}
::


# <NuxtLayout>

You can use `<NuxtLayout />` component to activate the `default` layout on `app.vue` or `error.vue`.

```vue [app/app.vue]
<template>
  <NuxtLayout>
    some page content
  </NuxtLayout>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/layouts"}
::

## Props

- `name`: Specify a layout name to be rendered, can be a string, reactive reference or a computed property. It **must** match the name of the corresponding layout file in the [`app/layouts/`](https://nuxt.com/docs/guide/directory-structure/app/layouts) directory.

  - **type**: `string`
  - **default**: `default`

```vue [app/pages/index.vue]
<script setup lang="ts">
// layouts/custom.vue
const layout = 'custom'
</script>

<template>
  <NuxtLayout :name="layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

::note
Please note the layout name is normalized to kebab-case, so if your layout file is named `errorLayout.vue`, it will become `error-layout` when passed as a `name` property to `<NuxtLayout />`.
::

```vue [error.vue]
<template>
  <NuxtLayout name="error-layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/layouts"}
Read more about dynamic layouts.
::

- `fallback`: If an invalid layout is passed to the `name` prop, no layout will be rendered. Specify a `fallback` layout to be rendered in this scenario. It **must** match the name of the corresponding layout file in the [`app/layouts/`](https://nuxt.com/docs/guide/directory-structure/app/layouts) directory.

  - **type**: `string`
  - **default**: `null`

## Additional Props

`NuxtLayout` also accepts any additional props that you may need to pass to the layout. These custom props are then made accessible as attributes.

```vue [app/pages/some-page.vue]
<template>
  <div>
    <NuxtLayout name="custom" title="I am a custom layout">
      <-- ... -->
    </NuxtLayout>
  </div>
</template>
```

In the above example, the value of `title` will be available using `$attrs.title` in the template or `useAttrs().title` in `<script setup>` at custom.vue.

```vue [app/layouts/custom.vue]
<script setup lang="ts">
const layoutCustomProps = useAttrs()

console.log(layoutCustomProps.title) // I am a custom layout
</script>
```

## Transitions

`<NuxtLayout />` renders incoming content via `<slot />`, which is then wrapped around Vue’s `<Transition />` component to activate layout transition. For this to work as expected, it is recommended that `<NuxtLayout />` is **not** the root element of the page component.

::code-group
```vue [app/pages/index.vue]
<template>
  <div>
    <NuxtLayout name="custom">
      <template #header> Some header template content. </template>
    </NuxtLayout>
  </div>
</template>
```

```vue [app/layouts/custom.vue]
<template>
  <div>
    <!-- named slot -->
    <slot name="header" />
    <slot />
  </div>
</template>
```
::

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

## Layout's Ref

To get the ref of a layout component, access it through `ref.value.layoutRef`.

::code-group
```vue [app/app.vue]
<script setup lang="ts">
const layout = ref()

function logFoo () {
  layout.value.layoutRef.foo()
}
</script>

<template>
  <NuxtLayout ref="layout">
    default layout
  </NuxtLayout>
</template>
```

```vue [app/layouts/default.vue]
<script setup lang="ts">
const foo = () => console.log('foo')
defineExpose({
  foo
})
</script>

<template>
  <div>
    default layout
    <slot />
  </div>
</template>
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/layouts"}
::


# <NuxtLink>

::note
`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is *internal* or *external* and renders it accordingly with available optimizations (prefetching, default attributes, etc.)
::

## Internal Routing

In this example, we use `<NuxtLink>` component to link to another page of the application.

::code-group
```vue [app/pages/index.vue]
<template>
  <NuxtLink to="/about">About page</NuxtLink>
</template>
```

```html [(Renders as) index.html]
<!-- (Vue Router & Smart Prefetching) -->
<a href="/about">About page</a>
```
::

### Passing Params to Dynamic Routes

In this example, we pass the `id` param to link to the route `~/pages/posts/[id].vue`.

::code-group
```vue [app/pages/index.vue]
<template>
  <NuxtLink :to="{ name: 'posts-id', params: { id: 123 } }">
    Post 123
  </NuxtLink>
</template>
```

```html [(Renders as) index.html]
<a href="/posts/123">Post 123</a>
```
::

::tip
Check out the Pages panel in Nuxt DevTools to see the route name and the params it might take.
::

::tip
When you pass an object into the `to` prop, `<NuxtLink>` will inherit Vue Router’s handling of query parameters. Keys and values will be automatically encoded, so you don’t need to call `encodeURI` or `encodeURIComponent` manually.
::

### Handling Static File and Cross-App Links

By default, `<NuxtLink>` uses Vue Router's client side navigation for relative route. When linking to static files in the `/public` directory or to another application hosted on the same domain, it might result in unexpected 404 errors because they are not part of the client routes. In such cases, you can use the `external` prop with `<NuxtLink>` to bypass Vue Router's internal routing mechanism.

The `external` prop explicitly indicates that the link is external. `<NuxtLink>` will render the link as a standard HTML `<a>` tag. This ensures the link behaves correctly, bypassing Vue Router’s logic and directly pointing to the resource.

#### Linking to Static Files

For static files in the `/public` directory, such as PDFs or images, use the `external` prop to ensure the link resolves correctly.

```vue [app/pages/index.vue]
<template>
  <NuxtLink to="/example-report.pdf" external>
    Download Report
  </NuxtLink>
</template>
```

#### Linking to a Cross-App URL

When pointing to a different application on the same domain, using the `external` prop ensures the correct behavior.

```vue [app/pages/index.vue]
<template>
  <NuxtLink to="/another-app" external>
    Go to Another App
  </NuxtLink>
</template>
```

Using the `external` prop or relying on automatic handling ensures proper navigation, avoids unexpected routing issues, and improves compatibility with static resources or cross-application scenarios.

## External Routing

In this example, we use `<NuxtLink>` component to link to a website.

```vue [app/app.vue]
<template>
  <NuxtLink to="https://nuxtjs.org">
    Nuxt website
  </NuxtLink>
  <!-- <a href="https://nuxtjs.org" rel="noopener noreferrer">...</a> -->
</template>
```

## `rel` and `noRel` Attributes

A `rel` attribute of `noopener noreferrer` is applied by default to links with a `target` attribute or to absolute links (e.g., links starting with `http://`, `https://`, or `//`).

- `noopener` solves a [security bug](https://mathiasbynens.github.io/rel-noopener/){rel="nofollow"} in older browsers.
- `noreferrer` improves privacy for your users by not sending the `Referer` header to the linked site.

These defaults have no negative impact on SEO and are considered [best practice](https://developer.chrome.com/docs/lighthouse/best-practices/external-anchors-use-rel-noopener){rel="nofollow"}.

When you need to overwrite this behavior you can use the `rel` or `noRel` props.

```vue [app/app.vue]
<template>
  <NuxtLink to="https://twitter.com/nuxt_js">
    Nuxt Twitter
  </NuxtLink>
  <!-- <a href="https://twitter.com/nuxt_js" rel="noopener noreferrer">...</a> -->

  <NuxtLink to="https://discord.nuxtjs.org" rel="noopener">
    Nuxt Discord
  </NuxtLink>
  <!-- <a href="https://discord.nuxtjs.org" rel="noopener">...</a> -->

  <NuxtLink to="/about" target="_blank">About page</NuxtLink>
  <!-- <a href="/about" target="_blank" rel="noopener noreferrer">...</a> -->
</template>
```

A `noRel` prop can be used to prevent the default `rel` attribute from being added to the absolute links.

```vue [app/app.vue]
<template>
  <NuxtLink to="https://github.com/nuxt" no-rel>
    Nuxt GitHub
  </NuxtLink>
  <!-- <a href="https://github.com/nuxt">...</a> -->
</template>
```

::note
`noRel` and `rel` cannot be used together. `rel` will be ignored.
::

## Prefetch Links

Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link. Nuxt only loads the resources when the browser isn't busy and skips prefetching if your connection is offline or if you only have 2g connection.

```vue [app/pages/index.vue]
<NuxtLink to="/about" no-prefetch>About page not pre-fetched</NuxtLink>
<NuxtLink to="/about" :prefetch="false">About page not pre-fetched</NuxtLink>
```

### Custom Prefetch Triggers

We now support custom prefetch triggers for `<NuxtLink>` after `v3.13.0`. You can use the `prefetchOn` prop to control when to prefetch links.

```vue
<template>
  <NuxtLink prefetch-on="visibility">
    This will prefetch when it becomes visible (default)
  </NuxtLink>

  <NuxtLink prefetch-on="interaction">
    This will prefetch when hovered or when it gains focus
  </NuxtLink>
</template>
```

- `visibility`: Prefetches when the link becomes visible in the viewport. Monitors the element's intersection with the viewport using the [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API){rel="nofollow"}. Prefetching is triggered when the element is scrolled into view.
- `interaction`: Prefetches when the link is hovered or focused. This approach listens for `pointerenter` and `focus` events, proactively prefetching resources when the user indicates intent to interact.

You can also use an object to configure `prefetchOn`:

```vue
<template>
  <NuxtLink :prefetch-on="{ interaction: true }">
    This will prefetch when hovered or when it gains focus
  </NuxtLink>
</template>
```

That you probably don't want both enabled!

```vue
<template>
  <NuxtLink :prefetch-on="{ visibility: true, interaction: true }">
    This will prefetch when hovered/focus - or when it becomes visible
  </NuxtLink>
</template>
```

This configuration will observe when the element enters the viewport and also listen for `pointerenter` and `focus` events. This may result in unnecessary resource usage or redundant prefetching, as both triggers can prefetch the same resource under different conditions.

### Enable Cross-origin Prefetch

To enable cross-origin prefetching, you can set the `crossOriginPrefetch` option in your `nuxt.config`. This will enable cross-origin prefetching using the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API){rel="nofollow"}.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    crossOriginPrefetch: true,
  },
})
```

### Disable prefetch globally

It's also possible to enable/disable prefetching all links globally for your app.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        prefetch: false,
      },
    },
  },
})
```

## Props

### RouterLink

When not using `external`, `<NuxtLink>` supports all Vue Router's [`RouterLink` props](https://router.vuejs.org/api/interfaces/RouterLinkProps.html){rel="nofollow"}

- `to`: Any URL or a [route location object](https://router.vuejs.org/api/type-aliases/RouteLocation.html){rel="nofollow"} from Vue Router
- `custom`: Whether `<NuxtLink>` should wrap its content in an `<a>` element. It allows taking full control of how a link is rendered and how navigation works when it is clicked. Works the same as [Vue Router's `custom` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-custom){rel="nofollow"}
- `exactActiveClass`: A class to apply on exact active links. Works the same as [Vue Router's `exactActiveClass` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-exactActiveClass){rel="nofollow"} on internal links. Defaults to Vue Router's default (`"router-link-exact-active"`)
- `activeClass`: A class to apply on active links. Works the same as [Vue Router's `activeClass` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-activeClass){rel="nofollow"} on internal links. Defaults to Vue Router's default (`"router-link-active"`)
- `replace`: Works the same as [Vue Router's `replace` prop](https://router.vuejs.org/api/interfaces/RouteLocationOptions.html#Properties-replace){rel="nofollow"} on internal links
- `ariaCurrentValue`: An `aria-current` attribute value to apply on exact active links. Works the same as [Vue Router's `ariaCurrentValue` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-ariaCurrentValue){rel="nofollow"} on internal links

### NuxtLink

- `href`: An alias for `to`. If used with `to`, `href` will be ignored
- `noRel`: If set to `true`, no `rel` attribute will be added to the external link
- `external`: Forces the link to be rendered as an `<a>` tag instead of a Vue Router `RouterLink`.
- `prefetch`: When enabled will prefetch middleware, layouts and payloads (when using [payloadExtraction](https://nuxt.com/docs/api/nuxt-config#crossoriginprefetch)) of links in the viewport. Used by the experimental [crossOriginPrefetch](https://nuxt.com/docs/api/nuxt-config#crossoriginprefetch) config.
- `prefetchOn`: Allows custom control of when to prefetch links. Possible options are `interaction` and `visibility` (default). You can also pass an object for full control, for example: `{ interaction: true, visibility: true }`. This prop is only used when `prefetch` is enabled (default) and `noPrefetch` is not set.
- `noPrefetch`: Disables prefetching.
- `prefetchedClass`: A class to apply to links that have been prefetched.

### Anchor

- `target`: A `target` attribute value to apply on the link
- `rel`: A `rel` attribute value to apply on the link. Defaults to `"noopener noreferrer"` for external links.

::tip
Defaults can be overwritten, see [overwriting defaults](https://nuxt.com/#overwriting-defaults) if you want to change them.
::

## Overwriting Defaults

### In Nuxt Config

You can overwrite some `<NuxtLink>` defaults in your [`nuxt.config`](https://nuxt.com/docs/api/nuxt-config#defaults)

::important
These options will likely be moved elsewhere in the future, such as into `app.config` or into the `app/` directory.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        // default values
        componentName: 'NuxtLink',
        externalRelAttribute: 'noopener noreferrer',
        activeClass: 'router-link-active',
        exactActiveClass: 'router-link-exact-active',
        prefetchedClass: undefined, // can be any valid string class name
        trailingSlash: undefined // can be 'append' or 'remove'
        prefetch: true,
        prefetchOn: { visibility: true } 
      }
    }
  }
})
```

### Custom Link Component

You can overwrite `<NuxtLink>` defaults by creating your own link component using `defineNuxtLink`.

```js [app/components/MyNuxtLink.ts]
export default defineNuxtLink({
  componentName: 'MyNuxtLink',
  /* see signature below for more */
})
```

You can then use `<MyNuxtLink />` component as usual with your new defaults.

### `defineNuxtLink` Signature

```ts
interface NuxtLinkOptions {
  componentName?: string;
  externalRelAttribute?: string;
  activeClass?: string;
  exactActiveClass?: string;
  trailingSlash?: 'append' | 'remove'
  prefetch?: boolean
  prefetchedClass?: string
  prefetchOn?: Partial<{
    visibility: boolean
    interaction: boolean
  }>
}
function defineNuxtLink(options: NuxtLinkOptions): Component {}
```

- `componentName`: A name for the component. Default is `NuxtLink`.
- `externalRelAttribute`: A default `rel` attribute value applied on external links. Defaults to `"noopener noreferrer"`. Set it to `""` to disable
- `activeClass`: A default class to apply on active links. Works the same as [Vue Router's `linkActiveClass` option](https://router.vuejs.org/api/interfaces/RouterOptions.html#Properties-linkActiveClass){rel="nofollow"}. Defaults to Vue Router's default (`"router-link-active"`)
- `exactActiveClass`: A default class to apply on exact active links. Works the same as [Vue Router's `linkExactActiveClass` option](https://router.vuejs.org/api/interfaces/RouterOptions.html#Properties-linkExactActiveClass){rel="nofollow"}. Defaults to Vue Router's default (`"router-link-exact-active"`)
- `trailingSlash`: An option to either add or remove trailing slashes in the `href`. If unset or not matching the valid values `append` or `remove`, it will be ignored.
- `prefetch`: Whether or not to prefetch links by default.
- `prefetchOn`: Granular control of which prefetch strategies to apply by default.
- `prefetchedClass`: A default class to apply to links that have been prefetched.

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::


# <NuxtLoadingIndicator>

## Usage

Add `<NuxtLoadingIndicator/>` in your [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) or [`app/layouts/`](https://nuxt.com/docs/guide/directory-structure/app/layouts).

```vue [app/app.vue]
<template>
  <NuxtLoadingIndicator />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::

## Slots

You can pass custom HTML or components through the loading indicator's default slot.

## Props

- `color`: The color of the loading bar. It can be set to `false` to turn off explicit color styling.
- `errorColor`: The color of the loading bar when `error` is set to `true`.
- `height`: Height of the loading bar, in pixels (default `3`).
- `duration`: Duration of the loading bar, in milliseconds (default `2000`).
- `throttle`: Throttle the appearing and hiding, in milliseconds (default `200`).
- `estimatedProgress`: By default Nuxt will back off as it approaches 100%. You can provide a custom function to customize the progress estimation, which is a function that receives the duration of the loading bar (above) and the elapsed time. It should return a value between 0 and 100.

::note
This component is optional. :br
To achieve full customization, you can implement your own one based on [its source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-loading-indicator.ts){rel="nofollow"}.
::

::note
You can hook into the underlying indicator instance using [the `useLoadingIndicator` composable](https://nuxt.com/docs/api/composables/use-loading-indicator), which will allow you to trigger start/finish events yourself.
::

::tip
The loading indicator's speed gradually decreases after reaching a specific point controlled by `estimatedProgress`. This adjustment provides a more accurate reflection of longer page loading times and prevents the indicator from prematurely showing 100% completion.
::


# <NuxtErrorBoundary>

::tip
The `<NuxtErrorBoundary>` uses Vue's [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"} hook under the hood.
::

## Events

- `@error`: Event emitted when the default slot of the component throws an error.
  ```vue
  <template>
    <NuxtErrorBoundary @error="logSomeError">
      <!-- ... -->
    </NuxtErrorBoundary>
  </template>
  ```

## Slots

- `#error`: Specify a fallback content to display in case of error.
  ```vue
    <template>
      <NuxtErrorBoundary>
        <!-- ... -->
        <template #error="{ error, clearError }">
          <p>An error occurred: {{ error }}</p>

          <button @click="clearError">Clear error</button>
        </template>
      </NuxtErrorBoundary>
    </template>
  ```

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::

## Examples

### Accessing `error` and `clearError` in script

You can access `error` and `clearError` properties within the component's script as below:

```vue
<template>
  <NuxtErrorBoundary ref="errorBoundary">
    <!-- ... -->
  </NuxtErrorBoundary>
</template>

<script setup lang="ts">
const errorBoundary = useTemplateRef('errorBoundary')

// errorBoundary.value?.error
// errorBoundary.value?.clearError()
</script>
```


# <NuxtWelcome>

It includes links to the Nuxt documentation, source code, and social media accounts.

```vue [app/app.vue]
<template>
  <NuxtWelcome />
</template>
```

::read-more
---
target: _blank
to: https://templates.ui.nuxtjs.org/templates/welcome
---
Preview the `<NuxtWelcome />` component.
::

::tip
This component is part of [nuxt/assets](https://github.com/nuxt/assets){rel="nofollow"}.
::


# <NuxtIsland>

When rendering an island component, the content of the island component is static, thus no JS is downloaded client-side.

Changing the island component props triggers a refetch of the island component to re-render it again.

::note
Global styles of your application are sent with the response.
::

::tip
Server only components use `<NuxtIsland>` under the hood
::

## Props

- `name` : Name of the component to render.

  - **type**: `string`
  - **required**
- `lazy`: Make the component non-blocking.

  - **type**: `boolean`
  - **default**: `false`
- `props`: Props to send to the component to render.

  - **type**: `Record<string, any>`
- `source`: Remote source to call the island to render.

  - **type**: `string`
- **dangerouslyLoadClientComponents**: Required to load components from a remote source.

  - **type**: `boolean`
  - **default**: `false`

::note
Remote islands need `experimental.componentIslands` to be `'local+remote'` in your `nuxt.config`.
It is strongly discouraged to enable `dangerouslyLoadClientComponents` as you can't trust a remote server's javascript.
::

::note
By default, component islands are scanned from the `~/components/islands/` directory. So the `~/components/islands/MyIsland.vue` component could be rendered with `<NuxtIsland name="MyIsland" />`.
::

## Slots

Slots can be passed to an island component if declared.

Every slot is interactive since the parent component is the one providing it.

Some slots are reserved to `NuxtIsland` for special cases.

- `#fallback`: Specify the content to be rendered before the island loads (if the component is lazy) or if `NuxtIsland` fails to fetch the component.

## Ref

- `refresh()`
  - **type**: `() => Promise<void>`
  - **description**: force refetch the server component by refetching it.

## Events

- `error`
  - **parameters**:

    - **error**:

      - **type**: `unknown`
  - **description**: emitted when when `NuxtIsland` fails to fetch the new island.


# <NuxtImg>

`<NuxtImg>` is a drop-in replacement for the native `<img>` tag.

- Uses built-in provider to optimize local and remote images
- Converts `src` to provider-optimized URLs
- Automatically resizes images based on `width` and `height`
- Generates responsive sizes when providing `sizes` option
- Supports native lazy loading as well as other `<img>` attributes

## Setup

In order to use `<NuxtImg>` you should install and enable the Nuxt Image module:

```bash [Terminal]
npx nuxt module add image
```

## Usage

`<NuxtImg>` outputs a native `img` tag directly (without any wrapper around it). Use it like you would use the `<img>` tag:

```html
<NuxtImg src="/nuxt-icon.png" />
```

Will result in:

```html
<img src="/nuxt-icon.png" />
```

::read-more{target="_blank" to="https://image.nuxt.com/usage/nuxt-img"}
Read more about the `<NuxtImg>` component.
::


# onPrehydrate

::important
This composable is available in Nuxt v3.12+.
::

`onPrehydrate` is a composable lifecycle hook that allows you to run a callback on the client immediately before Nuxt hydrates the page.

::note
This is an advanced utility and should be used with care. For example, [`nuxt-time`](https://github.com/danielroe/nuxt-time/pull/251){rel="nofollow"} and [`@nuxtjs/color-mode`](https://github.com/nuxt-modules/color-mode/blob/main/src/script.js){rel="nofollow"} manipulate the DOM to avoid hydration mismatches.
::

## Usage

Call `onPrehydrate` in the setup function of a Vue component (e.g., in `<script setup>`) or in a plugin. It only has an effect when called on the server and will not be included in your client build.

## Type

```ts [Signature]
export function onPrehydrate(callback: (el: HTMLElement) => void): void
export function onPrehydrate(callback: string | ((el: HTMLElement) => void), key?: string): undefined | string
```

## Parameters

| Parameter  | Type                                   | Required | Description                                                                                                                                                                                                                                                                              |
| ---------- | -------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `callback` | `((el: HTMLElement) => void) | string` | Yes      | A function (or stringified function) to run before Nuxt hydrates. It will be stringified and inlined in the HTML. Should not have external dependencies or reference variables outside the callback. Runs before Nuxt runtime initializes, so it should not rely on Nuxt or Vue context. |
| `key`      | `string`                               | No       | (Advanced) A unique key to identify the prehydrate script, useful for advanced scenarios like multiple root nodes.                                                                                                                                                                       |

## Return Values

- Returns `undefined` when called with only a callback function.
- Returns a string (the prehydrate id) when called with a callback and a key, which can be used to set or access the `data-prehydrate-id` attribute for advanced use cases.

## Example

```vue [app/app.vue] twoslash
<script setup lang="ts">
declare const window: Window
// ---cut---
// Run code before Nuxt hydrates
onPrehydrate(() => {
  console.log(window)
})

// Access the root element
onPrehydrate((el) => {
  console.log(el.outerHTML)
  // <div data-v-inspector="app.vue:15:3" data-prehydrate-id=":b3qlvSiBeH:"> Hi there </div>
})

// Advanced: access/set `data-prehydrate-id` yourself
const prehydrateId = onPrehydrate((el) => {})
</script>

<template>
  <div>
    Hi there
  </div>
</template>
```


# useAppConfig

## Usage

```ts
const appConfig = useAppConfig()

console.log(appConfig)
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
::


# useAsyncData

Within your pages, components, and plugins you can use useAsyncData to get access to data that resolves asynchronously.

::note
[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) is a composable meant to be called directly in the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context). It returns reactive composables and handles adding responses to the Nuxt payload so they can be passed from server to client **without re-fetching the data on client side** when the page hydrates.
::

## Usage

```vue [app/pages/index.vue]
<script setup lang="ts">
const { data, status, error, refresh, clear } = await useAsyncData(
  'mountains',
  () => $fetch('https://api.nuxtjs.dev/mountains')
)
</script>
```

::warning
If you're using a custom useAsyncData wrapper, do not await it in the composable, as that can cause unexpected behavior. Please follow [this recipe](https://nuxt.com/docs/guide/recipes/custom-usefetch#custom-usefetch) for more information on how to make a custom async data fetcher.
::

::note
`data`, `status` and `error` are Vue refs and they should be accessed with `.value` when used within the `<script setup>`, while `refresh`/`execute` and `clear` are plain functions.
::

### Watch Params

The built-in `watch` option allows automatically rerunning the fetcher function when any changes are detected.

```vue [app/pages/index.vue]
<script setup lang="ts">
const page = ref(1)
const { data: posts } = await useAsyncData(
  'posts',
  () => $fetch('https://fakeApi.com/posts', {
    params: {
      page: page.value
    }
  }), {
    watch: [page]
  }
)
</script>
```

### Reactive Keys

You can use a computed ref, plain ref or a getter function as the key, allowing for dynamic data fetching that automatically updates when the key changes:

```vue [app/pages/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const userId = computed(() => `user-${route.params.id}`)

// When the route changes and userId updates, the data will be automatically refetched
const { data: user } = useAsyncData(
  userId,
  () => fetchUserById(route.params.id)
)
</script>
```

::warning
[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) is a reserved function name transformed by the compiler, so you should not name your own function [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data).
::

::read-more
---
to: https://nuxt.com/docs/getting-started/data-fetching#useasyncdata
---
::

## Params

- `key`: a unique key to ensure that data fetching can be properly de-duplicated across requests. If you do not provide a key, then a key that is unique to the file name and line number of the instance of `useAsyncData` will be generated for you.
- `handler`: an asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
  :warning[The `handler` function should be **side-effect free** to ensure predictable behavior during SSR and CSR hydration. If you need to trigger side effects, use the [`callOnce`](https://nuxt.com/docs/api/utils/call-once) utility to do so.]
- `options`:

  - `server`: whether to fetch the data on the server (defaults to `true`)
  - `lazy`: whether to resolve the async function after loading the route, instead of blocking client-side navigation (defaults to `false`)
  - `immediate`: when set to `false`, will prevent the request from firing immediately. (defaults to `true`)
  - `default`: a factory function to set the default value of the `data`, before the async function resolves - useful with the `lazy: true` or `immediate: false` option
  - `transform`: a function that can be used to alter `handler` function result after resolving
  - `getCachedData`: Provide a function which returns cached data. A `null` or `undefined` return value will trigger a fetch. By default, this is:

    ```ts
    const getDefaultCachedData = (key, nuxtApp, ctx) => nuxtApp.isHydrating 
      ? nuxtApp.payload.data[key] 
      : nuxtApp.static.data[key]
    ```
    Which only caches data when `experimental.payloadExtraction` of `nuxt.config` is enabled.
  - `pick`: only pick specified keys in this array from the `handler` function result
  - `watch`: watch reactive sources to auto-refresh
  - `deep`: return data in a deep ref object. It is `false` by default to return data in a shallow ref object, which can improve performance if your data does not need to be deeply reactive.
  - `dedupe`: avoid fetching same key more than once at a time (defaults to `cancel`). Possible options:

    - `cancel` - cancels existing requests when a new one is made
    - `defer` - does not make new requests at all if there is a pending request

::note
Under the hood, `lazy: false` uses `<Suspense>` to block the loading of the route before the data has been fetched. Consider using `lazy: true` and implementing a loading state instead for a snappier user experience.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-lazy-async-data"}
You can use `useLazyAsyncData` to have the same behavior as `lazy: true` with `useAsyncData`.
::

::video-accordion
---
title: Watch a video from Alexander Lichter about client-side caching with
  getCachedData
video-id: aQPR0xn-MMk
---
::

### Shared State and Option Consistency

When using the same key for multiple `useAsyncData` calls, they will share the same `data`, `error` and `status` refs. This ensures consistency across components but requires option consistency.

The following options **must be consistent** across all calls with the same key:

- `handler` function
- `deep` option
- `transform` function
- `pick` array
- `getCachedData` function
- `default` value

The following options **can differ** without triggering warnings:

- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ❌ This will trigger a development warning
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })

// ✅ This is allowed
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: true })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: false })
```

::tip
Keyed state created using `useAsyncData` can be retrieved across your Nuxt application using [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data).
::

## Return Values

- `data`: the result of the asynchronous function that is passed in.
- `refresh`/`execute`: a function that can be used to refresh the data returned by the `handler` function.
- `error`: an error object if the data fetching failed.
- `status`: a string indicating the status of the data request:

  - `idle`: when the request has not started, such as:

    - when `execute` has not yet been called and `{ immediate: false }` is set
    - when rendering HTML on the server and `{ server: false }` is set
  - `pending`: the request is in progress
  - `success`: the request has completed successfully
  - `error`: the request has failed
- `clear`: a function that can be used to set `data` to `undefined` (or the value of `options.default()` if provided), set `error` to `undefined`, set `status` to `idle`, and mark any currently pending requests as cancelled.

By default, Nuxt waits until a `refresh` is finished before it can be executed again.

::note
If you have not fetched data on the server (for example, with `server: false`), then the data *will not* be fetched until hydration completes. This means even if you await [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) on the client side, `data` will remain `undefined` within `<script setup>`.
::

## Type

```ts [Signature]
function useAsyncData<DataT, DataE>(
  handler: (nuxtApp?: NuxtApp) => Promise<DataT>,
  options?: AsyncDataOptions<DataT>
): AsyncData<DataT, DataE>
function useAsyncData<DataT, DataE>(
  key: MaybeRefOrGetter<string>,
  handler: (nuxtApp?: NuxtApp) => Promise<DataT>,
  options?: AsyncDataOptions<DataT>
): Promise<AsyncData<DataT, DataE>>

type AsyncDataOptions<DataT> = {
  server?: boolean
  lazy?: boolean
  immediate?: boolean
  deep?: boolean
  dedupe?: 'cancel' | 'defer'
  default?: () => DataT | Ref<DataT> | null
  transform?: (input: DataT) => DataT | Promise<DataT>
  pick?: string[]
  watch?: MultiWatchSources | false
  getCachedData?: (key: string, nuxtApp: NuxtApp, ctx: AsyncDataRequestContext) => DataT | undefined
}

type AsyncDataRequestContext = {
  /** The reason for this data request */
  cause: 'initial' | 'refresh:manual' | 'refresh:hook' | 'watch'
}

type AsyncData<DataT, ErrorT> = {
  data: Ref<DataT | undefined>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
  clear: () => void
  error: Ref<ErrorT | undefined>
  status: Ref<AsyncDataRequestStatus>
};

interface AsyncDataExecuteOptions {
  dedupe?: 'cancel' | 'defer'
}

type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'
```

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# useCookie

## Usage

Within your pages, components, and plugins, you can use `useCookie` to read and write cookies in an SSR-friendly way.

```ts
const cookie = useCookie(name, options)
```

::note
`useCookie` only works in the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

::tip
The returned ref will automatically serialize and deserialize cookie values to JSON.
::

## Type

```ts [Signature]
import type { Ref } from 'vue'
import type { CookieParseOptions, CookieSerializeOptions } from 'cookie-es'

export interface CookieOptions<T = any> extends Omit<CookieSerializeOptions & CookieParseOptions, 'decode' | 'encode'> {
  decode?(value: string): T
  encode?(value: T): string
  default?: () => T | Ref<T>
  watch?: boolean | 'shallow'
  readonly?: boolean
}

export interface CookieRef<T> extends Ref<T> {}

export function useCookie<T = string | null | undefined>(
  name: string,
  options?: CookieOptions<T>
): CookieRef<T>
```

## Parameters

`name`: The name of the cookie.

`options`: Options to control cookie behavior. The object can have the following properties:

Most of the options will be directly passed to the [cookie](https://github.com/jshttp/cookie){rel="nofollow"} package.

| Property      | Type                   | Default                                                                        | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ------------- | ---------------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `decode`      | `(value: string) => T` | `decodeURIComponent` + [destr](https://github.com/unjs/destr){rel="nofollow"}. | Custom function to decode the cookie value. Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to decode a previously encoded cookie value into a JavaScript string or other object. :br &#x2A;*Note:** If an error is thrown from this function, the original, non-decoded cookie value will be returned as the cookie's value.                                                                                                                                                                                                                                                             |
| `encode`      | `(value: T) => string` | `JSON.stringify` + `encodeURIComponent`                                        | Custom function to encode the cookie value. Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to encode a value into a string suited for a cookie's value.                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `default`     | `() => T | Ref<T>`     | `undefined`                                                                    | Function returning the default value if the cookie does not exist. The function can also return a `Ref`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `watch`       | `boolean | 'shallow'`  | `true`                                                                         | Whether to watch for changes and update the cookie. `true` for deep watch, `'shallow'` for shallow watch, i.e. data changes for only top level properties, `false` to disable. :br &#x2A;*Note:** Refresh `useCookie` values manually when a cookie has changed with [`refreshCookie`](https://nuxt.com/docs/api/utils/refresh-cookie).                                                                                                                                                                                                                                                                                                                    |
| `readonly`    | `boolean`              | `false`                                                                        | If `true`, disables writing to the cookie.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `maxAge`      | `number`               | `undefined`                                                                    | Max age in seconds for the cookie, i.e. the value for the [`Max-Age` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.2){rel="nofollow"}. The given number will be converted to an integer by rounding down. By default, no maximum age is set.                                                                                                                                                                                                                                                                                                                                                                                     |
| `expires`     | `Date`                 | `undefined`                                                                    | Expiration date for the cookie. By default, no expiration is set. Most clients will consider this a "non-persistent cookie" and will delete it on a condition like exiting a web browser application. :br &#x2A;*Note:** The [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3){rel="nofollow"} states that if both `expires` and `maxAge` is set, then `maxAge` takes precedence, but not all clients may obey this, so if both are set, they should point to the same date and time! :br If neither of `expires` and `maxAge` is set, the cookie will be session-only and removed when the user closes their browser. |
| `httpOnly`    | `boolean`              | `false`                                                                        | Sets the HttpOnly attribute. :br &#x2A;*Note:** Be careful when setting this to `true`, as compliant clients will not allow client-side JavaScript to see the cookie in `document.cookie`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `secure`      | `boolean`              | `false`                                                                        | Sets the [`Secure` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.5){rel="nofollow"}. :br&#x2A;*Note:** Be careful when setting this to `true`, as compliant clients will not send the cookie back to the server in the future if the browser does not have an HTTPS connection. This can lead to hydration errors.                                                                                                                                                                                                                                                                                                               |
| `partitioned` | `boolean`              | `false`                                                                        | Sets the [`Partitioned` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/draft-cutler-httpbis-partitioned-cookies#section-2.1){rel="nofollow"}. :br&#x2A;*Note:** This is an attribute that has not yet been fully standardized, and may change in the future. :br This also means many clients may ignore this attribute until they understand it. :br More information can be found in the [proposal](https://github.com/privacycg/CHIPS){rel="nofollow"}.                                                                                                                                                                                  |
| `domain`      | `string`               | `undefined`                                                                    | Sets the [`Domain` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.3){rel="nofollow"}. By default, no domain is set, and most clients will consider applying the cookie only to the current domain.                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `path`        | `string`               | `'/'`                                                                          | Sets the [`Path` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.4){rel="nofollow"}. By default, the path is considered the ["default path"](https://tools.ietf.org/html/rfc6265#section-5.1.4){rel="nofollow"}.                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `sameSite`    | `boolean | string`     | `undefined`                                                                    | Sets the [`SameSite` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7){rel="nofollow"}. :br - `true` will set the `SameSite` attribute to `Strict` for strict same-site enforcement. :br - `false` will not set the `SameSite` attribute. :br - `'lax'` will set the `SameSite` attribute to `Lax` for lax same-site enforcement. :br - `'none'` will set the `SameSite` attribute to `None` for an explicit cross-site cookie. :br - `'strict'` will set the `SameSite` attribute to `Strict` for strict same-site enforcement.                                                                       |

## Return Values

Returns a Vue `Ref<T>` representing the cookie value. Updating the ref will update the cookie (unless `readonly` is set). The ref is SSR-friendly and will work on both client and server.

## Examples

### Basic Usage

The example below creates a cookie called `counter`. If the cookie doesn't exist, it is initially set to a random value. Whenever we update the `counter` variable, the cookie will be updated accordingly.

```vue [app/app.vue]
<script setup lang="ts">
const counter = useCookie('counter')

counter.value = counter.value || Math.round(Math.random() * 1000)
</script>

<template>
  <div>
    <h1>Counter: {{ counter || '-' }}</h1>
    <button @click="counter = null">reset</button>
    <button @click="counter--">-</button>
    <button @click="counter++">+</button>
  </div>
</template>
```

### Readonly Cookies

```vue
<script setup lang="ts">
const user = useCookie(
  'userInfo',
  {
    default: () => ({ score: -1 }),
    watch: false
  }
)

if (user.value) {
  // the actual `userInfo` cookie will not be updated
  user.value.score++
}
</script>

<template>
  <div>User score: {{ user?.score }}</div>
</template>
```

### Writable Cookies

```vue
<script setup lang="ts">
const list = useCookie(
  'list',
  {
    default: () => [],
    watch: 'shallow'
  }
)

function add() {
  list.value?.push(Math.round(Math.random() * 1000))
  // list cookie won't be updated with this change
}

function save() {
  if (list.value) {
    // the actual `list` cookie will be updated
    list.value = [...list.value]
  }
}
</script>

<template>
  <div>
    <h1>List</h1>
    <pre>{{ list }}</pre>
    <button @click="add">Add</button>
    <button @click="save">Save</button>
  </div>
</template>
```

### Cookies in API Routes

You can use `getCookie` and `setCookie` from [`h3`](https://github.com/h3js/h3){rel="nofollow"} package to set cookies in server API routes.

```ts [server/api/counter.ts]
export default defineEventHandler(event => {
  // Read counter cookie
  let counter = getCookie(event, 'counter') || 0

  // Increase counter cookie by 1
  setCookie(event, 'counter', ++counter)

  // Send JSON response
  return { counter }
})
```

::link-example{to="https://nuxt.com/docs/examples/advanced/use-cookie"}
::


# useError

## Usage

The `useError` composable returns the global Nuxt error that is being handled and is available on both client and server. It provides a reactive, SSR-friendly error state across your app.

```ts
const error = useError()
```

You can use this composable in your components, pages, or plugins to access or react to the current Nuxt error.

## Type

```ts
interface NuxtError<DataT = unknown> {
  statusCode: number
  statusMessage: string
  message: string
  data?: DataT
  error?: true
}

export const useError: () => Ref<NuxtError | undefined>
```

## Parameters

This composable does not take any parameters.

## Return Values

Returns a `Ref` containing the current Nuxt error (or `undefined` if there is no error). The error object is reactive and will update automatically when the error state changes.

## Example

```ts
<script setup lang="ts">
const error = useError()

if (error.value) {
  console.error('Nuxt error:', error.value)
}
</script>
```

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# useFetch

This composable provides a convenient wrapper around [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) and [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch).
It automatically generates a key based on URL and fetch options, provides type hints for request url based on server routes, and infers API response type.

::note
`useFetch` is a composable meant to be called directly in a setup function, plugin, or route middleware. It returns reactive composables and handles adding responses to the Nuxt payload so they can be passed from server to client without re-fetching the data on client side when the page hydrates.
::

## Usage

```vue [app/pages/modules.vue]
<script setup lang="ts">
const { data, status, error, refresh, clear } = await useFetch('/api/modules', {
  pick: ['title']
})
</script>
```

::warning
If you're using a custom useFetch wrapper, do not await it in the composable, as that can cause unexpected behavior. Please follow [this recipe](https://nuxt.com/docs/guide/recipes/custom-usefetch#custom-usefetch) for more information on how to make a custom async data fetcher.
::

::note
`data`, `status`, and `error` are Vue refs, and they should be accessed with `.value` when used within the `<script setup>`, while `refresh`/`execute` and `clear` are plain functions.
::

Using the `query` option, you can add search parameters to your query. This option is extended from [unjs/ofetch](https://github.com/unjs/ofetch){rel="nofollow"} and is using [unjs/ufo](https://github.com/unjs/ufo){rel="nofollow"} to create the URL. Objects are automatically stringified.

```ts
const param1 = ref('value1')
const { data, status, error, refresh } = await useFetch('/api/modules', {
  query: { param1, param2: 'value2' }
})
```

The above example results in `https://api.nuxt.com/modules?param1=value1&param2=value2`.

You can also use [interceptors](https://github.com/unjs/ofetch#%EF%B8%8F-interceptors){rel="nofollow"}:

```ts
const { data, status, error, refresh, clear } = await useFetch('/api/auth/login', {
  onRequest({ request, options }) {
    // Set the request headers
    // note that this relies on ofetch >= 1.4.0 - you may need to refresh your lockfile
    options.headers.set('Authorization', '...')
  },
  onRequestError({ request, options, error }) {
    // Handle the request errors
  },
  onResponse({ request, response, options }) {
    // Process the response data
    localStorage.setItem('token', response._data.token)
  },
  onResponseError({ request, response, options }) {
    // Handle the response errors
  }
})
```

### Reactive Keys and Shared State

You can use a computed ref or a plain ref as the URL, allowing for dynamic data fetching that automatically updates when the URL changes:

```vue [app/pages/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => route.params.id)

// When the route changes and id updates, the data will be automatically refetched
const { data: post } = await useFetch(() => `/api/posts/${id.value}`)
</script>
```

When using `useFetch` with the same URL and options in multiple components, they will share the same `data`, `error` and `status` refs. This ensures consistency across components.

::tip
Keyed state created using `useFetch` can be retrieved across your Nuxt application using [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data).
::

::warning
`useFetch` is a reserved function name transformed by the compiler, so you should not name your own function `useFetch`.
::

::warning
If you encounter the `data` variable destructured from a `useFetch` returns a string and not a JSON parsed object then make sure your component doesn't include an import statement like `import { useFetch } from '@vueuse/core`.
::

::video-accordion
---
title: Watch the video from Alexander Lichter to avoid using useFetch the wrong way
video-id: njsGVmcWviY
---
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::

## Type

```ts [Signature]
function useFetch<DataT, ErrorT>(
  url: string | Request | Ref<string | Request> | (() => string | Request),
  options?: UseFetchOptions<DataT>
): Promise<AsyncData<DataT, ErrorT>>

type UseFetchOptions<DataT> = {
  key?: MaybeRefOrGetter<string>
  method?: string
  query?: SearchParams
  params?: SearchParams
  body?: RequestInit['body'] | Record<string, any>
  headers?: Record<string, string> | [key: string, value: string][] | Headers
  baseURL?: string
  server?: boolean
  lazy?: boolean
  immediate?: boolean
  getCachedData?: (key: string, nuxtApp: NuxtApp, ctx: AsyncDataRequestContext) => DataT | undefined
  deep?: boolean
  dedupe?: 'cancel' | 'defer'
  default?: () => DataT
  transform?: (input: DataT) => DataT | Promise<DataT>
  pick?: string[]
  $fetch?: typeof globalThis.$fetch
  watch?: MultiWatchSources | false
}

type AsyncDataRequestContext = {
  /** The reason for this data request */
  cause: 'initial' | 'refresh:manual' | 'refresh:hook' | 'watch'
}

type AsyncData<DataT, ErrorT> = {
  data: Ref<DataT | undefined>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
  clear: () => void
  error: Ref<ErrorT | undefined>
  status: Ref<AsyncDataRequestStatus>
}

interface AsyncDataExecuteOptions {
  dedupe?: 'cancel' | 'defer'
}

type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'
```

## Parameters

- `URL` (`string | Request | Ref<string | Request> | () => string | Request`): The URL or request to fetch. Can be a string, a Request object, a Vue ref, or a function returning a string/Request. Supports reactivity for dynamic endpoints.
- `options` (object): Configuration for the fetch request. Extends [unjs/ofetch](https://github.com/unjs/ofetch){rel="nofollow"} options and [`AsyncDataOptions`](https://nuxt.com/docs/api/composables/use-async-data#params). All options can be a static value, a `ref`, or a computed value.

| Option          | Type                                                | Default    | Description                                                                                 |
| --------------- | --------------------------------------------------- | ---------- | ------------------------------------------------------------------------------------------- |
| `key`           | `MaybeRefOrGetter<string>`                          | auto-gen   | Unique key for de-duplication. If not provided, generated from URL and options.             |
| `method`        | `string`                                            | `'GET'`    | HTTP request method.                                                                        |
| `query`         | `object`                                            | -          | Query/search params to append to the URL. Alias: `params`. Supports refs/computed.          |
| `params`        | `object`                                            | -          | Alias for `query`.                                                                          |
| `body`          | `RequestInit['body'] | Record<string, any>`         | -          | Request body. Objects are automatically stringified. Supports refs/computed.                |
| `headers`       | `Record<string, string> | [key, value][] | Headers` | -          | Request headers.                                                                            |
| `baseURL`       | `string`                                            | -          | Base URL for the request.                                                                   |
| `timeout`       | `number`                                            | -          | Timeout in milliseconds to abort the request.                                               |
| `cache`         | `boolean | string`                                  | -          | Cache control. Boolean disables cache, or use Fetch API values: `default`, `no-store`, etc. |
| `server`        | `boolean`                                           | `true`     | Whether to fetch on the server.                                                             |
| `lazy`          | `boolean`                                           | `false`    | If true, resolves after route loads (does not block navigation).                            |
| `immediate`     | `boolean`                                           | `true`     | If false, prevents request from firing immediately.                                         |
| `default`       | `() => DataT`                                       | -          | Factory for default value of `data` before async resolves.                                  |
| `transform`     | `(input: DataT) => DataT | Promise<DataT>`          | -          | Function to transform the result after resolving.                                           |
| `getCachedData` | `(key, nuxtApp, ctx) => DataT | undefined`          | -          | Function to return cached data. See below for default.                                      |
| `pick`          | `string[]`                                          | -          | Only pick specified keys from the result.                                                   |
| `watch`         | `MultiWatchSources | false`                         | -          | Array of reactive sources to watch and auto-refresh. `false` disables watching.             |
| `deep`          | `boolean`                                           | `false`    | Return data in a deep ref object.                                                           |
| `dedupe`        | `'cancel' | 'defer'`                                | `'cancel'` | Avoid fetching same key more than once at a time.                                           |
| `$fetch`        | `typeof globalThis.$fetch`                          | -          | Custom $fetch implementation.                                                               |

::note
All fetch options can be given a `computed` or `ref` value. These will be watched and new requests made automatically with any new values if they are updated.
::

**getCachedData default:**

```ts
const getDefaultCachedData = (key, nuxtApp, ctx) => nuxtApp.isHydrating 
 ? nuxtApp.payload.data[key] 
 : nuxtApp.static.data[key]
```

This only caches data when `experimental.payloadExtraction` in `nuxt.config` is enabled.

## Return Values

| Name      | Type                                                | Description                                                                                                                                                       |
| --------- | --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `Ref<DataT | undefined>`                            | The result of the asynchronous fetch.                                                                                                                             |
| `refresh` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Function to manually refresh the data. By default, Nuxt waits until a `refresh` is finished before it can be executed again.                                      |
| `execute` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Alias for `refresh`.                                                                                                                                              |
| `error`   | `Ref<ErrorT | undefined>`                           | Error object if the data fetching failed.                                                                                                                         |
| `status`  | `Ref<'idle' | 'pending' | 'success' | 'error'>`     | Status of the data request. See below for possible values.                                                                                                        |
| `clear`   | `() => void`                                        | Resets `data` to `undefined` (or the value of `options.default()` if provided), `error` to `undefined`, set `status` to `idle`, and cancels any pending requests. |

### Status values

- `idle`: Request has not started (e.g. `{ immediate: false }` or `{ server: false }` on server render)
- `pending`: Request is in progress
- `success`: Request completed successfully
- `error`: Request failed

::note
If you have not fetched data on the server (for example, with `server: false`), then the data *will not* be fetched until hydration completes. This means even if you await `useFetch` on client-side, `data` will remain null within `<script setup>`.
::

### Examples

::link-example
---
to: https://nuxt.com/docs/examples/advanced/use-custom-fetch-composable
---
::

::link-example{to="https://nuxt.com/docs/examples/features/data-fetching"}
::


# useHead

The [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable function allows you to manage your head tags in a programmatic and reactive way, powered by [Unhead](https://unhead.unjs.io){rel="nofollow"}. If the data comes from a user or other untrusted source, we recommend you check out [`useHeadSafe`](https://nuxt.com/docs/api/composables/use-head-safe).

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Type

```ts
useHead(meta: MaybeComputedRef<MetaObject>): void
```

Below are the non-reactive types for [`useHead`](https://nuxt.com/docs/api/composables/use-head) .

```ts
interface MetaObject {
  title?: string
  titleTemplate?: string | ((title?: string) => string)
  base?: Base
  link?: Link[]
  meta?: Meta[]
  style?: Style[]
  script?: Script[]
  noscript?: Noscript[]
  htmlAttrs?: HtmlAttributes
  bodyAttrs?: BodyAttributes
}
```

See [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/schema.ts){rel="nofollow"} for more detailed types.

::note
The properties of `useHead` can be dynamic, accepting `ref`, `computed` and `reactive` properties. `meta` parameter can also accept a function returning an object to make the entire object reactive.
::

## Params

### `meta`

**Type**: `MetaObject`

An object accepting the following head metadata:

- `meta`: Each element in the array is mapped to a newly-created `<meta>` tag, where object properties are mapped to the corresponding attributes.

  - **Type**: `Array<Record<string, any>>`
- `link`: Each element in the array is mapped to a newly-created `<link>` tag, where object properties are mapped to the corresponding attributes.

  - **Type**: `Array<Record<string, any>>`
- `style`: Each element in the array is mapped to a newly-created `<style>` tag, where object properties are mapped to the corresponding attributes.

  - **Type**: `Array<Record<string, any>>`
- `script`: Each element in the array is mapped to a newly-created `<script>` tag, where object properties are mapped to the corresponding attributes.

  - **Type**: `Array<Record<string, any>>`
- `noscript`: Each element in the array is mapped to a newly-created `<noscript>` tag, where object properties are mapped to the corresponding attributes.

  - **Type**: `Array<Record<string, any>>`
- `titleTemplate`: Configures dynamic template to customize the page title on an individual page.

  - **Type**: `string` | `((title: string) => string)`
- `title`: Sets static page title on an individual page.

  - **Type**: `string`
- `bodyAttrs`: Sets attributes of the `<body>` tag. Each object property is mapped to the corresponding attribute.

  - **Type**: `Record<string, any>`
- `htmlAttrs`: Sets attributes of the `<html>` tag. Each object property is mapped to the corresponding attribute.

  - **Type**: `Record<string, any>`


# useHeadSafe

The `useHeadSafe` composable is a wrapper around the [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable that restricts the input to only allow safe values.

## Usage

You can pass all the same values as [`useHead`](https://nuxt.com/docs/api/composables/use-head)

```ts
useHeadSafe({
  script: [
    { id: 'xss-script', innerHTML: 'alert("xss")' }
  ],
  meta: [
    { 'http-equiv': 'refresh', content: '0;javascript:alert(1)' }
  ]
})
// Will safely generate
// <script id="xss-script"></script>
// <meta content="0;javascript:alert(1)">
```

::read-more
---
target: _blank
to: https://unhead.unjs.io/docs/typescript/head/api/composables/use-head-safe
---
Read more on the `Unhead` documentation.
::

## Type

```ts
useHeadSafe(input: MaybeComputedRef<HeadSafe>): void
```

The list of allowed values is:

```ts
const WhitelistAttributes = {
  htmlAttrs: ['class', 'style', 'lang', 'dir'],
  bodyAttrs: ['class', 'style'],
  meta: ['name', 'property', 'charset', 'content', 'media'],
  noscript: ['textContent'],
  style: ['media', 'textContent', 'nonce', 'title', 'blocking'],
  script: ['type', 'textContent', 'nonce', 'blocking'],
  link: ['color', 'crossorigin', 'fetchpriority', 'href', 'hreflang', 'imagesrcset', 'imagesizes', 'integrity', 'media', 'referrerpolicy', 'rel', 'sizes', 'type'],
}
```

See [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/safeSchema.ts){rel="nofollow"} for more detailed types.


# useHydration

::note
This is an advanced composable, primarily designed for use within plugins, mostly used by Nuxt modules.
::

::note
`useHydration` is designed to **ensure state synchronization and restoration during SSR**. If you need to create a globally reactive state that is SSR-friendly in Nuxt, [`useState`](https://nuxt.com/docs/api/composables/use-state) is the recommended choice.
::

`useHydration` is a built-in composable that provides a way to set data on the server side every time a new HTTP request is made and receive that data on the client side. This way `useHydration` allows you to take full control of the hydration cycle.

The data returned from the `get` function on the server is stored in `nuxtApp.payload` under the unique key provided as the first parameter to `useHydration`. During hydration, this data is then retrieved on the client, preventing redundant computations or API calls.

## Usage

::code-group
```ts [Without useHydration]
export default defineNuxtPlugin((nuxtApp) => {
  const myStore = new MyStore()

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      nuxtApp.payload.myStoreState = myStore.getState()
    })
  }

  if (import.meta.client) {
    nuxt.hooks.hook('app:created', () => {
      myStore.setState(nuxtApp.payload.myStoreState)
    })
  }
})
```

```ts [With useHydration]
export default defineNuxtPlugin((nuxtApp) => {
  const myStore = new MyStore()

  useHydration(
    'myStoreState', 
    () => myStore.getState(), 
    (data) => myStore.setState(data)
  )
})
```
::

## Type

```ts [signature]
useHydration <T> (key: string, get: () => T, set: (value: T) => void) => void
```

## Parameters

- `key`: A unique key that identifies the data in your Nuxt application.
- `get`: A function executed **only on the server** (called when SSR rendering is done) to set the initial value.
- `set`: A function executed **only on the client** (called when initial vue instance is created) to receive the data.


# useLazyAsyncData

## Description

By default, [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) blocks navigation until its async handler is resolved. `useLazyAsyncData` provides a wrapper around [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) that triggers navigation before the handler is resolved by setting the `lazy` option to `true`.

::note
`useLazyAsyncData` has the same signature as [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data).
::

::read-more{to="https://nuxt.com/docs/api/composables/use-async-data"}
::

## Example

```vue [app/pages/index.vue]
<script setup lang="ts">
/* Navigation will occur before fetching is complete.
  Handle 'pending' and 'error' states directly within your component's template
*/
const { status, data: count } = await useLazyAsyncData('count', () => $fetch('/api/count'))

watch(count, (newCount) => {
  // Because count might start out null, you won't have access
  // to its contents immediately, but you can watch it.
})
</script>

<template>
  <div>
    {{ status === 'pending' ? 'Loading' : count }}
  </div>
</template>
```

::warning
`useLazyAsyncData` is a reserved function name transformed by the compiler, so you should not name your own function `useLazyAsyncData`.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# useLazyFetch

## Description

By default, [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) blocks navigation until its async handler is resolved. `useLazyFetch` provides a wrapper around [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) that triggers navigation before the handler is resolved by setting the `lazy` option to `true`.

::note
`useLazyFetch` has the same signature as [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch).
::

::note
Awaiting `useLazyFetch` in this mode only ensures the call is initialized. On client-side navigation, data may not be immediately available, and you should make sure to handle the pending state in your app.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-fetch"}
::

## Example

```vue [app/pages/index.vue]
<script setup lang="ts">
/* Navigation will occur before fetching is complete.
 * Handle 'pending' and 'error' states directly within your component's template
 */
const { status, data: posts } = await useLazyFetch('/api/posts')
watch(posts, (newPosts) => {
  // Because posts might start out null, you won't have access
  // to its contents immediately, but you can watch it.
})
</script>

<template>
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

::note
`useLazyFetch` is a reserved function name transformed by the compiler, so you should not name your own function `useLazyFetch`.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# useLoadingIndicator

## Description

A composable which returns the loading state of the page. Used by [`<NuxtLoadingIndicator>`](https://nuxt.com/docs/api/components/nuxt-loading-indicator) and controllable.
It hooks into [`page:loading:start`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) and [`page:loading:end`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) to change its state.

## Parameters

- `duration`: Duration of the loading bar, in milliseconds (default `2000`).
- `throttle`: Throttle the appearing and hiding, in milliseconds (default `200`).
- `estimatedProgress`: By default Nuxt will back off as it approaches 100%. You can provide a custom function to customize the progress estimation, which is a function that receives the duration of the loading bar (above) and the elapsed time. It should return a value between 0 and 100.

## Properties

### `isLoading`

- **type**: `Ref<boolean>`
- **description**: The loading state

### `error`

- **type**: `Ref<boolean>`
- **description**: The error state

### `progress`

- **type**: `Ref<number>`
- **description**: The progress state. From `0` to `100`.

## Methods

### `start()`

Set `isLoading` to true and start to increase the `progress` value. `start` accepts a `{ force: true }` option to skip the interval and show the loading state immediately.

### `set()`

Set the `progress` value to a specific value. `set` accepts a `{ force: true }` option to skip the interval and show the loading state immediately.

### `finish()`

Set the `progress` value to `100`, stop all timers and intervals then reset the loading state `500` ms later. `finish` accepts a `{ force: true }` option to skip the interval before the state is reset, and `{ error: true }` to change the loading bar color and set the error property to true.

### `clear()`

Used by `finish()`. Clear all timers and intervals used by the composable.

## Example

```vue
<script setup lang="ts">
  const { progress, isLoading, start, finish, clear } = useLoadingIndicator({
    duration: 2000,
    throttle: 200,
    // This is how progress is calculated by default
    estimatedProgress: (duration, elapsed) => (2 / Math.PI * 100) * Math.atan(elapsed / duration * 100 / 50)
  })
</script>
```

```vue
<script setup lang="ts">
  const { start, set } = useLoadingIndicator()
  // same as set(0, { force: true })
  // set the progress to 0, and show loading immediately
  start({ force: true })
</script>
```


# useNuxtApp

`useNuxtApp` is a built-in composable that provides a way to access shared runtime context of Nuxt, also known as the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context), which is available on both client and server side (but not within Nitro routes). It helps you access the Vue app instance, runtime hooks, runtime config variables and internal states, such as `ssrContext` and `payload`.

```vue [app/app.vue]
<script setup lang="ts">
const nuxtApp = useNuxtApp()
</script>
```

If runtime context is unavailable in your scope, `useNuxtApp` will throw an exception when called. You can use [`tryUseNuxtApp`](https://nuxt.com/#tryusenuxtapp) instead for composables that do not require `nuxtApp`, or to simply check if context is available or not without an exception.

## Methods

### `provide (name, value)`

`nuxtApp` is a runtime context that you can extend using [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins). Use the `provide` function to create Nuxt plugins to make values and helper methods available in your Nuxt application across all composables and components.

`provide` function accepts `name` and `value` parameters.

```js
const nuxtApp = useNuxtApp()
nuxtApp.provide('hello', (name) => `Hello ${name}!`)

// Prints "Hello name!"
console.log(nuxtApp.$hello('name'))
```

As you can see in the example above, `$hello` has become the new and custom part of `nuxtApp` context and it is available in all places where `nuxtApp` is accessible.

### `hook(name, cb)`

Hooks available in `nuxtApp` allows you to customize the runtime aspects of your Nuxt application. You can use runtime hooks in Vue.js composables and [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins) to hook into the rendering lifecycle.

`hook` function is useful for adding custom logic by hooking into the rendering lifecycle at a specific point. `hook` function is mostly used when creating Nuxt plugins.

See [Runtime Hooks](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) for available runtime hooks called by Nuxt.

```ts [app/plugins/test.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('page:start', () => {
    /* your code goes here */
  })
  nuxtApp.hook('vue:error', (..._args) => {
    console.log('vue:error')
    // if (import.meta.client) {
    //   console.log(..._args)
    // }
  })
})
```

### `callHook(name, ...args)`

`callHook` returns a promise when called with any of the existing hooks.

```ts
await nuxtApp.callHook('my-plugin:init')
```

## Properties

`useNuxtApp()` exposes the following properties that you can use to extend and customize your app and share state, data and variables.

### `vueApp`

`vueApp` is the global Vue.js [application instance](https://vuejs.org/api/application.html#application-api){rel="nofollow"} that you can access through `nuxtApp`.

Some useful methods:

- [`component()`](https://vuejs.org/api/application.html#app-component){rel="nofollow"} - Registers a global component if passing both a name string and a component definition, or retrieves an already registered one if only the name is passed.
- [`directive()`](https://vuejs.org/api/application.html#app-directive){rel="nofollow"} - Registers a global custom directive if passing both a name string and a directive definition, or retrieves an already registered one if only the name is passed[(example)](https://nuxt.com/docs/guide/directory-structure/plugins#vue-directives).
- [`use()`](https://vuejs.org/api/application.html#app-use){rel="nofollow"&#x7D; - Installs a &#x2A;*[Vue.js Plugin](https://vuejs.org/guide/reusability/plugins.html){rel="nofollow"}** [(example)](https://nuxt.com/docs/guide/directory-structure/plugins#vue-plugins).

::read-more
---
icon: i-simple-icons-vuedotjs
to: https://vuejs.org/api/application.html#application-api
---
::

### `ssrContext`

`ssrContext` is generated during server-side rendering and it is only available on the server side.

Nuxt exposes the following properties through `ssrContext`:

- `url` (string) - Current request url.
- `event` ([h3js/h3](https://github.com/h3js/h3){rel="nofollow"} request event) - Access the request & response of the current route.
- `payload` (object) - NuxtApp payload object.

### `payload`

`payload` exposes data and state variables from server side to client side. The following keys will be available on the client after they have been passed from the server side:

- `serverRendered` (boolean) - Indicates if response is server-side-rendered.
- `data` (object) - When you fetch the data from an API endpoint using either [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) or [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) , resulting payload can be accessed from the `payload.data`. This data is cached and helps you prevent fetching the same data in case an identical request is made more than once. :code-group[```vue \[app/app.vue\]
  <script setup lang="ts">
  const { data } = await useAsyncData('count', () => $fetch('/api/count'))
  </script>
  ``````ts \[server/api/count.ts\]
  export default defineEventHandler(event => {
    return { count: 1 }
  })
  ```]:br After fetching the value of `count` using [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) in the example above, if you access `payload.data`, you will see `{ count: 1 }` recorded there. :br When accessing the same `payload.data` from [`ssrcontext`](https://nuxt.com/#ssrcontext), you can access the same value on the server side as well.
- `state` (object) - When you use [`useState`](https://nuxt.com/docs/api/composables/use-state) composable in Nuxt to set shared state, this state data is accessed through `payload.state.[name-of-your-state]`.
  ```ts [app/plugins/my-plugin.ts]
  export const useColor = () => useState<string>('color', () => 'pink')

  export default defineNuxtPlugin((nuxtApp) => {
    if (import.meta.server) {
      const color = useColor()
    }
  })
  ```
  :brIt is also possible to use more advanced types, such as `ref`, `reactive`, `shallowRef`, `shallowReactive` and `NuxtError`. :br Since [Nuxt v3.4](https://nuxt.com/blog/v3-4#payload-enhancements){rel="nofollow"}, it is possible to define your own reducer/reviver for types that are not supported by Nuxt. :video-accordion{title="Watch a video from Alexander Lichter about serializing payloads, especially with regards to classes" video-id="8w6ffRBs8a4"}:br In the example below, we define a reducer (or a serializer) and a reviver (or deserializer) for the [Luxon](https://moment.github.io/luxon/#/){rel="nofollow"} DateTime class, using a payload plugin.
  ```ts [app/plugins/date-time-payload.ts]
  /**
   * This kind of plugin runs very early in the Nuxt lifecycle, before we revive the payload.
   * You will not have access to the router or other Nuxt-injected properties.
   *
   * Note that the "DateTime" string is the type identifier and must
   * be the same on both the reducer and the reviver.
   */
  export default definePayloadPlugin((nuxtApp) => {
    definePayloadReducer('DateTime', (value) => {
      return value instanceof DateTime && value.toJSON()
    })
    definePayloadReviver('DateTime', (value) => {
      return DateTime.fromISO(value)
    })
  })
  ```

### `isHydrating`

Use `nuxtApp.isHydrating` (boolean) to check if the Nuxt app is hydrating on the client side.

```ts [app/components/nuxt-error-boundary.ts]
export default defineComponent({
  setup (_props, { slots, emit }) {
    const nuxtApp = useNuxtApp()
    onErrorCaptured((err) => {
      if (import.meta.client && !nuxtApp.isHydrating) {
        // ...
      }
    })
  }
})
```

### `runWithContext`

::note
You are likely here because you got a "Nuxt instance unavailable" message. Please use this method sparingly, and report examples that are causing issues, so that it can ultimately be solved at the framework level.
::

The `runWithContext` method is meant to be used to call a function and give it an explicit Nuxt context. Typically, the Nuxt context is passed around implicitly and you do not need to worry about this. However, when working with complex `async`/`await` scenarios in middleware/plugins, you can run into instances where the current instance has been unset after an async call.

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware(async (to, from) => {
  const nuxtApp = useNuxtApp()
  let user
  try {
    user = await fetchUser()
    // the Vue/Nuxt compiler loses context here because of the try/catch block.
  } catch (e) {
    user = null
  }
  if (!user) {
    // apply the correct Nuxt context to our `navigateTo` call.
    return nuxtApp.runWithContext(() => navigateTo('/auth'))
  }
})
```

#### Usage

```js
const result = nuxtApp.runWithContext(() => functionWithContext())
```

- `functionWithContext`: Any function that requires the context of the current Nuxt application. This context will be correctly applied automatically.

`runWithContext` will return whatever is returned by `functionWithContext`.

#### A Deeper Explanation of Context

Vue.js Composition API (and Nuxt composables similarly) work by depending on an implicit context. During the lifecycle, Vue sets the temporary instance of the current component (and Nuxt temporary instance of nuxtApp) to a global variable and unsets it in same tick. When rendering on the server side, there are multiple requests from different users and nuxtApp running in a same global context. Because of this, Nuxt and Vue immediately unset this global instance to avoid leaking a shared reference between two users or components.

What it does mean? The Composition API and Nuxt Composables are only available during lifecycle and in same tick before any async operation:

```js
// --- Vue internal ---
const _vueInstance = null
const getCurrentInstance = () => _vueInstance
// ---

// Vue / Nuxt sets a global variable referencing to current component in _vueInstance when calling setup()
async function setup() {
  getCurrentInstance() // Works
  await someAsyncOperation() // Vue unsets the context in same tick before async operation!
  getCurrentInstance() // null
}
```

The classic solution to this, is caching the current instance on first call to a local variable like `const instance = getCurrentInstance()` and use it in the next composable call but the issue is that any nested composable calls now needs to explicitly accept the instance as an argument and not depend on the implicit context of composition-api. This is design limitation with composables and not an issue per-se.

To overcome this limitation, Vue does some behind the scenes work when compiling our application code and restores context after each call for `<script setup>`:

```js
const __instance = getCurrentInstance() // Generated by Vue compiler
getCurrentInstance() // Works!
await someAsyncOperation() // Vue unsets the context
__restoreInstance(__instance) // Generated by Vue compiler
getCurrentInstance() // Still works!
```

For a better description of what Vue actually does, see [unjs/unctx#2 (comment)](https://github.com/unjs/unctx/issues/2#issuecomment-942193723){rel="nofollow"}.

#### Solution

This is where `runWithContext` can be used to restore context, similarly to how `<script setup>` works.

Nuxt internally uses [unjs/unctx](https://github.com/unjs/unctx){rel="nofollow"} to support composables similar to Vue for plugins and middleware. This enables composables like `navigateTo()` to work without directly passing `nuxtApp` to them - bringing the DX and performance benefits of Composition API to the whole Nuxt framework.

Nuxt composables have the same design as the Vue Composition API and therefore need a similar solution to magically do this transform. Check out [unjs/unctx#2](https://github.com/unjs/unctx/issues/2){rel="nofollow"} (proposal), [unjs/unctx#4](https://github.com/unjs/unctx/pull/4){rel="nofollow"} (transform implementation), and [nuxt/framework#3884](https://github.com/nuxt/framework/pull/3884){rel="nofollow"} (Integration to Nuxt).

Vue currently only supports async context restoration for `<script setup>` for async/await usage. In Nuxt, the transform support for `defineNuxtPlugin()` and `defineNuxtRouteMiddleware()` was added, which means when you use them Nuxt automatically transforms them with context restoration.

#### Remaining Issues

The `unjs/unctx` transformation to automatically restore context seems buggy with `try/catch` statements containing `await` which ultimately needs to be solved in order to remove the requirement of the workaround suggested above.

#### Native Async Context

Using a new experimental feature, it is possible to enable native async context support using [Node.js `AsyncLocalStorage`](https://nodejs.org/api/async_context.html#class-asynclocalstorage){rel="nofollow"} and new unctx support to make async context available **natively** to **any nested async composable** without needing a transform or manual passing/calling with context.

::tip
Native async context support works currently in Bun and Node.
::

::read-more
---
to: https://nuxt.com/docs/guide/going-further/experimental-features#asynccontext
---
::

## tryUseNuxtApp

This function works exactly the same as `useNuxtApp`, but returns `null` if context is unavailable instead of throwing an exception.

You can use it for composables that do not require `nuxtApp`, or to simply check if context is available or not without an exception.

Example usage:

```ts [composable.ts]
export function useStandType() {
  // Always works on the client
  if (tryUseNuxtApp()) {
    return useRuntimeConfig().public.STAND_TYPE
  } else {
    return process.env.STAND_TYPE
  }
}
```


# useNuxtData

::note
`useNuxtData` gives you access to the current cached value of [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) , [`useLazyAsyncData`](https://nuxt.com/docs/api/composables/use-lazy-async-data), [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) and [`useLazyFetch`](https://nuxt.com/docs/api/composables/use-lazy-fetch) with explicitly provided key.
::

## Usage

The `useNuxtData` composable is used to access the current cached value of data-fetching composables such as `useAsyncData`, `useLazyAsyncData`, `useFetch`, and `useLazyFetch`. By providing the key used during the data fetch, you can retrieve the cached data and use it as needed.

This is particularly useful for optimizing performance by reusing already-fetched data or implementing features like Optimistic Updates or cascading data updates.

To use `useNuxtData`, ensure that the data-fetching composable (`useFetch`, `useAsyncData`, etc.) has been called with an explicitly provided key.

::video-accordion
---
title: Watch a video from LearnVue about useNuxtData
video-id: e-_u6swXRWk
---
::

## Params

- `key`: The unique key that identifies the cached data. This key should match the one used during the original data fetch.

## Return Values

- `data`: A reactive reference to the cached data associated with the provided key. If no cached data exists, the value will be `null`. This `Ref` automatically updates if the cached data changes, allowing seamless reactivity in your components.

## Example

The example below shows how you can use cached data as a placeholder while the most recent data is being fetched from the server.

```vue [app/pages/posts.vue]
<script setup lang="ts">
// We can access same data later using 'posts' key
const { data } = await useFetch('/api/posts', { key: 'posts' })
</script>
```

```vue [app/pages/posts/[id\\].vue]
<script setup lang="ts">
// Access to the cached value of useFetch in posts.vue (parent route)
const { data: posts } = useNuxtData('posts')

const route = useRoute()

const { data } = useLazyFetch(`/api/posts/${route.params.id}`, {
  key: `post-${route.params.id}`,
  default() {
    // Find the individual post from the cache and set it as the default value.
    return posts.value.find(post => post.id === route.params.id)
  }
})
</script>
```

## Optimistic Updates

The example below shows how implementing Optimistic Updates can be achieved using useNuxtData.

Optimistic Updates is a technique where the user interface is updated immediately, assuming a server operation will succeed. If the operation eventually fails, the UI is rolled back to its previous state.

```vue [app/pages/todos.vue]
<script setup lang="ts">
// We can access same data later using 'todos' key
const { data } = await useAsyncData('todos', () => $fetch('/api/todos'))
</script>
```

```vue [app/components/NewTodo.vue]
<script setup lang="ts">
const newTodo = ref('')
let previousTodos = []

// Access to the cached value of useAsyncData in todos.vue
const { data: todos } = useNuxtData('todos')

async function addTodo () {
  return $fetch('/api/addTodo', {
    method: 'post',
    body: {
      todo: newTodo.value
    },
    onRequest () {
      // Store the previously cached value to restore if fetch fails.
      previousTodos = todos.value

      // Optimistically update the todos.
      todos.value = [...todos.value, newTodo.value]
    },
    onResponseError () {
      // Rollback the data if the request failed.
      todos.value = previousTodos
    },
    async onResponse () {
      // Invalidate todos in the background if the request succeeded.
      await refreshNuxtData('todos')
    }
  })
}
</script>
```

## Type

```ts
useNuxtData<DataT = any> (key: string): { data: Ref<DataT | undefined> }
```


# `usePreviewMode`

Preview mode allows you to see how your changes would be displayed on a live site without revealing them to users.

You can use the built-in `usePreviewMode` composable to access and control preview state in Nuxt. If the composable detects preview mode it will automatically force any updates necessary for [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) and [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) to rerender preview content.

```js
const { enabled, state } = usePreviewMode()
```

## Options

### Custom `enable` check

You can specify a custom way to enable preview mode. By default the `usePreviewMode` composable will enable preview mode if there is a `preview` param in url that is equal to `true` (for example, `http://localhost:3000?preview=true`). You can wrap the `usePreviewMode` into custom composable, to keep options consistent across usages and prevent any errors.

```js
export function useMyPreviewMode () {
  return usePreviewMode({
    shouldEnable: () => {
      return !!route.query.customPreview
    }
  });
}
```

### Modify default state

`usePreviewMode` will try to store the value of a `token` param from url in state. You can modify this state and it will be available for all [`usePreviewMode`](https://nuxt.com/docs/api/composables/use-preview-mode) calls.

```js
const data1 = ref('data1')

const { enabled, state } = usePreviewMode({
  getState: (currentState) => {
    return { data1, data2: 'data2' }
  }
})
```

::note
The `getState` function will append returned values to current state, so be careful not to accidentally overwrite important state.
::

### Customize the `onEnable` and `onDisable` callbacks

By default, when `usePreviewMode` is enabled, it will call `refreshNuxtData()` to re-fetch all data from the server.

When preview mode is disabled, the composable will attach a callback to call `refreshNuxtData()` to run after a subsequent router navigation.

You can specify custom callbacks to be triggered by providing your own functions for the `onEnable` and `onDisable` options.

```js
const { enabled, state } = usePreviewMode({
  onEnable: () => {
    console.log('preview mode has been enabled')
  },
  onDisable: () => {
    console.log('preview mode has been disabled')
  }
})
```

## Example

The example below creates a page where part of a content is rendered only in preview mode.

```vue [app/pages/some-page.vue]
<script setup>
const { enabled, state } = usePreviewMode()

const { data } = await useFetch('/api/preview', {
  query: {
    apiKey: state.token
  }
})
</script>

<template>
  <div>
    Some base content
    <p v-if="enabled">
      Only preview content: {{ state.token }}
      <br>
      <button @click="enabled = false">
        disable preview mode
      </button>
    </p>
  </div>
</template>
```

Now you can generate your site and serve it:

```bash [Terminal]
npx nuxt generate
npx nuxt preview
```

Then you can see your preview page by adding the query param `preview` to the end of the page you want to see once:

```js
?preview=true
```

::note
`usePreviewMode` should be tested locally with `nuxt generate` and then `nuxt preview` rather than `nuxt dev`. (The [preview command](https://nuxt.com/docs/api/commands/preview) is not related to preview mode.)
::


# useRequestEvent

Within the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context) you can use `useRequestEvent` to access the incoming request.

```ts
// Get underlying request event
const event = useRequestEvent()

// Get the URL
const url = event?.path
```

::tip
In the browser, `useRequestEvent` will return `undefined`.
::


# useRequestFetch

You can use `useRequestFetch` to forward the request context and headers when making server-side fetch requests.

When making a client-side fetch request, the browser automatically sends the necessary headers.
However, when making a request during server-side rendering, due to security considerations, we need to forward the headers manually.

::note
Headers that are **not meant to be forwarded** will **not be included** in the request. These headers include, for example:
`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

::tip
The [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) composable uses `useRequestFetch` under the hood to automatically forward the request context and headers.
::

::code-group
```vue [app/pages/index.vue]
<script setup lang="ts">
// This will forward the user's headers to the `/api/cookies` event handler
// Result: { cookies: { foo: 'bar' } }
const requestFetch = useRequestFetch()
const { data: forwarded } = await useAsyncData(() => requestFetch('/api/cookies'))

// This will NOT forward anything
// Result: { cookies: {} }
const { data: notForwarded } = await useAsyncData(() => $fetch('/api/cookies')) 
</script>
```

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```
::

::tip
In the browser during client-side navigation, `useRequestFetch` will behave just like regular [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch).
::


# useRequestHeader

You can use the built-in [`useRequestHeader`](https://nuxt.com/docs/api/composables/use-request-header) composable to access any incoming request header within your pages, components, and plugins.

```ts
// Get the authorization request header
const authorization = useRequestHeader('authorization')
```

::tip
In the browser, `useRequestHeader` will return `undefined`.
::

## Example

We can use `useRequestHeader` to easily figure out if a user is authorized or not.

The example below reads the `authorization` request header to find out if a person can access a restricted resource.

```ts [app/middleware/authorized-only.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  if (!useRequestHeader('authorization')) {
    return navigateTo('/not-authorized')
  }
})
```


# useRequestHeaders

You can use built-in [`useRequestHeaders`](https://nuxt.com/docs/api/composables/use-request-headers) composable to access the incoming request headers within your pages, components, and plugins.

```js
// Get all request headers
const headers = useRequestHeaders()

// Get only cookie request header
const headers = useRequestHeaders(['cookie'])
```

::tip
In the browser, `useRequestHeaders` will return an empty object.
::

## Example

We can use `useRequestHeaders` to access and proxy the initial request's `authorization` header to any future internal requests during SSR.

The example below adds the `authorization` request header to an isomorphic `$fetch` call.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/confidential', {
  headers: useRequestHeaders(['authorization'])
})
</script>
```


# useRequestURL

`useRequestURL` is a helper function that returns an [URL object](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL){rel="nofollow"} working on both server-side and client-side.

::important
When utilizing [Hybrid Rendering](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering) with cache strategies, all incoming request headers are dropped when handling the cached responses via the [Nitro caching layer](https://nitro.build/guide/cache){rel="nofollow"} (meaning `useRequestURL` will return `localhost` for the `host`).

You can define the [`cache.varies` option](https://nitro.build/guide/cache#options){rel="nofollow"} to specify headers that will be considered when caching and serving the responses, such as `host` and `x-forwarded-host` for multi-tenant environments.
::

::code-group
```vue [app/pages/about.vue]
<script setup lang="ts">
const url = useRequestURL()
</script>

<template>
  <p>URL is: {{ url }}</p>
  <p>Path is: {{ url.pathname }}</p>
</template>
```

```html [Result in development]
<p>URL is: http://localhost:3000/about</p>
<p>Path is: /about</p>
```
::

::tip
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/URL#instance_properties
---
Read about the URL instance properties on the MDN documentation.
::


# useResponseHeader

::important
This composable is available in Nuxt v3.14+.
::

You can use the built-in [`useResponseHeader`](https://nuxt.com/docs/api/composables/use-response-header) composable to set any server response header within your pages, components, and plugins.

```ts
// Set a custom response header
const header = useResponseHeader('X-My-Header');
header.value = 'my-value';
```

## Example

We can use `useResponseHeader` to easily set a response header on a per-page basis.

```vue [app/pages/test.vue]
<script setup>
// pages/test.vue
const header = useResponseHeader('X-My-Header');
header.value = 'my-value';
</script>

<template>
  <h1>Test page with custom header</h1>
  <p>The response from the server for this "/test" page will have a custom "X-My-Header" header.</p>
</template>
```

We can use `useResponseHeader` for example in Nuxt [middleware](https://nuxt.com/docs/guide/directory-structure/app/middleware) to set a response header for all pages.

```ts [app/middleware/my-header-middleware.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const header = useResponseHeader('X-My-Always-Header');
  header.value = `I'm Always here!`;
});

```


# useRoute

::note
Within the template of a Vue component, you can access the route using `$route`.
::

The `useRoute` composable is a wrapper around the identically named composable from `vue-router`, providing access to the current route in a Nuxt application.

The key difference is that in Nuxt, the composable ensures that the route is updated **only after** the page content has changed after navigation.
In contrast, the `vue-router` version updates the route **immediately**, which can lead to synchronization issues between different parts of the template
that rely on the route metadata, for example.

## Example

In the following example, we call an API via [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) using a dynamic page parameter - `slug` - as part of the URL.

```html [~/pages/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data: mountain } = await useFetch(`/api/mountains/${route.params.slug}`)
</script>

<template>
  <div>
    <h1>{{ mountain.title }}</h1>
    <p>{{ mountain.description }}</p>
  </div>
</template>
```

If you need to access the route query parameters (for example `example` in the path `/test?example=true`), then you can use `useRoute().query` instead of `useRoute().params`.

## API

Apart from dynamic parameters and query parameters, `useRoute()` also provides the following computed references related to the current route:

- `fullPath`: encoded URL associated with the current route that contains path, query and hash
- `hash`: decoded hash section of the URL that starts with a #
- `query`: access route query parameters
- `matched`: array of normalized matched routes with current route location
- `meta`: custom data attached to the record
- `name`: unique name for the route record
- `path`: encoded pathname section of the URL
- `redirectedFrom`: route location that was attempted to access before ending up on the current route location

## Common Pitfalls

### Route Synchronization Issues

It’s important to use the `useRoute()` composable from Nuxt rather than the one from `vue-router` to avoid synchronization issues during page navigation.
Importing `useRoute` directly from `vue-router` bypasses Nuxt's implementation.

```ts twoslash
// ❌ do not use `useRoute` from `vue-router`
// @errors: 2300
import { useRoute } from 'vue-router'
// ✅ use Nuxt's `useRoute` composable
import { useRoute } from '#app'
```

### Calling `useRoute` in Middleware

Using `useRoute` in middleware is not recommended because it can lead to unexpected behavior.
There is no concept of a "current route" in middleware.
The `useRoute()` composable should only be used in the setup function of a Vue component or in a Nuxt plugin.

::warning
This applies to any composable that uses `useRoute()` internally too.
::

::read-more
---
to: https://nuxt.com/docs/4.x/guide/directory-structure/app/middleware
---
Read more about accessing the route in the middleware section.
::

### Hydration Issues with `route.fullPath`

Browsers don't send [URL fragments](https://url.spec.whatwg.org/#concept-url-fragment){rel="nofollow"} (for example `#foo`) when making requests. So using `route.fullPath` to affect the template can trigger hydration issues because this will include the fragment on client but not the server.

::read-more
---
icon: i-simple-icons-vuedotjs
to: https://router.vuejs.org/api/type-aliases/RouteLocationNormalizedLoaded.html
---
::


# useRouteAnnouncer

::important
This composable is available in Nuxt v3.12+.
::

## Description

A composable which observes the page title changes and updates the announcer message accordingly. Used by [`<NuxtRouteAnnouncer>`](https://nuxt.com/docs/api/components/nuxt-route-announcer) and controllable.
It hooks into Unhead's [`dom:rendered`](https://unhead.unjs.io/docs/typescript/head/api/hooks/dom-rendered){rel="nofollow"} to read the page's title and set it as the announcer message.

## Parameters

- `politeness`: Sets the urgency for screen reader announcements: `off` (disable the announcement), `polite` (waits for silence), or `assertive` (interrupts immediately). (default `polite`).

## Properties

### `message`

- **type**: `Ref<string>`
- **description**: The message to announce

### `politeness`

- **type**: `Ref<string>`
- **description**: Screen reader announcement urgency level `off`, `polite`, or `assertive`

## Methods

### `set(message, politeness = "polite")`

Sets the message to announce with its urgency level.

### `polite(message)`

Sets the message with `politeness = "polite"`

### `assertive(message)`

Sets the message with `politeness = "assertive"`

## Example

```vue [app/pages/index.vue]
<script setup lang="ts">
  const { message, politeness, set, polite, assertive } = useRouteAnnouncer({
    politeness: 'assertive'
  })
</script>
```


# useRouter

```vue [app/pages/index.vue]
<script setup lang="ts">
const router = useRouter()
</script>
```

If you only need the router instance within your template, use `$router`:

```vue [app/pages/index.vue]
<template>
  <button @click="$router.back()">Back</button>
</template>
```

If you have a `app/pages/` directory, `useRouter` is identical in behavior to the one provided by `vue-router`.

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
to: https://router.vuejs.org/api/interfaces/Router.html#Properties-currentRoute
---
Read `vue-router` documentation about the `Router` interface.
::

## Basic Manipulation

- [`addRoute()`](https://router.vuejs.org/api/interfaces/Router.html#addRoute){rel="nofollow"}: Add a new route to the router instance. `parentName` can be provided to add new route as the child of an existing route.
- [`removeRoute()`](https://router.vuejs.org/api/interfaces/Router.html#removeRoute){rel="nofollow"}: Remove an existing route by its name.
- [`getRoutes()`](https://router.vuejs.org/api/interfaces/Router.html#getRoutes){rel="nofollow"}: Get a full list of all the route records.
- [`hasRoute()`](https://router.vuejs.org/api/interfaces/Router.html#hasRoute){rel="nofollow"}: Checks if a route with a given name exists.
- [`resolve()`](https://router.vuejs.org/api/interfaces/Router.html#resolve){rel="nofollow"}: Returns the normalized version of a route location. Also includes an `href` property that includes any existing base.

```ts [Example]
const router = useRouter()

router.addRoute({ name: 'home', path: '/home', component: Home })
router.removeRoute('home')
router.getRoutes()
router.hasRoute('home')
router.resolve({ name: 'home' })
```

::note
`router.addRoute()` adds route details into an array of routes and it is useful while building [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins) while `router.push()` on the other hand, triggers a new navigation immediately and it is useful in pages, Vue components and composable.
::

## Based on History API

- [`back()`](https://router.vuejs.org/api/interfaces/Router.html#back){rel="nofollow"}: Go back in history if possible, same as `router.go(-1)`.
- [`forward()`](https://router.vuejs.org/api/interfaces/Router.html#forward){rel="nofollow"}: Go forward in history if possible, same as `router.go(1)`.
- [`go()`](https://router.vuejs.org/api/interfaces/Router.html#go){rel="nofollow"}: Move forward or backward through the history without the hierarchical restrictions enforced in `router.back()` and `router.forward()`.
- [`push()`](https://router.vuejs.org/api/interfaces/Router.html#push){rel="nofollow"}: Programmatically navigate to a new URL by pushing an entry in the history stack. &#x2A;*It is recommended to use [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) instead.**
- [`replace()`](https://router.vuejs.org/api/interfaces/Router.html#replace){rel="nofollow"}: Programmatically navigate to a new URL by replacing the current entry in the routes history stack. &#x2A;*It is recommended to use [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) instead.**

```ts [Example]
const router = useRouter()

router.back()
router.forward()
router.go(3)
router.push({ path: "/home" })
router.replace({ hash: "#bio" })
```

::read-more
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/History
---
Read more about the browser's History API.
::

## Navigation Guards

`useRouter` composable provides `afterEach`, `beforeEach` and `beforeResolve` helper methods that acts as navigation guards.

However, Nuxt has a concept of **route middleware** that simplifies the implementation of navigation guards and provides a better developer experience.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/middleware"}
::

## Promise and Error Handling

- [`isReady()`](https://router.vuejs.org/api/interfaces/Router.html#isReady){rel="nofollow"}: Returns a Promise that resolves when the router has completed the initial navigation.
- [`onError`](https://router.vuejs.org/api/interfaces/Router.html#onError){rel="nofollow"}: Adds an error handler that is called every time a non caught error happens during navigation.

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Vue Router Docs
to: https://router.vuejs.org/api/interfaces/Router.html#Methods
---
::

## Universal Router Instance

If you do not have a `app/pages/` folder, then [`useRouter`](https://nuxt.com/docs/api/composables/use-router) will return a universal router instance with similar helper methods, but be aware that not all features may be supported or behave in exactly the same way as with `vue-router`.


# useRuntimeConfig

## Usage

```vue [app/app.vue]
<script setup lang="ts">
const config = useRuntimeConfig()
</script>
```

```ts [server/api/foo.ts]
export default defineEventHandler((event) => {
  const config = useRuntimeConfig(event)
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## Define Runtime Config

The example below shows how to set a public API base URL and a secret API token that is only accessible on the server.

We should always define `runtimeConfig` variables inside `nuxt.config`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // Private keys are only available on the server
    apiSecret: '123',

    // Public keys that are exposed to the client
    public: {
      apiBase: process.env.NUXT_PUBLIC_API_BASE || '/api'
    }
  }
})
```

::note
Variables that need to be accessible on the server are added directly inside `runtimeConfig`. Variables that need to be accessible on both the client and the server are defined in `runtimeConfig.public`.
::

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## Access Runtime Config

To access runtime config, we can use `useRuntimeConfig()` composable:

```ts [server/api/test.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  // Access public variables
  const result = await $fetch(`/test`, {
    baseURL: config.public.apiBase,
    headers: {
      // Access a private variable (only available on the server)
      Authorization: `Bearer ${config.apiSecret}`
    }
  })
  return result
}
```

In this example, since `apiBase` is defined within the `public` namespace, it is universally accessible on both server and client-side, while `apiSecret` **is only accessible on the server-side**.

## Environment Variables

It is possible to update runtime config values using a matching environment variable name prefixed with `NUXT_`.

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

### Using the `.env` File

We can set the environment variables inside the `.env` file to make them accessible during **development** and **build/generate**.

```ini [.env]
NUXT_PUBLIC_API_BASE = "https://api.localhost:5555"
NUXT_API_SECRET = "123"
```

::note
Any environment variables set within `.env` file are accessed using `process.env` in the Nuxt app during **development** and **build/generate**.
::

::warning
In **production runtime**, you should use platform environment variables and `.env` is not used.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/env"}
::

## `app` namespace

Nuxt uses `app` namespace in runtime-config with keys including `baseURL` and `cdnURL`. You can customize their values at runtime by setting environment variables.

::note
This is a reserved namespace. You should not introduce additional keys inside `app`.
::

### `app.baseURL`

By default, the `baseURL` is set to `'/'`.

However, the `baseURL` can be updated at runtime by setting the `NUXT_APP_BASE_URL` as an environment variable.

Then, you can access this new base URL using `config.app.baseURL`:

```ts [/plugins/my-plugin.ts]
export default defineNuxtPlugin((NuxtApp) => {
  const config = useRuntimeConfig()

  // Access baseURL universally
  const baseURL = config.app.baseURL
})
```

### `app.cdnURL`

This example shows how to set a custom CDN url and access them using `useRuntimeConfig()`.

You can use a custom CDN for serving static assets inside `.output/public` using the `NUXT_APP_CDN_URL` environment variable.

And then access the new CDN url using `config.app.cdnURL`.

```ts [server/api/foo.ts]
export default defineEventHandler((event) => {
  const config = useRuntimeConfig(event)

  // Access cdnURL universally
  const cdnURL = config.app.cdnURL
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::


# useRuntimeHook

::important
This composable is available in Nuxt v3.14+.
::

```ts [signature]
function useRuntimeHook<THookName extends keyof RuntimeNuxtHooks>(
  name: THookName,
  fn: RuntimeNuxtHooks[THookName] extends HookCallback ? RuntimeNuxtHooks[THookName] : never
): void
```

## Usage

### Parameters

- `name`: The name of the runtime hook to register. You can see the full list of [runtime Nuxt hooks here](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime).
- `fn`: The callback function to execute when the hook is triggered. The function signature varies based on the hook name.

### Returns

The composable doesn't return a value, but it automatically unregisters the hook when the component's scope is destroyed.

## Example

```vue [pages/index.vue] twoslash
<script setup lang="ts">
// Register a hook that runs every time a link is prefetched, but which will be
// automatically cleaned up (and not called again) when the component is unmounted
useRuntimeHook('link:prefetch', (link) => {
  console.log('Prefetching', link)
})
</script>
```


# useSeoMeta

This helps you avoid common mistakes, such as using `name` instead of `property`, as well as typos - with over 100+ meta tags fully typed.

::important
This is the recommended way to add meta tags to your site as it is XSS safe and has full TypeScript support.
::

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Usage

```vue [app/app.vue]
<script setup lang="ts">
useSeoMeta({
  title: 'My Amazing Site',
  ogTitle: 'My Amazing Site',
  description: 'This is my amazing site, let me tell you all about it.',
  ogDescription: 'This is my amazing site, let me tell you all about it.',
  ogImage: 'https://example.com/image.png',
  twitterCard: 'summary_large_image',
})
</script>
```

When inserting tags that are reactive, you should use the computed getter syntax (`() => value`):

```vue [app/app.vue]
<script setup lang="ts">
const title = ref('My title')

useSeoMeta({
  title,
  description: () => `This is a description for the ${title.value} page`
})
</script>
```

## Parameters

There are over 100 parameters. See the [full list of parameters in the source code](https://github.com/harlan-zw/zhead/blob/main/packages/zhead/src/metaFlat.ts#L1035){rel="nofollow"}.

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Performance

In most instances, SEO meta tags don't need to be reactive as search engine robots primarily scan the initial page load.

For better performance, you can wrap your `useSeoMeta` calls in a server-only condition when the meta tags don't need to be reactive:

```vue [app/app.vue]
<script setup lang="ts">
if (import.meta.server) {
  // These meta tags will only be added during server-side rendering
  useSeoMeta({
    robots: 'index, follow',
    description: 'Static description that does not need reactivity',
    ogImage: 'https://example.com/image.png',
    // other static meta tags...
  })
}

const dynamicTitle = ref('My title')
// Only use reactive meta tags outside the condition when necessary
useSeoMeta({
  title: () => dynamicTitle.value,
  ogTitle: () => dynamicTitle.value,
})
</script>
```

This previously used the [`useServerSeoMeta`](https://nuxt.com/docs/api/composables/use-server-seo-meta) composable, but it has been deprecated in favor of this approach.


# useServerSeoMeta

Just like [`useSeoMeta`](https://nuxt.com/docs/api/composables/use-seo-meta), `useServerSeoMeta` composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.

::read-more{to="https://nuxt.com/docs/api/composables/use-seo-meta"}
::

In most instances, the meta doesn't need to be reactive as robots will only scan the initial load. So we recommend using [`useServerSeoMeta`](https://nuxt.com/docs/api/composables/use-server-seo-meta) as a performance-focused utility that will not do anything (or return a `head` object) on the client.

```vue [app/app.vue]
<script setup lang="ts">
useServerSeoMeta({
  robots: 'index, follow'
})
</script>
```

Parameters are exactly the same as with [`useSeoMeta`](https://nuxt.com/docs/api/composables/use-seo-meta)

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::


# useState

## Usage

```ts
// Create a reactive state and set default value
const count = useState('counter', () => Math.round(Math.random() * 100))
```

::read-more{to="https://nuxt.com/docs/getting-started/state-management"}
::

::important
Because the data inside `useState` will be serialized to JSON, it is important that it does not contain anything that cannot be serialized, such as classes, functions or symbols.
::

::warning
`useState` is a reserved function name transformed by the compiler, so you should not name your own function `useState`.
::

::video-accordion
---
title: Watch a video from Alexander Lichter about why and when to use useState
video-id: mv0WcBABcIk
---
::

## Using `shallowRef`

If you don't need your state to be deeply reactive, you can combine `useState` with [`shallowRef`](https://vuejs.org/api/reactivity-advanced.html#shallowref){rel="nofollow"}. This can improve performance when your state contains large objects and arrays.

```ts
const state = useState('my-shallow-state', () => shallowRef({ deep: 'not reactive' }))
// isShallow(state) === true
```

## Type

```ts
useState<T>(init?: () => T | Ref<T>): Ref<T>
useState<T>(key: string, init?: () => T | Ref<T>): Ref<T>
```

- `key`: A unique key ensuring that data fetching is properly de-duplicated across requests. If you do not provide a key, then a key that is unique to the file and line number of the instance of [`useState`](https://nuxt.com/docs/api/composables/use-state) will be generated for you.
- `init`: A function that provides initial value for the state when not initiated. This function can also return a `Ref`.
- `T`: (typescript only) Specify the type of state


# $fetch

Nuxt uses [ofetch](https://github.com/unjs/ofetch){rel="nofollow"} to expose globally the `$fetch` helper for making HTTP requests within your Vue app or API routes.

::tip{icon="i-lucide-rocket"}
During server-side rendering, calling `$fetch` to fetch your internal [API routes](https://nuxt.com/docs/guide/directory-structure/server) will directly call the relevant function (emulating the request), **saving an additional API call**.
::

::note{color="blue" icon="i-lucide-info"}
Using `$fetch` in components without wrapping it with [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) causes fetching the data twice: initially on the server, then again on the client-side during hydration, because `$fetch` does not transfer state from the server to the client. Thus, the fetch will be executed on both sides because the client has to get the data again.
::

## Usage

We recommend using [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) or [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) + `$fetch` to prevent double data fetching when fetching the component data.

```vue [app/app.vue]
<script setup lang="ts">
// During SSR data is fetched twice, once on the server and once on the client.
const dataTwice = await $fetch('/api/item')

// During SSR data is fetched only on the server side and transferred to the client.
const { data } = await useAsyncData('item', () => $fetch('/api/item'))

// You can also useFetch as shortcut of useAsyncData + $fetch
const { data } = await useFetch('/api/item')
</script>
```

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::

You can use `$fetch` in any methods that are executed only on client-side.

```vue [app/pages/contact.vue]
<script setup lang="ts">
async function contactForm() {
  await $fetch('/api/contact', {
    method: 'POST',
    body: { hello: 'world '}
  })
}
</script>

<template>
  <button @click="contactForm">Contact</button>
</template>
```

::tip
`$fetch` is the preferred way to make HTTP calls in Nuxt instead of [@nuxt/http](https://github.com/nuxt/http){rel="nofollow"} and [@nuxtjs/axios](https://github.com/nuxt-community/axios-module){rel="nofollow"} that are made for Nuxt 2.
::

::note
If you use `$fetch` to call an (external) HTTPS URL with a self-signed certificate in development, you will need to set `NODE_TLS_REJECT_UNAUTHORIZED=0` in your environment.
::

### Passing Headers and Cookies

When we call `$fetch` in the browser, user headers like `cookie` will be directly sent to the API.

However, during Server-Side Rendering, due to security risks such as &#x2A;*Server-Side Request Forgery (SSRF)** or **Authentication Misuse**, the `$fetch` wouldn't include the user's browser cookies, nor pass on cookies from the fetch response.

::code-group
```vue [app/pages/index.vue]
<script setup lang="ts">
// This will NOT forward headers or cookies during SSR
const { data } = await useAsyncData(() => $fetch('/api/cookies'))
</script>
```

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const foo = getCookie(event, 'foo')
  // ... Do something with the cookie
})
```
::

If you need to forward headers and cookies on the server, you must manually pass them:

```vue [app/pages/index.vue]
<script setup lang="ts">
// This will forward the user's headers and cookies to `/api/cookies`
const requestFetch = useRequestFetch()
const { data } = await useAsyncData(() => requestFetch('/api/cookies'))
</script>
```

However, when calling `useFetch` with a relative URL on the server, Nuxt will use [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) to proxy headers and cookies (with the exception of headers not meant to be forwarded, like `host`).


# abortNavigation

::warning
`abortNavigation` is only usable inside a [route middleware handler](https://nuxt.com/docs/guide/directory-structure/app/middleware).
::

## Type

```ts
abortNavigation(err?: Error | string): false
```

## Parameters

### `err`

- **Type**: [`Error`](https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Error){rel="nofollow"} | `string`:br Optional error to be thrown by `abortNavigation`.

## Examples

The example below shows how you can use `abortNavigation` in a route middleware to prevent unauthorized route access:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('user')

  if (!user.value.isAuthorized) {
    return abortNavigation()
  }

  if (to.path !== '/edit-post') {
    return navigateTo('/edit-post')
  }
})
```

### `err` as a String

You can pass the error as a string:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('user')

  if (!user.value.isAuthorized) {
    return abortNavigation('Insufficient permissions.')
  }
})
```

### `err` as an Error Object

You can pass the error as an [`Error`](https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Error){rel="nofollow"} object, e.g. caught by the `catch`-block:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  try {
    /* code that might throw an error */
  } catch (err) {
    return abortNavigation(err)
  }
})
```


# addRouteMiddleware

::note
Route middleware are navigation guards stored in the [`app/middleware/`](https://nuxt.com/docs/guide/directory-structure/app/middleware) directory of your Nuxt application (unless [set otherwise](https://nuxt.com/docs/api/nuxt-config#middleware)).
::

## Type

```ts
function addRouteMiddleware (name: string, middleware: RouteMiddleware, options?: AddRouteMiddlewareOptions): void
function addRouteMiddleware (middleware: RouteMiddleware): void

interface AddRouteMiddlewareOptions {
  global?: boolean
}
```

## Parameters

### `name`

- **Type:** `string` | `RouteMiddleware`

Can be either a string or a function of type `RouteMiddleware`. Function takes the next route `to` as the first argument and the current route `from` as the second argument, both of which are Vue route objects.

Learn more about available properties of [route objects](https://nuxt.com/docs/api/composables/use-route).

### `middleware`

- **Type:** `RouteMiddleware`

The second argument is a function of type `RouteMiddleware`. Same as above, it provides `to` and `from` route objects. It becomes optional if the first argument in `addRouteMiddleware()` is already passed as a function.

### `options`

- **Type:** `AddRouteMiddlewareOptions`

An optional `options` argument lets you set the value of `global` to `true` to indicate whether the router middleware is global or not (set to `false` by default).

## Examples

### Named Route Middleware

Named route middleware is defined by providing a string as the first argument and a function as the second:

```ts [app/plugins/my-plugin.ts]
export default defineNuxtPlugin(() => {
  addRouteMiddleware('named-middleware', () => {
    console.log('named middleware added in Nuxt plugin')
  })
})
```

When defined in a plugin, it overrides any existing middleware of the same name located in the `app/middleware/` directory.

### Global Route Middleware

Global route middleware can be defined in two ways:

- Pass a function directly as the first argument without a name. It will automatically be treated as global middleware and applied on every route change.
  ```ts [app/plugins/my-plugin.ts]
  export default defineNuxtPlugin(() => {
    addRouteMiddleware((to, from) => {
      console.log('anonymous global middleware that runs on every route change')
    })
  })
  ```
- Set an optional, third argument `{ global: true }` to indicate whether the route middleware is global.
  ```ts [app/plugins/my-plugin.ts]
  export default defineNuxtPlugin(() => {
    addRouteMiddleware('global-middleware', (to, from) => {
        console.log('global middleware that runs on every route change')
      },
      { global: true }
    )
  })
  ```


# callOnce

::important
This utility is available since [Nuxt v3.9](https://nuxt.com/blog/v3-9).
::

## Purpose

The `callOnce` function is designed to execute a given function or block of code only once during:

- server-side rendering but not hydration
- client-side navigation

This is useful for code that should be executed only once, such as logging an event or setting up a global state.

## Usage

The default mode of `callOnce` is to run code only once. For example, if the code runs on the server it won't run again on the client. It also won't run again if you `callOnce` more than once on the client, for example by navigating back to this page.

```vue [app/app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  console.log('This will only be logged once')
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

It is also possible to run on every navigation while still avoiding the initial server/client double load. For this, it is possible to use the `navigation` mode:

```vue [app/app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  console.log('This will only be logged once and then on every client side navigation')
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
}, { mode: 'navigation' })
</script>
```

::important
`navigation` mode is available since [Nuxt v3.15](https://nuxt.com/blog/v3-15).
::

::tip
---
to: https://nuxt.com/docs/getting-started/state-management#usage-with-pinia
---
`callOnce` is useful in combination with the [Pinia module](https://nuxt.com/modules/pinia) to call store actions.
::

::read-more{to="https://nuxt.com/docs/getting-started/state-management"}
::

::warning
Note that `callOnce` doesn't return anything. You should use [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) or [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) if you want to do data fetching during SSR.
::

::note
`callOnce` is a composable meant to be called directly in a setup function, plugin, or route middleware, because it needs to add data to the Nuxt payload to avoid re-calling the function on the client when the page hydrates.
::

## Type

```ts
callOnce (key?: string, fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>
callOnce(fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>

type CallOnceOptions = {
  /**
   * Execution mode for the callOnce function
   * @default 'render'
   */
  mode?: 'navigation' | 'render'
}
```

## Parameters

- `key`: A unique key ensuring that the code is run once. If you do not provide a key, then a key that is unique to the file and line number of the instance of `callOnce` will be generated for you.
- `fn`: The function to run once. It can be asynchronous.
- `options`: Setup the mode, either to re-execute on navigation (`navigation`) or just once for the lifetime of the app (`render`). Defaults to `render`.

  - `render`: Executes once during initial render (either SSR or CSR) - Default mode
  - `navigation`: Executes once during initial render and once per subsequent client-side navigation


# clearError

Within your pages, components, and plugins, you can use `clearError` to clear all errors and redirect the user.

**Parameters:**

- `options?: { redirect?: string }`

You can provide an optional path to redirect to (for example, if you want to navigate to a 'safe' page).

```js
// Without redirect
clearError()

// With redirect
clearError({ redirect: '/homepage' })
```

Errors are set in state using [`useError()`](https://nuxt.com/docs/api/composables/use-error). The `clearError` composable will reset this state and calls the `app:error:cleared` hook with the provided options.

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# clearNuxtData

::note
This method is useful if you want to invalidate the data fetching for another page.
::

## Type

```ts
clearNuxtData (keys?: string | string[] | ((key: string) => boolean)): void
```

## Parameters

- `keys`: One or an array of keys that are used in [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) to delete their cached data. If no keys are provided, **all data** will be invalidated.


# clearNuxtState

::note
This method is useful if you want to invalidate the state of `useState`.
::

## Type

```ts
clearNuxtState (keys?: string | string[] | ((key: string) => boolean)): void
```

## Parameters

- `keys`: One or an array of keys that are used in [`useState`](https://nuxt.com/docs/api/composables/use-state) to delete their cached state. If no keys are provided, **all state** will be invalidated.


# createError

You can use this function to create an error object with additional metadata. It is usable in both the Vue and Nitro portions of your app, and is meant to be thrown.

## Parameters

- `err`: `string | { cause, data, message, name, stack, statusCode, statusMessage, fatal }`

You can pass either a string or an object to the `createError` function. If you pass a string, it will be used as the error `message`, and the `statusCode` will default to `500`. If you pass an object, you can set multiple properties of the error, such as `statusCode`, `message`, and other error properties.

## In Vue App

If you throw an error created with `createError`:

- on server-side, it will trigger a full-screen error page which you can clear with `clearError`.
- on client-side, it will throw a non-fatal error for you to handle. If you need to trigger a full-screen error page, then you can do this by setting `fatal: true`.

### Example

```vue [app/pages/movies/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data } = await useFetch(`/api/movies/${route.params.slug}`)
if (!data.value) {
  throw createError({ statusCode: 404, statusMessage: 'Page Not Found' })
}
</script>
```

## In API Routes

Use `createError` to trigger error handling in server API routes.

### Example

```ts [server/api/error.ts]
export default eventHandler(() => {
  throw createError({
    statusCode: 404,
    statusMessage: 'Page Not Found'
  })
})
```

In API routes, using `createError` by passing an object with a short `statusMessage` is recommended because it can be accessed on the client side. Otherwise, a `message` passed to `createError` on an API route will not propagate to the client. Alternatively, you can use the `data` property to pass data back to the client. In any case, always consider avoiding to put dynamic user input to the message to avoid potential security issues.

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# defineLazyHydrationComponent

`defineLazyHydrationComponent` is a compiler macro that helps you create a component with a specific lazy hydration strategy. Lazy hydration defers hydration until components become visible or until the browser has completed more critical tasks. This can significantly reduce the initial performance cost, especially for non-essential components.

## Usage

### Visibility Strategy

Hydrates the component when it becomes visible in the viewport.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'visible',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- 
      Hydration will be triggered when
      the element(s) is 100px away from entering the viewport.
    -->
    <LazyHydrationMyComponent :hydrate-on-visible="{ rootMargin: '100px' }" />
  </div>
</template>
```

The `hydrateOnVisible` prop is optional. You can pass an object to customize the behavior of the `IntersectionObserver` under the hood.

::read-more
---
title: IntersectionObserver options
to: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver
---
Read more about the options for `hydrate-on-visible`.
::

::note
Under the hood, this uses Vue's built-in [`hydrateOnVisible` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-visible){rel="nofollow"}.
::

### Idle Strategy

Hydrates the component when the browser is idle. This is suitable if you need the component to load as soon as possible, but not block the critical rendering path.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'idle',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- Hydration will be triggered when the browser is idle or after 2000ms. -->
    <LazyHydrationMyComponent :hydrate-on-idle="2000" />
  </div>
</template>
```

The `hydrateOnIdle` prop is optional. You can pass a positive number to specify the maximum timeout.

Idle strategy is for components that can be hydrated when the browser is idle.

::note
Under the hood, this uses Vue's built-in [`hydrateOnIdle` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-idle){rel="nofollow"}.
::

### Interaction Strategy

Hydrates the component after a specified interaction (e.g., click, mouseover).

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'interaction',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!--
      Hydration will be triggered when
      the element(s) is hovered over by the pointer.
    -->
    <LazyHydrationMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

The `hydrateOnInteraction` prop is optional. If you do not pass an event or a list of events, it defaults to hydrating on `pointerenter`, `click`, and `focus`.

::note
Under the hood, this uses Vue's built-in [`hydrateOnInteraction` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-interaction){rel="nofollow"}.
::

### Media Query Strategy

Hydrates the component when the window matches a media query.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'mediaQuery',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!--
      Hydration will be triggered when
      the window width is greater than or equal to 768px.
    -->
    <LazyHydrationMyComponent hydrate-on-media-query="(min-width: 768px)" />
  </div>
</template>
```

::note
Under the hood, this uses Vue's built-in [`hydrateOnMediaQuery` strategy](https://vuejs.org/guide/components/async.html#hydrate-on-media-query){rel="nofollow"}.
::

### Time Strategy

Hydrates the component after a specified delay (in milliseconds).

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'time', 
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- Hydration is triggered after 1000ms. -->
    <LazyHydrationMyComponent :hydrate-after="1000" />
  </div>
</template>
```

Time strategy is for components that can wait a specific amount of time.

### If Strategy

Hydrates the component based on a boolean condition.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'if',
  () => import('./components/MyComponent.vue')
)

const isReady = ref(false)

function myFunction() {
  // Trigger custom hydration strategy...
  isReady.value = true
}
</script>

<template>
  <div>
    <!-- Hydration is triggered when isReady becomes true. -->
    <LazyHydrationMyComponent :hydrate-when="isReady" />
  </div>
</template>
```

If strategy is best for components that might not always need to be hydrated.

### Never Hydrate

Never hydrates the component.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'never',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- This component will never be hydrated by Vue. -->
    <LazyHydrationMyComponent />
  </div>
</template>
```

### Listening to Hydration Events

All delayed hydration components emit a `@hydrated` event when they are hydrated.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'visible',
  () => import('./components/MyComponent.vue')
)

function onHydrate() {
  console.log("Component has been hydrated!")
}
</script>

<template>
  <div>
    <LazyHydrationMyComponent
      :hydrate-on-visible="{ rootMargin: '100px' }"
      @hydrated="onHydrated"
    />
  </div>
</template>
```

## Parameters

::warning
To ensure that the compiler correctly recognizes this macro, avoid using external variables. The following approach will prevent the macro from being properly recognized:

```vue
<script setup lang="ts">
const strategy = 'visible'
const source = () => import('./components/MyComponent.vue')
const LazyHydrationMyComponent = defineLazyHydrationComponent(strategy, source)
</script>
```
::

### `strategy`

- **Type**: `'visible' | 'idle' | 'interaction' | 'mediaQuery' | 'if' | 'time' | 'never'`
- **Required**: `true`

| Strategy      | Description                                                  |
| ------------- | ------------------------------------------------------------ |
| `visible`     | Hydrates when the component becomes visible in the viewport. |
| `idle`        | Hydrates when the browser is idle or after a delay.          |
| `interaction` | Hydrates upon user interaction (e.g., click, hover).         |
| `mediaQuery`  | Hydrates when the specified media query condition is met.    |
| `if`          | Hydrates when a specified boolean condition is met.          |
| `time`        | Hydrates after a specified time delay.                       |
| `never`       | Prevents Vue from hydrating the component.                   |

### `source`

- **Type**: `() => Promise<Component>`
- **Required**: `true`


# defineNuxtComponent

::note
`defineNuxtComponent()` is a helper function for defining type safe Vue components using options API similar to [`defineComponent()`](https://vuejs.org/api/general.html#definecomponent){rel="nofollow"}. `defineNuxtComponent()` wrapper also adds support for `asyncData` and `head` component options.
::

::note
Using `<script setup lang="ts">` is the recommended way of declaring Vue components in Nuxt.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::

## `asyncData()`

If you choose not to use `setup()` in your app, you can use the `asyncData()` method within your component definition:

```vue [app/pages/index.vue]
<script lang="ts">
export default defineNuxtComponent({
  async asyncData() {
    return {
      data: {
        greetings: 'hello world!'
      }
    }
  },
})
</script>
```

## `head()`

If you choose not to use `setup()` in your app, you can use the `head()` method within your component definition:

```vue [app/pages/index.vue]
<script lang="ts">
export default defineNuxtComponent({
  head(nuxtApp) {
    return {
      title: 'My site'
    }
  },
})
</script>
```


# defineNuxtPlugin

`defineNuxtPlugin` is a helper function for creating Nuxt plugins with enhanced functionality and type safety. This utility normalizes different plugin formats into a consistent structure that works seamlessly within Nuxt's plugin system.

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  // Doing something with nuxtApp
})
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/plugins#creating-plugins
---
::

## Type

```ts
defineNuxtPlugin<T extends Record<string, unknown>>(plugin: Plugin<T> | ObjectPlugin<T>): Plugin<T> & ObjectPlugin<T>

type Plugin<T> = (nuxt: [NuxtApp](/docs/guide/going-further/internals#the-nuxtapp-interface)) => Promise<void> | Promise<{ provide?: T }> | void | { provide?: T }

interface ObjectPlugin<T> {
  name?: string
  enforce?: 'pre' | 'default' | 'post'
  dependsOn?: string[]
  order?: number
  parallel?: boolean
  setup?: Plugin<T>
  hooks?: Partial<[RuntimeNuxtHooks](/docs/api/advanced/hooks#app-hooks-runtime)>
  env?: {
    islands?: boolean
  }
}
```

## Parameters

**plugin**: A plugin can be defined in two ways:

1. **Function Plugin**: A function that receives the [`NuxtApp`](https://nuxt.com/docs/guide/going-further/internals#the-nuxtapp-interface) instance and can return a promise with an potential object with a [`provide`](https://nuxt.com/docs/guide/directory-structure/plugins#providing-helpers) property if you want to provide a helper on [`NuxtApp`](https://nuxt.com/docs/guide/going-further/internals#the-nuxtapp-interface) instance.
2. **Object Plugin**: An object that can include various properties to configure the plugin's behavior, such as `name`, `enforce`, `dependsOn`, `order`, `parallel`, `setup`, `hooks`, and `env`.

| Property    | Type                                                                                                                                          | Required | Description                                                                                                                                                              |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name`      | `string`                                                                                                                                      | `false`  | Optional name for the plugin, useful for debugging and dependency management.                                                                                            |
| `enforce`   | `'pre'` \| `'default'` \| `'post'`                                                                                                            | `false`  | Controls when the plugin runs relative to other plugins.                                                                                                                 |
| `dependsOn` | `string[]`                                                                                                                                    | `false`  | Array of plugin names this plugin depends on. Ensures proper execution order.                                                                                            |
| `order`     | `number`                                                                                                                                      | `false`  | This allows more granular control over plugin order and should only be used by advanced users. &#x2A;*It overrides the value of `enforce` and is used to sort plugins.** |
| `parallel`  | `boolean`                                                                                                                                     | `false`  | Whether to execute the plugin in parallel with other parallel plugins.                                                                                                   |
| `setup`     | `Plugin<T>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                 | `false`  | The main plugin function, equivalent to a function plugin.                                                                                                               |
| `hooks`     | `Partial<RuntimeNuxtHooks>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Nuxt app runtime hooks to register directly.                                                                                                                             |
| `env`       | `{ islands?: boolean }`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}     | `false`  | Set this value to `false` if you don't want the plugin to run when rendering server-only or island components.                                                           |

::video-accordion
---
title: Watch a video from Alexander Lichter about the Object Syntax for Nuxt plugins
video-id: 2aXZyXB1QGQ
---
::

## Examples

### Basic Usage

The example below demonstrates a simple plugin that adds global functionality:

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  // Add a global method
  return {
    provide: {
      hello: (name: string) => `Hello ${name}!`
    }
  }
})
```

### Object Syntax Plugin

The example below shows the object syntax with advanced configuration:

```ts [plugins/advanced.ts] twoslash
export default defineNuxtPlugin({
  name: 'my-plugin',
  enforce: 'pre',
  async setup (nuxtApp) {
    // Plugin setup logic
    const data = await $fetch('/api/config')
    
    return {
      provide: {
        config: data
      }
    }
  },
  hooks: {
    'app:created'() {
      console.log('App created!')
    }
  },
})
```


# defineNuxtRouteMiddleware

Route middleware are stored in the [`app/middleware/`](https://nuxt.com/docs/guide/directory-structure/app/middleware) of your Nuxt application (unless [set otherwise](https://nuxt.com/docs/api/nuxt-config#middleware)).

## Type

```ts
defineNuxtRouteMiddleware(middleware: RouteMiddleware) => RouteMiddleware

interface RouteMiddleware {
  (to: RouteLocationNormalized, from: RouteLocationNormalized): ReturnType<NavigationGuard>
}
```

## Parameters

### `middleware`

- **Type**: `RouteMiddleware`

A function that takes two Vue Router's route location objects as parameters: the next route `to` as the first, and the current route `from` as the second.

Learn more about available properties of `RouteLocationNormalized&#x60; in the &#x2A;*[Vue Router docs](https://router.vuejs.org/api/type-aliases/RouteLocationNormalized.html){rel="nofollow"}**.

## Examples

### Showing Error Page

You can use route middleware to throw errors and show helpful error messages:

```ts [app/middleware/error.ts]
export default defineNuxtRouteMiddleware((to) => {
  if (to.params.id === '1') {
    throw createError({ statusCode: 404, statusMessage: 'Page Not Found' })
  }
})
```

The above route middleware will redirect a user to the custom error page defined in the `~/error.vue` file, and expose the error message and code passed from the middleware.

### Redirection

Use [`useState`](https://nuxt.com/docs/api/composables/use-state) in combination with `navigateTo` helper function inside the route middleware to redirect users to different routes based on their authentication status:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const auth = useState('auth')

  if (!auth.value.isAuthenticated) {
    return navigateTo('/login')
  }

  if (to.path !== '/dashboard') {
    return navigateTo('/dashboard')
  }
})
```

Both [navigateTo](https://nuxt.com/docs/api/utils/navigate-to) and [abortNavigation](https://nuxt.com/docs/api/utils/abort-navigation) are globally available helper functions that you can use inside `defineNuxtRouteMiddleware`.


# definePageMeta

`definePageMeta` is a compiler macro that you can use to set metadata for your **page** components located in the [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory (unless [set otherwise](https://nuxt.com/docs/api/nuxt-config#pages)). This way you can set custom metadata for each static or dynamic route of your Nuxt application.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'default'
})
</script>
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/pages#page-metadata
---
::

## Type

```ts
definePageMeta(meta: PageMeta) => void

interface PageMeta {
  validate?: (route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>
  redirect?: RouteRecordRedirectOption
  name?: string
  path?: string
  props?: RouteRecordRaw['props']
  alias?: string | string[]
  pageTransition?: boolean | TransitionProps
  layoutTransition?: boolean | TransitionProps
  viewTransition?: boolean | 'always'
  key?: false | string | ((route: RouteLocationNormalizedLoaded) => string)
  keepalive?: boolean | KeepAliveProps
  layout?: false | LayoutKey | Ref<LayoutKey> | ComputedRef<LayoutKey>
  middleware?: MiddlewareKey | NavigationGuard | Array<MiddlewareKey | NavigationGuard>
  scrollToTop?: boolean | ((to: RouteLocationNormalizedLoaded, from: RouteLocationNormalizedLoaded) => boolean)
  [key: string]: unknown
}
```

## Parameters

### `meta`

- **Type**: `PageMeta`:br An object accepting the following page metadata:&#x20;:b&#x72;&#x2A;*`name`**
  - **Type**: `string`:br You may define a name for this page's route. By default, name is generated based on path inside the [`app/pages/` directory](https://nuxt.com/docs/guide/directory-structure/app/pages).
  :b&#x72;&#x2A;*`path`**
  - **Type**: `string`:br You may define a [custom regular expression](https://nuxt.com/#using-a-custom-regular-expression) if you have a more complex pattern than can be expressed with the file name.
  :b&#x72;&#x2A;*`props`**
  - **Type**: [`RouteRecordRaw['props']`](https://router.vuejs.org/guide/essentials/passing-props){rel="nofollow"}:br Allows accessing the route `params` as props passed to the page component.
  :b&#x72;&#x2A;*`alias`**
  - **Type**: `string | string[]`:br Aliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like `/users/:id` and `/u/:id`. All `alias` and `path` values must share the same params.
  :b&#x72;&#x2A;*`keepalive`**
  - **Type**: `boolean` | [`KeepAliveProps`](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"}:br Set to `true` when you want to preserve page state across route changes or use the [`KeepAliveProps`](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"} for a fine-grained control.
  :b&#x72;&#x2A;*`key`**
  - **Type**: `false` | `string` | `((route: RouteLocationNormalizedLoaded) => string)`:br Set `key` value when you need more control over when the `<NuxtPage>` component is re-rendered.
  :b&#x72;&#x2A;*`layout`**
  - **Type**: `false` | `LayoutKey` | `Ref<LayoutKey>` | `ComputedRef<LayoutKey>`:br Set a static or dynamic name of the layout for each route. This can be set to `false` in case the default layout needs to be disabled.
  :b&#x72;&#x2A;*`layoutTransition`**
  - **Type**: `boolean` | [`TransitionProps`](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}:br Set name of the transition to apply for current layout. You can also set this value to `false` to disable the layout transition.
  :b&#x72;&#x2A;*`middleware`**
  - **Type**: `MiddlewareKey` | [`NavigationGuard`](https://router.vuejs.org/api/interfaces/NavigationGuard.html#navigationguard){rel="nofollow"} | `Array<MiddlewareKey | NavigationGuard>`:br Define anonymous or named middleware directly within `definePageMeta`. Learn more about [route middleware](https://nuxt.com/docs/guide/directory-structure/app/middleware).
  :b&#x72;&#x2A;*`pageTransition`**
  - **Type**: `boolean` | [`TransitionProps`](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}:br Set name of the transition to apply for current page. You can also set this value to `false` to disable the page transition.
  :b&#x72;&#x2A;*`viewTransition`**
  - **Type**: `boolean | 'always'`:br&#x2A;*Experimental feature, only available when [enabled in your nuxt.config file](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental)**:br
    Enable/disable View Transitions for the current page.
    If set to true, Nuxt will not apply the transition if the users browser matches `prefers-reduced-motion: reduce` (recommended). If set to `always`, Nuxt will always apply the transition.
  :b&#x72;&#x2A;*`redirect`**
  - **Type**: [`RouteRecordRedirectOption`](https://router.vuejs.org/guide/essentials/redirect-and-alias.html#redirect-and-alias){rel="nofollow"}:br Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.
  :b&#x72;&#x2A;*`validate`**
  - **Type**: `(route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>`:br Validate whether a given route can validly be rendered with this page. Return true if it is valid, or false if not. If another match can't be found, this will mean a 404. You can also directly return an object with `statusCode`/`statusMessage` to respond immediately with an error (other matches will not be checked).
  :b&#x72;&#x2A;*`scrollToTop`**
  - **Type**: `boolean | (to: RouteLocationNormalized, from: RouteLocationNormalized) => boolean`:br Tell Nuxt to scroll to the top before rendering the page or not. If you want to overwrite the default scroll behavior of Nuxt, you can do so in `~/router.options.ts` (see [custom routing](https://nuxt.com/docs/guide/recipes/custom-routing#using-approuteroptions)) for more info.
  :b&#x72;&#x2A;*`[key: string]`**
  - **Type**: `any`:br Apart from the above properties, you can also set **custom** metadata. You may wish to do so in a type-safe way by [augmenting the type of the `meta` object](https://nuxt.com/docs/guide/directory-structure/app/pages/#typing-custom-metadata).

## Examples

### Basic Usage

The example below demonstrates:

- how `key` can be a function that returns a value;
- how `keepalive` property makes sure that the `<modal>` component is not cached when switching between multiple components;
- adding `pageType` as a custom property:

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  key: (route) => route.fullPath,

  keepalive: {
    exclude: ['modal']
  },

  pageType: 'Checkout'
})
</script>
```

### Defining Middleware

The example below shows how the middleware can be defined using a `function` directly within the `definePageMeta` or set as a `string` that matches the middleware file name located in the `app/middleware/` directory:

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  // define middleware as a function
  middleware: [
    function (to, from) {
      const auth = useState('auth')

      if (!auth.value.authenticated) {
          return navigateTo('/login')
      }

      if (to.path !== '/checkout') {
        return navigateTo('/checkout')
      }
    }
  ],

  // ... or a string
  middleware: 'auth'

  // ... or multiple strings
  middleware: ['auth', 'another-named-middleware']
})
</script>
```

### Using a Custom Regular Expression

A custom regular expression is a good way to resolve conflicts between overlapping routes, for instance:

The two routes "/test-category" and "/1234-post" match both `[postId]-[postSlug].vue` and `[categorySlug].vue` page routes.

To make sure that we are only matching digits (`\d+`) for `postId` in the `[postId]-[postSlug]` route, we can add the following to the `[postId]-[postSlug].vue` page template:

```vue [app/pages/[postId\\]-[postSlug\\].vue]
<script setup lang="ts">
definePageMeta({
  path: '/:postId(\\d+)-:postSlug' 
})
</script>
```

For more examples see [Vue Router's Matching Syntax](https://router.vuejs.org/guide/essentials/route-matching-syntax.html){rel="nofollow"}.

### Defining Layout

You can define the layout that matches the layout's file name located (by default) in the [`app/layouts/` directory](https://nuxt.com/docs/guide/directory-structure/app/layouts). You can also disable the layout by setting the `layout` to `false`:

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  // set custom layout
  layout: 'admin'

  // ... or disable a default layout
  layout: false
})
</script>
```


# defineRouteRules

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#inlinerouterules
---
This feature is experimental and in order to use it you must enable the `experimental.inlineRouteRules` option in your `nuxt.config`.
::

## Usage

```vue [app/pages/index.vue]
<script setup lang="ts">
defineRouteRules({
  prerender: true
})
</script>

<template>
  <h1>Hello world!</h1>
</template>
```

Will be translated to:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true }
  }
})
```

::note
When running [`nuxt build`](https://nuxt.com/docs/api/commands/build), the home page will be pre-rendered in `.output/public/index.html` and statically served.
::

## Notes

- A rule defined in `~/pages/foo/bar.vue` will be applied to `/foo/bar` requests.
- A rule in `~/pages/foo/[id].vue` will be applied to `/foo/**` requests.

For more control, such as if you are using a custom `path` or `alias` set in the page's [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta), you should set `routeRules` directly within your `nuxt.config`.

::read-more
---
icon: i-lucide-medal
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
Read more about the `routeRules`.
::


# navigateTo

## Usage

`navigateTo` is available on both server side and client side. It can be used within the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context), or directly, to perform page navigation.

::warning
Make sure to always use `await` or `return` on result of `navigateTo` when calling it.
::

::note
`navigateTo` cannot be used within Nitro routes. To perform a server-side redirect in Nitro routes, use [`sendRedirect`](https://h3.dev/utils/response#sendredirectevent-location-code){rel="nofollow"} instead.
::

### Within a Vue Component

```vue
<script setup lang="ts">
// passing 'to' as a string
await navigateTo('/search')

// ... or as a route object
await navigateTo({ path: '/search' })

// ... or as a route object with query parameters
await navigateTo({
  path: '/search',
  query: {
    page: 1,
    sort: 'asc'
  }
})
</script>
```

### Within Route Middleware

```ts
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.path !== '/search') {
    // setting the redirect code to '301 Moved Permanently'
    return navigateTo('/search', { redirectCode: 301 })
  }
})
```

When using `navigateTo` within route middleware, you must **return its result** to ensure the middleware execution flow works correctly.

For example, the following implementation **will not work as expected**:

```ts
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.path !== '/search') {
    // ❌ This will not work as expected
    navigateTo('/search', { redirectCode: 301 })
    return
  }
})
```

In this case, `navigateTo` will be executed but not returned, which may lead to unexpected behavior.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/middleware"}
::

### Navigating to an External URL

The `external` parameter in `navigateTo` influences how navigating to URLs is handled:

- **Without `external: true`**:
  - Internal URLs navigate as expected.
  - External URLs throw an error.
- **With `external: true`**:
  - Internal URLs navigate with a full-page reload.
  - External URLs navigate as expected.

#### Example

```vue
<script setup lang="ts">
// will throw an error;
// navigating to an external URL is not allowed by default
await navigateTo('https://nuxt.com')

// will redirect successfully with the 'external' parameter set to 'true'
await navigateTo('https://nuxt.com', {
  external: true
})
</script>
```

### Opening a Page in a New Tab

```vue
<script setup lang="ts">
// will open 'https://nuxt.com' in a new tab
await navigateTo('https://nuxt.com', {
  open: {
    target: '_blank',
    windowFeatures: {
      width: 500,
      height: 500
    }
  }
})
</script>
```

## Type

```ts
function navigateTo(
  to: RouteLocationRaw | undefined | null,
  options?: NavigateToOptions
) => Promise<void | NavigationFailure | false> | false | void | RouteLocationRaw 

interface NavigateToOptions {
  replace?: boolean
  redirectCode?: number
  external?: boolean
  open?: OpenOptions
}

type OpenOptions = {
  target: string
  windowFeatures?: OpenWindowFeatures
}

type OpenWindowFeatures = {
  popup?: boolean
  noopener?: boolean
  noreferrer?: boolean
} & XOR<{ width?: number }, { innerWidth?: number }>
  & XOR<{ height?: number }, { innerHeight?: number }>
  & XOR<{ left?: number }, { screenX?: number }>
  & XOR<{ top?: number }, { screenY?: number }>
```

## Parameters

### `to`

**Type**: [`RouteLocationRaw`](https://router.vuejs.org/api/interfaces/RouteLocationOptions.html#Interface-RouteLocationOptions){rel="nofollow"} | `undefined` | `null`

**Default**: `'/'`

`to` can be a plain string or a route object to redirect to. When passed as `undefined` or `null`, it will default to `'/'`.

#### Example

```ts
// Passing the URL directly will redirect to the '/blog' page
await navigateTo('/blog')

// Using the route object, will redirect to the route with the name 'blog'
await navigateTo({ name: 'blog' })

// Redirects to the 'product' route while passing a parameter (id = 1) using the route object.
await navigateTo({ name: 'product', params: { id: 1 } })
```

### `options` (optional)

**Type**: `NavigateToOptions`

An object accepting the following properties:

- `replace`
  - **Type**: `boolean`
  - **Default**: `false`
  - By default, `navigateTo` pushes the given route into the Vue Router's instance on the client side. :br This behavior can be changed by setting `replace` to `true`, to indicate that given route should be replaced.
- `redirectCode`
  - **Type**: `number`
  - **Default**: `302`
  - `navigateTo` redirects to the given path and sets the redirect code to [`302 Found`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302){rel="nofollow"} by default when the redirection takes place on the server side. :br This default behavior can be modified by providing different `redirectCode`. Commonly, [`301 Moved Permanently`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301){rel="nofollow"} can be used for permanent redirections.
- `external`
  - **Type**: `boolean`
  - **Default**: `false`
  - Allows navigating to an external URL when set to `true`. Otherwise, `navigateTo` will throw an error, as external navigation is not allowed by default.
- `open`
  - **Type**: `OpenOptions`
  - Allows navigating to the URL using the [open()](https://developer.mozilla.org/en-US/docs/Web/API/Window/open){rel="nofollow"} method of the window. This option is only applicable on the client side and will be ignored on the server side. :br An object accepting the following properties:
  - `target`
    - **Type**: `string`
    - **Default**: `'_blank'`
    - A string, without whitespace, specifying the name of the browsing context the resource is being loaded into.
  - `windowFeatures`
    - **Type**: `OpenWindowFeatures`
    - An object accepting the following properties:
      | Property                  | Type      | Description                                                                                    |
      | ------------------------- | --------- | ---------------------------------------------------------------------------------------------- |
      | `popup`                   | `boolean` | Requests a minimal popup window instead of a new tab, with UI features decided by the browser. |
      | `width` or `innerWidth`   | `number`  | Specifies the content area's width (minimum 100 pixels), including scrollbars.                 |
      | `height` or `innerHeight` | `number`  | Specifies the content area's height (minimum 100 pixels), including scrollbars.                |
      | `left` or `screenX`       | `number`  | Sets the horizontal position of the new window relative to the left edge of the screen.        |
      | `top` or `screenY`        | `number`  | Sets the vertical position of the new window relative to the top edge of the screen.           |
      | `noopener`                | `boolean` | Prevents the new window from accessing the originating window via `window.opener`.             |
      | `noreferrer`              | `boolean` | Prevents the Referer header from being sent and implicitly enables `noopener`.                 |
      :brRefer to the [documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/open#windowfeatures){rel="nofollow"} for more detailed information on the **windowFeatures** properties.


# onBeforeRouteLeave

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Vue Router Docs
to: https://router.vuejs.org/api/functions/onBeforeRouteLeave.html
---
::


# onBeforeRouteUpdate

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Vue Router Docs
to: https://router.vuejs.org/api/functions/onBeforeRouteUpdate.html
---
::


# onNuxtReady

::important
`onNuxtReady` only runs on the client-side. :br
It is ideal for running code that should not block the initial rendering of your app.
::

```ts [app/plugins/ready.client.ts]
export default defineNuxtPlugin(() => {
  onNuxtReady(async () => {
    const myAnalyticsLibrary = await import('my-big-analytics-library')
    // do something with myAnalyticsLibrary
  })
})
```

It is 'safe' to run even after your app has initialized. In this case, then the code will be registered to run in the next idle callback.


# prefetchComponents

Prefetching component downloads the code in the background, this is based on the assumption that the component will likely be used for rendering, enabling the component to load instantly if and when the user requests it. The component is downloaded and cached for anticipated future use without the user making an explicit request for it.

Use `prefetchComponents` to manually prefetch individual components that have been registered globally in your Nuxt app. By default Nuxt registers these as async components. You must use the Pascal-cased version of the component name.

```ts
await prefetchComponents('MyGlobalComponent')

await prefetchComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])
```

::note
Current implementation behaves exactly the same as [`preloadComponents`](https://nuxt.com/docs/api/utils/preload-components) by preloading components instead of just prefetching we are working to improve this behavior.
::

::note
On server, `prefetchComponents` will have no effect.
::


# preloadComponents

Preloading components loads components that your page will need very soon, which you want to start loading early in rendering lifecycle. This ensures they are available earlier and are less likely to block the page's render, improving performance.

Use `preloadComponents` to manually preload individual components that have been registered globally in your Nuxt app. By default Nuxt registers these as async components. You must use the Pascal-cased version of the component name.

```js
await preloadComponents('MyGlobalComponent')

await preloadComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])
```

::note
On server, `preloadComponents` will have no effect.
::


# preloadRouteComponents

Preloading routes loads the components of a given route that the user might navigate to in future. This ensures that the components are available earlier and less likely to block the navigation, improving performance.

::tip{icon="i-lucide-rocket"}
Nuxt already automatically preloads the necessary routes if you're using the `NuxtLink` component.
::

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
::

## Example

Preload a route when using `navigateTo`.

```ts
// we don't await this async function, to avoid blocking rendering
// this component's setup function
preloadRouteComponents('/dashboard')

const submit = async () => {
  const results = await $fetch('/api/authentication')

  if (results.token) {
    await navigateTo('/dashboard')
  }
}
```

::read-more{to="https://nuxt.com/docs/api/utils/navigate-to"}
::

::note
On server, `preloadRouteComponents` will have no effect.
::


# prerenderRoutes

When prerendering, you can hint to Nitro to prerender additional paths, even if their URLs do not show up in the HTML of the generated page.

::important
`prerenderRoutes` can only be called within the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

::note
`prerenderRoutes` has to be executed during prerendering. If the `prerenderRoutes` is used in dynamic pages/routes which are not prerendered, then it will not be executed.
::

```js
const route = useRoute()

prerenderRoutes('/')
prerenderRoutes(['/', '/about'])
```

::note
In the browser, or if called outside prerendering, `prerenderRoutes` will have no effect.
::

You can even prerender API routes which is particularly useful for full statically generated sites (SSG) because you can then `$fetch` data as if you have an available server!

```js
prerenderRoutes('/api/content/article/name-of-article')

// Somewhere later in App
const articleContent = await $fetch('/api/content/article/name-of-article', {
  responseType: 'json',
})
```

::warning
Prerendered API routes in production may not return the expected response headers, depending on the provider you deploy to. For example, a JSON response might be served with an `application/octet-stream` content type.
Always manually set `responseType` when fetching prerendered API routes.
::


# refreshCookie

::important
This utility is available since [Nuxt v3.10](https://nuxt.com/blog/v3-10).
::

## Purpose

The `refreshCookie` function is designed to refresh cookie value returned by `useCookie`.

This is useful for updating the `useCookie` ref when we know the new cookie value has been set in the browser.

## Usage

```vue [app/app.vue]
<script setup lang="ts">
const tokenCookie = useCookie('token')

const login = async (username, password) => {
  const token = await $fetch('/api/token', { ... }) // Sets `token` cookie on response
  refreshCookie('token')
}

const loggedIn = computed(() => !!tokenCookie.value)
</script>
```

::note
---
to: https://nuxt.com/docs/guide/going-further/experimental-features#cookiestore
---
You can enable experimental `cookieStore` option to automatically refresh `useCookie` value when cookie changes in the browser.
::

## Type

```ts
refreshCookie(name: string): void
```


# refreshNuxtData

`refreshNuxtData` is used to refetch all or specific `asyncData` instances, including those from [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data), [`useLazyAsyncData`](https://nuxt.com/docs/api/composables/use-lazy-async-data), [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch), and [`useLazyFetch`](https://nuxt.com/docs/api/composables/use-lazy-fetch).

::note
If your component is cached by `<KeepAlive>` and enters a deactivated state, the `asyncData` inside the component will still be refetched until the component is unmounted.
::

## Type

```ts
refreshNuxtData(keys?: string | string[])
```

## Parameters

- `keys`: A single string or an array of strings as `keys` that are used to fetch the data. This parameter is **optional**. All [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) and [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) keys are re-fetched when no `keys` are explicitly specified.

## Return Values

`refreshNuxtData` returns a promise, resolving when all or specific `asyncData` instances have been refreshed.

## Examples

### Refresh All Data

This example below refreshes all data being fetched using `useAsyncData` and `useFetch` in Nuxt application.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
const refreshing = ref(false)

async function refreshAll () {
  refreshing.value = true
  try {
    await refreshNuxtData()
  } finally {
    refreshing.value = false
  }
}
</script>

<template>
  <div>
    <button :disabled="refreshing" @click="refreshAll">
      Refetch All Data
    </button>
  </div>
</template>
```

### Refresh Specific Data

This example below refreshes only data where the key matches to `count` and `user`.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
const refreshing = ref(false)

async function refresh () {
  refreshing.value = true
  try {
    // you could also pass an array of keys to refresh multiple data
    await refreshNuxtData(['count', 'user'])
  } finally {
    refreshing.value = false
  }
}
</script>

<template>
  <div v-if="refreshing">
    Loading
  </div>
  <button @click="refresh">Refresh</button>
</template>
```

::note
If you have access to the `asyncData` instance, it is recommended to use its `refresh` or `execute` method as the preferred way to refetch the data.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# reloadNuxtApp

::note
`reloadNuxtApp` will perform a hard reload of your app, re-requesting a page and its dependencies from the server.
::

By default, it will also save the current `state` of your app (that is, any state you could access with `useState`).

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#restorestate
---
You can enable experimental restoration of this state by enabling the `experimental.restoreState` option in your `nuxt.config` file.
::

## Type

```ts
reloadNuxtApp(options?: ReloadNuxtAppOptions)

interface ReloadNuxtAppOptions {
  ttl?: number
  force?: boolean
  path?: string
  persistState?: boolean
}
```

### `options` (optional)

**Type**: `ReloadNuxtAppOptions`

An object accepting the following properties:

- `path` (optional) :br**Type**: `string`:br**Default**: `window.location.pathname`:br The path to reload (defaulting to the current path). If this is different from the current window location it
  will trigger a navigation and add an entry in the browser history.
- `ttl` (optional) :br**Type**: `number`:br**Default**: `10000`:br The number of milliseconds in which to ignore future reload requests. If called again within this time period,
  `reloadNuxtApp` will not reload your app to avoid reload loops.
- `force` (optional) :br**Type**: `boolean`:br**Default**: `false`:br This option allows bypassing reload loop protection entirely, forcing a reload even if one has occurred within
  the previously specified TTL.
- `persistState` (optional) :br**Type**: `boolean`:br**Default**: `false`:br Whether to dump the current Nuxt state to sessionStorage (as `nuxt:reload:state`). By default this will have no
  effect on reload unless `experimental.restoreState` is also set, or unless you handle restoring the state yourself.


# setPageLayout

::important
`setPageLayout` allows you to dynamically change the layout of a page. It relies on access to the Nuxt context and therefore can only be called within the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

```ts [app/middleware/custom-layout.ts]
export default defineNuxtRouteMiddleware((to) => {
  // Set the layout on the route you are navigating _to_
  setPageLayout('other')
})
```

::note
If you choose to set the layout dynamically on the server side, you *must* do so before the layout is rendered by Vue (that is, within a plugin or route middleware) to avoid a hydration mismatch.
::


# setResponseStatus

Nuxt provides composables and utilities for first-class server-side-rendering support.

`setResponseStatus` sets the statusCode (and optionally the statusMessage) of the response.

::important
`setResponseStatus` can only be called in the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

```js
const event = useRequestEvent()

// event will be undefined in the browser
if (event) {
  // Set the status code to 404 for a custom 404 page
  setResponseStatus(event, 404)

  // Set the status message as well
  setResponseStatus(event, 404, 'Page Not Found')
}
```

::note
In the browser, `setResponseStatus` will have no effect.
::

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# showError

Within the [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context) you can use `showError` to show an error.

**Parameters:**

- `error`: `string | Error | Partial<{ cause, data, message, name, stack, statusCode, statusMessage }>`

```ts
showError("😱 Oh no, an error has been thrown.")
showError({
  statusCode: 404,
  statusMessage: "Page Not Found"
})
```

The error is set in the state using [`useError()`](https://nuxt.com/docs/api/composables/use-error) to create a reactive and SSR-friendly shared error state across components.

::tip
`showError` calls the `app:error` hook.
::

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# updateAppConfig

::note
Updates the [`app.config`](https://nuxt.com/docs/guide/directory-structure/app-config) using deep assignment. Existing (nested) properties will be preserved.
::

## Usage

```js
const appConfig = useAppConfig() // { foo: 'bar' }

const newAppConfig = { foo: 'baz' }

updateAppConfig(newAppConfig)

console.log(appConfig) // { foo: 'baz' }
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
::


# nuxt add

```bash [Terminal]
npx nuxt add <TEMPLATE> <NAME> [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--force]
```

### Arguments

| Argument   | Description                                                                                                          |
| ---------- | -------------------------------------------------------------------------------------------------------------------- |
| `TEMPLATE` | Specify which template to generate (options: \<api\|plugin\|component\|composable\|middleware\|layout\|page\|layer>) |
| `NAME`     | Specify name of the generated file                                                                                   |

### Options

| Option                             | Default | Description                              |
| ---------------------------------- | ------- | ---------------------------------------- |
| `--cwd=<directory>`                | `.`     | Specify the working directory            |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level             |
| `--force`                          | `false` | Force override file if it already exists |

**Modifiers:**

Some templates support additional modifier flags to add a suffix (like `.client` or `.get`) to their name.

```bash [Terminal]
# Generates `/plugins/sockets.client.ts`
npx nuxt add plugin sockets --client
```

## `nuxt add component`

- Modifier flags: `--mode client|server` or `--client` or `--server`

```bash [Terminal]
# Generates `app/components/TheHeader.vue`
npx nuxt add component TheHeader
```

## `nuxt add composable`

```bash [Terminal]
# Generates `app/composables/foo.ts`
npx nuxt add composable foo
```

## `nuxt add layout`

```bash [Terminal]
# Generates `app/layouts/custom.vue`
npx nuxt add layout custom
```

## `nuxt add plugin`

- Modifier flags: `--mode client|server` or `--client`or `--server`

```bash [Terminal]
# Generates `app/plugins/analytics.ts`
npx nuxt add plugin analytics
```

## `nuxt add page`

```bash [Terminal]
# Generates `app/pages/about.vue`
npx nuxt add page about
```

```bash [Terminal]
# Generates `app/pages/category/[id].vue`
npx nuxt add page "category/[id]"
```

## `nuxt add middleware`

- Modifier flags: `--global`

```bash [Terminal]
# Generates `app/middleware/auth.ts`
npx nuxt add middleware auth
```

## `nuxt add api`

- Modifier flags: `--method` (can accept `connect`, `delete`, `get`, `head`, `options`, `patch`, `post`, `put` or `trace`) or alternatively you can directly use `--get`, `--post`, etc.

```bash [Terminal]
# Generates `server/api/hello.ts`
npx nuxt add api hello
```

## `nuxt add layer`

```bash [Terminal]
# Generates `layers/subscribe/nuxt.config.ts`
npx nuxt add layer subscribe
```


# nuxt analyze

```bash [Terminal]
npx nuxt analyze [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dotenv] [--name=<name>] [--no-serve]
```

The `analyze` command builds Nuxt and analyzes the production bundle (experimental).

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default   | Description                                                                      |
| ---------------------------------- | --------- | -------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |           | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent|info|verbose>` |           | Specify build-time log level                                                     |
| `--dotenv`                         |           | Path to `.env` file to load, relative to the root directory                      |
| `--name=<name>`                    | `default` | Name of the analysis                                                             |
| `--no-serve`                       |           | Skip serving the analysis results                                                |

::note
This command sets `process.env.NODE_ENV` to `production`.
::


# nuxt build

```bash [Terminal]
npx nuxt build [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--prerender] [--preset] [--dotenv] [--envName]
```

The `build` command creates a `.output` directory with all your application, server and dependencies ready for production.

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default | Description                                                                                                                                          |
| ---------------------------------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--prerender`                      |         | Build Nuxt and prerender static routes                                                                                                               |
| `--preset`                         |         | Nitro server preset                                                                                                                                  |
| `--dotenv`                         |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--envName`                        |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |

::note
This command sets `process.env.NODE_ENV` to `production`.
::

::note
`--prerender` will always set the `preset` to `static`
::


# nuxt build-module

```bash [Terminal]
npx nuxt build-module [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--build] [--stub] [--sourcemap] [--prepare]
```

The `build-module` command runs `@nuxt/module-builder` to generate `dist` directory within your `rootDir` that contains the full build for your **nuxt-module**.

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default | Description                                                                      |
| ---------------------------------- | ------- | -------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level                                                     |
| `--build`                          | `false` | Build module for distribution                                                    |
| `--stub`                           | `false` | Stub dist instead of actually building it for development                        |
| `--sourcemap`                      | `false` | Generate sourcemaps                                                              |
| `--prepare`                        | `false` | Prepare module for local development                                             |

::read-more
---
icon: i-simple-icons-github
target: \_blank
to: https://github.com/nuxt/module-builder
---
Read more about `@nuxt/module-builder`.
::


# nuxt cleanup

```bash [Terminal]
npx nuxt cleanup [ROOTDIR] [--cwd=<directory>]
```

The `cleanup` command removes common generated Nuxt files and caches, including:

- `.nuxt`
- `.output`
- `node_modules/.vite`
- `node_modules/.cache`

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option              | Default | Description                                                                      |
| ------------------- | ------- | -------------------------------------------------------------------------------- |
| `--cwd=<directory>` |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |


# nuxt dev

```bash [Terminal]
npx nuxt dev [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dotenv] [--envName] [--no-clear] [--no-fork] [-p, --port] [-h, --host] [--clipboard] [-o, --open] [--https] [--publicURL] [--qr] [--public] [--tunnel] [--sslCert] [--sslKey]
```

The `dev` command starts a development server with hot module replacement at [http://localhost:3000](https://localhost:3000){rel="nofollow"}

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default | Description                                                                                                                                          |
| ---------------------------------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--dotenv`                         |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--envName`                        |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |
| `--no-clear`                       |         | Disable clear console on restart                                                                                                                     |
| `--no-fork`                        |         | Disable forked mode                                                                                                                                  |
| `-p, --port`                       |         | Port to listen on (default: `NUXT_PORT || NITRO_PORT || PORT || nuxtOptions.devServer.port`)                                                         |
| `-h, --host`                       |         | Host to listen on (default: `NUXT_HOST || NITRO_HOST || HOST || nuxtOptions._layers?.[0]?.devServer?.host`)                                          |
| `--clipboard`                      | `false` | Copy the URL to the clipboard                                                                                                                        |
| `-o, --open`                       | `false` | Open the URL in the browser                                                                                                                          |
| `--https`                          |         | Enable HTTPS                                                                                                                                         |
| `--publicURL`                      |         | Displayed public URL (used for QR code)                                                                                                              |
| `--qr`                             |         | Display The QR code of public URL when available                                                                                                     |
| `--public`                         |         | Listen to all network interfaces                                                                                                                     |
| `--tunnel`                         |         | Open a tunnel using <https://github.com/unjs/untun>{rel="nofollow"}                                                                                  |
| `--sslCert`                        |         | (DEPRECATED) Use `--https.cert` instead.                                                                                                             |
| `--sslKey`                         |         | (DEPRECATED) Use `--https.key` instead.                                                                                                              |

The port and host can also be set via NUXT\_PORT, PORT, NUXT\_HOST or HOST environment variables.

Additionally to the above options, `@nuxt/cli` can pass options through to `listhen`, e.g. `--no-qr` to turn off the dev server QR code. You can find the list of `listhen` options in the [unjs/listhen](https://github.com/unjs/listhen){rel="nofollow"} docs.

This command sets `process.env.NODE_ENV` to `development`.

::note
If you are using a self-signed certificate in development, you will need to set `NODE_TLS_REJECT_UNAUTHORIZED=0` in your environment.
::


# nuxt devtools

```bash [Terminal]
npx nuxt devtools <COMMAND> [ROOTDIR] [--cwd=<directory>]
```

Running `nuxt devtools enable` will install the Nuxt DevTools globally, and also enable it within the particular project you are using. It is saved as a preference in your user-level `.nuxtrc`. If you want to remove devtools support for a particular project, you can run `nuxt devtools disable`.

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `COMMAND`     | Command to run (options: \<enable\|disable>)   |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option              | Default | Description                                                                      |
| ------------------- | ------- | -------------------------------------------------------------------------------- |
| `--cwd=<directory>` |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |

::read-more
---
icon: i-simple-icons-nuxtdotjs
target: \_blank
to: https://devtools.nuxt.com
---
Read more about the **Nuxt DevTools**.
::


# nuxt generate

```bash [Terminal]
npx nuxt generate [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--preset] [--dotenv] [--envName]
```

The `generate` command pre-renders every route of your application and stores the result in plain HTML files that you can deploy on any static hosting services. The command triggers the `nuxt build` command with the `prerender` argument set to `true`

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default | Description                                                                                                                                          |
| ---------------------------------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--preset`                         |         | Nitro server preset                                                                                                                                  |
| `--dotenv`                         |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--envName`                        |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |

::read-more
---
to: https://nuxt.com/docs/getting-started/deployment#static-hosting
---
Read more about pre-rendering and static hosting.
::


# nuxt info

```bash [Terminal]
npx nuxt info [ROOTDIR] [--cwd=<directory>]
```

The `info` command logs information about the current or specified Nuxt project.

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option              | Default | Description                                                                      |
| ------------------- | ------- | -------------------------------------------------------------------------------- |
| `--cwd=<directory>` |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |


# create nuxt

```bash [Terminal]
npm create nuxt@latest [DIR] [--cwd=<directory>] [-t, --template] [-f, --force] [--offline] [--preferOffline] [--no-install] [--gitInit] [--shell] [--packageManager] [--nightly]
```

The `create-nuxt` command initializes a fresh Nuxt project using [unjs/giget](https://github.com/unjs/giget){rel="nofollow"}.

## Arguments

| Argument | Description       |
| -------- | ----------------- |
| `DIR=""` | Project directory |

## Options

| Option              | Default | Description                                              |
| ------------------- | ------- | -------------------------------------------------------- |
| `--cwd=<directory>` | `.`     | Specify the working directory                            |
| `-t, --template`    |         | Template name                                            |
| `-f, --force`       |         | Override existing directory                              |
| `--offline`         |         | Force offline mode                                       |
| `--preferOffline`   |         | Prefer offline mode                                      |
| `--no-install`      |         | Skip installing dependencies                             |
| `--gitInit`         |         | Initialize git repository                                |
| `--shell`           |         | Start shell after installation in project directory      |
| `--packageManager`  |         | Package manager choice (npm, pnpm, yarn, bun)            |
| `--modules`         |         | Nuxt modules to install (comma separated without spaces) |
| `--no-modules`      |         | Skip module installation prompt                          |
| `--nightly`         |         | Use Nuxt nightly release channel (3x or latest)          |

## Environment variables

- `NUXI_INIT_REGISTRY`: Set to a custom template registry. ([learn more](https://github.com/unjs/giget#custom-registry){rel="nofollow"}).

  - Default registry is loaded from [nuxt/starter/templates](https://github.com/nuxt/starter/tree/templates/templates){rel="nofollow"}


# nuxt module

Nuxt provides a few utilities to work with [Nuxt modules](https://nuxt.com/modules) seamlessly.

## nuxt module add

```bash [Terminal]
npx nuxt module add <MODULENAME> [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--skipInstall] [--skipConfig] [--dev]
```

| Argument     | Description |
| ------------ | ----------- |
| `MODULENAME` | Module name |

| Option                             | Default | Description                      |
| ---------------------------------- | ------- | -------------------------------- |
| `--cwd=<directory>`                | `.`     | Specify the working directory    |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level     |
| `--skipInstall`                    |         | Skip npm install                 |
| `--skipConfig`                     |         | Skip nuxt.config.ts update       |
| `--dev`                            |         | Install module as dev dependency |

The command lets you install [Nuxt modules](https://nuxt.com/modules) in your application with no manual work.

When running the command, it will:

- install the module as a dependency using your package manager
- add it to your [package.json](https://nuxt.com/docs/guide/directory-structure/package) file
- update your [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) file

**Example:**

Installing the [`Pinia`](https://nuxt.com/modules/pinia) module

```bash [Terminal]
npx nuxt module add pinia
```

## nuxt module search

```bash [Terminal]
npx nuxt module search <QUERY> [--cwd=<directory>] [--nuxtVersion=<2|3>]
```

### Arguments

| Argument | Description            |
| -------- | ---------------------- |
| `QUERY`  | keywords to search for |

### Options

| Option                | Default | Description                                                                        |
| --------------------- | ------- | ---------------------------------------------------------------------------------- |
| `--cwd=<directory>`   | `.`     | Specify the working directory                                                      |
| `--nuxtVersion=<2|3>` |         | Filter by Nuxt version and list compatible modules only (auto detected by default) |

The command searches for Nuxt modules matching your query that are compatible with your Nuxt version.

**Example:**

```bash [Terminal]
npx nuxt module search pinia
```


# nuxt prepare

```bash [Terminal]
npx nuxt prepare [ROOTDIR] [--dotenv] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--envName]
```

The `prepare` command creates a [`.nuxt`](https://nuxt.com/docs/guide/directory-structure/nuxt) directory in your application and generates types. This can be useful in a CI environment or as a `postinstall` command in your [`package.json`](https://nuxt.com/docs/guide/directory-structure/package).

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default | Description                                                                                                                                          |
| ---------------------------------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--dotenv`                         |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--cwd=<directory>`                |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--envName`                        |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |


# nuxt preview

```bash [Terminal]
npx nuxt preview [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--envName] [--dotenv] [-p, --port]
```

The `preview` command starts a server to preview your Nuxt application after running the `build` command. The `start` command is an alias for `preview`. When running your application in production refer to the [Deployment section](https://nuxt.com/docs/getting-started/deployment).

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default | Description                                                                                                                                          |
| ---------------------------------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--envName`                        |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |
| `--dotenv`                         |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `-p, --port`                       |         | Port to listen on (default: `NUXT_PORT || NITRO_PORT || PORT`)                                                                                       |

This command sets `process.env.NODE_ENV` to `production`. To override, define `NODE_ENV` in a `.env` file or as command-line argument.

::note
For convenience, in preview mode, your [`.env`](https://nuxt.com/docs/guide/directory-structure/env) file will be loaded into `process.env`. (However, in production you will need to ensure your environment variables are set yourself. For example, with Node.js 20+ you could do this by running `node --env-file .env .output/server/index.mjs` to start your server.)
::


# nuxt typecheck

```bash [Terminal]
npx nuxt typecheck [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>]
```

The `typecheck` command runs [`vue-tsc`](https://github.com/vuejs/language-tools/tree/master/packages/tsc){rel="nofollow"} to check types throughout your app.

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default | Description                                                                      |
| ---------------------------------- | ------- | -------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent|info|verbose>` |         | Specify build-time log level                                                     |

::note
This command sets `process.env.NODE_ENV` to `production`. To override, define `NODE_ENV` in a [`.env`](https://nuxt.com/docs/guide/directory-structure/env) file or as a command-line argument.
::

::read-more{to="https://nuxt.com/docs/guide/concepts/typescript#type-checking"}
Read more on how to enable type-checking at build or development time.
::


# nuxt upgrade

```bash [Terminal]
npx nuxt upgrade [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dedupe] [-f, --force] [-ch, --channel=<stable|nightly>]
```

The `upgrade` command upgrades Nuxt to the latest version.

## Arguments

| Argument      | Description                                    |
| ------------- | ---------------------------------------------- |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |

## Options

| Option                             | Default  | Description                                                                      |
| ---------------------------------- | -------- | -------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |          | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent|info|verbose>` |          | Specify build-time log level                                                     |
| `--dedupe`                         |          | Will deduplicate dependencies but not recreate the lockfile                      |
| `-f, --force`                      |          | Force upgrade to recreate lockfile and node\_modules                             |
| `-ch, --channel=<stable|nightly>`  | `stable` | Specify a channel to install from (default: stable)                              |


# Modules

Modules are the building blocks of Nuxt. Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules. For example, you can use the `defineNuxtModule` function to define a module and the `installModule` function to install a module programmatically.

## `defineNuxtModule`

Define a Nuxt module, automatically merging defaults with user provided options, installing any hooks that are provided, and calling an optional setup function for full control.

### Usage

```ts twoslash
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule'
  },
  defaults: {
    enabled: true
  },
  setup (options) {
    if (options.enabled) {
      console.log('My Nuxt module is enabled!')
    }
  }
})
```

### Type

```ts twoslash
// @errors: 2391
import type { ModuleDefinition, ModuleOptions, NuxtModule } from '@nuxt/schema'
// ---cut---
export function defineNuxtModule<TOptions extends ModuleOptions> (
  definition?: ModuleDefinition<TOptions, Partial<TOptions>, false> | NuxtModule<TOptions, Partial<TOptions>, false>,
): NuxtModule<TOptions, TOptions, false>

export function defineNuxtModule<TOptions extends ModuleOptions> (): {
  with: <TOptionsDefaults extends Partial<TOptions>> (
    definition: ModuleDefinition<TOptions, TOptionsDefaults, true> | NuxtModule<TOptions, TOptionsDefaults, true>
  ) => NuxtModule<TOptions, TOptionsDefaults, true>
}
```

### Parameters

**definition**: A module definition object or a module function. The module definition object should contain the following properties:

| Property    | Type                                                                                                                                                                                                                   | Required | Description                                                                                                                  |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `meta`      | `ModuleMeta`                                                                                                                                                                                                           | `false`  | Metadata of the module. It defines the module name, version, config key and compatibility.                                   |
| `defaults`  | `T | ((nuxt: Nuxt) => T)`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                                            | `false`  | Default options for the module. If a function is provided, it will be called with the Nuxt instance as the first argument.   |
| `schema`    | `T`                                                                                                                                                                                                                    | `false`  | Schema for the module options. If provided, options will be applied to the schema.                                           |
| `hooks`     | `Partial<NuxtHooks>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                                                 | `false`  | Hooks to be installed for the module. If provided, the module will install the hooks.                                        |
| `onInstall` | `(nuxt: Nuxt) => Awaitable<void>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                                    | `false`  | Lifecycle hook called when the module is first installed. Requires `meta.name` and `meta.version` to be defined.             |
| `onUpgrade` | `(options: T, nuxt: Nuxt, previousVersion: string) => Awaitable<void>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                               | `false`  | Lifecycle hook called when the module is upgraded to a newer version. Requires `meta.name` and `meta.version` to be defined. |
| `setup`     | `(this: void, resolvedOptions: T, nuxt: Nuxt) => Awaitable<void | false | ModuleSetupInstallResult>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Setup function for the module. If provided, the module will call the setup function.                                         |

### Examples

#### Using `configKey` to Make Your Module Configurable

When defining a Nuxt module, you can set a `configKey` to specify how users should configure the module in their `nuxt.config`.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule'
  },
  defaults: {
    // Module options
    enabled: true
  },
  setup (options) {
    if (options.enabled) {
      console.log('My Nuxt module is enabled!')
    }
  }
})
```

Users can provide options for this module under the corresponding key in `nuxt.config`.

```ts
export default defineNuxtConfig({
  myModule: {
    enabled: false
  }
})
```

#### Defining Module Compatibility Requirements

If you're developing a Nuxt module and using APIs that are only supported in specific Nuxt versions, it's highly recommended to include `compatibility.nuxt`.

```ts
export default defineNuxtModule({
  meta: {
    name: '@nuxt/icon',
    configKey: 'icon',
    compatibility: {
      // Required nuxt version in semver format.
      nuxt: '>=3.0.0', // or use '^3.0.0'
    },
  },
  async setup() {
    const resolver = createResolver(import.meta.url)
    // Implement
  },
})
```

If the user tries to use your module with an incompatible Nuxt version, they will receive a warning in the console.

```terminal
 WARN  Module @nuxt/icon is disabled due to incompatibility issues:
 - [nuxt] Nuxt version ^3.1.0 is required but currently using 3.0.0
```

#### Type Safety for Resolved Options with `.with()`

When you need type safety for your resolved/merged module options, you can use the `.with()` method. This enables TypeScript to properly infer the relationship between your module's defaults and the final resolved options that your setup function receives.

```ts
import { defineNuxtModule } from '@nuxt/kit'

// Define your module options interface
interface ModuleOptions {
  apiKey: string
  baseURL: string
  timeout?: number
  retries?: number
}

export default defineNuxtModule<ModuleOptions>().with({
  meta: {
    name: '@nuxtjs/my-api',
    configKey: 'myApi'
  },
  defaults: {
    baseURL: 'https://api.example.com',
    timeout: 5000,
    retries: 3
  },
  setup(resolvedOptions, nuxt) {
    // resolvedOptions is properly typed as:
    // {
    //   apiKey: string          // Required, no default provided
    //   baseURL: string         // Required, has default value
    //   timeout: number         // Optional, has default value
    //   retries: number         // Optional, has default value  
    // }
    
    console.log(resolvedOptions.baseURL) // ✅ TypeScript knows this is always defined
    console.log(resolvedOptions.timeout) // ✅ TypeScript knows this is always defined
    console.log(resolvedOptions.retries) // ✅ TypeScript knows this is always defined
  }
})
```

Without using `.with()`, the `resolvedOptions` parameter would be typed as the raw `ModuleOptions` interface, where `timeout` and `retries` could be `undefined` even when defaults are provided. The `.with()` method enables TypeScript to understand that default values make those properties non-optional in the resolved options.

#### Using Lifecycle Hooks for Module Installation and Upgrade

You can define lifecycle hooks that run when your module is first installed or upgraded to a new version. These hooks are useful for performing one-time setup tasks, database migrations, or cleanup operations.

::important
For lifecycle hooks to work, you **must** provide both `meta.name` and `meta.version` in your module definition. The hooks use these values to track the module's installation state in the project's `.nuxtrc` file.
::

Lifecycle hooks run before the main `setup` function, and if a hook throws an error, it's logged but doesn't stop the build process.

**`onInstall`** runs only once when the module is first added to a project.

**`onUpgrade`** runs each time the module version increases (using semver comparison) — but only once for each version bump.

##### Example

```ts
import { defineNuxtModule } from '@nuxt/kit'
import semver from 'semver'

export default defineNuxtModule({
  meta: {
    name: 'my-awesome-module',
    version: '1.2.0', // Required for lifecycle hooks
    configKey: 'myAwesomeModule'
  },
  defaults: {
    apiKey: '',
    enabled: true
  },
  
  onInstall(nuxt) {
    // This runs only when the module is first installed
    console.log('Setting up my-awesome-module for the first time!')
    
    // You might want to:
    // - Create initial configuration files
    // - Set up database schemas
    // - Display welcome messages
    // - Perform initial data migration
  },
  
  onUpgrade(options, nuxt, previousVersion) {
    // This runs when the module is upgraded to a newer version
    console.log(`Upgrading my-awesome-module from ${previousVersion} to 1.2.0`)
    
    // You might want to:
    // - Migrate configuration files
    // - Update database schemas  
    // - Clean up deprecated files
    // - Display upgrade notes
    
    if (semver.lt(previousVersion, '1.1.0')) {
      console.log('⚠️  Breaking changes in 1.1.0 - please check the migration guide')
    }
  },
  
  setup(options, nuxt) {
    // Regular setup logic runs on every build
    if (options.enabled) {
      // Configure the module
    }
  }
})
```

## `installModule`

Install specified Nuxt module programmatically. This is helpful when your module depends on other modules. You can pass the module options as an object to `inlineOptions` and they will be passed to the module's `setup` function.

### Usage

```ts twoslash
import { defineNuxtModule, installModule } from '@nuxt/kit'

export default defineNuxtModule({  
  async setup () {
    // will install @nuxtjs/fontaine with Roboto font and Impact fallback
    await installModule('@nuxtjs/fontaine', {
      // module configuration
      fonts: [
        {
          family: 'Roboto',
          fallbacks: ['Impact'],
          fallbackName: 'fallback-a',
        }
      ]
    })
  }
})
```

### Type

```ts
async function installModule (moduleToInstall: string | NuxtModule, inlineOptions?: any, nuxt?: Nuxt)
```

### Parameters

| Property          | Type                                                                                                                                    | Required | Description                                                                                   |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------- |
| `moduleToInstall` | `string | NuxtModule`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | The module to install. Can be either a string with the module name or a module object itself. |
| `inlineOptions`   | `any`                                                                                                                                   | `false`  | An object with the module options to be passed to the module's `setup` function.              |
| `nuxt`            | `Nuxt`                                                                                                                                  | `false`  | Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.   |

### Examples

```ts
import { defineNuxtModule, installModule } from '@nuxt/kit'

export default defineNuxtModule({  
  async setup (options, nuxt) {
    // will install @nuxtjs/fontaine with Roboto font and Impact fallback
    await installModule('@nuxtjs/fontaine', {
      // module configuration
      fonts: [
        {
          family: 'Roboto',
          fallbacks: ['Impact'],
          fallbackName: 'fallback-a',
        }
      ]
    })
  }
})
```


# Runtime Config

## `useRuntimeConfig`

At build-time, it is possible to access the resolved Nuxt [runtime config](https://nuxt.com/docs/guide/going-further/runtime-config).

### Type

```ts
function useRuntimeConfig (): Record<string, unknown>
```

## `updateRuntimeConfig`

It is also possible to update runtime configuration. This will be merged with the existing runtime configuration, and if Nitro has already been initialized it will trigger an HMR event to reload the Nitro runtime config.

### Type

```ts
function updateRuntimeConfig (config: Record<string, unknown>): void | Promise<void>
```


# Templates

Templates allow you to generate extra files during development and build time. These files will be available in virtual filesystem and can be used in plugins, layouts, components, etc. `addTemplate` and `addTypeTemplate` allow you to add templates to the Nuxt application. `updateTemplates` allows you to regenerate templates that match the filter.

## `addTemplate`

Renders given template during build into the virtual file system, and optionally to disk in the project `buildDir`

### Usage

```ts twoslash
import { addTemplate, defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup(options, nuxt) {
    const globalMeta = defu(nuxt.options.app.head, {
      charset: options.charset,
      viewport: options.viewport
    })

    addTemplate({
      filename: 'meta.config.mjs',
      getContents: () => 'export default ' + JSON.stringify({ globalMeta, mixinKey: 'setup' })
    })
  }
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NuxtTemplate, ResolvedNuxtTemplate } from '@nuxt/schema'
// ---cut---
function addTemplate (template: NuxtTemplate | string): ResolvedNuxtTemplate
```

### Parameters

**template**: A template object or a string with the path to the template. If a string is provided, it will be converted to a template object with `src` set to the string value. If a template object is provided, it must have the following properties:

| Property      | Type                                                                                                                                                            | Required | Description                                                                                                                                                                      |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                                                                                                                                        | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                          |
| `filename`    | `string`                                                                                                                                                        | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                   |
| `dst`         | `string`                                                                                                                                                        | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                |
| `options`     | `Options`                                                                                                                                                       | `false`  | Options to pass to the template.                                                                                                                                                 |
| `getContents` | `(data: Options) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored. |
| `write`       | `boolean`                                                                                                                                                       | `false`  | If set to `true`, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.                                         |

### Examples

#### Creating a Virtual File for Runtime Plugin

In this example, we merge an object inside a module and consume the result in a runtime plugin.

```ts [module.ts] twoslash
import { addTemplate, defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    const globalMeta = defu(nuxt.options.app.head, {
      charset: options.charset,
      viewport: options.viewport,
    })

    addTemplate({
      filename: 'meta.config.mjs',
      getContents: () => 'export default ' + JSON.stringify({ globalMeta, mixinKey: 'setup' }),
    })
  },
})
```

In the module above, we generate a virtual file named `meta.config.mjs`. In the runtime plugin, we can import it using the `#build` alias:

```ts [runtime/plugin.ts]
import { createHead as createServerHead } from '@unhead/vue/server'
import { createHead as createClientHead } from '@unhead/vue/client'
import { defineNuxtPlugin } from '#imports'
// @ts-ignore
import metaConfig from '#build/meta.config.mjs'

export default defineNuxtPlugin((nuxtApp) => {
  const createHead = import.meta.server ? createServerHead : createClientHead
  const head = createHead()
  head.push(metaConfig.globalMeta)

  nuxtApp.vueApp.use(head)
})
```

## `addTypeTemplate`

Renders given template during build into the project buildDir, then registers it as types.

### Usage

```ts twoslash
import { addTypeTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addTypeTemplate({
      filename: 'types/markdown.d.ts',
      getContents: () => `declare module '*.md' {
  import type { ComponentOptions } from 'vue'
  const Component: ComponentOptions
  export default Component
}`,
    })
  },
})
```

### Type

```ts
function addTypeTemplate (template: NuxtTypeTemplate | string, context?: { nitro?: boolean, nuxt?: boolean }): ResolvedNuxtTemplate
```

### Parameters

**template**: A template object or a string with the path to the template. If a string is provided, it will be converted to a template object with `src` set to the string value. If a template object is provided, it must have the following properties:

| Property      | Type                                                                                                                                                            | Required | Description                                                                                                                                                                      |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                                                                                                                                        | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                          |
| `filename`    | `string`                                                                                                                                                        | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                   |
| `dst`         | `string`                                                                                                                                                        | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                |
| `options`     | `Options`                                                                                                                                                       | `false`  | Options to pass to the template.                                                                                                                                                 |
| `getContents` | `(data: Options) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored. |

**context**: An optional context object can be passed to control where the type is added. If omitted, the type will only be added to the Nuxt context. This object supports the following properties:

| Property | Type      | Required | Description                                                    |
| -------- | --------- | -------- | -------------------------------------------------------------- |
| `nuxt`   | `boolean` | `false`  | If set to `true`, the type will be added to the Nuxt context.  |
| `nitro`  | `boolean` | `false`  | If set to `true`, the type will be added to the Nitro context. |

### Examples

#### Adding Type Templates to the Nitro Context

By default, －－ only adds the type declarations to the Nuxt context. To also add them to the Nitro context, set nitro to true.

```ts twoslash
import { addTypeTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addTypeTemplate({
      filename: 'types/auth.d.ts',
      getContents: () => `declare module '#auth-utils' {
  interface User {
    id: string;
    name: string;
  }

}`,
    }, {
      nitro: true,
    })
  },
})
```

This allows the `#auth-utils` module to be used within the Nitro context.

```ts [server/api/auth.ts]
import type { User } from '#auth-utils'

export default eventHandler(() => {
  const user: User = {
    id: '123',
    name: 'John Doe',
  }

  // do something with the user

  return user
})
```

## `addServerTemplate`

Adds a virtual file that can be used within the Nuxt Nitro server build.

### Usage

```ts twoslash
import { addServerTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addServerTemplate({
      filename: '#my-module/test.mjs',
      getContents () {
        return 'export const test = 123'
      },
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NuxtServerTemplate } from '@nuxt/schema'
// ---cut---
function addServerTemplate (template: NuxtServerTemplate): NuxtServerTemplate
```

### Parameters

**template**: A template object. It must have the following properties:

| Property      | Type                                                                                                                                               | Required | Description                                                                                                                 |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------- |
| `filename`    | `string`                                                                                                                                           | `true`   | Filename of the template.                                                                                                   |
| `getContents` | `() => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. |

### Examples

### Creating a Virtual File for Nitro

In this example, we create a virtual file that can be used within the Nuxt Nitro server build.

```ts twoslash
import { addServerTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addServerTemplate({
      filename: '#my-module/test.mjs',
      getContents () {
        return 'export const test = 123'
      },
    })
  },
})
```

And then in a runtime file

```ts [server/api/test.ts]
import { test } from '#my-module/test.js'

export default eventHandler(() => {
  return test
})
```

## `updateTemplates`

Regenerate templates that match the filter. If no filter is provided, all templates will be regenerated.

### Usage

```ts
import { defineNuxtModule, updateTemplates } from '@nuxt/kit'
import { resolve } from 'pathe'

export default defineNuxtModule({
  setup (options, nuxt) {
    const updateTemplatePaths = [
      resolve(nuxt.options.srcDir, 'pages'),
    ]
    // watch and rebuild routes template list when one of the pages changes
    nuxt.hook('builder:watch', async (event, relativePath) => {
      if (event === 'change') { return }

      const path = resolve(nuxt.options.srcDir, relativePath)
      if (updateTemplatePaths.some(dir => path.startsWith(dir))) {
        await updateTemplates({
          filter: template => template.filename === 'routes.mjs',
        })
      }
    })
  },
})
```

### Type

```ts
async function updateTemplates (options: UpdateTemplatesOptions): void
```

### Parameters

**options**: Options to pass to the template. This object can have the following property:

| Property | Type                                                                                                                                                            | Required | Description                                                                                                                                                                                                  |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `filter` | `(template: ResolvedNuxtTemplate) => boolean`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | A function that will be called with the `template` object. It should return a boolean indicating whether the template should be regenerated. If `filter` is not provided, all templates will be regenerated. |


# Nitro

Nitro is an open source TypeScript framework to build ultra-fast web servers. Nuxt uses Nitro as its server engine. You can use `useNitro` to access the Nitro instance, `addServerHandler` to add a server handler, `addDevServerHandler` to add a server handler to be used only in development mode, `addServerPlugin` to add a plugin to extend Nitro's runtime behavior, and `addPrerenderRoutes` to add routes to be prerendered by Nitro.

## `addServerHandler`

Adds a Nitro server handler. Use this if you want to create server middleware or a custom route.

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, addServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options) {
    const { resolve } = createResolver(import.meta.url)

    addServerHandler({
      route: '/robots.txt',
      handler: resolve('./runtime/robots.get')
    })
  }
})
```

### Type

```ts
function addServerHandler (handler: NitroEventHandler): void
```

### Parameters

**handler**: A handler object with the following properties:

| Property     | Type      | Required | Description                                                                                                                                   |
| ------------ | --------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `handler`    | `string`  | `true`   | Path to event handler.                                                                                                                        |
| `route`      | `string`  | `false`  | Path prefix or route. If an empty string used, will be used as a middleware.                                                                  |
| `middleware` | `boolean` | `false`  | Specifies this is a middleware handler. Middleware are called on every route and should normally return nothing to pass to the next handlers. |
| `lazy`       | `boolean` | `false`  | Use lazy loading to import the handler. This is useful when you only want to load the handler on demand.                                      |
| `method`     | `string`  | `false`  | Router method matcher. If handler name contains method name, it will be used as a default value.                                              |

### Examples

#### Basic Usage

You can use `addServerHandler` to add a server handler from your module.

::code-group
```ts [module.ts] twoslash
import { createResolver, defineNuxtModule, addServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options) {
    const { resolve } = createResolver(import.meta.url)

    addServerHandler({
      route: '/robots.txt',
      handler: resolve('./runtime/robots.get')
    })
  }
})
```

```ts [runtime/robots.get.ts] twoslash
export default defineEventHandler(() => {
  return {
    body: `User-agent: *\nDisallow: /`
  }
})
```
::

When you access `/robots.txt`, it will return the following response:

```txt
User-agent: *
Disallow: /
```

## `addDevServerHandler`

Adds a Nitro server handler to be used only in development mode. This handler will be excluded from production build.

### Usage

```ts twoslash
import { defineEventHandler } from 'h3'
import { createResolver, defineNuxtModule, addDevServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    addDevServerHandler({
      handler: defineEventHandler(() => {
        return {
          body: `Response generated at ${new Date().toISOString()}`
        }
      }),
      route: '/_handler'
    })
  }
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NitroDevEventHandler } from 'nitropack/types'
// ---cut---
function addDevServerHandler (handler: NitroDevEventHandler): void
```

### Parameters

**handler**: A handler object with the following properties:

| Property  | Type           | Required | Description                                                                  |
| --------- | -------------- | -------- | ---------------------------------------------------------------------------- |
| `handler` | `EventHandler` | `true`   | Event handler.                                                               |
| `route`   | `string`       | `false`  | Path prefix or route. If an empty string used, will be used as a middleware. |

### Examples

#### Basic Usage

In some cases, you may want to create a server handler specifically for development purposes, such as a Tailwind config viewer.

```ts
import { joinURL } from 'ufo'
import { defineNuxtModule, addDevServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  async setup(options, nuxt) {
    const route = joinURL(nuxt.options.app?.baseURL, '/_tailwind')

    // @ts-ignore
    const createServer = await import('tailwind-config-viewer/server/index.js').then(r => r.default || r) as any
    const viewerDevMiddleware = createServer({ tailwindConfigProvider: () => options, routerPrefix: route }).asMiddleware()

    addDevServerHandler({ route, handler: viewerDevMiddleware })
  }
})
```

## `useNitro`

Returns the Nitro instance.

::warning
You can call `useNitro()` only after `ready` hook.
::

::note
Changes to the Nitro instance configuration are not applied.
::

### Usage

```ts
import { defineNuxtModule, useNitro } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('ready', () => {
      const nitro = useNitro()
      // Do something with Nitro instance
    })
  }
})
```

### Type

```ts
function useNitro (): Nitro
```

## `addServerPlugin`

Add plugin to extend Nitro's runtime behavior.

::tip
You can read more about Nitro plugins in the [Nitro documentation](https://nitro.build/guide/plugins){rel="nofollow"}.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, addServerPlugin } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const { resolve } = createResolver(import.meta.url)
    addServerPlugin(resolve('./runtime/plugin.ts'))
  }
})
```

### Type

```ts
function addServerPlugin (plugin: string): void
```

### Parameters

| Property | Type     | Required | Description                                                                                                   |
| -------- | -------- | -------- | ------------------------------------------------------------------------------------------------------------- |
| `plugin` | `string` | `true`   | Path to the plugin. The plugin must export a default function that accepts the Nitro instance as an argument. |

### Examples

::code-group
```ts [module.ts]
import { createResolver, defineNuxtModule, addServerPlugin } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const { resolve } = createResolver(import.meta.url)
    addServerPlugin(resolve('./runtime/plugin.ts'))
  }
})
```

```ts [runtime/plugin.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook("request", (event) => {
    console.log("on request", event.path);
  });

  nitroApp.hooks.hook("beforeResponse", (event, { body }) => {
    console.log("on response", event.path, { body });
  });

  nitroApp.hooks.hook("afterResponse", (event, { body }) => {
    console.log("on after response", event.path, { body });
  });
});
```
::

## `addPrerenderRoutes`

Add routes to be prerendered to Nitro.

### Usage

```ts
import { defineNuxtModule, addPrerenderRoutes } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-sitemap',
    configKey: 'sitemap',
  },
  defaults: {
    sitemapUrl: '/sitemap.xml',
    prerender: true,
  },
  setup(options) {
    if (options.prerender) {
      addPrerenderRoutes(options.sitemapUrl)
    }
  }
})
```

### Type

```ts
function addPrerenderRoutes (routes: string | string[]): void
```

### Parameters

| Property | Type                                                                                                                                  | Required | Description                                 |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------- |
| `routes` | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | A route or an array of routes to prerender. |

## `addServerImports`

Add imports to the server. It makes your imports available in Nitro without the need to import them manually.

### Usage

```ts twoslash
import { defineNuxtModule, createResolver, addServerImports } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options) {
    const names = [
      'useStoryblok',
      'useStoryblokApi',
      'useStoryblokBridge',
      'renderRichText',
      'RichTextSchema'
    ]

    names.forEach((name) =>
      addServerImports({ name, as: name, from: '@storyblok/vue' })
    )
  }
})
```

### Type

```ts
function addServerImports (dirs: Import | Import[]): void
```

### Parameters

`imports`: An object or an array of objects with the following properties:

| Property   | Type                  | Required | Description                                                                                                     |
| ---------- | --------------------- | -------- | --------------------------------------------------------------------------------------------------------------- |
| `name`     | `string`              | `true`   | Import name to be detected.                                                                                     |
| `from`     | `string`              | `true`   | Module specifier to import from.                                                                                |
| `priority` | `number`              | `false`  | Priority of the import; if multiple imports have the same name, the one with the highest priority will be used. |
| `disabled` | `boolean`             | `false`  | If this import is disabled.                                                                                     |
| `meta`     | `Record<string, any>` | `false`  | Metadata of the import.                                                                                         |
| `type`     | `boolean`             | `false`  | If this import is a pure type import.                                                                           |
| `typeFrom` | `string`              | `false`  | Use this as the `from` value when generating type declarations.                                                 |
| `as`       | `string`              | `false`  | Import as this name.                                                                                            |

## `addServerImportsDir`

Add a directory to be scanned for auto-imports by Nitro.

### Usage

```ts twoslash
import { defineNuxtModule, createResolver, addServerImportsDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerImportsDir(resolve('./runtime/server/composables'))
  }
})
```

### Type

```ts
function addServerImportsDir (dirs: string | string[], opts: { prepend?: boolean }): void
```

### Parameters

| Property | Type                                                                                                                                  | Required | Description                                                                                                         |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------- |
| `dirs`   | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | A directory or an array of directories to register to be scanned by Nitro.                                          |
| `opts`   | `{ prepend?: boolean }`                                                                                                               | `false`  | Options for the import directory. If `prepend` is `true`, the directory is added to the beginning of the scan list. |

### Examples

You can use `addServerImportsDir` to add a directory to be scanned by Nitro. This is useful when you want Nitro to auto-import functions from a custom server directory.

::code-group
```ts [module.ts] twoslash
import { defineNuxtModule, createResolver, addServerImportsDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerImportsDir(resolve('./runtime/server/composables'))
  }
})
```

```ts [runtime/server/composables/index.ts] twoslash
export function useApiSecret() {
  const { apiSecret } = useRuntimeConfig()
  return apiSecret
}
```
::

You can then use the `useApiSecret` function in your server code:

```ts [runtime/server/api/hello.ts] twoslash
const useApiSecret = (): string => ''
// ---cut---
export default defineEventHandler(() => {
  const apiSecret = useApiSecret()
  // Do something with the apiSecret
})
```

## `addServerScanDir`

Add directories to be scanned by Nitro. It will check for subdirectories, which will be registered
just like the `~/server` folder is.

::note
Only `~/server/api`, `~/server/routes`, `~/server/middleware`, and `~/server/utils` are scanned.
::

### Usage

```ts twoslash
import { defineNuxtModule, createResolver, addServerScanDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerScanDir(resolve('./runtime/server'))
  }
})
```

### Type

```ts
function addServerScanDir (dirs: string | string[], opts: { prepend?: boolean }): void
```

### Parameters

| Property | Type                                                                                                                                  | Required | Description                                                                                                         |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------- |
| `dirs`   | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | A directory or an array of directories to register to be scanned for by Nitro as server dirs.                       |
| `opts`   | `{ prepend?: boolean }`                                                                                                               | `false`  | Options for the import directory. If `prepend` is `true`, the directory is added to the beginning of the scan list. |

### Examples

You can use `addServerScanDir` to add a directory to be scanned by Nitro. This is useful when you want to add a custom server directory.

::code-group
```ts [module.ts] twoslash
import { defineNuxtModule, createResolver, addServerScanDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerScanDir(resolve('./runtime/server'))
  }
})
```

```ts [runtime/server/utils/index.ts] twoslash
export function hello() {
  return 'Hello from server utils!'
}
```
::

You can then use the `hello` function in your server code.

```ts [runtime/server/api/hello.ts] twoslash
function hello() {
  return 'Hello from server utils!'
}
// ---cut---
export default defineEventHandler(() => {
  return hello() // Hello from server utils!
})
```


# Resolving

Sometimes you need to resolve a paths: relative to the current module, with unknown name or extension. For example, you may want to add a plugin that is located in the same directory as the module. To handle this cases, nuxt provides a set of utilities to resolve paths. `resolvePath` and `resolveAlias` are used to resolve paths relative to the current module. `findPath` is used to find first existing file in given paths. `createResolver` is used to create resolver relative to base path.

## `resolvePath`

Resolves full path to a file or directory respecting Nuxt alias and extensions options. If path could not be resolved, normalized input path will be returned.

### Usage

```ts
import { defineNuxtModule, resolvePath } from '@nuxt/kit'

export default defineNuxtModule({
  async setup () {
    const entrypoint = await resolvePath('@unhead/vue')
    console.log(`Unhead entrypoint is ${entrypoint}`)
  },
})
```

### Type

```ts
function resolvePath (path: string, options?: ResolvePathOptions): Promise<string>
```

### Parameters

**`path`**: A path to resolve.

**`options`**: Options to pass to the resolver. This object can have the following properties:

| Property             | Type                                                                                                                                       | Required | Description                                                                                                                  |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | -------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `cwd`                | `string`                                                                                                                                   | `false`  | Base for resolving paths from. Default is Nuxt rootDir.                                                                      |
| `alias`              | `Record<string, string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | An object of aliases. Default is Nuxt configured aliases.                                                                    |
| `extensions`         | `string[]`                                                                                                                                 | `false`  | The file extensions to try. Default is Nuxt configured extensions.                                                           |
| `virtual`            | `boolean`                                                                                                                                  | `false`  | Whether to resolve files that exist in the Nuxt VFS (for example, as a Nuxt template).                                       |
| `fallbackToOriginal` | `boolean`                                                                                                                                  | `false`  | Whether to fallback to the original path if the resolved path does not exist instead of returning the normalized input path. |

### Examples

```ts
import { defineNuxtModule, resolvePath } from '@nuxt/kit'
import { join } from 'pathe'

const headlessComponents: ComponentGroup[] = [
  {
    relativePath: 'combobox/combobox.js',
    chunkName: 'headlessui/combobox',
    exports: [
      'Combobox',
      'ComboboxLabel',
      'ComboboxButton',
      'ComboboxInput',
      'ComboboxOptions',
      'ComboboxOption',
    ],
  },
]

export default defineNuxtModule({
  meta: {
    name: 'nuxt-headlessui',
    configKey: 'headlessui',
  },
  defaults: {
    prefix: 'Headless',
  },
  async setup (options) {
    const entrypoint = await resolvePath('@headlessui/vue')
    const root = join(entrypoint, '../components')

    for (const group of headlessComponents) {
      for (const e of group.exports) {
        addComponent(
          {
            name: e,
            export: e,
            filePath: join(root, group.relativePath),
            chunkName: group.chunkName,
            mode: 'all',
          },
        )
      }
    }
  },
})
```

## `resolveAlias`

Resolves path aliases respecting Nuxt alias options.

### Type

```ts
function resolveAlias (path: string, alias?: Record<string, string>): string
```

### Parameters

**`path`**: A path to resolve.

**`alias`**: An object of aliases. If not provided, it will be read from `nuxt.options.alias`.

## `findPath`

Try to resolve first existing file in given paths.

### Usage

```ts
import { defineNuxtModule, findPath } from '@nuxt/kit'
import { join } from 'pathe'

export default defineNuxtModule({
  async setup (_, nuxt) {
    // Resolve main (app.vue)
    const mainComponent = await findPath([
      join(nuxt.options.srcDir, 'App'),
      join(nuxt.options.srcDir, 'app'),
    ])
  },
})
```

### Type

```ts
function findPath (paths: string | string[], options?: ResolvePathOptions, pathType: 'file' | 'dir'): Promise<string | null>
```

### Parameters

**`paths`**: A path or an array of paths to resolve.

**`options`**: Options to pass to the resolver. This object can have the following properties:

| Property             | Type                                                                                                                                       | Required | Description                                                                                                                  |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | -------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `cwd`                | `string`                                                                                                                                   | `false`  | Base for resolving paths from. Default is Nuxt rootDir.                                                                      |
| `alias`              | `Record<string, string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | An object of aliases. Default is Nuxt configured aliases.                                                                    |
| `extensions`         | `string[]`                                                                                                                                 | `false`  | The file extensions to try. Default is Nuxt configured extensions.                                                           |
| `virtual`            | `boolean`                                                                                                                                  | `false`  | Whether to resolve files that exist in the Nuxt VFS (for example, as a Nuxt template).                                       |
| `fallbackToOriginal` | `boolean`                                                                                                                                  | `false`  | Whether to fallback to the original path if the resolved path does not exist instead of returning the normalized input path. |

## `createResolver`

Creates resolver relative to base path.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/resolving-paths-and-injecting-assets-to-the-app?friend=nuxt
---
Watch Vue School video about createResolver.
::

### Usage

```ts
import { defineNuxtModule, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_, nuxt) {
    const { resolve, resolvePath } = createResolver(import.meta.url)
  },
})
```

### Type

```ts
function createResolver (basePath: string | URL): Resolver
```

### Parameters

**`basePath`**: A base path to resolve from. It can be a string or a URL.

### Return Value

The `createResolver` function returns an object with the following properties:

| Property      | Type                                                                                                                                                                                | Description                                                                                               |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| `resolve`     | `(path: string) => string`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                        | A function that resolves a path relative to the base path.                                                |
| `resolvePath` | `(path: string, options?: ResolvePathOptions) => Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | A function that resolves a path relative to the base path and respects Nuxt alias and extensions options. |

### Examples

```ts
import { createResolver, defineNuxtModule, isNuxt2 } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('modules:done', () => {
      if (isNuxt2()) {
        addPlugin(resolver.resolve('./runtime/plugin.vue2'))
      } else {
        addPlugin(resolver.resolve('./runtime/plugin.vue3'))
      }
    })
  },
})
```


# Logging

Nuxt provides a logger instance that you can use to log messages with extra features. `useLogger` allows you to get a logger instance.

## `useLogger`

Returns a logger instance. It uses [consola](https://github.com/unjs/consola){rel="nofollow"} under the hood.

### Usage

```ts twoslash
import { defineNuxtModule, useLogger } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const logger = useLogger('my-module')

    logger.info('Hello from my module!')
  },
})
```

### Type

```ts
function useLogger (tag?: string, options?: Partial<ConsolaOptions>): ConsolaInstance
```

### Parameters

**`tag`**: A tag to suffix all log messages with, displayed on the right near the timestamp.

**`options`**: Consola configuration options.

### Examples

```ts twoslash
import { defineNuxtModule, useLogger } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const logger = useLogger('my-module', { level: options.quiet ? 0 : 3 })

    logger.info('Hello from my module!')
  },
})
```


# Builder

Nuxt have builders based on [Vite](https://github.com/nuxt/nuxt/tree/main/packages/vite){rel="nofollow"} and [webpack](https://github.com/nuxt/nuxt/tree/main/packages/webpack){rel="nofollow"}. You can extend the config passed to each one using `extendViteConfig` and `extendWebpackConfig` functions. You can also add additional plugins via `addVitePlugin`, `addWebpackPlugin` and `addBuildPlugin`.

## `extendViteConfig`

Extends the Vite configuration. Callback function can be called multiple times, when applying to both client and server builds.

### Usage

```ts twoslash
import { defineNuxtModule, extendViteConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    extendViteConfig((config) => {
      config.optimizeDeps ||= {}
      config.optimizeDeps.include ||= []
      config.optimizeDeps.include.push('cross-fetch')
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { UserConfig as ViteConfig } from 'vite'
import type { ExtendViteConfigOptions } from '@nuxt/kit'
// ---cut---
function extendViteConfig (callback: ((config: ViteConfig) => void), options?: ExtendViteConfigOptions): void
```

::read-more
---
icon: i-simple-icons-vite
target: _blank
to: https://vite.dev/config
---
Checkout Vite website for more information about its configuration.
::

### Parameters

**`callback`**: A callback function that will be called with the Vite configuration object.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `extendWebpackConfig`

Extends the webpack configuration. Callback function can be called multiple times, when applying to both client and server builds.

### Usage

```ts twoslash
import { defineNuxtModule, extendWebpackConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    extendWebpackConfig((config) => {
      config.module!.rules!.push({
        test: /\.txt$/,
        use: 'raw-loader',
      })
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Configuration as WebpackConfig } from 'webpack'
import type { ExtendWebpackConfigOptions } from '@nuxt/kit'
// ---cut---
function extendWebpackConfig (callback: ((config: WebpackConfig) => void), options?: ExtendWebpackConfigOptions): void
```

::read-more
---
icon: i-simple-icons-webpack
target: _blank
to: https://webpack.js.org/configuration
---
Checkout webpack website for more information about its configuration.
::

### Parameters

**`callback`**: A callback function that will be called with the webpack configuration object.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addVitePlugin`

Append Vite plugin to the config.

### Usage

```ts twoslash
// @errors: 2307
// ---cut---
import { addVitePlugin, defineNuxtModule } from '@nuxt/kit'
import { svg4VuePlugin } from 'vite-plugin-svg4vue'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-svg-icons',
    configKey: 'nuxtSvgIcons',
  },
  defaults: {
    svg4vue: {
      assetsDirName: 'assets/icons',
    },
  },
  setup (options) {
    addVitePlugin(svg4VuePlugin(options.svg4vue))
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Plugin as VitePlugin } from 'vite'
import type { ExtendViteConfigOptions } from '@nuxt/kit'
// ---cut---
function addVitePlugin (pluginOrGetter: VitePlugin | VitePlugin[] | (() => VitePlugin | VitePlugin[]), options?: ExtendViteConfigOptions): void
```

::tip
See [Vite website](https://vite.dev/guide/api-plugin.html){rel="nofollow"} for more information about Vite plugins. You can also use [this repository](https://github.com/vitejs/awesome-vite#plugins){rel="nofollow"} to find a plugin that suits your needs.
::

### Parameters

**`pluginOrGetter`**: A Vite plugin instance or an array of Vite plugin instances. If a function is provided, it must return a Vite plugin instance or an array of Vite plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addWebpackPlugin`

Append webpack plugin to the config.

### Usage

```ts
import EslintWebpackPlugin from 'eslint-webpack-plugin'
import { addWebpackPlugin, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-eslint',
    configKey: 'eslint',
  },
  defaults: nuxt => ({
    include: [`${nuxt.options.srcDir}/**/*.{js,jsx,ts,tsx,vue}`],
    lintOnStart: true,
  }),
  setup (options, nuxt) {
    const webpackOptions = {
      ...options,
      context: nuxt.options.srcDir,
      files: options.include,
      lintDirtyModulesOnly: !options.lintOnStart,
    }
    addWebpackPlugin(new EslintWebpackPlugin(webpackOptions), { server: false })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { WebpackPluginInstance } from 'webpack'
import type { ExtendWebpackConfigOptions } from '@nuxt/kit'
// ---cut---
function addWebpackPlugin (pluginOrGetter: WebpackPluginInstance | WebpackPluginInstance[] | (() => WebpackPluginInstance | WebpackPluginInstance[]), options?: ExtendWebpackConfigOptions): void
```

::tip
See [webpack website](https://webpack.js.org/concepts/plugins){rel="nofollow"} for more information about webpack plugins. You can also use [this collection](https://webpack.js.org/awesome-webpack/#webpack-plugins){rel="nofollow"} to find a plugin that suits your needs.
::

### Parameters

**`pluginOrGetter`**: A webpack plugin instance or an array of webpack plugin instances. If a function is provided, it must return a webpack plugin instance or an array of webpack plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addBuildPlugin`

Builder-agnostic version of `addVitePlugin` and `addWebpackPlugin`. It will add the plugin to both Vite and webpack configurations if they are present.

### Type

```ts twoslash
// @errors: 2391
import type { ExtendConfigOptions } from '@nuxt/kit'
import type { Plugin as VitePlugin } from 'vite'
import type { WebpackPluginInstance } from 'webpack'
import type { RspackPluginInstance } from '@rspack/core'
interface AddBuildPluginFactory {
  vite?: () => VitePlugin | VitePlugin[]
  webpack?: () => WebpackPluginInstance | WebpackPluginInstance[]
  rspack?: () => RspackPluginInstance | RspackPluginInstance[]
}
// ---cut---
function addBuildPlugin (pluginFactory: AddBuildPluginFactory, options?: ExtendConfigOptions): void
```

### Parameters

**`pluginFactory`**: A factory function that returns an object with `vite` and/or `webpack` properties. These properties must be functions that return a Vite plugin instance or an array of Vite plugin instances and/or a webpack plugin instance or an array of webpack plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |


# Examples

## Accessing Nuxt Vite Config

If you are building an integration that needs access to the runtime Vite or webpack config that Nuxt uses, it is possible to extract this using Kit utilities.

Some examples of projects doing this already:

- [histoire](https://github.com/histoire-dev/histoire/blob/main/packages/histoire-plugin-nuxt/src/index.ts){rel="nofollow"}
- [nuxt-vitest](https://github.com/danielroe/nuxt-vitest/blob/main/packages/nuxt-vitest/src/config.ts){rel="nofollow"}
- [@storybook-vue/nuxt](https://github.com/storybook-vue/storybook-nuxt/blob/main/packages/storybook-nuxt/src/preset.ts){rel="nofollow"}

Here is a brief example of how you might access the Vite config from a project; you could implement a similar approach to get the webpack configuration.

```js
import { loadNuxt, buildNuxt } from '@nuxt/kit'

// https://github.com/nuxt/nuxt/issues/14534
async function getViteConfig() {
  const nuxt = await loadNuxt({ cwd: process.cwd(), dev: false, overrides: { ssr: false } })
  return new Promise((resolve, reject) => {
    nuxt.hook('vite:extendConfig', (config, { isClient }) => {
      if (isClient) {
        resolve(config)
        throw new Error('_stop_')
      }
    })
    buildNuxt(nuxt).catch((err) => {
      if (!err.toString().includes('_stop_')) {
        reject(err)
      }
    })
  }).finally(() => nuxt.close())
}

const viteConfig = await getViteConfig()
console.log(viteConfig)
```


# Layers

Nuxt layers provide a powerful way to share and extend functionality across projects. When working with layers in modules, you often need to access directory paths from each layer. Nuxt Kit provides the `getLayerDirectories` utility to access resolved directory paths for all layers in your Nuxt application.

## `getLayerDirectories`

Get the resolved directory paths for all layers in a Nuxt application. This function provides a structured way to access layer directories without directly accessing the private `nuxt.options._layers` property.

### Usage

```ts twoslash
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const layerDirs = getLayerDirectories()
    
    // Access directories from all layers
    for (const [index, layer] of layerDirs.entries()) {
      console.log(`Layer ${index}:`)
      console.log(`  Root: ${layer.root}`)
      console.log(`  App: ${layer.app}`)
      console.log(`  Server: ${layer.server}`)
      console.log(`  Pages: ${layer.appPages}`)
      // ... other directories
    }
  }
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function getLayerDirectories(nuxt?: Nuxt): LayerDirectories[]

interface LayerDirectories {
  /** Nuxt rootDir (`/` by default) */
  readonly root: string
  /** Nitro source directory (`/server` by default) */
  readonly server: string
  /** Local modules directory (`/modules` by default) */
  readonly modules: string
  /** Shared directory (`/shared` by default) */
  readonly shared: string
  /** Public directory (`/public` by default) */
  readonly public: string
  /** Nuxt srcDir (`/app/` by default) */
  readonly app: string
  /** Layouts directory (`/app/layouts` by default) */
  readonly appLayouts: string
  /** Middleware directory (`/app/middleware` by default) */
  readonly appMiddleware: string
  /** Pages directory (`/app/pages` by default) */
  readonly appPages: string
  /** Plugins directory (`/app/plugins` by default) */
  readonly appPlugins: string
}
```

### Parameters

**`nuxt`** (optional): The Nuxt instance to get layers from. If not provided, the function will use the current Nuxt context.

### Return Value

The `getLayerDirectories` function returns an array of `LayerDirectories` objects, one for each layer in the application.

**Layer Priority Ordering**: The layers are ordered by priority, where:

- The **first layer** is the user/project layer (highest priority)
- **Earlier layers override later layers** in the array
- **Base layers appear last** in the array (lowest priority)

This ordering matches Nuxt's layer resolution system, where user-defined configurations and files take precedence over those from base layers.

**`LayerDirectories`**: An object containing the resolved directory paths for a layer.

| Property        | Type     | Description                                                  |
| --------------- | -------- | ------------------------------------------------------------ |
| `root`          | `string` | The root directory of the layer (equivalent to `rootDir`)    |
| `server`        | `string` | The server directory for Nitro server-side code              |
| `modules`       | `string` | The local modules directory                                  |
| `shared`        | `string` | The shared directory for code used by both client and server |
| `app`           | `string` | The source directory of the layer (equivalent to `srcDir`)   |
| `public`        | `string` | The public directory for static assets                       |
| `appLayouts`    | `string` | The layouts directory for Vue layout components              |
| `appMiddleware` | `string` | The middleware directory for route middleware                |
| `appPages`      | `string` | The pages directory for file-based routing                   |
| `appPlugins`    | `string` | The plugins directory for Nuxt plugins                       |

### Examples

**Processing files from all layers:**

```ts twoslash
// @errors: 2307
// ---cut---
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'
import { resolve } from 'pathe'
import { globby } from 'globby'

export default defineNuxtModule({
  async setup() {
    const layerDirs = getLayerDirectories()
    
    // Find all component files across layers
    // Note: layerDirs[0] is the user layer (highest priority)
    // Later layers in the array have lower priority
    const componentFiles = []
    for (const [index, layer] of layerDirs.entries()) {
      const files = await globby('**/*.vue', {
        cwd: resolve(layer.app, 'components'),
        absolute: true
      })
      console.log(`Layer ${index} (${index === 0 ? 'user' : 'base'}):`, files.length, 'components')
      componentFiles.push(...files)
    }
  }
})
```

**Adding templates from multiple layers:**

```ts twoslash
import { defineNuxtModule, getLayerDirectories, addTemplate } from '@nuxt/kit'
import { resolve, basename } from 'pathe'
import { existsSync } from 'fs'

export default defineNuxtModule({
  async setup() {
    const layerDirs = getLayerDirectories()
    
    // Add a config file from each layer that has one
    for (const dirs of layerDirs) {
      const configPath = resolve(dirs.app, 'my-module.config.ts')
      if (existsSync(configPath)) {
        addTemplate({
          filename: `my-module-${basename(dirs.root)}.config.ts`,
          src: configPath
        })
      }
    }
  }
})
```

**Respecting layer priority:**

```ts twoslash
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'
import { resolve } from 'pathe'
import { existsSync, readFileSync } from 'fs'

export default defineNuxtModule({
  setup() {
    const layerDirs = getLayerDirectories()
    
    // Find the first (highest priority) layer that has a specific config file
    // This respects the layer priority system
    let configContent = null
    for (const dirs of layerDirs) {
      const configPath = resolve(dirs.app, 'my-config.json')
      if (existsSync(configPath)) {
        configContent = readFileSync(configPath, 'utf-8')
        console.log(`Using config from layer: ${dirs.root}`)
        break // Use the first (highest priority) config found
      }
    }
    
    // Alternative: Collect configs from all layers, with user layer taking precedence
    const allConfigs = {}
    for (const dirs of layerDirs.reverse()) { // Process from lowest to highest priority
      const configPath = resolve(dirs.app, 'my-config.json')
      if (existsSync(configPath)) {
        const config = JSON.parse(readFileSync(configPath, 'utf-8'))
        Object.assign(allConfigs, config) // Later assignments override earlier ones
      }
    }
  }
})
```

**Checking for layer-specific directories:**

```ts twoslash
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'
import { existsSync } from 'fs'
import { resolve } from 'pathe'

export default defineNuxtModule({
  setup() {
    const layerDirs = getLayerDirectories()
    
    // Find layers that have a specific custom directory
    const layersWithAssets = layerDirs.filter(layer => {
      return existsSync(resolve(layer.app, 'assets'))
    })
    
    console.log(`Found ${layersWithAssets.length} layers with assets directory`)
  }
})
```

::note
The `getLayerDirectories` function includes caching via a WeakMap to avoid recomputing directory paths for the same layers repeatedly, improving performance when called multiple times.
::

::note
Directory paths returned by this function always include a trailing slash for consistency.
::


# Programmatic Usage

Programmatic usage can be helpful when you want to use Nuxt programmatically, for example, when building a [CLI tool](https://github.com/nuxt/cli){rel="nofollow"} or [test utils](https://github.com/nuxt/nuxt/tree/main/packages/test-utils){rel="nofollow"}.

## `loadNuxt`

Load Nuxt programmatically. It will load the Nuxt configuration, instantiate and return the promise with Nuxt instance.

### Type

```ts
function loadNuxt (loadOptions?: LoadNuxtOptions): Promise<Nuxt>
```

### Parameters

**`loadOptions`**: Loading conditions for Nuxt. `loadNuxt` uses [`c12`](https://github.com/unjs/c12){rel="nofollow"} under the hood, so it accepts the same options as `c12.loadConfig` with some additional options:

| Property | Type      | Required | Description                                                                                                                                                       |
| -------- | --------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dev`    | `boolean` | `false`  | If set to `true`, Nuxt will be loaded in development mode.                                                                                                        |
| `ready`  | `boolean` | `true`   | If set to `true`, Nuxt will be ready to use after the `loadNuxt` call. If set to `false`, you will need to call `nuxt.ready()` to make sure Nuxt is ready to use. |

## `buildNuxt`

Build Nuxt programmatically. It will invoke the builder (currently [@nuxt/vite-builder](https://github.com/nuxt/nuxt/tree/main/packages/vite){rel="nofollow"} or [@nuxt/webpack-builder](https://github.com/nuxt/nuxt/tree/main/packages/webpack){rel="nofollow"}) to bundle the application.

### Type

```ts
function buildNuxt (nuxt: Nuxt): Promise<any>
```

### Parameters

**`nuxt`**: Nuxt instance to build. It can be retrieved from the context via `useNuxt()` call.

## `loadNuxtConfig`

Load Nuxt configuration. It will return the promise with the configuration object.

### Type

```ts
function loadNuxtConfig (options: LoadNuxtConfigOptions): Promise<NuxtOptions>
```

### Parameters

**`options`**: Options to pass in [`c12`](https://github.com/unjs/c12#options){rel="nofollow"} `loadConfig` call.

## `writeTypes`

Generates `tsconfig.json` and writes it to the project buildDir.

### Type

```ts
function writeTypes (nuxt?: Nuxt): void
```

### Parameters

**`nuxt`**: Nuxt instance to build. It can be retrieved from the context via `useNuxt()` call.


# Compatibility

Nuxt Kit utilities can be used in Nuxt 3, Nuxt 2 with Bridge and even Nuxt 2 without Bridge. To make sure your module is compatible with all versions, you can use the `checkNuxtCompatibility`, `assertNuxtCompatibility` and `hasNuxtCompatibility` functions. They will check if the current Nuxt version meets the constraints you provide. Also you can use `isNuxt2`, `isNuxt3` and `getNuxtVersion` functions for more granular checks.

## `checkNuxtCompatibility`

Checks if constraints are met for the current Nuxt version. If not, returns an array of messages. Nuxt 2 version also checks for `bridge` support.

### Usage

```ts twoslash
import { defineNuxtModule, checkNuxtCompatibility } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_options, nuxt) {
    const issues = await checkNuxtCompatibility({ nuxt: '^2.16.0' }, nuxt)
    if (issues.length) {
      console.warn('Nuxt compatibility issues found:\n' + issues.toString())
    } else {
      // do something
    }
  }
})
```

### Type

```ts
function checkNuxtCompatibility(constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<NuxtCompatibilityIssues>;
```

### Parameters

**`constraints`**: Version and builder constraints to check against. It accepts the following properties:

| Property | Type                                                                                                                                               | Required | Description                                                                                                                                     |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `nuxt`   | `string`                                                                                                                                           | `false`  | Nuxt version in semver format. Versions may be defined in Node.js way, for example: `>=2.15.0 <3.0.0`.                                          |
| `bridge` | `Record<string, string | false>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Specifies version constraints or disables compatibility for specific Nuxt builders like `vite`, `webpack`, or `rspack`. Use `false` to disable. |

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `assertNuxtCompatibility`

Asserts that constraints are met for the current Nuxt version. If not, throws an error with the list of issues as string.

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt, NuxtCompatibility } from '@nuxt/schema'
// ---cut---
function assertNuxtCompatibility(constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<true>;
```

### Parameters

**`constraints`**: Version and builder constraints to check against. Refer to the [constraints table in `checkNuxtCompatibility`](https://nuxt.com/#parameters) for details.

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `hasNuxtCompatibility`

Checks if constraints are met for the current Nuxt version. Return `true` if all constraints are met, otherwise returns `false`. Nuxt 2 version also checks for `bridge` support.

### Usage

```ts twoslash
import { defineNuxtModule, hasNuxtCompatibility } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_options, nuxt) {
    const usingNewPostcss = await hasNuxtCompatibility({ nuxt: '^2.16.0' }, nuxt)
    if (usingNewPostcss) {
      // do something
    } else {
      // do something else
    }
  }
})
```

### Type

```ts
function hasNuxtCompatibility(constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<boolean>;
```

### Parameters

**`constraints`**: Version and builder constraints to check against. Refer to the [constraints table in `checkNuxtCompatibility`](https://nuxt.com/#parameters) for details.

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `isNuxtMajorVersion`

Check if current Nuxt instance is of specified major version

### Usage

```ts twoslash
import { defineNuxtModule, isNuxtMajorVersion } from '@nuxt/kit'

export default defineNuxtModule({
  async setup () {
    if (isNuxtMajorVersion(3)) {
      // do something for Nuxt 3
    } else {
      // do something else for other versions
    }
  }
})
```

### Type

```ts
function isNuxtMajorVersion(major: number, nuxt?: Nuxt): boolean;
```

### Parameters

**`major`**: Major version to check against.

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `isNuxt3`

Checks if the current Nuxt version is 3.x.

::note
Use `isNuxtMajorVersion(2, nuxt)` instead. This may be removed in @nuxt/kit v5 or a future major version.
::

### Type

```ts
function isNuxt3(nuxt?: Nuxt): boolean;
```

### Parameters

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `isNuxt2`

Checks if the current Nuxt version is 2.x.

::note
Use `isNuxtMajorVersion(2, nuxt)` instead. This may be removed in @nuxt/kit v5 or a future major version.
::

### Type

```ts
function isNuxt2(nuxt?: Nuxt): boolean;
```

### Parameters

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `getNuxtVersion`

Returns the current Nuxt version.

### Type

```ts
function getNuxtVersion(nuxt?: Nuxt): string;
```

### Parameters

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.


# Auto-imports

Nuxt auto-imports helper functions, composables and Vue APIs to use across your application without explicitly importing them. Based on the directory structure, every Nuxt application can also use auto-imports for its own composables and plugins.

With Nuxt Kit you can also add your own auto-imports. `addImports` and `addImportsDir` allow you to add imports to the Nuxt application. `addImportsSources` allows you to add listed imports from 3rd party packages to the Nuxt application.

These utilities are powered by [`unimport`](https://github.com/unjs/unimport){rel="nofollow"}, which provides the underlying auto-import mechanism used in Nuxt.

::note
These functions are designed for registering your own utils, composables and Vue APIs. For pages, components and plugins, please refer to the specific sections: [Pages](https://nuxt.com/docs/api/kit/pages), [Components](https://nuxt.com/docs/api/kit/components), [Plugins](https://nuxt.com/docs/api/kit/plugins).
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/expanding-nuxt-s-auto-imports?friend=nuxt
---
Watch Vue School video about Auto-imports Nuxt Kit utilities.
::

## `addImports`

Add imports to the Nuxt application. It makes your imports available in the Nuxt application without the need to import them manually.

### Usage

```ts twoslash
import { defineNuxtModule, addImports } from "@nuxt/kit";

export default defineNuxtModule({
  setup(options, nuxt) {
    const names = [
      'useStoryblok',
      'useStoryblokApi',
      'useStoryblokBridge',
      'renderRichText',
      'RichTextSchema'
    ]

    names.forEach((name) =>
      addImports({ name, as: name, from: '@storyblok/vue' })
    )
  }
})
```

### Type

```ts
function addImports (imports: Import | Import[]): void
```

### Parameters

`imports`: An object or an array of objects with the following properties:

| Property   | Type                  | Required | Description                                                                                                     |
| ---------- | --------------------- | -------- | --------------------------------------------------------------------------------------------------------------- |
| `name`     | `string`              | `true`   | Import name to be detected.                                                                                     |
| `from`     | `string`              | `true`   | Module specifier to import from.                                                                                |
| `priority` | `number`              | `false`  | Priority of the import; if multiple imports have the same name, the one with the highest priority will be used. |
| `disabled` | `boolean`             | `false`  | If this import is disabled.                                                                                     |
| `meta`     | `Record<string, any>` | `false`  | Metadata of the import.                                                                                         |
| `type`     | `boolean`             | `false`  | If this import is a pure type import.                                                                           |
| `typeFrom` | `string`              | `false`  | Use this as the `from` value when generating type declarations.                                                 |
| `as`       | `string`              | `false`  | Import as this name.                                                                                            |

## `addImportsDir`

Add imports from a directory to the Nuxt application. It will automatically import all files from the directory and make them available in the Nuxt application without the need to import them manually.

### Usage

```ts twoslash
import { defineNuxtModule, addImportsDir, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: '@vueuse/motion',
    configKey: 'motion',
  },
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    addImportsDir(resolver.resolve('./runtime/composables'))
  },
})
```

### Type

```ts
function addImportsDir (dirs: string | string[], options?: { prepend?: boolean }): void
```

### Parameters

| Property  | Type                                                                                                                                      | Required | Description                                                                                                         |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------- |
| `dirs`    | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}     | `true`   | A string or an array of strings with the path to the directory to import from.                                      |
| `options` | `{ prepend?: boolean }`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Options to pass to the import. If `prepend` is set to `true`, the imports will be prepended to the list of imports. |

## `addImportsSources`

Add listed imports to the Nuxt application.

### Usage

```ts twoslash
import { defineNuxtModule, addImportsSources } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    addImportsSources({
      from: 'h3',
      imports: [
        'defineEventHandler',
        'getQuery',
        'getRouterParams',
        'readBody',
        'sendRedirect'
      ],
    })
  }
})
```

### Type

```ts
function addImportsSources (importSources: ImportSource | ImportSource[]): void
```

### Parameters

**importSources**: An object or an array of objects with the following properties:

| Property  | Type                                                                                                                                              | Required | Description                                                                                    |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------- |
| `from`    | `string`                                                                                                                                          | `true`   | Module specifier to import from.                                                               |
| `imports` | `PresetImport | ImportSource[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | An object or an array of objects, which can be import names, import objects or import sources. |


# Components

Components are the building blocks of your Nuxt application. They are reusable Vue instances that can be used to create a user interface. In Nuxt, components from the components directory are automatically imported by default. However, if you need to import components from an alternative directory or wish to selectively import them as needed, `@nuxt/kit` provides the `addComponentsDir` and `addComponent` methods. These utils allow you to customize the component configuration to better suit your needs.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/injecting-components-and-component-directories?friend=nuxt
---
Watch Vue School video about injecting components.
::

## `addComponentsDir`

Register a directory to be scanned for components and imported only when used. Keep in mind, that this does not register components globally, until you specify `global: true` option.

### Usage

```ts
export default defineNuxtModule({
  meta: {
    name: '@nuxt/ui',
    configKey: 'ui',
  },
  setup() {
    addComponentsDir({
      path: resolve('./runtime/components'),
      prefix: 'U',
      pathPrefix: false
    })
  }
})
```

### Type

```ts
function addComponentsDir (dir: ComponentsDir, opts: { prepend?: boolean } = {}): void
```

### Parameters

`dir` An object with the following properties:

| Property          | Type                                                                                                                                                                                         | Required | Description                                                                                                                                                                                                                                                             |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `path`            | `string`                                                                                                                                                                                     | `true`   | Path (absolute or relative) to the directory containing your components. You can use Nuxt aliases (\~ or @) to refer to directories inside project or directly use an npm package path similar to require.                                                              |
| `pattern`         | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                        | `false`  | Accept Pattern that will be run against specified path.                                                                                                                                                                                                                 |
| `ignore`          | `string[]`                                                                                                                                                                                   | `false`  | Ignore patterns that will be run against specified path.                                                                                                                                                                                                                |
| `prefix`          | `string`                                                                                                                                                                                     | `false`  | Prefix all matched components with this string.                                                                                                                                                                                                                         |
| `pathPrefix`      | `boolean`                                                                                                                                                                                    | `false`  | Prefix component name by its path.                                                                                                                                                                                                                                      |
| `prefetch`        | `boolean`                                                                                                                                                                                    | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `preload`         | `boolean`                                                                                                                                                                                    | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `isAsync`         | `boolean`                                                                                                                                                                                    | `false`  | This flag indicates, component should be loaded async (with a separate chunk) regardless of using Lazy prefix or not.                                                                                                                                                   |
| `extendComponent` | `(component: Component) => Promise<Component | void> | (Component | void)`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | A function that will be called for each component found in the directory. It accepts a component object and should return a component object or a promise that resolves to a component object.                                                                          |
| `global`          | `boolean`                                                                                                                                                                                    | `false`  | If enabled, registers components to be globally available.                                                                                                                                                                                                              |
| `island`          | `boolean`                                                                                                                                                                                    | `false`  | If enabled, registers components as islands. You can read more about islands in [`<NuxtIsland/>`](https://nuxt.com/docs/api/components/nuxt-island#nuxtisland) component description.                                                                                   |
| `watch`           | `boolean`                                                                                                                                                                                    | `false`  | Watch specified path for changes, including file additions and file deletions.                                                                                                                                                                                          |
| `extensions`      | `string[]`                                                                                                                                                                                   | `false`  | Extensions supported by Nuxt builder.                                                                                                                                                                                                                                   |
| `transpile`       | `'auto' | boolean`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                         | `false`  | Transpile specified path using build.transpile. If set to `'auto'`, it will set `transpile: true` if `node_modules/` is in path.                                                                                                                                        |

`opts`

| Property  | Type      | Required | Description                                                                                          |
| --------- | --------- | -------- | ---------------------------------------------------------------------------------------------------- |
| `prepend` | `boolean` | `false`  | If set to `true`, the directory will be prepended to the array with `unshift()` instead of `push()`. |

## `addComponent`

Register a component to be automatically imported.

### Usage

```ts
import { defineNuxtModule, createResolver, addComponent } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: '@nuxt/image',
    configKey: 'image',
  },
  async setup() {
    const resolver = createResolver(import.meta.url)

    addComponent({
      name: 'NuxtImg',
      filePath: resolver.resolve('./runtime/components/NuxtImg.vue'),
    })

    addComponent({
      name: 'NuxtPicture',
      filePath: resolver.resolve('./runtime/components/NuxtPicture.vue'),
    })
  },
})
```

### Type

```ts
function addComponent (options: AddComponentOptions): void
```

### Parameters

`options`: An object with the following properties:

| Property     | Type                                                                                                                                            | Required | Description                                                                                                                                                                                                                                                             |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`       | `string`                                                                                                                                        | `true`   | Component name.                                                                                                                                                                                                                                                         |
| `filePath`   | `string`                                                                                                                                        | `true`   | Path to the component.                                                                                                                                                                                                                                                  |
| `pascalName` | `string`                                                                                                                                        | `false`  | Pascal case component name. If not provided, it will be generated from the component name.                                                                                                                                                                              |
| `kebabName`  | `string`                                                                                                                                        | `false`  | Kebab case component name. If not provided, it will be generated from the component name.                                                                                                                                                                               |
| `export`     | `string`                                                                                                                                        | `false`  | Specify named or default export. If not provided, it will be set to `'default'`.                                                                                                                                                                                        |
| `shortPath`  | `string`                                                                                                                                        | `false`  | Short path to the component. If not provided, it will be generated from the component path.                                                                                                                                                                             |
| `chunkName`  | `string`                                                                                                                                        | `false`  | Chunk name for the component. If not provided, it will be generated from the component name.                                                                                                                                                                            |
| `prefetch`   | `boolean`                                                                                                                                       | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `preload`    | `boolean`                                                                                                                                       | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `global`     | `boolean`                                                                                                                                       | `false`  | If enabled, registers component to be globally available.                                                                                                                                                                                                               |
| `island`     | `boolean`                                                                                                                                       | `false`  | If enabled, registers component as island. You can read more about islands in [`<NuxtIsland/>`](https://nuxt.com/docs/api/components/nuxt-island#nuxtisland) component description.                                                                                     |
| `mode`       | `'client' | 'server' | 'all'`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | This options indicates if component should render on client, server or both. By default, it will render on both client and server.                                                                                                                                      |
| `priority`   | `number`                                                                                                                                        | `false`  | Priority of the component, if multiple components have the same name, the one with the highest priority will be used.                                                                                                                                                   |

### Examples

If you want to auto-import a component from an npm package, and the component is a named export (rather than the default), you can use the `export` option to specify it.

```ts
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```


# Context

Nuxt modules allow you to enhance Nuxt's capabilities. They offer a structured way to keep your code organized and modular. If you're looking to break down your module into smaller components, Nuxt offers the `useNuxt` and `tryUseNuxt` functions. These functions enable you to conveniently access the Nuxt instance from the context without having to pass it as an argument.

::note
When you're working with the `setup` function in Nuxt modules, Nuxt is already provided as the second argument. This means you can access it directly without needing to call `useNuxt()`.
::

## `useNuxt`

Get the Nuxt instance from the context. It will throw an error if Nuxt is not available.

### Usage

```ts
import { useNuxt } from '@nuxt/kit'

const setupSomeFeature = () => {
  const nuxt = useNuxt()

  // You can now use the nuxt instance
  console.log(nuxt.options)
}
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function useNuxt(): Nuxt
```

### Return Value

The `useNuxt` function returns the Nuxt instance, which contains all the options and methods available in Nuxt.

| Property   | Type                                                                     | Description                                                                                               |
| ---------- | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------- |
| `options`  | `NuxtOptions`                                                            | The resolved Nuxt configuration.                                                                          |
| `hooks`    | `Hookable<NuxtHooks>`                                                    | The Nuxt hook system. Allows registering and listening to lifecycle events.                               |
| `hook`     | `(name: string, (...args: any[]) => Promise<void> | void) => () => void` | Shortcut for `nuxt.hooks.hook`. Registers a single callback for a specific lifecycle hook.                |
| `callHook` | `(name: string, ...args: any[]) => Promise<any>`                         | Shortcut for `nuxt.hooks.callHook`. Triggers a lifecycle hook manually and runs all registered callbacks. |
| `addHooks` | `(configHooks: NestedHooks) => () => void`                               | Shortcut for `nuxt.hooks.addHooks`. Registers multiple hooks at once.                                     |

### Examples

::code-group
```ts [setupTranspilation.ts] twoslash
import { useNuxt } from '@nuxt/kit'

export const setupTranspilation = () => {
  const nuxt = useNuxt()

  if (nuxt.options.builder === '@nuxt/webpack-builder') {
    nuxt.options.build.transpile ||= []
    nuxt.options.build.transpile.push('xstate')
  }
}
```

```ts [module.ts] twoslash
// @module: esnext
// @filename: setupTranspilation.ts
export const setupTranspilation = () => {}
// @filename: module.ts
import { defineNuxtModule } from '@nuxt/kit'
// ---cut---
import { setupTranspilation } from './setupTranspilation'

export default defineNuxtModule({
  setup () {
    setupTranspilation()
  },
})
```
::

## `tryUseNuxt`

Get the Nuxt instance from the context. It will return `null` if Nuxt is not available.

### Usage

```ts twoslash
import { tryUseNuxt } from '@nuxt/kit'

function setupSomething () {
  const nuxt = tryUseNuxt()

  if (nuxt) {
    // You can now use the nuxt instance
    console.log(nuxt.options)
  } else {
    console.log('Nuxt is not available')
  }
}
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function tryUseNuxt(): Nuxt | null
```

### Return Value

The `tryUseNuxt` function returns the Nuxt instance if available, or `null` if Nuxt is not available.

The Nuxt instance as described in the `useNuxt` section.

### Examples

::code-group
```ts [requireSiteConfig.ts] twoslash
declare module 'nuxt/schema' {
  interface NuxtOptions {
    siteConfig: SiteConfig
  }
}
// ---cut---
import { tryUseNuxt } from '@nuxt/kit'

interface SiteConfig {
  title?: string
}

export const requireSiteConfig = (): SiteConfig => {
  const nuxt = tryUseNuxt()
  if (!nuxt) {
    return {}
  }
  return nuxt.options.siteConfig
}
```

```ts [module.ts] twoslash
// @module: esnext
// @filename: requireSiteConfig.ts
interface SiteConfig {
  title?: string
}
export const requireSiteConfig = (): SiteConfig => {
 return {}
}
// @filename: module.ts
// ---cut---
import { defineNuxtModule, useNuxt } from '@nuxt/kit'
import { requireSiteConfig } from './requireSiteConfig'

export default defineNuxtModule({
  setup (_, nuxt) {
    const config = requireSiteConfig()
    nuxt.options.app.head.title = config.title
  },
})
```
::


# Pages

## `extendPages`

In Nuxt, routes are automatically generated based on the structure of the files in the `app/pages` directory. However, there may be scenarios where you'd want to customize these routes. For instance, you might need to add a route for a dynamic page not generated by Nuxt, remove an existing route, or modify the configuration of a route. For such customizations, Nuxt offers the `extendPages` feature, which allows you to extend and alter the pages configuration.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/extend-and-alter-nuxt-pages?friend=nuxt
---
Watch Vue School video about extendPages.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, extendPages } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    extendPages((pages) => {
      pages.unshift({
        name: 'prismic-preview',
        path: '/preview',
        file: resolve('runtime/preview.vue'),
      })
    })
  },
})
```

### Type

```ts
function extendPages(callback: (pages: NuxtPage[]) => void): void
```

### Parameters

**callback**: A function that will be called with the pages configuration. You can alter this array by adding, deleting, or modifying its elements. Note: You should modify the provided pages array directly, as changes made to a copied array will not be reflected in the configuration.

| Property   | Type                                                                                                                                    | Required | Description                                                                               |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------- |
| `name`     | `string`                                                                                                                                | `false`  | The name of the route. Useful for programmatic navigation and identifying routes.         |
| `path`     | `string`                                                                                                                                | `false`  | The route URL path. If not set, Nuxt will infer it from the file location.                |
| `file`     | `string`                                                                                                                                | `false`  | Path to the Vue file that should be used as the component for the route.                  |
| `meta`     | `Record<string, any>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Custom metadata for the route. Can be used in layouts, middlewares, or navigation guards. |
| `alias`    | `string[] | string`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}   | `false`  | One or more alias paths for the route. Useful for supporting multiple URLs.               |
| `redirect` | `RouteLocationRaw`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}    | `false`  | Redirect rule for the route. Supports named routes, objects, or string paths.             |
| `children` | `NuxtPage[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}          | `false`  | Nested child routes under this route for layout or view nesting.                          |

## `extendRouteRules`

Nuxt is powered by the [Nitro](https://nitro.build/){rel="nofollow"} server engine. With Nitro, you can incorporate high-level logic directly into your configuration, which is useful for actions like redirects, proxying, caching, and appending headers to routes. This configuration works by associating route patterns with specific route settings.

::tip
You can read more about Nitro route rules in the [Nitro documentation](https://nitro.build/guide/routing#route-rules){rel="nofollow"}.
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/adding-route-rules-and-route-middlewares?friend=nuxt
---
Watch Vue School video about adding route rules and route middelwares.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, extendPages, extendRouteRules } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    extendPages((pages) => {
      pages.unshift({
        name: 'preview-new',
        path: '/preview-new',
        file: resolve('runtime/preview.vue'),
      })
    })

    extendRouteRules('/preview', {
      redirect: {
        to: '/preview-new',
        statusCode: 302,
      },
    })

    extendRouteRules('/preview-new', {
      cache: {
        maxAge: 60 * 60 * 24 * 7,
      },
    })
  },
})
```

### Type

```ts
function extendRouteRules(route: string, rule: NitroRouteConfig, options?: ExtendRouteRulesOptions): void
```

### Parameters

**route**: A route pattern to match against. :br**rule**: A route rule configuration to apply to the matched route.

::tip
About route rules configurations, you can get more detail in [Hybrid Rendering > Route Rules](https://nuxt.com/docs/guide/concepts/rendering#route-rules).
::

**options**: A object to pass to the route configuration. If `override` is set to `true`, it will override the existing route configuration.

| Name       | Type      | Default | Description                                  |
| ---------- | --------- | ------- | -------------------------------------------- |
| `override` | `boolean` | `false` | Override route rule config, default is false |

## `addRouteMiddleware`

Registers route middlewares to be available for all routes or for specific routes.

Route middlewares can be also defined in plugins via [`addRouteMiddleware`](https://nuxt.com/docs/api/utils/add-route-middleware) composable.

::tip
Read more about route middlewares in the [Route middleware documentation](https://nuxt.com/docs/getting-started/routing#route-middleware).
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/adding-route-rules-and-route-middlewares?friend=nuxt
---
Watch Vue School video about adding route rules and route middelwares.
::

### Usage

::code-group
```ts [module.ts] twoslash
import { addRouteMiddleware, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addRouteMiddleware({
      name: 'auth',
      path: resolve('runtime/auth'),
      global: true,
    }, { prepend: true })
  },
})
```

```ts [runtime/auth.ts] twoslash
function isAuthenticated(): boolean { return false }
// ---cut---
export default defineNuxtRouteMiddleware((to, from) => {
  // isAuthenticated() is an example method verifying if a user is authenticated
  if (to.path !== '/login' && isAuthenticated() === false) {
    return navigateTo('/login')
  }
})
```
::

### Type

```ts
function addRouteMiddleware(input: NuxtMiddleware | NuxtMiddleware[], options?: AddRouteMiddlewareOptions): void
```

### Parameters

**input**: A middleware object or an array of middleware objects with the following properties:

| Property | Type      | Required | Description                                         |
| -------- | --------- | -------- | --------------------------------------------------- |
| `name`   | `string`  | `true`   | The name of the middleware.                         |
| `path`   | `string`  | `true`   | The file path to the middleware.                    |
| `global` | `boolean` | `false`  | If set to `true`, applies middleware to all routes. |

**options**: An object with the following properties:

| Property   | Type      | Default | Description                                                 |
| ---------- | --------- | ------- | ----------------------------------------------------------- |
| `override` | `boolean` | `false` | If `true`, replaces middleware with the same name.          |
| `prepend`  | `boolean` | `false` | If `true`, prepends middleware before existing middlewares. |


# Layout

Layouts is used to be a wrapper around your pages. It can be used to wrap your pages with common components, for example, a header and a footer. Layouts can be registered using `addLayout` utility.

## `addLayout`

Register template as layout and add it to the layouts.

::note
In Nuxt 2 `error` layout can also be registered using this utility. In Nuxt 3+ `error` layout [replaced](https://nuxt.com/docs/getting-started/error-handling#rendering-an-error-page) with `error.vue` page in project root.
::

### Usage

```ts twoslash
import { addLayout, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addLayout({
      src: resolve('templates/custom-layout.ts'),
      filename: 'custom-layout.ts',
    }, 'custom')
  },
})
```

### Type

```ts
function addLayout(layout: NuxtTemplate | string, name: string): void
```

### Parameters

**`layout`**: A template object or a string with the path to the template. If a string is provided, it will be converted to a template object with `src` set to the string value. If a template object is provided, it must have the following properties:

| Property      | Type                                                                                                                                                   | Required | Description                                                                                                                                                                      |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                                                                                                                               | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                          |
| `filename`    | `string`                                                                                                                                               | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                   |
| `dst`         | `string`                                                                                                                                               | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                |
| `options`     | `Record<string, any>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                | `false`  | Options to pass to the template.                                                                                                                                                 |
| `getContents` | `(data) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored. |
| `write`       | `boolean`                                                                                                                                              | `false`  | If set to `true`, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.                                         |

**`name`**: The name to register the layout under (e.g., `default`, `custom`, etc.).

### Example

This will register a layout named `custom` that wraps pages with a header and footer.

```ts twoslash
import { addLayout, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addLayout({
      write: true,
      filename: 'my-layout.vue',
      getContents: () => `<template>
  <div>
    <header>My Header</header>
    <slot />
    <footer>My Footer</footer>
  </div>
</template>`,
    }, 'custom')
  },
})
```

You can then use this layout in your pages:

```vue [app/pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'custom',
})
</script>

<template>
  <div>About Page</div>
</template>
```

::warning
Due to the lack of support for virtual `.vue` files by `@vitejs/plugin-vue`, you can work around this limitation by passing `write: true` to the first argument of `addLayout`.
::


# Plugins

Plugins are self-contained code that usually add app-level functionality to Vue. In Nuxt, plugins are automatically imported from the `app/plugins/` directory. However, if you need to ship a plugin with your module, Nuxt Kit provides the `addPlugin` and `addPluginTemplate` methods. These utils allow you to customize the plugin configuration to better suit your needs.

## `addPlugin`

Registers a Nuxt plugin and adds it to the plugins array.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/injecting-plugins?friend=nuxt
---
Watch Vue School video about `addPlugin`.
::

### Usage

```ts twoslash
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addPlugin({
      src: resolve('runtime/plugin.js'),
      mode: 'client',
    })
  },
})
```

### Type

```ts
function addPlugin(plugin: NuxtPlugin | string, options?: AddPluginOptions): NuxtPlugin
```

### Parameters

**`plugin`**: A plugin object or a string with the path to the plugin. If a string is provided, it will be converted to a plugin object with `src` set to the string value.

If a plugin object is provided, it must have the following properties:

| Property | Type                                                                                                                                            | Required | Description                                                                                                                                                                                                                                                                                                                                                              |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `src`    | `string`                                                                                                                                        | `true`   | Path to the plugin file.                                                                                                                                                                                                                                                                                                                                                 |
| `mode`   | `'all' | 'server' | 'client'`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | If set to `'all'`, the plugin will be included in both client and server bundles. If set to `'server'`, the plugin will only be included in the server bundle. If set to `'client'`, the plugin will only be included in the client bundle. You can also use `.client` and `.server` modifiers when specifying `src` option to use plugin only in client or server side. |
| `order`  | `number`                                                                                                                                        | `false`  | Order of the plugin. This allows more granular control over plugin order and should only be used by advanced users. Lower numbers run first, and user plugins default to `0`. It's recommended to set `order` to a number between `-20` for `pre`-plugins (plugins that run before Nuxt plugins) and `20` for `post`-plugins (plugins that run after Nuxt plugins).      |

::warning
Avoid using `order` unless necessary. Use `append` if you simply need to register plugins after Nuxt defaults.
::

**`options`**: Optional object with the following properties:

| Property | Type      | Required | Description                                                                                                         |
| -------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------------- |
| `append` | `boolean` | `false`  | If `true`, the plugin will be appended to the plugins array. If `false`, it will be prepended. Defaults to `false`. |

### Examples

::code-group
```ts [module.ts]
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addPlugin({
      src: resolve('runtime/plugin.js'),
      mode: 'client',
    })
  },
})
```

```ts [runtime/plugin.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const colorMode = useColorMode()

  nuxtApp.hook('app:mounted', () => {
    if (colorMode.preference !== 'dark') {
      colorMode.preference = 'dark'
    }
  })
})
```
::

## `addPluginTemplate`

Adds a template and registers as a nuxt plugin. This is useful for plugins that need to generate code at build time.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/injecting-plugin-templates?friend=nuxt
---
Watch Vue School video about `addPluginTemplate`.
::

### Usage

```ts twoslash
import { addPluginTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    addPluginTemplate({
      filename: 'module-plugin.mjs',
      getContents: () => `import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'module-plugin',
  setup (nuxtApp) {
    ${options.log ? 'console.log("Plugin install")' : ''}
  }
})`,
    })
  },
})
```

### Type

```ts
function addPluginTemplate(pluginOptions: NuxtPluginTemplate, options?: AddPluginOptions): NuxtPlugin
```

### Parameters

**`pluginOptions`**: A plugin template object with the following properties:

| Property      | Type                                                                                                                                                                        | Required | Description                                                                                                                                                                                                                                                                                                                                                              |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `src`         | `string`                                                                                                                                                                    | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                                                                                                                                                                                                                  |
| `filename`    | `string`                                                                                                                                                                    | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                                                                                                                                                                                                           |
| `dst`         | `string`                                                                                                                                                                    | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                                                                                                                                                                                                        |
| `mode`        | `'all' | 'server' | 'client'`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                             | `false`  | If set to `'all'`, the plugin will be included in both client and server bundles. If set to `'server'`, the plugin will only be included in the server bundle. If set to `'client'`, the plugin will only be included in the client bundle. You can also use `.client` and `.server` modifiers when specifying `src` option to use plugin only in client or server side. |
| `options`     | `Record<string, any>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                     | `false`  | Options to pass to the template.                                                                                                                                                                                                                                                                                                                                         |
| `getContents` | `(data: Record<string, any>) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored.                                                                                                                                                                                         |
| `write`       | `boolean`                                                                                                                                                                   | `false`  | If set to `true`, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.                                                                                                                                                                                                                                 |
| `order`       | `number`                                                                                                                                                                    | `false`  | Order of the plugin. This allows more granular control over plugin order and should only be used by advanced users. Lower numbers run first, and user plugins default to `0`. It's recommended to set `order` to a number between `-20` for `pre`-plugins (plugins that run before Nuxt plugins) and `20` for `post`-plugins (plugins that run after Nuxt plugins).      |

::warning
Prefer using `getContents` for dynamic plugin generation. Avoid setting `order` unless necessary.
::

**`options`**: Optional object with the following properties:

| Property | Type      | Required | Description                                                                                                         |
| -------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------------- |
| `append` | `boolean` | `false`  | If `true`, the plugin will be appended to the plugins array. If `false`, it will be prepended. Defaults to `false`. |

### Examples

#### Generate a plugin template with different options

Use `addPluginTemplate` when you need to generate plugin code dynamically at build time. This allows you to generate different plugin contents based on the options passed to it. For example, Nuxt internally uses this function to generate Vue app configurations.

```ts [module.ts] twoslash
import { addPluginTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (_, nuxt) {
    if (nuxt.options.vue.config && Object.values(nuxt.options.vue.config).some(v => v !== null && v !== undefined)) {
      addPluginTemplate({
        filename: 'vue-app-config.mjs',
        write: true,
        getContents: () => `import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'nuxt:vue-app-config',
  enforce: 'pre',
  setup (nuxtApp) {
    ${Object.keys(nuxt.options.vue.config!)
        .map(k => `nuxtApp.vueApp.config[${JSON.stringify(k)}] = ${JSON.stringify(nuxt.options.vue.config![k as 'idPrefix'])}`)
        .join('\n')
    }
  }
})`,
      })
    }
  },
})
```

This generates different plugin code depending on the provided configuration.

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  vue: {
    config: {
      idPrefix: 'nuxt',
    },
  },
})
```

```ts [#build/vue-app-config.mjs]
import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'nuxt:vue-app-config',
  enforce: 'pre',
  setup (nuxtApp) {
    nuxtApp.vueApp.config["idPrefix"] = "nuxt"
  }
})
```
::


# Lifecycle Hooks

::read-more{to="https://nuxt.com/docs/guide/going-further/hooks"}
::

## App Hooks (runtime)

Check the [app source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts#L37){rel="nofollow"} for all available hooks.

| Hook                         | Arguments           | Environment     | Description                                                                                                                                                                                       |
| ---------------------------- | ------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `app:created`                | `vueApp`            | Server & Client | Called when initial `vueApp` instance is created.                                                                                                                                                 |
| `app:error`                  | `err`               | Server & Client | Called when a fatal error occurs.                                                                                                                                                                 |
| `app:error:cleared`          | `{ redirect? }`     | Server & Client | Called when a fatal error occurs.                                                                                                                                                                 |
| `vue:setup`                  | -                   | Server & Client | Called when the setup of Nuxt root is initialized. This callback must be synchronous.                                                                                                             |
| `vue:error`                  | `err, target, info` | Server & Client | Called when a vue error propagates to the root component. [Learn More](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"}.                                     |
| `app:rendered`               | `renderContext`     | Server          | Called when SSR rendering is done.                                                                                                                                                                |
| `app:redirected`             | -                   | Server          | Called before SSR redirection.                                                                                                                                                                    |
| `app:beforeMount`            | `vueApp`            | Client          | Called before mounting the app, called only on client side.                                                                                                                                       |
| `app:mounted`                | `vueApp`            | Client          | Called when Vue app is initialized and mounted in browser.                                                                                                                                        |
| `app:suspense:resolve`       | `appComponent`      | Client          | On [Suspense](https://vuejs.org/guide/built-ins/suspense.html#suspense){rel="nofollow"} resolved event.                                                                                           |
| `app:manifest:update`        | `{ id, timestamp }` | Client          | Called when there is a newer version of your app detected.                                                                                                                                        |
| `app:data:refresh`           | `keys?`             | Client          | Called when `refreshNuxtData` is called.                                                                                                                                                          |
| `link:prefetch`              | `to`                | Client          | Called when a `<NuxtLink>` is observed to be prefetched.                                                                                                                                          |
| `page:start`                 | `pageComponent?`    | Client          | Called on [Suspense](https://vuejs.org/guide/built-ins/suspense.html#suspense){rel="nofollow"} inside of `NuxtPage` pending event.                                                                |
| `page:finish`                | `pageComponent?`    | Client          | Called on [Suspense](https://vuejs.org/guide/built-ins/suspense.html#suspense){rel="nofollow"} inside of `NuxtPage` resolved event.                                                               |
| `page:loading:start`         | -                   | Client          | Called when the `setup()` of the new page is running.                                                                                                                                             |
| `page:loading:end`           | -                   | Client          | Called after `page:finish`                                                                                                                                                                        |
| `page:transition:finish`     | `pageComponent?`    | Client          | After page transition [onAfterLeave](https://vuejs.org/guide/built-ins/transition.html#javascript-hooks){rel="nofollow"} event.                                                                   |
| `dev:ssr-logs`               | `logs`              | Client          | Called with an array of server-side logs that have been passed to the client (if `features.devLogs` is enabled).                                                                                  |
| `page:view-transition:start` | `transition`        | Client          | Called after `document.startViewTransition` is called when [experimental viewTransition support is enabled](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental). |

## Nuxt Hooks (build time)

Check the [schema source code](https://github.com/nuxt/nuxt/blob/main/packages/schema/src/types/hooks.ts#L83){rel="nofollow"} for all available hooks.

| Hook                        | Arguments                                                | Description                                                                                                                                                                                                                                                                                  |
| --------------------------- | -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `kit:compatibility`         | `compatibility, issues`                                  | Allows extending compatibility checks.                                                                                                                                                                                                                                                       |
| `ready`                     | `nuxt`                                                   | Called after Nuxt initialization, when the Nuxt instance is ready to work.                                                                                                                                                                                                                   |
| `close`                     | `nuxt`                                                   | Called when Nuxt instance is gracefully closing.                                                                                                                                                                                                                                             |
| `restart`                   | `{ hard?: boolean }`                                     | To be called to restart the current Nuxt instance.                                                                                                                                                                                                                                           |
| `modules:before`            | -                                                        | Called during Nuxt initialization, before installing user modules.                                                                                                                                                                                                                           |
| `modules:done`              | -                                                        | Called during Nuxt initialization, after installing user modules.                                                                                                                                                                                                                            |
| `app:resolve`               | `app`                                                    | Called after resolving the `app` instance.                                                                                                                                                                                                                                                   |
| `app:templates`             | `app`                                                    | Called during `NuxtApp` generation, to allow customizing, modifying or adding new files to the build directory (either virtually or to written to `.nuxt`).                                                                                                                                  |
| `app:templatesGenerated`    | `app`                                                    | Called after templates are compiled into the [virtual file system](https://nuxt.com/docs/guide/directory-structure/nuxt#virtual-file-system) (vfs).                                                                                                                                          |
| `build:before`              | -                                                        | Called before Nuxt bundle builder.                                                                                                                                                                                                                                                           |
| `build:done`                | -                                                        | Called after Nuxt bundle builder is complete.                                                                                                                                                                                                                                                |
| `build:manifest`            | `manifest`                                               | Called during the manifest build by Vite and webpack. This allows customizing the manifest that Nitro will use to render `<script>` and `<link>` tags in the final HTML.                                                                                                                     |
| `builder:generateApp`       | `options`                                                | Called before generating the app.                                                                                                                                                                                                                                                            |
| `builder:watch`             | `event, path`                                            | Called at build time in development when the watcher spots a change to a file or directory in the project.                                                                                                                                                                                   |
| `pages:extend`              | `pages`                                                  | Called after page routes are scanned from the file system.                                                                                                                                                                                                                                   |
| `pages:resolved`            | `pages`                                                  | Called after page routes have been augmented with scanned metadata.                                                                                                                                                                                                                          |
| `pages:routerOptions`       | `{ files: Array<{ path: string, optional?: boolean }> }` | Called when resolving `router.options` files. Later items in the array override earlier ones.                                                                                                                                                                                                |
| `server:devHandler`         | `handler`                                                | Called when the dev middleware is being registered on the Nitro dev server.                                                                                                                                                                                                                  |
| `imports:sources`           | `presets`                                                | Called at setup allowing modules to extend sources.                                                                                                                                                                                                                                          |
| `imports:extend`            | `imports`                                                | Called at setup allowing modules to extend imports.                                                                                                                                                                                                                                          |
| `imports:context`           | `context`                                                | Called when the [unimport](https://github.com/unjs/unimport){rel="nofollow"} context is created.                                                                                                                                                                                             |
| `imports:dirs`              | `dirs`                                                   | Allows extending import directories.                                                                                                                                                                                                                                                         |
| `components:dirs`           | `dirs`                                                   | Called within `app:resolve` allowing to extend the directories that are scanned for auto-importable components.                                                                                                                                                                              |
| `components:extend`         | `components`                                             | Allows extending new components.                                                                                                                                                                                                                                                             |
| `nitro:config`              | `nitroConfig`                                            | Called before initializing Nitro, allowing customization of Nitro's configuration.                                                                                                                                                                                                           |
| `nitro:init`                | `nitro`                                                  | Called after Nitro is initialized, which allows registering Nitro hooks and interacting directly with Nitro.                                                                                                                                                                                 |
| `nitro:build:before`        | `nitro`                                                  | Called before building the Nitro instance.                                                                                                                                                                                                                                                   |
| `nitro:build:public-assets` | `nitro`                                                  | Called after copying public assets. Allows modifying public assets before Nitro server is built.                                                                                                                                                                                             |
| `prerender:routes`          | `ctx`                                                    | Allows extending the routes to be pre-rendered.                                                                                                                                                                                                                                              |
| `build:error`               | `error`                                                  | Called when an error occurs at build time.                                                                                                                                                                                                                                                   |
| `prepare:types`             | `options`                                                | Called before `@nuxt/cli` writes TypeScript configuration files (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) and `.nuxt/nuxt.d.ts`, allowing addition of custom references and declarations in `nuxt.d.ts`, or directly modifying the options in generated configurations |
| `listen`                    | `listenerServer, listener`                               | Called when the dev server is loading.                                                                                                                                                                                                                                                       |
| `schema:extend`             | `schemas`                                                | Allows extending default schemas.                                                                                                                                                                                                                                                            |
| `schema:resolved`           | `schema`                                                 | Allows extending resolved schema.                                                                                                                                                                                                                                                            |
| `schema:beforeWrite`        | `schema`                                                 | Called before writing the given schema.                                                                                                                                                                                                                                                      |
| `schema:written`            | -                                                        | Called after the schema is written.                                                                                                                                                                                                                                                          |
| `vite:extend`               | `viteBuildContext`                                       | Allows extending Vite default context.                                                                                                                                                                                                                                                       |
| `vite:extendConfig`         | `viteInlineConfig, env`                                  | Allows extending Vite default config.                                                                                                                                                                                                                                                        |
| `vite:configResolved`       | `viteInlineConfig, env`                                  | Allows reading the resolved Vite config.                                                                                                                                                                                                                                                     |
| `vite:serverCreated`        | `viteServer, env`                                        | Called when the Vite server is created.                                                                                                                                                                                                                                                      |
| `vite:compiled`             | -                                                        | Called after Vite server is compiled.                                                                                                                                                                                                                                                        |
| `webpack:config`            | `webpackConfigs`                                         | Called before configuring the webpack compiler.                                                                                                                                                                                                                                              |
| `webpack:configResolved`    | `webpackConfigs`                                         | Allows reading the resolved webpack config.                                                                                                                                                                                                                                                  |
| `webpack:compile`           | `options`                                                | Called right before compilation.                                                                                                                                                                                                                                                             |
| `webpack:compiled`          | `options`                                                | Called after resources are loaded.                                                                                                                                                                                                                                                           |
| `webpack:change`            | `shortPath`                                              | Called on `change` on WebpackBar.                                                                                                                                                                                                                                                            |
| `webpack:error`             | -                                                        | Called on `done` if has errors on WebpackBar.                                                                                                                                                                                                                                                |
| `webpack:done`              | -                                                        | Called on `allDone` on WebpackBar.                                                                                                                                                                                                                                                           |
| `webpack:progress`          | `statesArray`                                            | Called on `progress` on WebpackBar.                                                                                                                                                                                                                                                          |

## Nitro App Hooks (runtime, server-side)

See [Nitro](https://nitro.build/guide/plugins#available-hooks){rel="nofollow"} for all available hooks.

| Hook              | Arguments                                  | Description                                 | Types                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ----------------- | ------------------------------------------ | ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dev:ssr-logs`    | `{ path, logs }`                           | Server                                      | Called at the end of a request cycle with an array of server-side logs.                                                                                                                                                                                                                                                                                                                                                                                 |
| `render:response` | `response, { event }`                      | Called before sending the response.         | [response](https://github.com/nuxt/nuxt/blob/71ef8bd3ff207fd51c2ca18d5a8c7140476780c7/packages/nuxt/src/core/runtime/nitro/renderer.ts#L24){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                         |
| `render:html`     | `html, { event }`                          | Called before constructing the HTML.        | [html](https://github.com/nuxt/nuxt/blob/71ef8bd3ff207fd51c2ca18d5a8c7140476780c7/packages/nuxt/src/core/runtime/nitro/renderer.ts#L15){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                             |
| `render:island`   | `islandResponse, { event, islandContext }` | Called before constructing the island HTML. | [islandResponse](https://github.com/nuxt/nuxt/blob/e50cabfed1984c341af0d0c056a325a8aec26980/packages/nuxt/src/core/runtime/nitro/renderer.ts#L28){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}, [islandContext](https://github.com/nuxt/nuxt/blob/e50cabfed1984c341af0d0c056a325a8aec26980/packages/nuxt/src/core/runtime/nitro/renderer.ts#L38){rel="nofollow"} |
| `close`           | -                                          | Called when Nitro is closed.                | -                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `error`           | `error, { event? }`                        | Called when an error occurs.                | [error](https://github.com/nitrojs/nitro/blob/d20ffcbd16fc4003b774445e1a01e698c2bb078a/src/types/runtime/nitro.ts#L48){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                                              |
| `request`         | `event`                                    | Called when a request is received.          | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                                                                                                                                                                                      |
| `beforeResponse`  | `event, { body }`                          | Called before sending the response.         | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}, unknown                                                                                                                                                                                                                                                                                                                             |
| `afterResponse`   | `event, { body }`                          | Called after sending the response.          | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}, unknown                                                                                                                                                                                                                                                                                                                             |


# Import meta

## The `import.meta` object

With ES modules you can obtain some metadata from the code that imports or compiles your ES-module.
This is done through `import.meta`, which is an object that provides your code with this information.
Throughout the Nuxt documentation you may see snippets that use this already to figure out whether the
code is currently running on the client or server side.

::read-more
---
to: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta
---
Read more about `import.meta`.
::

## Runtime (App) Properties

These values are statically injected and can be used for tree-shaking your runtime code.

| Property                | Type    | Description                                                                  |
| ----------------------- | ------- | ---------------------------------------------------------------------------- |
| `import.meta.client`    | boolean | True when evaluated on the client side.                                      |
| `import.meta.browser`   | boolean | True when evaluated on the client side.                                      |
| `import.meta.server`    | boolean | True when evaluated on the server side.                                      |
| `import.meta.nitro`     | boolean | True when evaluated on the server side.                                      |
| `import.meta.dev`       | boolean | True when running the Nuxt dev server.                                       |
| `import.meta.test`      | boolean | True when running in a test context.                                         |
| `import.meta.prerender` | boolean | True when rendering HTML on the server in the prerender stage of your build. |

## Builder Properties

These values are available both in modules and in your `nuxt.config`.

| Property          | Type   | Description                           |
| ----------------- | ------ | ------------------------------------- |
| `import.meta.env` | object | Equals `process.env`                  |
| `import.meta.url` | string | Resolvable path for the current file. |

## Examples

### Using `import.meta.url` to resolve files within modules

```ts [modules/my-module/index.ts]
import { createResolver } from 'nuxt/kit'

// Resolve relative from the current file
const resolver = createResolver(import.meta.url)

export default defineNuxtModule({
  meta: { name: 'myModule' },
  setup() {
    addComponent({
      name: 'MyModuleComponent',
      // Resolves to '/modules/my-module/components/MyModuleComponent.vue'
      filePath: resolver.resolve('./components/MyModuleComponent.vue')
    })
  }
})
```


# Nuxt Configuration

## alias

You can improve your DX by defining additional aliases to access custom directories within your JavaScript and CSS.

- **Type**: `object`
- **Default**

```json
{
  "~": "/<srcDir>",
  "@": "/<srcDir>",
  "~~": "/<rootDir>",
  "@@": "/<rootDir>",
  "#shared": "/<rootDir>/shared",
  "assets": "/<srcDir>/assets",
  "public": "/<rootDir>/public",
  "#build": "/<rootDir>/.nuxt",
  "#internal/nuxt/paths": "/<rootDir>/.nuxt/paths.mjs"
}
```

::callout
**Note**: Within a webpack context (image sources, CSS - but not JavaScript) you *must* access
your alias by prefixing it with `~`.
::

::callout
**Note**: These aliases will be automatically added to the generated TypeScript configurations (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) so you can get full type support and path auto-complete. In case you need to extend options provided by the generated configurations further, make sure to add them here or within the `typescript.tsConfig` property in `nuxt.config`.
::

**Example**:

```js
import { fileURLToPath } from "node:url";

export default defineNuxtConfig({
  alias: {
    'images': fileURLToPath(new URL('./assets/images', import.meta.url)),
    'style': fileURLToPath(new URL('./assets/style', import.meta.url)),
    'data': fileURLToPath(new URL('./assets/other/data', import.meta.url))
  }
})
```

```html
<template>
  <img src="~images/main-bg.jpg">
</template>

<script>
import data from 'data/test.json'
</script>

<style>
// Uncomment the below
//@import '~style/variables.scss';
//@import '~style/utils.scss';
//@import '~style/base.scss';
body {
  background-image: url('~images/main-bg.jpg');
}
</style>
```

## analyzeDir

The directory where Nuxt will store the generated files when running `nuxt analyze`.

If a relative path is specified, it will be relative to your `rootDir`.

- **Type**: `string`
- **Default:** `"/<rootDir>/.nuxt/analyze"`

## app

Nuxt App configuration.

### `baseURL`

The base path of your Nuxt application.

For example:

- **Type**: `string`
- **Default:** `"/"`

**Example**:

```ts
export default defineNuxtConfig({
  app: {
    baseURL: '/prefix/'
  }
})
```

This can also be set at runtime by setting the NUXT\_APP\_BASE\_URL environment variable.

**Example**:

```bash
NUXT_APP_BASE_URL=/prefix/ node .output/server/index.mjs
```

### `buildAssetsDir`

The folder name for the built site assets, relative to `baseURL` (or `cdnURL` if set). This is set at build time and should not be customized at runtime.

- **Type**: `string`
- **Default:** `"/_nuxt/"`

### `cdnURL`

An absolute URL to serve the public folder from (production-only).

For example:

- **Type**: `string`
- **Default:** `""`

**Example**:

```ts
export default defineNuxtConfig({
  app: {
    cdnURL: 'https://mycdn.org/'
  }
})
```

This can be set to a different value at runtime by setting the `NUXT_APP_CDN_URL` environment variable.

**Example**:

```bash
NUXT_APP_CDN_URL=https://mycdn.org/ node .output/server/index.mjs
```

### `head`

Set default configuration for `<head>` on every page.

- **Type**: `object`
- **Default**

```json
{
  "meta": [
    {
      "name": "viewport",
      "content": "width=device-width, initial-scale=1"
    },
    {
      "charset": "utf-8"
    }
  ],
  "link": [],
  "style": [],
  "script": [],
  "noscript": []
}
```

**Example**:

```js
app: {
  head: {
    meta: [
      // <meta name="viewport" content="width=device-width, initial-scale=1">
      { name: 'viewport', content: 'width=device-width, initial-scale=1' }
    ],
    script: [
      // <script src="https://myawesome-lib.js"></script>
      { src: 'https://awesome-lib.js' }
    ],
    link: [
      // <link rel="stylesheet" href="https://myawesome-lib.css">
      { rel: 'stylesheet', href: 'https://awesome-lib.css' }
    ],
    // please note that this is an area that is likely to change
    style: [
      // <style>:root { color: red }</style>
      { textContent: ':root { color: red }' }
    ],
    noscript: [
      // <noscript>JavaScript is required</noscript>
      { textContent: 'JavaScript is required' }
    ]
  }
}
```

### `keepalive`

Default values for KeepAlive configuration between pages.

This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Vue KeepAlive](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"}

### `layoutTransition`

Default values for layout transitions.

This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Vue Transition docs](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}

### `pageTransition`

Default values for page transitions.

This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Vue Transition docs](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}

### `rootAttrs`

Customize Nuxt root element id.

- **Type**: `object`
- **Default**

```json
{
  "id": "__nuxt"
}
```

### `rootId`

Customize Nuxt root element id.

- **Type**: `string`
- **Default:** `"__nuxt"`

### `rootTag`

Customize Nuxt root element tag.

- **Type**: `string`
- **Default:** `"div"`

### `spaLoaderAttrs`

Customize Nuxt SPA loading template element attributes.

- **Type**: `object`
- **Default:**

```json
{
"id": "__nuxt-loader"
}
```

#### `id`

- **Type**: `string`
- **Default:** `"__nuxt-loader"`

### `spaLoaderTag`

Customize Nuxt SpaLoader element tag.

- **Type**: `string`
- **Default:** `"div"`

### `teleportAttrs`

Customize Nuxt Teleport element attributes.

- **Type**: `object`
- **Default**

```json
{
  "id": "teleports"
}
```

### `teleportId`

Customize Nuxt Teleport element id.

- **Type**: `string`
- **Default:** `"teleports"`

### `teleportTag`

Customize Nuxt Teleport element tag.

- **Type**: `string`
- **Default:** `"div"`

### `viewTransition`

Default values for view transitions.

This only has an effect when **experimental** support for View Transitions is [enabled in your nuxt.config file](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental).
This can be overridden with `definePageMeta` on an individual page.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt View Transition API docs](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental){rel="nofollow"}

## appConfig

Additional app configuration

For programmatic usage and type support, you can directly provide app config with this option. It will be merged with `app.config` file as default value.

### `nuxt`

## appId

For multi-app projects, the unique id of the Nuxt application.

Defaults to `nuxt-app`.

- **Type**: `string`
- **Default:** `"nuxt-app"`

## build

Shared build configuration.

### `analyze`

Nuxt allows visualizing your bundles and how to optimize them.

Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack-contrib/webpack-bundle-analyzer#options-for-plugin){rel="nofollow"} or [for vite](https://github.com/btd/rollup-plugin-visualizer#options){rel="nofollow"}.

- **Type**: `object`
- **Default**

```json
{
  "template": "treemap",
  "projectRoot": "/<rootDir>",
  "filename": "/<rootDir>/.nuxt/analyze/{name}.html"
}
```

**Example**:

```js
analyze: {
  analyzerMode: 'static'
}
```

### `templates`

It is recommended to use `addTemplate` from `@nuxt/kit` instead of this option.

- **Type**: `array`

**Example**:

```js
templates: [
  {
    src: '~/modules/support/plugin.js', // `src` can be absolute or relative
    dst: 'support.js', // `dst` is relative to project `.nuxt` dir
  }
]
```

### `transpile`

If you want to transpile specific dependencies with Babel, you can add them here. Each item in transpile can be a package name, a function, a string or regex object matching the dependency's file name.

You can also use a function to conditionally transpile. The function will receive an object ({ isDev, isServer, isClient, isModern, isLegacy }).

- **Type**: `array`

**Example**:

```js
transpile: [({ isLegacy }) => isLegacy && 'ky']
```

## buildDir

Define the directory where your built Nuxt files will be placed.

Many tools assume that `.nuxt` is a hidden directory (because it starts with a `.`). If that is a problem, you can use this option to prevent that.

- **Type**: `string`
- **Default:** `"/<rootDir>/.nuxt"`

**Example**:

```js
export default {
  buildDir: 'nuxt-build'
}
```

## buildId

A unique identifier matching the build. This may contain the hash of the current state of the project.

- **Type**: `string`
- **Default:** `"4a2e2d30-418f-41df-8e58-ed5df06de7fd"`

## builder

The builder to use for bundling the Vue part of your application.

- **Type**: `string`
- **Default:** `"@nuxt/vite-builder"`

## compatibilityDate

Specify a compatibility date for your app.

This is used to control the behavior of presets in Nitro, Nuxt Image and other modules that may change behavior without a major version bump.
We plan to improve the tooling around this feature in the future.

## components

Configure Nuxt component auto-registration.

Any components in the directories configured here can be used throughout your pages, layouts (and other components) without needing to explicitly import them.

- **Type**: `object`
- **Default**

```json
{
  "dirs": [
    {
      "path": "~/components/global",
      "global": true
    },
    "~/components"
  ]
}
```

**See**: [`app/components/` directory documentation](https://nuxt.com/docs/guide/directory-structure/app/components){rel="nofollow"}

## css

You can define the CSS files/modules/libraries you want to set globally (included in every page).

Nuxt will automatically guess the file type by its extension and use the appropriate pre-processor. You will still need to install the required loader if you need to use them.

- **Type**: `array`

**Example**:

```js
css: [
  // Load a Node.js module directly (here it's a Sass file).
  'bulma',
  // CSS file in the project
  '~/assets/css/main.css',
  // SCSS file in the project
  '~/assets/css/main.scss'
]
```

## debug

Set to `true` to enable debug mode.

At the moment, it prints out hook names and timings on the server, and logs hook arguments as well in the browser.
You can also set this to an object to enable specific debug options.

- **Type**: `boolean`
- **Default:** `false`

## dev

Whether Nuxt is running in development mode.

Normally, you should not need to set this.

- **Type**: `boolean`
- **Default:** `false`

## devServer

### `cors`

Set CORS options for the dev server

#### `origin`

- **Type**: `array`
- **Default**

```json
[
  {}
]
```

### `host`

Dev server listening host

### `https`

Whether to enable HTTPS.

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
export default defineNuxtConfig({
  devServer: {
    https: {
      key: './server.key',
      cert: './server.crt'
    }
  }
})
```

### `loadingTemplate`

Template to show a loading screen

- **Type**: `function`

### `port`

Dev server listening port

- **Type**: `number`
- **Default:** `3000`

### `url`

Listening dev server URL.

This should not be set directly as it will always be overridden by the dev server with the full URL (for module and internal use).

- **Type**: `string`
- **Default:** `"http://localhost:3000"`

## devServerHandlers

Nitro development-only server handlers.

- **Type**: `array`

**See**: [Nitro server routes documentation](https://nitro.build/guide/routing){rel="nofollow"}

## devtools

Enable Nuxt DevTools for development.

Breaking changes for devtools might not reflect on the version of Nuxt.

**See**: [Nuxt DevTools](https://devtools.nuxt.com/){rel="nofollow"} for more information.

## dir

Customize default directory structure used by Nuxt.

It is better to stick with defaults unless needed.

### `app`

- **Type**: `string`
- **Default:** `"app"`

### `assets`

The assets directory (aliased as `~assets` in your build).

- **Type**: `string`
- **Default:** `"app/assets"`

### `layouts`

The layouts directory, each file of which will be auto-registered as a Nuxt layout.

- **Type**: `string`
- **Default:** `"app/layouts"`

### `middleware`

The middleware directory, each file of which will be auto-registered as a Nuxt middleware.

- **Type**: `string`
- **Default:** `"app/middleware"`

### `modules`

The modules directory, each file in which will be auto-registered as a Nuxt module.

- **Type**: `string`
- **Default:** `"modules"`

### `pages`

The directory which will be processed to auto-generate your application page routes.

- **Type**: `string`
- **Default:** `"app/pages"`

### `plugins`

The plugins directory, each file of which will be auto-registered as a Nuxt plugin.

- **Type**: `string`
- **Default:** `"app/plugins"`

### `public`

The directory containing your static files, which will be directly accessible via the Nuxt server and copied across into your `dist` folder when your app is generated.

- **Type**: `string`
- **Default:** `"public"`

### `shared`

The shared directory. This directory is shared between the app and the server.

- **Type**: `string`
- **Default:** `"shared"`

## esbuild

### `options`

Configure shared esbuild options used within Nuxt and passed to other builders, such as Vite or webpack.

#### `jsxFactory`

- **Type**: `string`
- **Default:** `"h"`

#### `jsxFragment`

- **Type**: `string`
- **Default:** `"Fragment"`

#### `target`

- **Type**: `string`
- **Default:** `"esnext"`

#### `tsconfigRaw`

- **Type**: `object`

## experimental

### `alwaysRunFetchOnKeyChange`

Whether to run `useFetch` when the key changes, even if it is set to `immediate: false` and it has not been triggered yet.

`useFetch` and `useAsyncData` will always run when the key changes if `immediate: true` or if it has been already triggered.

- **Type**: `boolean`
- **Default:** `true`

### `appManifest`

Use app manifests to respect route rules on client-side.

- **Type**: `boolean`
- **Default:** `true`

### `asyncContext`

Enable native async context to be accessible for nested composables

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt PR #20918](https://github.com/nuxt/nuxt/pull/20918){rel="nofollow"}

### `asyncEntry`

Set to true to generate an async entry point for the Vue bundle (for module federation support).

- **Type**: `boolean`
- **Default:** `false`

### `browserDevtoolsTiming`

Enable timings for Nuxt application hooks in the performance panel of Chromium-based browsers.

This feature adds performance markers for Nuxt hooks, allowing you to track their execution time in the browser's Performance tab. This is particularly useful for debugging performance issues.

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Enable performance markers for Nuxt hooks in browser devtools
    browserDevtoolsTiming: true
  }
})
```

**See**: [PR #29922](https://github.com/nuxt/nuxt/pull/29922){rel="nofollow"}

**See**: [Chrome DevTools Performance API](https://developer.chrome.com/docs/devtools/performance/extension#tracks){rel="nofollow"}

### `buildCache`

Cache Nuxt/Nitro build artifacts based on a hash of the configuration and source files.

This only works for source files within `srcDir` and `serverDir` for the Vue/Nitro parts of your app.

- **Type**: `boolean`
- **Default:** `false`

### `checkOutdatedBuildInterval`

Set the time interval (in ms) to check for new builds. Disabled when `experimental.appManifest` is `false`.

Set to `false` to disable.

- **Type**: `number`
- **Default:** `3600000`

### `clientFallback`

Whether to enable the experimental `<NuxtClientFallback>` component for rendering content on the client if there's an error in SSR.

- **Type**: `boolean`
- **Default:** `false`

### `clientNodeCompat`

Automatically polyfill Node.js imports in the client build using `unenv`.

- **Type**: `boolean`
- **Default:** `false`

**See**: [unenv](https://github.com/unjs/unenv){rel="nofollow"}

**Note:** To make globals like `Buffer` work in the browser, you need to manually inject them.

```ts
import { Buffer } from 'node:buffer'

globalThis.Buffer = globalThis.Buffer || Buffer
```

### `compileTemplate`

Whether to use `lodash.template` to compile Nuxt templates.

This flag will be removed with the release of v4 and exists only for advance testing within Nuxt v3.12+ or in [the nightly release channel](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

- **Type**: `boolean`
- **Default:** `true`

### `componentIslands`

Experimental component islands support with `<NuxtIsland>` and `.island.vue` files.

By default it is set to 'auto', which means it will be enabled only when there are islands, server components or server pages in your app.

- **Type**: `string`
- **Default:** `"auto"`

### `configSchema`

Config schema support

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Issue #15592](https://github.com/nuxt/nuxt/issues/15592){rel="nofollow"}

### `cookieStore`

Enables CookieStore support to listen for cookie updates (if supported by the browser) and refresh `useCookie` ref values.

- **Type**: `boolean`
- **Default:** `true`

**See**: [CookieStore](https://developer.mozilla.org/en-US/docs/Web/API/CookieStore){rel="nofollow"}

### `crossOriginPrefetch`

Enable cross-origin prefetch using the Speculation Rules API.

- **Type**: `boolean`
- **Default:** `false`

### `debugModuleMutation`

Record mutations to `nuxt.options` in module context, helping to debug configuration changes made by modules during the Nuxt initialization phase.

When enabled, Nuxt will track which modules modify configuration options, making it easier to trace unexpected configuration changes.

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Enable tracking of config mutations by modules
    debugModuleMutation: true
  }
})
```

**See**: [PR #30555](https://github.com/nuxt/nuxt/pull/30555){rel="nofollow"}

### `decorators`

Enable the use of experimental decorators in Nuxt and Nitro.

- **Type**: `boolean`
- **Default:** `false`

**See**: <https://github.com/tc39/proposal-decorators>{rel="nofollow"}

### `defaults`

This allows specifying the default options for core Nuxt components and composables.

These options will likely be moved elsewhere in the future, such as into `app.config` or into the `app/` directory.

#### `nuxtLink`

##### `componentName`

- **Type**: `string`
- **Default:** `"NuxtLink"`

##### `prefetch`

- **Type**: `boolean`
- **Default:** `true`

##### `prefetchOn`

###### `visibility`

- **Type**: `boolean`
- **Default:** `true`

#### `useAsyncData`

Options that apply to `useAsyncData` (and also therefore `useFetch`)

##### `deep`

- **Type**: `boolean`
- **Default:** `true`

##### `errorValue`

- **Type**: `string`
- **Default:** `"null"`

##### `value`

- **Type**: `string`
- **Default:** `"null"`

#### `useFetch`

### `emitRouteChunkError`

Emit `app:chunkError` hook when there is an error loading vite/webpack chunks.

By default, Nuxt will also perform a reload of the new route when a chunk fails to load when navigating to a new route (`automatic`).
Setting `automatic-immediate` will lead Nuxt to perform a reload of the current route right when a chunk fails to load (instead of waiting for navigation).
You can disable automatic handling by setting this to `false`, or handle chunk errors manually by setting it to `manual`.

- **Type**: `string`
- **Default:** `"automatic"`

**See**: [Nuxt PR #19038](https://github.com/nuxt/nuxt/pull/19038){rel="nofollow"}

### `enforceModuleCompatibility`

Whether Nuxt should stop if a Nuxt module is incompatible.

- **Type**: `boolean`
- **Default:** `false`

### `externalVue`

Externalize `vue`, `@vue/*` and `vue-router` when building.

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Issue #13632](https://github.com/nuxt/nuxt/issues/13632){rel="nofollow"}

### `extraPageMetaExtractionKeys`

Configure additional keys to extract from the page metadata when using `scanPageMeta`.

This allows modules to access additional metadata from the page metadata. It's recommended to augment the NuxtPage types with your keys.

- **Type**: `array`

### `granularCachedData`

Whether to call and use the result from `getCachedData` on manual refresh for `useAsyncData` and `useFetch`.

- **Type**: `boolean`
- **Default:** `false`

### `headNext`

Use new experimental head optimisations:

- Add the capo.js head plugin in order to render tags in of the head in a more performant way. - Uses the hash hydration plugin to reduce initial hydration
- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Discussion #22632](https://github.com/nuxt/nuxt/discussions/22632){rel="nofollow"}

### `inlineRouteRules`

Allow defining `routeRules` directly within your `~/pages` directory using `defineRouteRules`.

Rules are converted (based on the path) and applied for server requests. For example, a rule defined in `~/pages/foo/bar.vue` will be applied to `/foo/bar` requests. A rule in `~/pages/foo/[id].vue` will be applied to `/foo/**` requests.
For more control, such as if you are using a custom `path` or `alias` set in the page's `definePageMeta`, you should set `routeRules` directly within your `nuxt.config`.

- **Type**: `boolean`
- **Default:** `false`

### `lazyHydration`

Enable automatic configuration of hydration strategies for `<Lazy>` components.

This feature intelligently determines when to hydrate lazy components based on visibility, idle time, or other triggers, improving performance by deferring hydration of components until they're needed.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    lazyHydration: true // Enable smart hydration strategies for Lazy components
  }
})

// In your Vue components
<template>
  <Lazy>
    <ExpensiveComponent />
  </Lazy>
</template>
```

**See**: [PR #26468](https://github.com/nuxt/nuxt/pull/26468){rel="nofollow"}

### `localLayerAliases`

Resolve `~`, `~~`, `@` and `@@` aliases located within layers with respect to their layer source and root directories.

- **Type**: `boolean`
- **Default:** `true`

### `navigationRepaint`

Wait for a single animation frame before navigation, which gives an opportunity for the browser to repaint, acknowledging user interaction.

It can reduce INP when navigating on prerendered routes.

- **Type**: `boolean`
- **Default:** `true`

### `noVueServer`

Disable vue server renderer endpoint within nitro.

- **Type**: `boolean`
- **Default:** `false`

### `normalizeComponentNames`

Ensure that auto-generated Vue component names match the full component name you would use to auto-import the component.

- **Type**: `boolean`
- **Default:** `false`

### `parseErrorData`

Whether to parse `error.data` when rendering a server error page.

- **Type**: `boolean`
- **Default:** `false`

### `payloadExtraction`

When this option is enabled (by default) payload of pages that are prerendered are extracted

- **Type**: `boolean`
- **Default:** `true`

### `pendingWhenIdle`

For `useAsyncData` and `useFetch`, whether `pending` should be `true` when data has not yet started to be fetched.

- **Type**: `boolean`
- **Default:** `true`

### `polyfillVueUseHead`

Whether or not to add a compatibility layer for modules, plugins or user code relying on the old `@vueuse/head` API.

This is disabled to reduce the client-side bundle by \~0.5kb.

- **Type**: `boolean`
- **Default:** `false`

### `purgeCachedData`

Whether to clean up Nuxt static and asyncData caches on route navigation.

Nuxt will automatically purge cached data from `useAsyncData` and `nuxtApp.static.data`. This helps prevent memory leaks and ensures fresh data is loaded when needed, but it is possible to disable it.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Disable automatic cache cleanup (default is true)
    purgeCachedData: false
  }
})
```

**See**: [PR #31379](https://github.com/nuxt/nuxt/pull/31379){rel="nofollow"}

### `relativeWatchPaths`

Whether to provide relative paths in the `builder:watch` hook.

This flag will be removed with the release of v4 and exists only for advance testing within Nuxt v3.12+ or in [the nightly release channel](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

- **Type**: `boolean`
- **Default:** `true`

### `renderJsonPayloads`

Render JSON payloads with support for revivifying complex types.

- **Type**: `boolean`
- **Default:** `true`

### `resetAsyncDataToUndefined`

Whether `clear` and `clearNuxtData` should reset async data to its *default* value or update it to `null`/`undefined`.

- **Type**: `boolean`
- **Default:** `true`

### `respectNoSSRHeader`

Allow disabling Nuxt SSR responses by setting the `x-nuxt-no-ssr` header.

- **Type**: `boolean`
- **Default:** `false`

### `restoreState`

Whether to restore Nuxt app state from `sessionStorage` when reloading the page after a chunk error or manual `reloadNuxtApp()` call.

To avoid hydration errors, it will be applied only after the Vue app has been mounted, meaning there may be a flicker on initial load.
Consider carefully before enabling this as it can cause unexpected behavior, and consider providing explicit keys to `useState` as auto-generated keys may not match across builds.

- **Type**: `boolean`
- **Default:** `false`

### `scanPageMeta`

Allow exposing some route metadata defined in `definePageMeta` at build-time to modules (alias, name, path, redirect, props, middleware).

This only works with static or strings/arrays rather than variables or conditional assignment.

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Issues #24770](https://github.com/nuxt/nuxt/issues/24770){rel="nofollow"}

### `sharedPrerenderData`

Automatically share payload *data* between pages that are prerendered. This can result in a significant performance improvement when prerendering sites that use `useAsyncData` or `useFetch` and fetch the same data in different pages.

It is particularly important when enabling this feature to make sure that any unique key of your data is always resolvable to the same data. For example, if you are using `useAsyncData` to fetch data related to a particular page, you should provide a key that uniquely matches that data. (`useFetch` should do this automatically for you.)

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
// This would be unsafe in a dynamic page (e.g. `[slug].vue`) because the route slug makes a difference
// to the data fetched, but Nuxt can't know that because it's not reflected in the key.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Instead, you should use a key that uniquely identifies the data fetched.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

### `spaLoadingTemplateLocation`

Keep showing the spa-loading-template until suspense\:resolve

- **Type**: `string`
- **Default:** `"within"`

**See**: [Nuxt Issues #24770](https://github.com/nuxt/nuxt/issues/21721){rel="nofollow"}

### `templateImportResolution`

Disable resolving imports into Nuxt templates from the path of the module that added the template.

By default, Nuxt attempts to resolve imports in templates relative to the module that added them. Setting this to `false` disables this behavior, which may be useful if you're experiencing resolution conflicts in certain environments.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Disable template import resolution from module path
    templateImportResolution: false
  }
})
```

**See**: [PR #31175](https://github.com/nuxt/nuxt/pull/31175){rel="nofollow"}

### `templateRouteInjection`

By default the route object returned by the auto-imported `useRoute()` composable is kept in sync with the current page in view in `<NuxtPage>`. This is not true for `vue-router`'s exported `useRoute` or for the default `$route` object available in your Vue templates.

By enabling this option a mixin will be injected to keep the `$route` template object in sync with Nuxt's managed `useRoute()`.

- **Type**: `boolean`
- **Default:** `true`

### `templateUtils`

Whether to provide a legacy `templateUtils` object (with `serialize`, `importName` and `importSources`) when compiling Nuxt templates.

This flag will be removed with the release of v4 and exists only for advance testing within Nuxt v3.12+ or in [the nightly release channel](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

- **Type**: `boolean`
- **Default:** `true`

### `treeshakeClientOnly`

Tree shakes contents of client-only components from server bundle.

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt PR #5750](https://github.com/nuxt/framework/pull/5750){rel="nofollow"}

### `typedPages`

Enable the new experimental typed router using [unplugin-vue-router](https://github.com/posva/unplugin-vue-router){rel="nofollow"}.

- **Type**: `boolean`
- **Default:** `false`

### `viewTransition`

Enable View Transition API integration with client-side router.

- **Type**: `boolean`
- **Default:** `false`

**See**: [View Transitions API](https://developer.chrome.com/docs/web-platform/view-transitions){rel="nofollow"}

### `watcher`

Set an alternative watcher that will be used as the watching service for Nuxt.

Nuxt uses 'chokidar-granular' if your source directory is the same as your root directory . This will ignore top-level directories (like `node_modules` and `.git`) that are excluded from watching.
You can set this instead to `parcel` to use `@parcel/watcher`, which may improve performance in large projects or on Windows platforms.
You can also set this to `chokidar` to watch all files in your source directory.

- **Type**: `string`
- **Default:** `"chokidar"`

**See**: [chokidar](https://github.com/paulmillr/chokidar){rel="nofollow"}

**See**: [@parcel/watcher](https://github.com/parcel-bundler/watcher){rel="nofollow"}

### `writeEarlyHints`

Write early hints when using node server.

- **Type**: `boolean`
- **Default:** `false`

::callout
**Note**: nginx does not support 103 Early hints in the current version.
::

## extends

Extend project from multiple local or remote sources.

Value should be either a string or array of strings pointing to source directories or config path relative to current config.
You can use `github:`, `gh:` `gitlab:` or `bitbucket:`

**See**: [`c12` docs on extending config layers](https://github.com/unjs/c12#extending-config-layer-from-remote-sources){rel="nofollow"}

**See**: [`giget` documentation](https://github.com/unjs/giget){rel="nofollow"}

## extensions

The extensions that should be resolved by the Nuxt resolver.

- **Type**: `array`
- **Default**

```json
[
  ".js",
  ".jsx",
  ".mjs",
  ".ts",
  ".tsx",
  ".vue"
]
```

## features

Some features of Nuxt are available on an opt-in basis, or can be disabled based on your needs.

### `devLogs`

Stream server logs to the client as you are developing. These logs can be handled in the `dev:ssr-logs` hook.

If set to `silent`, the logs will not be printed to the browser console.

- **Type**: `boolean`
- **Default:** `false`

### `inlineStyles`

Inline styles when rendering HTML (currently vite only).

You can also pass a function that receives the path of a Vue component and returns a boolean indicating whether to inline the styles for that component.

- **Type**: `boolean`
- **Default:** `(id) => id.includes('.vue')`

### `noScripts`

Turn off rendering of Nuxt scripts and JS resource hints. You can also disable scripts more granularly within `routeRules`.

If set to 'production' or `true`, JS will be disabled in production mode only.

- **Type**: `boolean`
- **Default:** `false`

## future

`future` is for early opting-in to new features that will become default in a future (possibly major) version of the framework.

### `compatibilityVersion`

This is used for enabling early access to Nuxt features or flags.

It is not configurable yet in Nuxt 4, but once we begin merging breaking changes for v5, it will be possible to enable it.

### `multiApp`

This enables early access to the experimental multi-app support.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt Issue #21635](https://github.com/nuxt/nuxt/issues/21635){rel="nofollow"}

### `typescriptBundlerResolution`

This enables 'Bundler' module resolution mode for TypeScript, which is the recommended setting for frameworks like Nuxt and Vite.

It improves type support when using modern libraries with `exports`.
You can set it to false to use the legacy 'Node' mode, which is the default for TypeScript.

- **Type**: `boolean`
- **Default:** `true`

**See**: [TypeScript PR implementing `bundler` module resolution](https://github.com/microsoft/TypeScript/pull/51669){rel="nofollow"}

## hooks

Hooks are listeners to Nuxt events that are typically used in modules, but are also available in `nuxt.config`.

Internally, hooks follow a naming pattern using colons (e.g., build\:done).
For ease of configuration, you can also structure them as an hierarchical object in `nuxt.config` (as below).

**Example**:

```js
import fs from 'node:fs'
import path from 'node:path'
export default {
  hooks: {
    build: {
      done(builder) {
        const extraFilePath = path.join(
          builder.nuxt.options.buildDir,
          'extra-file'
        )
        fs.writeFileSync(extraFilePath, 'Something extra')
      }
    }
  }
}
```

## ignore

More customizable than `ignorePrefix`: all files matching glob patterns specified inside the `ignore` array will be ignored in building.

- **Type**: `array`
- **Default**

```json
[
  "**/*.stories.{js,cts,mts,ts,jsx,tsx}",
  "**/*.{spec,test}.{js,cts,mts,ts,jsx,tsx}",
  "**/*.d.{cts,mts,ts}",
  "**/.{pnpm-store,vercel,netlify,output,git,cache,data}",
  "**/*.sock",
  ".nuxt/analyze",
  ".nuxt",
  "**/-*.*"
]
```

## ignoreOptions

Pass options directly to `node-ignore` (which is used by Nuxt to ignore files).

**See**: [node-ignore](https://github.com/kaelzhang/node-ignore){rel="nofollow"}

**Example**:

```js
ignoreOptions: {
  ignorecase: false
}
```

## ignorePrefix

Any file in `app/pages/`, `app/layouts/`, `app/middleware/`, and `public/` directories will be ignored during the build process if its filename starts with the prefix specified by `ignorePrefix`. This is intended to prevent certain files from being processed or served in the built application. By default, the `ignorePrefix` is set to '-', ignoring any files starting with '-'.

- **Type**: `string`
- **Default:** `"-"`

## imports

Configure how Nuxt auto-imports composables into your application.

**See**: [Nuxt documentation](https://nuxt.com/docs/guide/directory-structure/app/composables){rel="nofollow"}

### `dirs`

An array of custom directories that will be auto-imported. Note that this option will not override the default directories (\~/composables, \~/utils).

- **Type**: `array`

**Example**:

```js
imports: {
  // Auto-import pinia stores defined in `~/stores`
  dirs: ['stores']
}
```

### `global`

- **Type**: `boolean`
- **Default:** `false`

### `scan`

Whether to scan your `app/composables/` and `app/utils/` directories for composables to auto-import. Auto-imports registered by Nuxt or other modules, such as imports from `vue` or `nuxt`, will still be enabled.

- **Type**: `boolean`
- **Default:** `true`

## logLevel

Log level when building logs.

Defaults to 'silent' when running in CI or when a TTY is not available. This option is then used as 'silent' in Vite and 'none' in webpack

- **Type**: `string`
- **Default:** `"info"`

## modules

Modules are Nuxt extensions which can extend its core functionality and add endless integrations.

Each module is either a string (which can refer to a package, or be a path to a file), a tuple with the module as first string and the options as a second object, or an inline module function.
Nuxt tries to resolve each item in the modules array using node require path (in `node_modules`) and then will be resolved from project `srcDir` if `~` alias is used.

- **Type**: `array`

::callout
**Note**: Modules are executed sequentially so the order is important. First, the modules defined in `nuxt.config.ts` are loaded. Then, modules found in the `modules/`
directory are executed, and they load in alphabetical order.
::

**Example**:

```js
modules: [
  // Using package name
  '@nuxtjs/axios',
  // Relative to your project srcDir
  '~/modules/awesome.js',
  // Providing options
  ['@nuxtjs/google-analytics', { ua: 'X1234567' }],
  // Inline definition
  function () {}
]
```

## modulesDir

Used to set the modules directories for path resolving (for example, webpack's `resolveLoading`, `nodeExternals` and `postcss`).

The configuration path is relative to `options.rootDir` (default is current working directory).
Setting this field may be necessary if your project is organized as a yarn workspace-styled mono-repository.

- **Type**: `array`
- **Default**

```json
[
  "/<rootDir>/node_modules"
]
```

**Example**:

```js
export default {
  modulesDir: ['../../node_modules']
}
```

## nitro

Configuration for Nitro.

**See**: [Nitro configuration docs](https://nitro.build/config){rel="nofollow"}

### `routeRules`

- **Type**: `object`

### `runtimeConfig`

- **Type**: `object`
- **Default**

```json
{
  "public": {},
  "app": {
    "buildId": "4a2e2d30-418f-41df-8e58-ed5df06de7fd",
    "baseURL": "/",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  },
  "nitro": {
    "envPrefix": "NUXT_"
  }
}
```

## optimization

Build time optimization configuration.

### `asyncTransforms`

Options passed directly to the transformer from `unctx` that preserves async context after `await`.

#### `asyncFunctions`

- **Type**: `array`
- **Default**

```json
[
  "defineNuxtPlugin",
  "defineNuxtRouteMiddleware"
]
```

#### `objectDefinitions`

##### `defineNuxtComponent`

- **Type**: `array`
- **Default**

```json
[
  "asyncData",
  "setup"
]
```

##### `defineNuxtPlugin`

- **Type**: `array`
- **Default**

```json
[
  "setup"
]
```

##### `definePageMeta`

- **Type**: `array`
- **Default**

```json
[
  "middleware",
  "validate"
]
```

### `keyedComposables`

Functions to inject a key for.

As long as the number of arguments passed to the function is less than `argumentLength`, an additional magic string will be injected that can be used to deduplicate requests between server and client. You will need to take steps to handle this additional key.
The key will be unique based on the location of the function being invoked within the file.

- **Type**: `array`
- **Default**

```json
[
  {
    "name": "callOnce",
    "argumentLength": 3
  },
  {
    "name": "defineNuxtComponent",
    "argumentLength": 2
  },
  {
    "name": "useState",
    "argumentLength": 2
  },
  {
    "name": "useFetch",
    "argumentLength": 3
  },
  {
    "name": "useAsyncData",
    "argumentLength": 3
  },
  {
    "name": "useLazyAsyncData",
    "argumentLength": 3
  },
  {
    "name": "useLazyFetch",
    "argumentLength": 3
  }
]
```

### `treeShake`

Tree shake code from specific builds.

#### `composables`

Tree shake composables from the server or client builds.

**Example**:

```js
treeShake: { client: { myPackage: ['useServerOnlyComposable'] } }
```

##### `client`

- **Type**: `object`
- **Default**

```json
{
  "vue": [
    "onRenderTracked",
    "onRenderTriggered",
    "onServerPrefetch"
  ],
  "#app": [
    "definePayloadReducer",
    "definePageMeta",
    "onPrehydrate"
  ]
}
```

##### `server`

- **Type**: `object`
- **Default**

```json
{
  "vue": [
    "onMounted",
    "onUpdated",
    "onUnmounted",
    "onBeforeMount",
    "onBeforeUpdate",
    "onBeforeUnmount",
    "onRenderTracked",
    "onRenderTriggered",
    "onActivated",
    "onDeactivated"
  ],
  "#app": [
    "definePayloadReviver",
    "definePageMeta"
  ]
}
```

## pages

Whether to use the vue-router integration in Nuxt 3. If you do not provide a value it will be enabled if you have a `app/pages/` directory in your source folder.

Additionally, you can provide a glob pattern or an array of patterns to scan only certain files for pages.

**Example**:

```js
pages: {
  pattern: ['**\/*\/*.vue', '!**\/*.spec.*'],
}
```

## plugins

An array of nuxt app plugins.

Each plugin can be a string (which can be an absolute or relative path to a file). If it ends with `.client` or `.server` then it will be automatically loaded only in the appropriate context.
It can also be an object with `src` and `mode` keys.

- **Type**: `array`

::callout
**Note**: Plugins are also auto-registered from the `~/plugins` directory
and these plugins do not need to be listed in `nuxt.config` unless you
need to customize their order. All plugins are deduplicated by their src path.
::

**See**: [`app/plugins/` directory documentation](https://nuxt.com/docs/guide/directory-structure/plugins){rel="nofollow"}

**Example**:

```js
plugins: [
  '~/plugins/foo.client.js', // only in client side
  '~/plugins/bar.server.js', // only in server side
  '~/plugins/baz.js', // both client & server
  { src: '~/plugins/both-sides.js' },
  { src: '~/plugins/client-only.js', mode: 'client' }, // only on client side
  { src: '~/plugins/server-only.js', mode: 'server' } // only on server side
]
```

## postcss

### `order`

A strategy for ordering PostCSS plugins.

- **Type**: `function`

### `plugins`

Options for configuring PostCSS plugins.

**See**: [PostCSS docs](https://postcss.org/){rel="nofollow"}

#### `autoprefixer`

Plugin to parse CSS and add vendor prefixes to CSS rules.

**See**: [`autoprefixer`](https://github.com/postcss/autoprefixer){rel="nofollow"}

#### `cssnano`

- **Type**: `object`

**See**: [`cssnano` configuration options](https://cssnano.github.io/cssnano/docs/config-file/#configuration-options){rel="nofollow"}

## rootDir

Define the root directory of your application.

This property can be overwritten (for example, running `nuxt ./my-app/` will set the `rootDir` to the absolute path of `./my-app/` from the current/working directory.
It is normally not needed to configure this option.

- **Type**: `string`
- **Default:** `"/<rootDir>"`

## routeRules

Global route options applied to matching server routes.

**Experimental**: This is an experimental feature and API may change in the future.

**See**: [Nitro route rules documentation](https://nitro.build/config#routerules){rel="nofollow"}

## router

### `options`

Additional router options passed to `vue-router`. On top of the options for `vue-router`, Nuxt offers additional options to customize the router (see below).

::callout
**Note**: Only JSON serializable options should be passed by Nuxt config.
For more control, you can use an `router.options.ts` file.
::

**See**: [Vue Router documentation](https://router.vuejs.org/api/interfaces/routeroptions.html){rel="nofollow"}.

#### `hashMode`

You can enable hash history in SPA mode. In this mode, router uses a hash character (#) before the actual URL that is internally passed. When enabled, the **URL is never sent to the server** and **SSR is not supported**.

- **Type**: `boolean`
- **Default:** `false`

**Default**: false

#### `scrollBehaviorType`

Customize the scroll behavior for hash links.

- **Type**: `string`
- **Default:** `"auto"`

**Default**: 'auto'

## runtimeConfig

Runtime config allows passing dynamic config and environment variables to the Nuxt app context.

The value of this object is accessible from server only using `useRuntimeConfig`.
It mainly should hold *private* configuration which is not exposed on the frontend. This could include a reference to your API secret tokens.
Anything under `public` and `app` will be exposed to the frontend as well.
Values are automatically replaced by matching env variables at runtime, e.g. setting an environment variable `NUXT_API_KEY=my-api-key NUXT_PUBLIC_BASE_URL=/foo/` would overwrite the two values in the example below.

- **Type**: `object`
- **Default**

```json
{
  "public": {},
  "app": {
    "buildId": "4a2e2d30-418f-41df-8e58-ed5df06de7fd",
    "baseURL": "/",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  }
}
```

**Example**:

```js
export default {
 runtimeConfig: {
    apiKey: '', // Default to an empty string, automatically set at runtime using process.env.NUXT_API_KEY
    public: {
       baseURL: '' // Exposed to the frontend as well.
    }
  }
}
```

## serverDir

Define the server directory of your Nuxt application, where Nitro routes, middleware and plugins are kept.

If a relative path is specified, it will be relative to your `rootDir`.

- **Type**: `string`
- **Default:** `"/<srcDir>/server"`

## serverHandlers

Nitro server handlers.

Each handler accepts the following options:

- handler: The path to the file defining the handler. - route: The route under which the handler is available. This follows the conventions of [rou3](https://github.com/h3js/rou3){rel="nofollow"}. - method: The HTTP method of requests that should be handled. - middleware: Specifies whether it is a middleware handler. - lazy: Specifies whether to use lazy loading to import the handler.
- **Type**: `array`

**See**: [`server/` directory documentation](https://nuxt.com/docs/guide/directory-structure/server){rel="nofollow"}

::callout
**Note**: Files from `server/api`, `server/middleware` and `server/routes` will be automatically registered by Nuxt.
::

**Example**:

```js
serverHandlers: [
  { route: '/path/foo/**:name', handler: '~/server/foohandler.ts' }
]
```

## sourcemap

Configures whether and how sourcemaps are generated for server and/or client bundles.

If set to a single boolean, that value applies to both server and client. Additionally, the `'hidden'` option is also available for both server and client.
Available options for both client and server: - `true`: Generates sourcemaps and includes source references in the final bundle. - `false`: Does not generate any sourcemaps. - `'hidden'`: Generates sourcemaps but does not include references in the final bundle.

- **Type**: `object`
- **Default**

```json
{
  "server": true,
  "client": false
}
```

## spaLoadingTemplate

Boolean or a path to an HTML file with the contents of which will be inserted into any HTML page rendered with `ssr: false`.

- If it is unset, it will use `~/spa-loading-template.html` file in one of your layers, if it exists. - If it is false, no SPA loading indicator will be loaded. - If true, Nuxt will look for `~/spa-loading-template.html` file in one of your layers, or a
  default Nuxt image will be used.
  Some good sources for spinners are [SpinKit](https://github.com/tobiasahlin/SpinKit){rel="nofollow"} or [SVG Spinners](https://icones.js.org/collection/svg-spinners){rel="nofollow"}.
- **Default:** `null`

**Example**: \~/spa-loading-template.html

```html
<!-- https://github.com/barelyhuman/snips/blob/dev/pages/css-loader.md -->
<div class="loader"></div>
<style>
.loader {
  display: block;
  position: fixed;
  z-index: 1031;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 18px;
  height: 18px;
  box-sizing: border-box;
  border: solid 2px transparent;
  border-top-color: #000;
  border-left-color: #000;
  border-bottom-color: #efefef;
  border-right-color: #efefef;
  border-radius: 50%;
  -webkit-animation: loader 400ms linear infinite;
  animation: loader 400ms linear infinite;
}

@-webkit-keyframes loader {
  0% {
    -webkit-transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    -webkit-transform: translate(-50%, -50%) rotate(360deg);
  }
}
@keyframes loader {
  0% {
    transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}
</style>
```

## srcDir

Define the source directory of your Nuxt application.

If a relative path is specified, it will be relative to the `rootDir`.

- **Type**: `string`
- **Default:** `"app"` (Nuxt 4), `"."` (Nuxt 3 with `compatibilityMode: 3`)

**Example**:

```js
export default {
  srcDir: 'app/'
}
```

This expects the following folder structure:

```bash
-| app/
---| assets/
---| components/
---| layouts/
---| middleware/
---| pages/
---| plugins/
---| app.config.ts
---| app.vue
---| error.vue
-| server/
-| public/
-| modules/
-| nuxt.config.js
-| package.json
```

## ssr

Whether to enable rendering of HTML - either dynamically (in server mode) or at generate time. If set to `false` generated pages will have no content.

- **Type**: `boolean`
- **Default:** `true`

## telemetry

Manually disable nuxt telemetry.

**See**: [Nuxt Telemetry](https://github.com/nuxt/telemetry){rel="nofollow"} for more information.

## test

Whether your app is being unit tested.

- **Type**: `boolean`
- **Default:** `false`

## theme

Extend project from a local or remote source.

Value should be a string pointing to source directory or config path relative to current config.
You can use `github:`, `gitlab:`, `bitbucket:` or `https://` to extend from a remote git repository.

- **Type**: `string`

## typescript

Configuration for Nuxt's TypeScript integration.

### `builder`

Which builder types to include for your project.

By default Nuxt infers this based on your `builder` option (defaulting to 'vite') but you can either turn off builder environment types (with `false`) to handle this fully yourself, or opt for a 'shared' option.
The 'shared' option is advised for module authors, who will want to support multiple possible builders.

- **Default:** `null`

### `hoist`

Modules to generate deep aliases for within `compilerOptions.paths`. This does not yet support subpaths. It may be necessary when using Nuxt within a pnpm monorepo with `shamefully-hoist=false`.

- **Type**: `array`
- **Default**

```json
[
  "nitropack/types",
  "nitropack/runtime",
  "nitropack",
  "defu",
  "h3",
  "consola",
  "ofetch",
  "@unhead/vue",
  "@nuxt/devtools",
  "vue",
  "@vue/runtime-core",
  "@vue/compiler-sfc",
  "vue-router",
  "vue-router/auto-routes",
  "unplugin-vue-router/client",
  "@nuxt/schema",
  "nuxt"
]
```

### `includeWorkspace`

Include parent workspace in the Nuxt project. Mostly useful for themes and module authors.

- **Type**: `boolean`
- **Default:** `false`

### `shim`

Generate a `*.vue` shim.

We recommend instead letting the [official Vue extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar){rel="nofollow"} generate accurate types for your components.
Note that you may wish to set this to `true` if you are using other libraries, such as ESLint, that are unable to understand the type of `.vue` files.

- **Type**: `boolean`
- **Default:** `false`

### `strict`

TypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety. [Read More](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks){rel="nofollow"}

- **Type**: `boolean`
- **Default:** `true`

### `tsConfig`

You can extend the generated TypeScript configurations (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) using this option.

### `typeCheck`

Enable build-time type checking.

If set to true, this will type check in development. You can restrict this to build-time type checking by setting it to `build`. Requires to install `typescript` and `vue-tsc` as dev dependencies.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt TypeScript docs](https://nuxt.com/docs/guide/concepts/typescript){rel="nofollow"}

## unhead

An object that allows us to configure the `unhead` nuxt module.

### `legacy`

Enable the legacy compatibility mode for `unhead` module. This applies the following changes: - Disables Capo.js sorting - Adds the `DeprecationsPlugin`: supports `hid`, `vmid`, `children`, `body` - Adds the `PromisesPlugin`: supports promises as input

- **Type**: `boolean`
- **Default:** `false`

**See**: [`unhead` migration documentation](https://unhead.unjs.io/docs/typescript/head/guides/get-started/migration){rel="nofollow"}

**Example**:

```ts
export default defineNuxtConfig({
 unhead: {
  legacy: true
})
```

### `renderSSRHeadOptions`

An object that will be passed to `renderSSRHead` to customize the output.

- **Type**: `object`
- **Default**

```json
{
  "omitLineBreaks": false
}
```

**Example**:

```ts
export default defineNuxtConfig({
 unhead: {
  renderSSRHeadOptions: {
   omitLineBreaks: true
  }
})
```

## vite

Configuration that will be passed directly to Vite.

**See**: [Vite configuration docs](https://vite.dev/config){rel="nofollow"} for more information.
Please note that not all vite options are supported in Nuxt.

### `build`

#### `assetsDir`

- **Type**: `string`
- **Default:** `"_nuxt/"`

#### `emptyOutDir`

- **Type**: `boolean`
- **Default:** `false`

### `cacheDir`

- **Type**: `string`
- **Default:** `"/<rootDir>/node_modules/.cache/vite"`

### `clearScreen`

- **Type**: `boolean`
- **Default:** `true`

### `define`

- **Type**: `object`
- **Default**

```json
{
  "__VUE_PROD_HYDRATION_MISMATCH_DETAILS__": false,
  "process.dev": false,
  "import.meta.dev": false,
  "process.test": false,
  "import.meta.test": false
}
```

### `esbuild`

- **Type**: `object`
- **Default**

```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

### `mode`

- **Type**: `string`
- **Default:** `"production"`

### `optimizeDeps`

#### `esbuildOptions`

- **Type**: `object`
- **Default**

```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

#### `exclude`

- **Type**: `array`
- **Default**

```json
[
  "vue-demi"
]
```

### `publicDir`

### `resolve`

#### `extensions`

- **Type**: `array`
- **Default**

```json
[
  ".mjs",
  ".js",
  ".ts",
  ".jsx",
  ".tsx",
  ".json",
  ".vue"
]
```

### `root`

- **Type**: `string`
- **Default:** `"/<srcDir>"`

### `server`

#### `fs`

##### `allow`

- **Type**: `array`
- **Default**

```json
[
  "/<rootDir>/.nuxt",
  "/<srcDir>",
  "/<rootDir>",
  "/<workspaceDir>"
]
```

### `vue`

#### `features`

##### `propsDestructure`

- **Type**: `boolean`
- **Default:** `true`

#### `isProduction`

- **Type**: `boolean`
- **Default:** `true`

#### `script`

##### `hoistStatic`

#### `template`

##### `compilerOptions`

- **Type**: `object`

##### `transformAssetUrls`

- **Type**: `object`
- **Default**

```json
{
  "video": [
    "src",
    "poster"
  ],
  "source": [
    "src"
  ],
  "img": [
    "src"
  ],
  "image": [
    "xlink:href",
    "href"
  ],
  "use": [
    "xlink:href",
    "href"
  ]
}
```

### `vueJsx`

- **Type**: `object`
- **Default**

```json
{
  "isCustomElement": {
    "$schema": {
      "title": "",
      "description": "",
      "tags": []
    }
  }
}
```

## vue

Vue.js config

### `compilerOptions`

Options for the Vue compiler that will be passed at build time.

**See**: [Vue documentation](https://vuejs.org/api/application.html#app-config-compileroptions){rel="nofollow"}

### `config`

It is possible to pass configure the Vue app globally. Only serializable options may be set in your `nuxt.config`. All other options should be set at runtime in a Nuxt plugin..

**See**: [Vue app config documentation](https://vuejs.org/api/application.html#app-config){rel="nofollow"}

### `propsDestructure`

Enable reactive destructure for `defineProps`

- **Type**: `boolean`
- **Default:** `true`

### `runtimeCompiler`

Include Vue compiler in runtime bundle.

- **Type**: `boolean`
- **Default:** `false`

### `transformAssetUrls`

#### `image`

- **Type**: `array`
- **Default**

```json
[
  "xlink:href",
  "href"
]
```

#### `img`

- **Type**: `array`
- **Default**

```json
[
  "src"
]
```

#### `source`

- **Type**: `array`
- **Default**

```json
[
  "src"
]
```

#### `use`

- **Type**: `array`
- **Default**

```json
[
  "xlink:href",
  "href"
]
```

#### `video`

- **Type**: `array`
- **Default**

```json
[
  "src",
  "poster"
]
```

## watch

The watch property lets you define patterns that will restart the Nuxt dev server when changed.

It is an array of strings or regular expressions. Strings should be either absolute paths or relative to the `srcDir` (and the `srcDir` of any layers). Regular expressions will be matched against the path relative to the project `srcDir` (and the `srcDir` of any layers).

- **Type**: `array`

## watchers

The watchers property lets you overwrite watchers configuration in your `nuxt.config`.

### `chokidar`

Options to pass directly to `chokidar`.

**See**: [chokidar](https://github.com/paulmillr/chokidar#api){rel="nofollow"}

#### `ignoreInitial`

- **Type**: `boolean`
- **Default:** `true`

#### `ignorePermissionErrors`

- **Type**: `boolean`
- **Default:** `true`

### `rewatchOnRawEvents`

An array of event types, which, when received, will cause the watcher to restart.

### `webpack`

`watchOptions` to pass directly to webpack.

**See**: [webpack@4 watch options](https://v4.webpack.js.org/configuration/watch/#watchoptions){rel="nofollow"}.

#### `aggregateTimeout`

- **Type**: `number`
- **Default:** `1000`

## webpack

### `aggressiveCodeRemoval`

Hard-replaces `typeof process`, `typeof window` and `typeof document` to tree-shake bundle.

- **Type**: `boolean`
- **Default:** `false`

### `analyze`

Nuxt uses `webpack-bundle-analyzer` to visualize your bundles and how to optimize them.

Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack-contrib/webpack-bundle-analyzer#options-for-plugin){rel="nofollow"} or [for vite](https://github.com/btd/rollup-plugin-visualizer#options){rel="nofollow"}.

- **Type**: `object`
- **Default**

```json
{
  "template": "treemap",
  "projectRoot": "/<rootDir>",
  "filename": "/<rootDir>/.nuxt/analyze/{name}.html"
}
```

**Example**:

```js
analyze: {
  analyzerMode: 'static'
}
```

### `cssSourceMap`

Enables CSS source map support (defaults to `true` in development).

- **Type**: `boolean`
- **Default:** `false`

### `devMiddleware`

See [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware){rel="nofollow"} for available options.

#### `stats`

- **Type**: `string`
- **Default:** `"none"`

### `experiments`

Configure [webpack experiments](https://webpack.js.org/configuration/experiments/){rel="nofollow"}

### `extractCSS`

Enables Common CSS Extraction.

Using [mini-css-extract-plugin](https://github.com/webpack-contrib/mini-css-extract-plugin){rel="nofollow"} under the hood, your CSS will be extracted into separate files, usually one per component. This allows caching your CSS and JavaScript separately.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```js
export default {
  webpack: {
    extractCSS: true,
    // or
    extractCSS: {
      ignoreOrder: true
    }
  }
}
```

If you want to extract all your CSS to a single file, there is a workaround for this.
However, note that it is not recommended to extract everything into a single file.
Extracting into multiple CSS files is better for caching and preload isolation. It
can also improve page performance by downloading and resolving only those resources
that are needed.

**Example**:

```js
export default {
  webpack: {
    extractCSS: true,
    optimization: {
      splitChunks: {
        cacheGroups: {
          styles: {
            name: 'styles',
            test: /\.(css|vue)$/,
            chunks: 'all',
            enforce: true
          }
        }
      }
    }
  }
}
```

### `filenames`

Customize bundle filenames.

To understand a bit more about the use of manifests, take a look at [webpack documentation](https://webpack.js.org/guides/code-splitting/){rel="nofollow"}.

::callout
**Note**: Be careful when using non-hashed based filenames in production
as most browsers will cache the asset and not detect the changes on first load.
::

This example changes fancy chunk names to numerical ids:

**Example**:

```js
filenames: {
  chunk: ({ isDev }) => (isDev ? '[name].js' : '[id].[contenthash].js')
}
```

#### `app`

- **Type**: `function`

#### `chunk`

- **Type**: `function`

#### `css`

- **Type**: `function`

#### `font`

- **Type**: `function`

#### `img`

- **Type**: `function`

#### `video`

- **Type**: `function`

### `friendlyErrors`

Set to `false` to disable the overlay provided by [FriendlyErrorsWebpackPlugin](https://github.com/nuxt/friendly-errors-webpack-plugin){rel="nofollow"}.

- **Type**: `boolean`
- **Default:** `true`

### `hotMiddleware`

See [webpack-hot-middleware](https://github.com/webpack-contrib/webpack-hot-middleware){rel="nofollow"} for available options.

### `loaders`

Customize the options of Nuxt's integrated webpack loaders.

#### `css`

See [css-loader](https://github.com/webpack-contrib/css-loader){rel="nofollow"} for available options.

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `importLoaders`

- **Type**: `number`
- **Default:** `0`

##### `url`

###### `filter`

- **Type**: `function`

#### `cssModules`

See [css-loader](https://github.com/webpack-contrib/css-loader){rel="nofollow"} for available options.

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `importLoaders`

- **Type**: `number`
- **Default:** `0`

##### `modules`

###### `localIdentName`

- **Type**: `string`
- **Default:** `"[local]_[hash:base64:5]"`

##### `url`

###### `filter`

- **Type**: `function`

#### `esbuild`

- **Type**: `object`
- **Default**

```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

**See**: [esbuild loader](https://github.com/esbuild-kit/esbuild-loader){rel="nofollow"}

#### `file`

**See**: [`file-loader` Options](https://github.com/webpack-contrib/file-loader#options){rel="nofollow"}

**Default**:

```ts
{ esModule: false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `fontUrl`

**See**: [`file-loader` Options](https://github.com/webpack-contrib/file-loader#options){rel="nofollow"}

**Default**:

```ts
{ esModule: false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `imgUrl`

**See**: [`file-loader` Options](https://github.com/webpack-contrib/file-loader#options){rel="nofollow"}

**Default**:

```ts
{ esModule: false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `less`

- **Default**

```json
{
  "sourceMap": false
}
```

**See**: [`less-loader` Options](https://github.com/webpack-contrib/less-loader#options){rel="nofollow"}

#### `pugPlain`

**See**: [`pug` options](https://pugjs.org/api/reference.html#options){rel="nofollow"}

#### `sass`

**See**: [`sass-loader` Options](https://github.com/webpack-contrib/sass-loader#options){rel="nofollow"}

**Default**:

```ts
{
  sassOptions: {
    indentedSyntax: true
  }
}
```

##### `sassOptions`

###### `indentedSyntax`

- **Type**: `boolean`
- **Default:** `true`

#### `scss`

- **Default**

```json
{
  "sourceMap": false
}
```

**See**: [`sass-loader` Options](https://github.com/webpack-contrib/sass-loader#options){rel="nofollow"}

#### `stylus`

- **Default**

```json
{
  "sourceMap": false
}
```

**See**: [`stylus-loader` Options](https://github.com/webpack-contrib/stylus-loader#options){rel="nofollow"}

#### `vue`

See [vue-loader](https://github.com/vuejs/vue-loader){rel="nofollow"} for available options.

##### `compilerOptions`

- **Type**: `object`

##### `propsDestructure`

- **Type**: `boolean`
- **Default:** `true`

##### `transformAssetUrls`

- **Type**: `object`
- **Default**

```json
{
  "video": [
    "src",
    "poster"
  ],
  "source": [
    "src"
  ],
  "img": [
    "src"
  ],
  "image": [
    "xlink:href",
    "href"
  ],
  "use": [
    "xlink:href",
    "href"
  ]
}
```

#### `vueStyle`

- **Default**

```json
{
  "sourceMap": false
}
```

### `optimization`

Configure [webpack optimization](https://webpack.js.org/configuration/optimization/){rel="nofollow"}.

#### `minimize`

Set minimize to `false` to disable all minimizers. (It is disabled in development by default).

- **Type**: `boolean`
- **Default:** `true`

#### `minimizer`

You can set minimizer to a customized array of plugins.

#### `runtimeChunk`

- **Type**: `string`
- **Default:** `"single"`

#### `splitChunks`

##### `automaticNameDelimiter`

- **Type**: `string`
- **Default:** `"/"`

##### `cacheGroups`

##### `chunks`

- **Type**: `string`
- **Default:** `"all"`

### `optimizeCSS`

OptimizeCSSAssets plugin options.

Defaults to true when `extractCSS` is enabled.

- **Type**: `boolean`
- **Default:** `false`

**See**: [css-minimizer-webpack-plugin documentation](https://github.com/webpack-contrib/css-minimizer-webpack-plugin){rel="nofollow"}.

### `plugins`

Add webpack plugins.

- **Type**: `array`

**Example**:

```js
import webpack from 'webpack'
import { version } from './package.json'
// ...
plugins: [
  new webpack.DefinePlugin({
    'process.VERSION': version
  })
]
```

### `postcss`

Customize PostCSS Loader. same options as [`postcss-loader` options](https://github.com/webpack-contrib/postcss-loader#options){rel="nofollow"}

#### `postcssOptions`

##### `plugins`

- **Type**: `object`
- **Default**

```json
{
  "autoprefixer": {},
  "cssnano": {}
}
```

### `profile`

Enable the profiler in webpackbar.

It is normally enabled by CLI argument `--profile`.

- **Type**: `boolean`
- **Default:** `false`

**See**: [webpackbar](https://github.com/unjs/webpackbar#profile){rel="nofollow"}.

### `serverURLPolyfill`

The polyfill library to load to provide URL and URLSearchParams.

Defaults to `'url'` ([see package](https://www.npmjs.com/package/url){rel="nofollow"}).

- **Type**: `string`
- **Default:** `"url"`

### `warningIgnoreFilters`

Filters to hide build warnings.

- **Type**: `array`

## workspaceDir

Define the workspace directory of your application.

Often this is used when in a monorepo setup. Nuxt will attempt to detect your workspace directory automatically, but you can override it here.
It is normally not needed to configure this option.

- **Type**: `string`
- **Default:** `"/<workspaceDir>"`


# Nuxt API Reference

::card-group
  :::card
  ---
  icon: i-lucide-box
  title: Components
  to: https://nuxt.com/docs/api/components/client-only
  ---
  Explore Nuxt built-in components for pages, layouts, head, and more.
  :::

  :::card
  ---
  icon: i-lucide-arrow-left-right
  title: Composables
  to: https://nuxt.com/docs/api/composables/use-app-config
  ---
  Discover Nuxt composable functions for data-fetching, head management and more.
  :::

  :::card
  ---
  icon: i-lucide-square-function
  title: Utils
  to: https://nuxt.com/docs/api/utils/dollarfetch
  ---
  Learn about Nuxt utility functions for navigation, error handling and more.
  :::

  :::card
  ---
  icon: i-lucide-square-terminal
  title: Commands
  to: https://nuxt.com/docs/api/commands/add
  ---
  List of Nuxt CLI commands to init, analyze, build, and preview your application.
  :::

  :::card
  ---
  icon: i-lucide-package
  title: Nuxt Kit
  to: https://nuxt.com/docs/api/kit/modules
  ---
  Understand Nuxt Kit utilities to create modules and control Nuxt.
  :::

  :::card
  ---
  icon: i-lucide-brain
  title: Advanced
  to: https://nuxt.com/docs/api/advanced/hooks
  ---
  Go deep in Nuxt internals with Nuxt lifecycle hooks.
  :::

  :::card
  ---
  icon: i-lucide-cog
  title: Nuxt Configuration
  to: https://nuxt.com/docs/api/nuxt-config
  ---
  Explore all Nuxt configuration options to customize your application.
  :::
::


# Getting Help

At some point, you may find that there's an issue you need some help with.

But don't worry! We're a friendly community of developers and we'd love to help.

::card-group
  :::card
  ---
  icon: i-simple-icons-discord
  target: _blank
  title: Discord
  to: https://go.nuxt.com/discord
  ---
  Get real-time help, exchange with the core team and the community, and stay updated on the latest Nuxt news.
  :::

  :::card
  ---
  icon: i-simple-icons-nuxt
  target: _blank
  title: Nuxters
  to: https://nuxters.nuxt.com
  ---
  Connect with other Nuxt enthusiasts.
  :::
::

## "I can't figure out how to (...)."

You've read through these docs and you think it should be possible, but it's not clear how. The best thing is to [open a GitHub Discussion](https://github.com/nuxt/nuxt/discussions){rel="nofollow"}.

Please don't feel embarrassed about asking a question that you think is easy - we've all been there! ❤️

Everyone you'll encounter is helping out because they care, not because they are paid to do so. The kindest thing to do is make it easy for them to help you. Here are some ideas:

- *Explain what your objective is, not just the problem you're facing.* "I need to ensure my form inputs are accessible, so I'm trying to get the ids to match between server and client."
- *Make sure you've first read the docs and used your favorite search engine*. Let people know by saying something like "I've Googled for 'nuxt script setup' but I couldn't find code examples anywhere."
- *Explain what you've tried.* Tell people the kind of solutions you've experimented with, and why. Often this can make people's advice more relevant to your situation.
- *Share your code.* People probably won't be able to help if they just see an error message or a screenshot - but that all changes if you share your code in a copy/pasteable format - preferably in the form of a minimal reproduction like a CodeSandbox.

And finally, just ask the question! There's no need to [ask permission to ask a question](https://dontasktoask.com){rel="nofollow"} or [wait for someone to reply to your 'hello'](https://www.nohello.com){rel="nofollow"}. If you do, you might not get a response because people are waiting for the whole question before engaging.

## "Could there be a bug?"

Something isn't working the way that the docs say that it should. You're not sure if it's a bug. You've searched through the [open issues](https://github.com/nuxt/nuxt/issues){rel="nofollow"} and [discussions](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} but you can't find anything. (if there is a closed issue, please create a new one)

We recommend taking a look at [how to report bugs](https://nuxt.com/docs/community/reporting-bugs). Nuxt is still in active development, and every issue helps make it better.

## "I need professional help"

If the community couldn't provide the help you need in the time-frame you have, NuxtLabs offers professional support with the [Nuxt Experts](https://nuxt.com/enterprise/support){rel="nofollow"}.

The objective of the Nuxt Expert is to provide support to the Vue ecosystem, while also creating freelance opportunities for those contributing to open-source solutions, thus helping to maintain the sustainability of the ecosystem.

The Nuxt experts are Vue, Nuxt and Vite chosen contributors providing professional support and consulting services.


# Reporting Bugs

Try as we might, we will never completely eliminate bugs.

Even if you can't fix the underlying code, reporting a bug well can enable someone else with a bit more familiarity with the codebase to spot a pattern or make a quick fix.

Here are a few key steps.

## Is It Really a Bug?

Consider if you're looking to get help with something, or whether you think there's a bug with Nuxt itself. If it's the former, we'd love to help you - but the best way to do that is through [asking for help](https://nuxt.com/docs/community/getting-help) rather than reporting a bug.

## Search the Issues

Search through the [open issues](https://github.com/nuxt/nuxt/issues){rel="nofollow"} and [discussions](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} first. If you find anything that seems like the same bug, it's much better to comment on an existing thread than create a duplicate.

## Create a Minimal Reproduction

It's important to be able to reproduce the bug reliably - in a minimal way and apart from the rest of your project. This narrows down what could be causing the issue and makes it possible for someone not only to find the cause, but also to test a potential solution.

Start with the Nuxt sandbox and add the **minimum** amount of code necessary to reproduce the bug you're experiencing.

::note
If your issue concerns Vue or Vite, please try to reproduce it first with the Vue SSR starter.
::

**Nuxt**:

::card-group
  :::card
  ---
  icon: i-simple-icons-stackblitz
  target: _blank
  title: Nuxt on StackBlitz
  to: https://nuxt.new/s/v3
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-codesandbox
  target: _blank
  title: Nuxt on CodeSandbox
  to: https://nuxt.new/c/v3
  ---
  :::
::

**Vue**:

::card-group
  :::card
  ---
  icon: i-simple-icons-stackblitz
  target: _blank
  title: Vue SSR on StackBlitz
  to: https://stackblitz.com/github/nuxt-contrib/vue3-ssr-starter/tree/main?terminal=dev
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-codesandbox
  target: _blank
  title: Vue SSR on CodeSandbox
  to: https://codesandbox.io/s/github/nuxt-contrib/vue3-ssr-starter/main
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-github
  target: _blank
  title: Vue SSR Template on GitHub
  to: https://github.com/nuxt-contrib/vue3-ssr-starter/generate
  ---
  :::
::

Once you've reproduced the issue, remove as much code from your reproduction as you can (while still recreating the bug). The time spent making the reproduction as minimal as possible will make a huge difference to whoever sets out to fix the issue.

## Figure Out What the Cause Might Be

With a Nuxt project, there are lots of moving pieces - from [Nuxt modules](https://nuxt.com/modules) to [other JavaScript libraries](https://www.npmjs.com){rel="nofollow"}. Try to report the bug at the most relevant and specific place. That will likely be the Nuxt module causing an issue, or the upstream library that Nuxt is depending on.


# Contribution

There is a range of different ways you might be able to contribute to the Nuxt ecosystem.

## Ecosystem

The Nuxt ecosystem includes many different projects and organizations:

- [nuxt/](https://github.com/nuxt){rel="nofollow"} - core repositories for the Nuxt framework itself. [**nuxt/nuxt**](https://github.com/nuxt/nuxt){rel="nofollow"} contains the Nuxt framework (both versions 2 and 3).
- [nuxt-modules/](https://github.com/nuxt-modules){rel="nofollow"} - community-contributed and maintained modules and libraries. There is a [process to migrate a module](https://nuxt.com/docs/guide/going-further/modules/#joining-nuxt-modules-and-nuxtjs) to `nuxt-modules`. While these modules have individual maintainers, they are not dependent on a single person.
- [unjs/](https://github.com/unjs){rel="nofollow"} - many of these libraries are used throughout the Nuxt ecosystem. They are designed to be universal libraries that are framework- and environment-agnostic. We welcome contributions and usage by other frameworks and projects.

## How To Contribute

### Triage Issues and Help Out in Discussions

Check out the issues and discussions for the project you want to help. For example, here are [the issues board](https://github.com/nuxt/nuxt/issues){rel="nofollow"} and [discussions](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} for Nuxt. Helping other users, sharing workarounds, creating reproductions, or even poking into a bug a little bit and sharing your findings makes a huge difference.

### Creating an Issue

Thank you for taking the time to create an issue! ❤️

- **Reporting bugs**: Check out [our guide](https://nuxt.com/docs/community/reporting-bugs) for some things to do before opening an issue.
- **Feature requests**: Check that there is not an existing issue or discussion covering the scope of the feature you have in mind. If the feature is to another part of the Nuxt ecosystem (such as a module), please consider raising a feature request there first. If the feature you have in mind is general or the API is not entirely clear, consider opening a discussion in the **Ideas** section to discuss with the community first.

We'll do our best to follow our [internal issue decision making flowchart](https://mermaid.live/view#pako\:eNqFlE1v2zAMhv8K4UuToslhx2Bo0TZt12Edhm7YMCAXWqJtorLk6qOpkfS_j7KdfpyWQ-BQr8mHL6nsCuU0FauiMm6rGvQRfq03FuRzvvvTYIQHthpcBT_ugQNwPHuZjheLxf4i1VDx8x4udrf5EBCOQvSsYg4ffS79KS9pmX9QALTgyid2KYB7Ih-4bmKWbDk2YB0E1gRUVaRi-FDmmjAmT3u4nB3DmoNKIUA1BsGSohA49jnVMQhHbDh_EZQUImyxh-gAtfaiG-KWSJ-N8nt6YtpCdgEeE5rXPOdav5YwWJIJU7zrvNADV9C7JBIyIC07Wxupkx3LFQ5vCkguRno5f9fP2qnUko0Y2dk9rGdvHAa9IIhVGlCp5FFNPN-ce4DKeXBd53xMliOLp9IZtyORQVsnrGm-WJzejtUu5fFqdr5FGQ3bLslYvGthjZbJTLpReZG5_lLYw7XQ_CbPVT92ws9gnEJj-v84dk-PiaXnmF1XGAaPsOsMKywNvYmG80ZohV8k4wDR9_N3KN_dHm5mh1lnkM5FsYzRfNiTvJoT5gnQsl6uxjqXLhkNQ9syHJ0UZZ8ERUIlNShr6N8gZDEliR-ow7QZa0fhY4LoHLRo-8N7ZxPwjRj5ZZYXpvOSNs9v3Jjs8NXB4ets92xan3zydXZHvj64lKMayh4-gZC1bjASW2ipLeWuzIuToiXfImu5rbucclMIc0ubYiWPGv3DptjYF9Fhiu5nb1Wxij7RSZE6jZHWjLXHtlhVaIJESXN0_m68_sO_wMs_oO9gyg){rel="nofollow"} when responding to issues.

### Send a Pull Request

We always welcome pull requests! ❤️

#### Before You Start

Before you fix a bug, we recommend that you check whether **there's an issue that describes it**, as it's possible it's a documentation issue or that there is some context that would be helpful to know.

If you're working on a feature, then we ask that you **open a feature request issue first** to discuss with the maintainers whether the feature is desired - and the design of those features. This helps save time for both the maintainers and the contributors and means that features can be shipped faster. The issue **should be confirmed** by a framework team member before building out a feature in a pull request.

For typo fixes, it's recommended to batch multiple typo fixes into one pull request to maintain a cleaner commit history.

For bigger changes to Nuxt itself, we recommend that you first [create a Nuxt module](https://nuxt.com/#create-a-module) and implement the feature there. This allows for quick proof-of-concept. You can then [create an RFC](https://nuxt.com/#make-an-rfc) in the form of a discussion. As users adopt it and you gather feedback, it can then be refined and either added to Nuxt core or continue as a standalone module.

#### Commit Conventions

We use [Conventional Commits](https://www.conventionalcommits.org){rel="nofollow"} for commit messages, which [allows a changelog to be auto-generated](https://github.com/unjs/changelogen){rel="nofollow"} based on the commits. Please read the guide through if you aren't familiar with it already.

Note that `fix:` and `feat:` are for **actual code changes** (that might affect logic). For typo or document changes, use `docs:` or `chore:` instead:

- ~~`fix: typo`~~ -> `docs: fix typo`

If you are working in a project with a monorepo, like `nuxt/nuxt`, ensure that you specify the main scope of your commit in brackets. For example: `feat(kit): add 'addMagicStuff' utility`.

#### Making the Pull Request

If you don't know how to send a pull request, we recommend reading [the guide](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request){rel="nofollow"}.

When sending a pull request, make sure your PR's title also follows the [Commit Convention](https://nuxt.com/#commit-conventions).

If your PR fixes or resolves existing issues, please make sure you mention them in the PR description.

It's ok to have multiple commits in a single PR; you don't need to rebase or force push for your changes as we will use `Squash and Merge` to squash the commits into one commit when merging.

We do not add any commit hooks to allow for quick commits. But before you make a pull request, you should ensure that any lint/test scripts are passing.

In general, please also make sure that there are no *unrelated* changes in a PR. For example, if your editor has made any changes to whitespace or formatting elsewhere in a file that you edited, please revert these so it is more obvious what your PR changes. And please avoid including multiple unrelated features or fixes in a single PR. If it is possible to separate them, it is better to have multiple PRs to review and merge separately. In general, a PR should do *one thing only*.

#### Once You've Made a Pull Request

Once you've made a pull request, we'll do our best to review it promptly.

If we assign it to a maintainer, then that means that person will take special care to review it and implement any changes that may be required.

If we request changes on a PR, please ignore the red text! It doesn't mean we think it's a bad PR - it's just a way of easily telling the status of a list of pull requests at a glance.

If we mark a PR as 'pending', that means we likely have another task to do in reviewing the PR - it's an internal note-to-self, and not necessarily a reflection on whether the PR is a good idea or not. We will do our best to explain via a comment the reason for the pending status.

We'll do our best to follow [our PR decision making flowchart](https://mermaid.live/view#pako\:eNp9VE1v2kAQ_SsjXzBSEqlALlaUisSh0ACK2l4qcVm8Y9hi7672Iwly-O-ZtYPt5FAOCHbee_PmzdpVlCmOURLlhXrJ9sw4-JNuJNBnWs1UQafIQVjrERyWumAOv58-AJeXt29_0b7BXbWwwL0uRPa1vlZvcB_fF8oiMMmB2QM4BXkt3UoON7Lh3LWaDz2SVkK6QGt7DHvw0CKt5sxCKaQoWQEGtVHcZ04oGdw04LTVngW_LHOeFcURGGz97mw6PSv-iJdsi0UCA4nI7SfNwc3W3JZit3eQ1SZFDlKB15yswQ2MgbOjbYeatY3n8bcr-IWlekYYaJRcyB04I9gOB1CEfkF5dAVTzmFAtnqn4-bUYAiMMmHZgWhNPRhgus5mW2BATxq0NkIZ4Y4NbNjzE2ZchBzcHmGLe_ZMSKCcyRXyLrVFa_5n_PBK2xKy3kk9eOjULUdltk6C8kI-7NFDr8f4EVGDoqlp-wa4sJm3ltIMIuZ_mTQXJyTSkQZtunPqsKxShV9GKdkBYe1fHXjpbcjlvONlO9Kqx_M7YHmOmav_luxfE5zKwVs09hM5DLSupgYDlr5flDkwo7ykixKG-xDsUly1LZ-uY32dgDc7lG7YqwbNp0msJwmIUivjWFtfd-xRrEcJ7Omydz37qFplHOtxEp4GskI2qB5dRCWakglOz3oV8JuITJa4iRL6yZk5bKKNPBGOead-H2UWJc54vIiaW53SPgwrz4fIhVNm1bw76lfI6R2_MW21){rel="nofollow"} when responding and reviewing to pull requests.

### AI-Assisted Contributions

We welcome the thoughtful use of AI tools when contributing to Nuxt, yet ask all contributors to follow [two core principles](https://roe.dev/blog/using-ai-in-open-source){rel="nofollow"}.

#### Never let an LLM speak for you

- All comments, issues, and pull request descriptions should be written in your own voice
- We value clear, human communication over perfect grammar or spelling
- Avoid copy-pasting AI-generated summaries that don't reflect your own understanding

#### Never let an LLM think for you

- Feel free to use AI tools to generate code or explore ideas
- Only submit contributions you fully understand and can explain
- Contributions should reflect your own reasoning and problem-solving

Our aim is ensuring quality and maintaining the joy of collaborating and communicating with real people. If you have ideas for improving our policy on AI in the Nuxt community, we'd love to hear them! ❤️

### Create a Module

If you've built something with Nuxt that's cool, why not [extract it into a module](https://nuxt.com/docs/guide/going-further/modules), so it can be shared with others? We have [many excellent modules already](https://nuxt.com/modules), but there's always room for more.

If you need help while building it, feel free to [check in with us](https://nuxt.com/docs/community/getting-help).

### Make an RFC

We highly recommend [creating a module](https://nuxt.com/#create-a-module) first to test out big new features and gain community adoption.

If you have done this already, or it's not appropriate to create a new module, then please start by creating a new discussion. Make sure it explains your thinking as clearly as possible. Include code examples or function signatures for new APIs. Reference existing issues or pain points with examples.

If we think this should be an RFC, we'll change the category to RFC and broadcast it more widely for feedback.

An RFC will then move through the following stages:

- `rfc: active` - currently open for comment
- `rfc: approved` - approved by the Nuxt team
- `rfc: ready to implement` - an issue has been created and assigned to implement
- `rfc: shipped` - implemented
- `rfc: archived` - not approved, but archived for future reference

### Conventions Across Ecosystem

The following conventions are *required* within the `nuxt/` organization and recommended for other maintainers in the ecosystem.

#### Module Conventions

Modules should follow the [Nuxt module template](https://github.com/nuxt/starter/tree/module){rel="nofollow"}. See [module guide](https://nuxt.com/docs/guide/going-further/modules) for more information.

#### Use Core `unjs/` Libraries

We recommend the following libraries which are used throughout the ecosystem:

- [pathe](https://github.com/unjs/pathe){rel="nofollow"} - universal path utilities (replacement for node `path`)
- [ufo](https://github.com/unjs/ufo){rel="nofollow"} - URL parsing and joining utilities
- [unbuild](https://github.com/unjs/unbuild){rel="nofollow"} - rollup-powered build system
- ... check out the rest of the [unjs/](https://github.com/unjs){rel="nofollow"} organization for many more!

#### Use ESM Syntax and Default to `type: module`

Most of the Nuxt ecosystem can consume ESM directly. In general we advocate that you avoid using CJS-specific code, such as `__dirname` and `require` statements. You can [read more about ESM](https://nuxt.com/docs/guide/concepts/esm).

#### What's Corepack

[Corepack](https://nodejs.org/api/corepack.html){rel="nofollow"} makes sure you are using the correct version for package manager when you run corresponding commands. Projects might have `packageManager` field in their `package.json`.

Under projects with configuration as shown below, Corepack will install `v7.5.0` of `pnpm` (if you don't have it already) and use it to run your commands.

```jsonc [package.json]
{
  "packageManager": "pnpm@7.5.0"
}
```

#### Use ESLint

We use [ESLint](https://eslint.org){rel="nofollow"} for both linting and formatting with [`@nuxt/eslint`](https://github.com/nuxt/eslint){rel="nofollow"}.

##### IDE Setup

We recommend using [VS Code](https://code.visualstudio.com){rel="nofollow"} along with the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint){rel="nofollow"}. If you would like, you can enable auto-fix and formatting when you save the code you are editing:

```json [settings.json]
{
  "editor.codeActionsOnSave": {
    "source.fixAll": "never",
    "source.fixAll.eslint": "explicit"
  }
}
```

#### No Prettier

Since ESLint is already configured to format the code, there is no need to duplicate the functionality with Prettier. To format the code, you can run `yarn lint --fix`, `pnpm lint --fix`, or `bun run lint --fix` or referring the [ESLint section](https://nuxt.com/#use-eslint) for IDE Setup.

If you have Prettier installed in your editor, we recommend you disable it when working on the project to avoid conflict.

#### Package Manager

We recommend `pnpm` as a package manager for modules, libraries and apps.

It is important to enable Corepack to ensure you are on the same version of the package manager as the project. Corepack is built-in to new node versions for seamless package manager integration.

To enable it, run

```bash [Terminal]
corepack enable
```

You only need to do this one time, after Node.js is installed on your computer.

## Documentation Style Guide

Documentation is an essential part of Nuxt. We aim to be an intuitive framework - and a big part of that is making sure that both the developer experience and the docs are perfect across the ecosystem. 👌

Here are some tips that may help improve your documentation:

- Avoid subjective words like *simply*, *just*, &#x2A;obviously...* when possible. :br Keep in mind your readers can have different backgrounds and experiences. Therefore, these words don't convey meaning and can be harmful. :caution[Simply make sure the function returns a promise.]{icon="i-lucide-circle-x"}:tip[Make sure the function returns a [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise){rel="nofollow"}.]{icon="i-lucide-circle-check"}
- Prefer [active voice](https://developers.google.com/tech-writing/one/active-voice){rel="nofollow"}. :caution[An error will be thrown by Nuxt.]{icon="i-lucide-circle-x"}:tip[Nuxt will throw an error.]{icon="i-lucide-circle-check"}

::read-more
---
to: https://nuxt.com/docs/community/framework-contribution#documentation-guide
---
Learn how to contribute to the documentation.
::


# Framework

Once you've read the [general contribution guide](https://nuxt.com/docs/community/contribution), here are some specific points to make about contributions to the [`nuxt/nuxt`](https://github.com/nuxt/nuxt){rel="nofollow"} repository.

## Monorepo Guide

- `packages/kit`: Toolkit for authoring Nuxt Modules, published as [`@nuxt/kit`](https://npmjs.com/package/@nuxt/kit){rel="nofollow"}.
- `packages/nuxt`: The core of Nuxt, published as [`nuxt`](https://npmjs.com/package/nuxt){rel="nofollow"}.
- `packages/schema`: Cross-version Nuxt typedefs and defaults, published as [`@nuxt/schema`](https://npmjs.com/package/@nuxt/schema){rel="nofollow"}.
- `packages/rspack`: The [Rspack](https://rspack.dev){rel="nofollow"} bundler for Nuxt, published as [`@nuxt/rspack-builder`](https://npmjs.com/package/@nuxt/rspack-builder){rel="nofollow"}.
- `packages/vite`: The [Vite](https://vite.dev){rel="nofollow"} bundler for Nuxt, published as [`@nuxt/vite-builder`](https://npmjs.com/package/@nuxt/vite-builder){rel="nofollow"}.
- `packages/webpack`: The [webpack](https://webpack.js.org){rel="nofollow"} bundler for Nuxt, published as [`@nuxt/webpack-builder`](https://npmjs.com/package/@nuxt/webpack-builder){rel="nofollow"}.

## Setup

To contribute to Nuxt, you need to set up a local environment.

1. [Fork](https://help.github.com/articles/fork-a-repo){rel="nofollow"} the [`nuxt/nuxt`](https://github.com/nuxt/nuxt){rel="nofollow"} repository to your own GitHub account and then [clone](https://help.github.com/articles/cloning-a-repository){rel="nofollow"} it to your local device.
2. Ensure using the latest [Node.js](https://nodejs.org/en){rel="nofollow"} (20.x)
3. Enable [Corepack](https://github.com/nodejs/corepack){rel="nofollow"} to have `pnpm` and `yarn`
   ```bash [Terminal]
   corepack enable
   ```
4. Run `pnpm install --frozen-lockfile` to Install the dependencies with pnpm:

   ```bash [Terminal]
   pnpm install --frozen-lockfile
   ```
   :note[If you are adding a dependency, please use `pnpm add`. :br
   The `pnpm-lock.yaml` file is the source of truth for all Nuxt dependencies.]
5. Activate the passive development system

   ```bash [Terminal]
   pnpm dev:prepare
   ```
6. Check out a branch where you can work and commit your changes:

   ```bash [Terminal]
   git checkout -b my-new-branch
   ```

Then, test your changes against the [playground](https://nuxt.com/#playground) and [test](https://nuxt.com/#testing) your changes before submitting a pull request.

### Playground

While working on a pull request, you will likely want to check if your changes are working correctly.

You can modify the example app in `playground/`, and run:

```bash [Terminal]
pnpm dev
```

::important
Please make sure not to commit it to your branch, but it could be helpful to add some example code to your PR description. This can help reviewers and other Nuxt users understand the feature you've built in-depth.
::

### Testing

Every new feature should have a corresponding unit test (if possible). The `test/` directory in this repository is currently a work in progress, but do your best to create a new test following the example of what's already there.

Before creating a PR or marking it as ready-to-review, ensure that all tests pass by running:

```bash [Terminal]
pnpm test
```

### Linting

You might have noticed already that we use ESLint to enforce a coding standard.

Before committing your changes, to verify that the code style is correct, run:

```bash [Terminal]
pnpm lint
```

::note
You can use `pnpm lint --fix` to fix most of the style changes. :br
If there are still errors left, you must correct them manually.
::

### Documentation

If you are adding a new feature or refactoring or changing the behavior of Nuxt in any other manner, you'll likely want to document the changes. Please include any changes to the docs in the same PR. You don't have to write documentation up on the first commit (but please do so as soon as your pull request is mature enough).

::important
Make sure to make changes according to the [Documentation Style Guide](https://nuxt.com/docs/community/contribution#documentation-style-guide).
::

### Final Checklist

When submitting your PR, there is a simple template that you have to fill out. Please tick all appropriate "answers" in the checklists.

## Documentation Guide

If you spot an area where we can improve documentation or error messages, please do open a PR - even if it's just to fix a typo!

::important
Make sure to make changes according to the [Documentation Style Guide](https://nuxt.com/docs/community/contribution#documentation-style-guide).
::

### Quick Edits

If you spot a typo or want to rephrase a sentence, you can click on the **Edit this page** link located on the right aside in the **Community** section.

Make the change directly in the GitHub interface and open a Pull Request.

### Longer Edits

The documentation content is inside the `docs/` directory of the [nuxt/nuxt](https://github.com/nuxt/nuxt){rel="nofollow"} repository and written in markdown.

::note
To preview the docs locally, follow the steps on [nuxt/nuxt.com](https://github.com/nuxt/nuxt.com){rel="nofollow"} repository.
::

::note
We recommend that you install the [MDC extension](https://marketplace.visualstudio.com/items?itemName=Nuxt.mdc){rel="nofollow"} for VS Code.
::

### Linting Docs

Documentation is linted using [MarkdownLint](https://github.com/DavidAnson/markdownlint){rel="nofollow"} and [case police](https://github.com/antfu/case-police){rel="nofollow"} to keep the documentation cohesive.

```bash [Terminal]
pnpm lint:docs
```

::note
You can also run `pnpm lint:docs:fix` to highlight and resolve any lint issues.
::

### Open a PR

Please make sure your PR title adheres to the [conventional commits](https://www.conventionalcommits.org){rel="nofollow"} guidelines.

```bash [Example of PR title]
docs: update the section about the nuxt.config.ts file
```


# Roadmap

::read-more{to="https://nuxt.com/blog"}
See our blog for the latest framework and ecosystem announcements.
::

## Status Reports

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/issues/13653
---
Documentation Progress
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/discussions/16119
---
Rendering Optimizations: Today and Tomorrow
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/image/discussions/563
---
Nuxt Image: Performance and Status
::

## Roadmap

In roadmap below are some features we are planning or working on at the moment.

::tip
Check [Discussions](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} and [RFCs](https://github.com/nuxt/nuxt/discussions/categories/rfcs){rel="nofollow"} for more upcoming features and ideas.
::

| Milestone    | Expected date | Notes                                                                                                                                                                        | Description                                                                                                                                                             |
| ------------ | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SEO & PWA    | 2025          | [nuxt/nuxt#18395](https://github.com/nuxt/nuxt/discussions/18395){rel="nofollow"}                                                                                            | Migrating from [nuxt-community/pwa-module](https://github.com/nuxt-community/pwa-module){rel="nofollow"} for built-in SEO utils and service worker support              |
| Assets       | 2025          | [nuxt/nuxt#22012](https://github.com/nuxt/nuxt/discussions/22012){rel="nofollow"}                                                                                            | Allow developers and modules to handle loading third-party assets.                                                                                                      |
| Translations | -             | [nuxt/translations#4](https://github.com/nuxt/translations/discussions/4){rel="nofollow"} ([request access](https://github.com/nuxt/nuxt/discussions/16054){rel="nofollow"}) | A collaborative project for a stable translation process for Nuxt docs. Currently pending for ideas and documentation tooling support (content v2 with remote sources). |

## Core Modules Roadmap

In addition to the Nuxt framework, there are modules that are vital for the ecosystem. Their status will be updated below.

| Module                                              | Status      | Nuxt Support | Repository                                                      | Description                                                                                                                                                                          |
| --------------------------------------------------- | ----------- | ------------ | --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [Scripts](https://scripts.nuxt.com){rel="nofollow"} | Public Beta | 3.x, 4.x     | [nuxt/scripts](https://github.com/nuxt/scripts){rel="nofollow"} | Easy 3rd party script management.                                                                                                                                                    |
| Auth Utils                                          | Planned     | 4.x, 5.x     | `nuxt/auth-utils` to be announced                               | The temporary repository [atinux/nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils){rel="nofollow"} is available while awaiting its official integration into Nuxt via RFC. |
| A11y                                                | Planned     | 4.x, 5.x     | `nuxt/a11y` to be announced                                     | Accessibility hinting and utilities [nuxt/nuxt#23255](https://github.com/nuxt/nuxt/issues/23255){rel="nofollow"}                                                                     |
| Hints                                               | Planned     | 4.x, 5.x     | `nuxt/hints` to be announced                                    | Guidance and suggestions for enhancing development practices.                                                                                                                        |

## Release Cycle

Since January 2023, we've adopted a consistent release cycle for Nuxt, following [semver](https://semver.org){rel="nofollow"}. We aim for major framework releases every year, with an expectation of patch releases every week or so and minor releases every month or so. They should never contain breaking changes except within options clearly marked as `experimental`.

We are planning a slight variation from this plan for Nuxt 4 and Nuxt 5. Nuxt 4 will be a stability-focused release containing all `compatibilityVersion: 4` features, and will be followed shortly by Nuxt 5 which will include an upgrade to Nitro v3 and additional changes.

This approach separates breaking changes into manageable phases, allowing for better ecosystem testing and smoother migrations.

### Ongoing Support for Nuxt

We commit to support each major version of Nuxt for a minimum of six months after the release of the next major version, and to providing an upgrade path for current users at that point.

### Current Packages

The current active version of [Nuxt](https://nuxt.com){rel="nofollow"} is **v4** which is available as `nuxt` on npm with the `latest` tag.

Nuxt 3 will continue to receive maintenance updates (both bug fixes and backports of features from Nuxt 4) until the end of January 2026.

Each active version has its own nightly releases which are generated automatically. For more about enabling the Nuxt nightly release channel, see [the nightly release channel docs](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

| Release               |                                                                                                                                        | Initial release     | End Of Life                | Docs                                                    |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------------- | ------------------------------------------------------- |
| **5.x** (scheduled)   |                                                                                                                                        | Q4 2025 (estimated) | TBA                        |                                                         |
| **4.x** (stable)      | [![Nuxt latest version](https://flat.badgen.net/npm/v/nuxt?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2025-07-16          | 6 months after 5.x release | [nuxt.com](https://nuxt.com/docs/4.x)                   |
| **3.x** (maintenance) | [![Nuxt 3.x version](https://flat.badgen.net/npm/v/nuxt/3x?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2022-11-16          | 2026-01-31                 | [nuxt.com](https://nuxt.com/docs/3.x)                   |
| **2.x** (unsupported) | [![Nuxt 2.x version](https://flat.badgen.net/npm/v/nuxt/2x?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2018-09-21          | 2024-06-30                 | [v2.nuxt.com](https://v2.nuxt.com/docs){rel="nofollow"} |
| **1.x** (unsupported) | [![Nuxt 1.x version](https://flat.badgen.net/npm/v/nuxt/1x?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2018-01-08          | 2019-09-21                 |                                                         |

### Support Status

| Status      | Description                                                                   |
| ----------- | ----------------------------------------------------------------------------- |
| Unsupported | This version is not maintained any more and will not receive security patches |
| Maintenance | This version will only receive security patches                               |
| Stable      | This version is being developed for and will receive security patches         |
| Development | This version could be unstable                                                |
| Scheduled   | This version does not exist yet but is planned                                |


# Releases

::card-group
  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/nuxt
  to: https://github.com/nuxt/nuxt/releases
  ---
  Nuxt framework releases.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/cli
  to: https://github.com/nuxt/cli/releases
  ---
  Nuxt CLI (`@nuxt/cli`) releases.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/content
  to: https://github.com/nuxt/content/releases
  ---
  Nuxt Content releases.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/devtools
  to: https://github.com/nuxt/devtools/releases
  ---
  Nuxt DevTools releases.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/fonts
  to: https://github.com/nuxt/fonts/releases
  ---
  Nuxt Fonts releases.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/image
  to: https://github.com/nuxt/image/releases
  ---
  Nuxt Image releases.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/scripts
  to: https://github.com/nuxt/scripts/releases
  ---
  Nuxt Scripts releases.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/ui
  to: https://github.com/nuxt/ui/releases
  ---
  Nuxt UI releases.
  :::
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt
---
Discover the `nuxt` organization on GitHub
::


# Overview

::note
If you're starting a fresh Nuxt 3 project, please skip this section and go to [Nuxt 3 Installation](https://nuxt.com/docs/getting-started/introduction).
::

::warning
Nuxt Bridge provides identical features to Nuxt 3 ([docs](https://nuxt.com/docs/guide/concepts/auto-imports)) but there are some limitations, notably that [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) and [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) composables are not available. Please read the rest of this page for details.
::

Bridge is a forward-compatibility layer that allows you to experience many of the new Nuxt 3 features by simply installing and enabling a Nuxt module.

Using Nuxt Bridge, you can make sure your project is (almost) ready for Nuxt 3 and you can gradually proceed with the transition to Nuxt 3.

## First Step

### Upgrade Nuxt 2

Make sure your dev server (`nuxt dev`) isn't running, remove any package lock files (`package-lock.json` and `yarn.lock`), and install the latest Nuxt 2 version:

```diff [package.json]
- "nuxt": "^2.16.3"
+ "nuxt": "^2.17.3"
```

Then, reinstall your dependencies:

::code-group{sync="pm"}
```bash [npm]
npm install
```

```bash [yarn]
yarn install
```

```bash [pnpm]
pnpm install
```

```bash [bun]
bun install
```
::

::note
Once the installation is complete, make sure both development and production builds are working as expected before proceeding.
::

### Install Nuxt Bridge

Install `@nuxt/bridge` and `nuxi` as development dependencies:

::code-group{sync="pm"}
```bash [npm]
npm install -D @nuxt/bridge nuxi
```

```bash [yarn]
yarn add --dev @nuxt/bridge nuxi
```

```bash [pnpm]
pnpm add -D @nuxt/bridge nuxi
```

```bash [bun]
bun add -D @nuxt/bridge nuxi
```
::

### Update `nuxt.config`

Please make sure to avoid any CommonJS syntax such as `module.exports`, `require` or `require.resolve` in your config file. It will soon be deprecated and unsupported.

You can use static `import`, dynamic `import()` and `export default` instead. Using TypeScript by renaming to [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) is also possible and recommended.

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: false
})
```

### Update Commands

The `nuxt` command should now be changed to the `nuxt2` command.

```diff
{
  "scripts": {
-   "dev": "nuxt",
+   "dev": "nuxt2",
-   "build": "nuxt build",
+   "build": "nuxt2 build",
-   "start": "nuxt start",
+   "start": "nuxt2 start"
  }
}
```

Try running `nuxt2` once here. You will see that the application works as before.

(If 'bridge' is set to false, your application will operate without any changes as before.)

## Upgrade Steps

With Nuxt Bridge, the migration to Nuxt 3 can proceed in steps.
The below `Upgrade Steps` does not need to be done all at once.

- [TypeScript](https://nuxt.com/docs/bridge/typescript)
- [Migrate Legacy Composition API](https://nuxt.com/docs/bridge/bridge-composition-api)
- [Plugins and Middleware](https://nuxt.com/docs/bridge/plugins-and-middleware)
- [Migrate New Composition API](https://nuxt.com/docs/bridge/nuxt3-compatible-api)
- [Meta Tags](https://nuxt.com/docs/bridge/meta)
- [Runtime Config](https://nuxt.com/docs/bridge/runtime-config)
- [Nitro](https://nuxt.com/docs/bridge/nitro)
- [Vite](https://nuxt.com/docs/bridge/vite)

## Migrate from CommonJS to ESM

Nuxt 3 natively supports TypeScript and ECMAScript Modules. Please check [Native ES Modules](https://nuxt.com/docs/guide/concepts/esm) for more info and upgrading.


# Configuration

## Feature Flags

You can optionally disable some features from bridge or opt-in to less stable ones. In normal circumstances, it is always best to stick with defaults!

You can check [bridge/src/module.ts](https://github.com/nuxt/bridge/blob/main/packages/bridge/src/module.ts){rel="nofollow"} for latest defaults.

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'
export default defineNuxtConfig({
  bridge: {

    // -- Opt-in features --

    // Use Vite as the bundler instead of webpack 4
    // vite: true,

    // Enable Nuxt 3 compatible useHead
    // meta: true,

    // Enable definePageMeta macro
    // macros: {
    //   pageMeta: true
    // },

    // Enable transpiling TypeScript with esbuild
    // typescript: {
    //   esbuild: true
    // },

    // -- Default features --

    // Use legacy server instead of Nitro
    // nitro: false,

    // Disable Nuxt 3 compatible `nuxtApp` interface
    // app: false,

    // Disable Composition API support
    // capi: false,

    // ... or just disable legacy Composition API support
    // capi: {
    //   legacy: false
    // },

    // Do not transpile modules
    // transpile: false,

    // Disable <script setup> support
    // scriptSetup: false,

    // Disable composables auto importing
    // imports: false,

    // Do not warn about module incompatibilities
    // constraints: false
  },

  vite: {
    // Config for Vite
  }
})
```

## Migration of each option

### router.base

```diff
export default defineNuxtConfig({
- router: {
-   base: '/my-app/'
- }
+ app: {
+   baseURL: '/my-app/'
+ }
})
```

### build.publicPath

```diff
export default defineNuxtConfig({
- build: {
-   publicPath: 'https://my-cdn.net'
- }
+ app: {
+   cdnURL: 'https://my-cdn.net'
+ }
})
```


# TypeScript

## Remove Modules

- Remove `@nuxt/typescript-build`: Bridge enables same functionality
- Remove `@nuxt/typescript-runtime` and `nuxt-ts`: Nuxt 2 has built-in runtime support

### Set `bridge.typescript`

```ts
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    typescript: true,
    nitro: false // If migration to Nitro is complete, set to true
  }
})
```

## Update `tsconfig.json`

If you are using TypeScript, you can edit your `tsconfig.json` to benefit from auto-generated Nuxt types:

```diff [tsconfig.json]
{
+ "extends": "./.nuxt/tsconfig.json",
  "compilerOptions": {
    ...
  }
}
```

::note
As `.nuxt/tsconfig.json` is generated and not checked into version control, you'll need to generate that file before running your tests. Add `nuxi prepare` as a step before your tests, otherwise you'll see `TS5083: Cannot read file '~/.nuxt/tsconfig.json'`

For modern Nuxt projects, we recommend using [TypeScript project references](https://nuxt.com/docs/guide/directory-structure/tsconfig) instead of directly extending `.nuxt/tsconfig.json`.
::

::note
Keep in mind that all options extended from `./.nuxt/tsconfig.json` will be overwritten by the options defined in your `tsconfig.json`.
Overwriting options such as `"compilerOptions.paths"` with your own configuration will lead TypeScript to not factor in the module resolutions from `./.nuxt/tsconfig.json`. This can lead to module resolutions such as `#imports` not being recognized.

In case you need to extend options provided by `./.nuxt/tsconfig.json` further, you can use the `alias` property within your `nuxt.config`. `nuxi` will pick them up and extend `./.nuxt/tsconfig.json` accordingly.
::


# Legacy Composition API

Nuxt Bridge provides access to Composition API syntax. It is specifically designed to be aligned with Nuxt 3. Because of this, there are a few extra steps to take when enabling Nuxt Bridge, if you have been using the Composition API previously.

## Remove Modules

- Remove `@vue/composition-api` from your dependencies.
- Remove `@nuxtjs/composition-api` from your dependencies (and from your modules in `nuxt.config`).

## Using `@vue/composition-api`

If you have been using just `@vue/composition-api` and not `@nuxtjs/composition-api`, then things are very straightforward.

1. First, remove the plugin where you are manually registering the Composition API. Nuxt Bridge will handle this for you.
   ```diff
   - import Vue from 'vue'
   - import VueCompositionApi from '@vue/composition-api'
   -
   - Vue.use(VueCompositionApi)
   ```
2. Otherwise, there is nothing you need to do. However, if you want, you can remove your explicit imports from `@vue/composition-api` and rely on Nuxt Bridge auto-importing them for you.

## Migrating from `@nuxtjs/composition-api`

Nuxt Bridge implements the Composition API slightly differently from `@nuxtjs/composition-api` and provides different composables (designed to be aligned with the composables that Nuxt 3 provides).

Because some composables have been removed and don't yet have a replacement, this will be a slightly more complicated process.

### Remove `@nuxtjs/composition-api/module` from your buildModules

You don't have to immediately update your imports yet - Nuxt Bridge will automatically provide a 'shim' for most imports you currently have, to give you time to migrate to the new, Nuxt 3-compatible composables, with the following exceptions:

- `withContext` has been removed. See [below](https://nuxt.com/docs/bridge/nuxt3-compatible-api#usecontext-and-withcontext).
- `useStatic` has been removed. There is no current replacement. Feel free to raise a discussion if you have a use case for this.
- `reqRef` and `reqSsrRef`, which were deprecated, have now been removed entirely. Follow the instructions below regarding [ssrRef](https://nuxt.com/docs/bridge/nuxt3-compatible-api#ssrref-and-shallowssrref) to replace this.

### Set `bridge.capi`

```ts
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    capi: true,
    nitro: false // If migration to Nitro is complete, set to true
  }
})
```

For each other composable you are using from `@nuxtjs/composition-api`, follow the steps below.

### useFetch

`$fetchState` and `$fetch` have been removed.

```diff
const {
- $fetch,
- $fetchState,
+ fetch,
+ fetchState,
} = useFetch(() => { posts.value = await $fetch('/api/posts') })
```

### `defineNuxtMiddleware`

This was a type-helper stub function that is now removed.

Remove the `defineNuxtMiddleware` wrapper:

```diff
- import { defineNuxtMiddleware } from '@nuxtjs/composition-api`
- export default defineNuxtMiddleware((ctx) => {})
+ export default (ctx) => {}
```

For typescript support, you can use `@nuxt/types`:

```ts
import type { Middleware } from '@nuxt/types'

export default <Middleware> function (ctx) { }
```

### `defineNuxtPlugin`

This was a type-helper stub function that is now removed.

You may also keep using Nuxt 2-style plugins, by removing the function (as with [defineNuxtMiddleware](https://nuxt.com/#definenuxtmiddleware)).

Remove the `defineNuxtPlugin` wrapper:

```diff
- import { defineNuxtPlugin } from '@nuxtjs/composition-api'
- export default defineNuxtPlugin((ctx, inject) => {})
+ export default (ctx, inject) => {}
```

For typescript support, you can use `@nuxt/types`:

```ts
import type { Plugin } from '@nuxt/types'

export default <Plugin> function (ctx, inject) {}
```

::warning
While this example is valid, Nuxt 3 introduces a new defineNuxtPlugin function that has a slightly different signature.
::

::read-more{link="/docs/guide/directory-structure/app/plugins#creating-plugins"}
::

### `useRouter` and `useRoute`

Nuxt Bridge provides direct replacements for these composables via [`useRouter`](https://nuxt.com/docs/api/composables/use-router) and `useRoute`.

The only key difference is that [`useRoute`](https://nuxt.com/docs/api/composables/use-route) no longer returns a computed property.

```diff
- import { useRouter, useRoute } from '@nuxtjs/composition-api'

  const router = useRouter()
  const route = useRoute()

- console.log(route.value.path)
+ console.log(route.path)
```


# Plugins and Middleware

## New Plugins Format

You can now migrate to the Nuxt 3 plugins API, which is slightly different in format from Nuxt 2.

Plugins now take only one argument (`nuxtApp`). You can find out more in [the docs](https://nuxt.com/docs/guide/directory-structure/plugins).

```js [app/plugins/hello.ts]
export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.provide('injected', () => 'my injected function')
  // now available on `nuxtApp.$injected`
})
```

::note
If you want to use the new Nuxt composables (such as [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) or `useRuntimeConfig`) within your plugins, you will need to use the `defineNuxtPlugin` helper for those plugins.
::

::warning
Although a compatibility interface is provided via `nuxtApp.vueApp` you should avoid registering plugins, directives, mixins or components this way without adding your own logic to ensure they are not installed more than once, or this may cause a memory leak.
::

## New Middleware Format

You can now migrate to the Nuxt 3 middleware API, which is slightly different in format from Nuxt 2.

Middleware now take only two argument (`to`, `from`). You can find out more in [the docs](https://nuxt.com/docs/guide/directory-structure/app/middleware).

```ts twoslash
export default defineNuxtRouteMiddleware((to) => {
  if (to.path !== '/') {
    return navigateTo('/')
  }
})
```

::important
Use of `defineNuxtRouteMiddleware` is not supported outside of the `app/middleware` directory.
::

## definePageMeta

You can also use [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) in Nuxt Bridge.

You can be enabled with the `macros.pageMeta` option in your configuration file

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    macros: {
      pageMeta: true
    }
  }
})
```

::note
But only for `middleware` and `layout`.
::


# New Composition API

By migrating from `@nuxtjs/composition-api` to the Nuxt 3 compatible API, there will be less rewriting when migrating to Nuxt 3.

## `ssrRef` and `shallowSsrRef`

These two functions have been replaced with a new composable that works very similarly under the hood: `useState`.

The key differences are that you must provide a *key* for this state (which Nuxt generated automatically for `ssrRef` and `shallowSsrRef`), and that it can only be called within a Nuxt 3 plugin (which is defined by `defineNuxtPlugin`) or a component instance. (In other words, you cannot use [`useState`](https://nuxt.com/docs/api/composables/use-state) with a global/ambient context, because of the danger of shared state across requests.)

```diff
- import { ssrRef } from '@nuxtjs/composition-api'

- const ref1 = ssrRef('initialData')
- const ref2 = ssrRef(() => 'factory function')
+ const ref1 = useState('ref1-key', () => 'initialData')
+ const ref2 = useState('ref2-key', () => 'factory function')
  // accessing the state
  console.log(ref1.value)
```

Because the state is keyed, you can access the same state from multiple locations, as long as you are using the same key.

You can read more about how to use this composable in [the Nuxt 3 docs](https://nuxt.com/docs/api/composables/use-state).

## `ssrPromise`

This function has been removed, and you will need to find an alternative implementation if you were using it. If you have a use case for `ssrPromise`, please let us know via a discussion.

## `onGlobalSetup`

This function has been removed, but its use cases can be met by using [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) or [`useState`](https://nuxt.com/docs/api/composables/use-state) within `defineNuxtPlugin`. You can also run any custom code within the `setup()` function of a layout.

```diff
- import { onGlobalSetup } from '@nuxtjs/composition-api'

- export default () => {
-   onGlobalSetup(() => {
+ export default defineNuxtPlugin((nuxtApp) => {
+   nuxtApp.hook('vue:setup', () => {
      // ...
    })
- }
+ })
```

## `useStore`

In order to access Vuex store instance, you can use `useNuxtApp().$store`.

```diff
- import { useStore } from '@nuxtjs/composition-api`
+ const { $store } = useNuxtApp()
```

## `useContext` and `withContext`

You can access injected helpers using `useNuxtApp`.

```diff
- import { useContext } from '@nuxtjs/composition-api`
+ const { $axios } = useNuxtApp()
```

::note
`useNuxtApp()` also provides a key called `nuxt2Context` which contains all the same properties you would normally access from Nuxt 2 context, but it's advised *not* to use this directly, as it won't exist in Nuxt 3. Instead, see if there is another way to access what you need. (If not, please raise a feature request or discussion.)
::

## `wrapProperty`

This helper function is not provided any more but you can replace it with the following code:

```js
const wrapProperty = (property, makeComputed = true) => () => {
  const vm = getCurrentInstance().proxy
  return makeComputed ? computed(() => vm[property]) : vm[property]
}
```

## `useAsync` and `useFetch`

These two composables can be replaced with `useLazyAsyncData` and `useLazyFetch`, which are documented [in the Nuxt 3 docs](https://nuxt.com/docs/getting-started/data-fetching). Just like the previous `@nuxtjs/composition-api` composables, these composables do not block route navigation on the client-side (hence the 'lazy' part of the name).

::important
Note that the API is entirely different, despite similar sounding names. Importantly, you should not attempt to change the value of other variables outside the composable (as you may have been doing with the previous `useFetch`).
::

::warning
The `useLazyFetch` must have been configured for [Nitro](https://nuxt.com/docs/bridge/nitro).
::

Migrating to the new composables from `useAsync`:

```diff
<script setup>
- import { useAsync } from '@nuxtjs/composition-api'
- const posts = useAsync(() => $fetch('/api/posts'))
+ const { data: posts } = useLazyAsyncData('posts', () => $fetch('/api/posts'))
+ // or, more simply!
+ const { data: posts } = useLazyFetch('/api/posts')
</script>
```

Migrating to the new composables from `useFetch`:

```diff
<script setup>
- import { useFetch } from '@nuxtjs/composition-api'
- const posts = ref([])
- const { fetch } = useFetch(() => { posts.value = await $fetch('/api/posts') })
+ const { data: posts, refresh } = useLazyAsyncData('posts', () => $fetch('/api/posts'))
+ // or, more simply!
+ const { data: posts, refresh } = useLazyFetch('/api/posts')
  function updatePosts() {
-   return fetch()
+   return refresh()
  }
</script>
```

### `useMeta`

In order to interact with `vue-meta`, you may use `useNuxt2Meta`, which will work in Nuxt Bridge (but not Nuxt 3) and will allow you to manipulate your meta tags in a `vue-meta`-compatible way.

```diff
<script setup>
- import { useMeta } from '@nuxtjs/composition-api'
  useNuxt2Meta({
    title: 'My Nuxt App',
  })
</script>
```

You can also pass in computed values or refs, and the meta values will be updated reactively:

```ts
<script setup>
const title = ref('my title')
useNuxt2Meta({
  title,
})
title.value = 'new title'
</script>
```

::note
Be careful not to use both `useNuxt2Meta()` and the Options API `head()` within the same component, as behavior may be unpredictable.
::

Nuxt Bridge also provides a Nuxt 3-compatible meta implementation that can be accessed with the [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable.

```diff
<script setup>
- import { useMeta } from '@nuxtjs/composition-api'
  useHead({
    title: 'My Nuxt App',
  })
</script>
```

You will also need to enable it explicitly in your `nuxt.config`:

```js
import { defineNuxtConfig } from '@nuxt/bridge'
export default defineNuxtConfig({
  bridge: {
    meta: true
  }
})
```

This [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable uses `@unhead/vue` under the hood (rather than `vue-meta`) to manipulate your `<head>`. Accordingly, it is recommended not to use both the native Nuxt 2 `head()` properties as well as [`useHead`](https://nuxt.com/docs/api/composables/use-head) , as they may conflict.

For more information on how to use this composable, see [the Nuxt 3 docs](https://nuxt.com/docs/getting-started/seo-meta).

### Explicit Imports

Nuxt exposes every auto-import with the `#imports` alias that can be used to make the import explicit if needed:

```vue
<script setup lang="ts">
import { ref, computed } from '#imports'

const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Disabling Auto-imports

If you want to disable auto-importing composables and utilities, you can set `imports.autoImport` to `false` in the `nuxt.config` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    autoImport: false
  }
})
```

This will disable auto-imports completely but it's still possible to use [explicit imports](https://nuxt.com/#explicit-imports) from `#imports`.


# Meta Tags

If you need to access the component state with `head`, you should migrate to using [`useHead`](https://nuxt.com/docs/api/composables/use-head) .

If you need to use the Options API, there is a `head()` method you can use when you use `defineNuxtComponent`.

## Migration

### Set `bridge.meta`

```js
import { defineNuxtConfig } from '@nuxt/bridge'
export default defineNuxtConfig({
  bridge: {
    meta: true,
    nitro: false // If migration to Nitro is complete, set to true
  }
})
```

### Update head properties

In your `nuxt.config`, rename `head` to `app.head`. (Note that objects no longer have a `hid` key for deduplication.)

::code-group
```ts [Nuxt 2]
export default {
  head: {
    titleTemplate: '%s - Nuxt',
    meta: [
      { charset: 'utf-8' },
      { name: 'viewport', content: 'width=device-width, initial-scale=1' },
      { hid: 'description', name: 'description', content: 'Meta description' }
    ]
  }
}
```

```ts [Nuxt 3]
export default defineNuxtConfig({
  app: {
    head: {
      titleTemplate: '%s - Nuxt',
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { name: 'description', content: 'Meta description' }
      ]
    }
  }
})
```
::

## `useHead` Composables

Nuxt Bridge provides a new Nuxt 3 meta API that can be accessed with a new [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable.

```vue
<script setup lang="ts">
useHead({
  title: 'My Nuxt App',
})
</script>
```

::tip
This [`useHead`](https://nuxt.com/docs/api/composables/use-head) composable uses `@unhead/vue` under the hood (rather than `vue-meta`) to manipulate your `<head>`.
::

::warning
We recommend not using the native Nuxt 2 `head()` properties in addition to [`useHead`](https://nuxt.com/docs/api/composables/use-head) , as they may conflict.
::

For more information on how to use this composable, see [the docs](https://nuxt.com/docs/getting-started/seo-meta).

## Options API

```vue
<script>
// if using options API `head` method you must use `defineNuxtComponent`
export default defineNuxtComponent({
  head (nuxtApp) {
    // `head` receives the nuxt app but cannot access the component instance
    return {
      meta: [{
        name: 'description',
        content: 'This is my page description.'
      }]
    }
  }
})
</script>
```

::warning
Possible breaking change: `head` receives the nuxt app but cannot access the component instance. If the code in your `head` tries to access the data object through `this` or `this.$data`, you will need to migrate to the `useHead` composable.
::

## Title Template

If you want to use a function (for full control), then this cannot be set in your nuxt.config, and it is recommended instead to set it within your `/layouts` directory.

```vue [app/layouts/default.vue]
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} - Site Title` : 'Site Title';
  }
})
</script>
```


# Runtime Config

::warning
When using `runtimeConfig` option, [nitro](https://nuxt.com/docs/bridge/nitro) must have been configured.
::

## Update Runtime Config

Nuxt 3 approaches runtime config differently than Nuxt 2, using a new combined `runtimeConfig` option.

First, you'll need to combine your `publicRuntimeConfig` and `privateRuntimeConfig` properties into a new one called `runtimeConfig`, with the public config within a key called `public`.

```diff
// nuxt.config.js
- privateRuntimeConfig: {
-   apiKey: process.env.NUXT_API_KEY || 'super-secret-key'
- },
- publicRuntimeConfig: {
-   websiteURL: 'https://public-data.com'
- }
+ runtimeConfig: {
+   apiKey: process.env.NUXT_API_KEY || 'super-secret-key',
+   public: {
+     websiteURL: 'https://public-data.com'
+   }
+ }
```

This also means that when you need to access public runtime config, it's behind a property called `public`. If you use public runtime config, you'll need to update your code.

```diff
// MyWidget.vue
- <div>Website: {{ $config.websiteURL }}</div>
+ <div>Website: {{ $config.public.websiteURL }}</div>
```


# Nitro

## Remove Modules

- Remove `@nuxt/nitro`: Bridge injects same functionality

## Update Config

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    nitro: true
  }
})
```

## Update Your Scripts

You will also need to update your scripts within your `package.json` to reflect the fact that Nuxt will now produce a Nitro server as build output.

### Install Nuxi

Install `nuxi` as a development dependency:

::code-group{sync="pm"}
```bash [npm]
npm install -D nuxi
```

```bash [yarn]
yarn add --dev nuxi
```

```bash [pnpm]
pnpm add -D nuxi
```

```bash [bun]
bun add -D nuxi
```
::

### Nuxi

Nuxt 3 introduced the new Nuxt CLI command [`nuxi`](https://nuxt.com/docs/api/commands/add). Update your scripts as follows to leverage the better support from Nuxt Bridge:

```diff
{
  "scripts": {
-   "dev": "nuxt",
+   "dev": "nuxi dev",
-   "build": "nuxt build",
+   "build": "nuxi build",
-   "start": "nuxt start",
+   "start": "nuxi preview"
  }
}
```

::tip
If `nitro: false`, use the `nuxt2` command.
::

### Static Target

If you have set `target: 'static'` in your `nuxt.config` then you need to ensure that you update your build script to be `nuxi generate`.

```json [package.json]
{
  "scripts": {
    "build": "nuxi generate"
  }
}
```

### Server Target

For all other situations, you can use the `nuxi build` command.

```json [package.json]
{
  "scripts": {
    "build": "nuxi build",
    "start": "nuxi preview"
  }
}
```

## Exclude Built Nitro Folder From Git

Add the folder `.output` to the `.gitignore` file.

## Ensure Everything Goes Well

✔️ Try with `nuxi dev` and `nuxi build` (or `nuxi generate`) to see if everything goes well.


# Vite

::warning
When using `vite`, [nitro](https://nuxt.com/docs/bridge/nitro) must have been configured.
::

## Remove Modules

- Remove `nuxt-vite`: Bridge enables same functionality

## Update Config

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    vite: true,
    nitro: true
  }
})
```

## Configuration

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  vite: {
    // Config for Vite
  }
})
```


# Overview

There are significant changes when migrating a Nuxt 2 app to Nuxt 3, although you can expect migration to become more straightforward as we move toward a stable release.

::note
This migration guide is under progress to align with the development of Nuxt 3.
::

Some of these significant changes include:

1. Moving from Vue 2 to Vue 3, including defaulting to the Composition API and script setup.
2. Moving from webpack 4 and Babel to Vite or webpack 5 and esbuild.
3. Moving from a runtime Nuxt dependency to a minimal, standalone server compiled with nitropack.

::tip
If you need to remain on Nuxt 2, but want to benefit from Nuxt 3 features in Nuxt 2, you can alternatively check out [how to get started with Bridge](https://nuxt.com/docs/bridge/overview).
::

## Next Steps

- Learn about differences in [configuration](https://nuxt.com/docs/migration/configuration)


# Build Tooling

We use the following build tools by default:

- [Vite](https://vite.dev){rel="nofollow"} or [webpack](https://webpack.js.org){rel="nofollow"}
- [Rollup](https://rollupjs.org){rel="nofollow"}
- [PostCSS](https://postcss.org){rel="nofollow"}
- [esbuild](https://esbuild.github.io){rel="nofollow"}

For this reason, most of your previous `build` configuration in `nuxt.config` will now be ignored, including any custom babel configuration.

If you need to configure any of Nuxt's build tools, you can do so in your `nuxt.config`, using the new top-level `vite`, `webpack` and `postcss` keys.

In addition, Nuxt ships with TypeScript support.

::read-more{to="https://nuxt.com/docs/guide/concepts/typescript"}
::

## Steps

1. Remove `@nuxt/typescript-build` and `@nuxt/typescript-runtime` from your dependencies and modules.
2. Remove any unused babel dependencies from your project.
3. Remove any explicit core-js dependencies.
4. Migrate `require` to `import`.


# Server

In a built Nuxt 3 application, there is no runtime Nuxt dependency. That means your site will be highly performant, and ultra-slim. But it also means you can no longer hook into runtime Nuxt server hooks.

::read-more{to="https://nuxt.com/docs/guide/concepts/server-engine"}
::

## Steps

1. Remove the `render` key in your `nuxt.config`.
2. Any files in `~/server/api` and `~/server/middleware` will be automatically registered; you can remove them from your `serverMiddleware` array.
3. Update any other items in your `serverMiddleware` array to point to files or npm packages directly, rather than using inline functions.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/server"}
::

::read-more
---
to: https://nuxt.com/docs/guide/going-further/hooks#server-hooks-runtime
---
::


# Configuration

## `nuxt.config`

The starting point for your Nuxt app remains your `nuxt.config` file.

::note
Nuxt configuration will be loaded using [`unjs/jiti`](https://github.com/unjs/jiti){rel="nofollow"} and [`unjs/c12`](https://github.com/unjs/c12){rel="nofollow"}.
::

### Migration

1. You should migrate to the new `defineNuxtConfig` function that provides a typed configuration schema. :code-group[```ts \[Nuxt 2\]
   export default {
     // ...
   }
   ``````ts \[Nuxt 3\]
   export default defineNuxtConfig({
     // ...
   })
   ```]
2. If you were using `router.extendRoutes` you can migrate to the new `pages:extend` hook: :code-group[```ts \[Nuxt 2\]
   export default {
     router: {
       extendRoutes (routes) {
         //
       }
     }
   }
   ``````ts \[Nuxt 3\]
   export default defineNuxtConfig({
     hooks: {
       'pages:extend' (routes) {
         //
       }
     }
   })
   ```]
3. If you were using `router.routeNameSplitter` you can achieve same result by updating route name generation logic in the new `pages:extend` hook: :code-group[```ts \[Nuxt 2\]
   export default {
     router: {
       routeNameSplitter: '/'
     }
   }
   ``````ts \[Nuxt 3\]
   import { createResolver } from '@nuxt/kit'

   export default defineNuxtConfig({
     hooks: {
       'pages:extend' (routes) {
         const routeNameSplitter = '/'
         const root = createResolver(import.meta.url).resolve('./pages')

         function updateName(routes) {
           if (!routes) return

           for (const route of routes) {
             const relativePath = route.file.substring(root.length + 1)
             route.name = relativePath.slice(0, -4).replace(/\/index$/, '').replace(/\//g, routeNameSplitter)

             updateName(route.children)
           }
         }
         updateName(routes)
       },
     },
   })
   ```]

#### ESM Syntax

Nuxt 3 is an [ESM native framework](https://nuxt.com/docs/guide/concepts/esm). Although [`unjs/jiti`](https://github.com/unjs/jiti){rel="nofollow"} provides semi compatibility when loading `nuxt.config` file, avoid any usage of `require` and `module.exports` in this file.

1. Change `module.exports` to `export default`
2. Change `const lib = require('lib')` to `import lib from 'lib'`

#### Async Configuration

In order to make Nuxt loading behavior more predictable, async config syntax is deprecated. Consider using Nuxt hooks for async operations.

#### Dotenv

Nuxt has built-in support for loading `.env` files. Avoid directly importing it from `nuxt.config`.

## Modules

Nuxt and Nuxt Modules are now build-time-only.

### Migration

1. Move all your `buildModules` into `modules`.
2. Check for Nuxt 3 compatibility of modules.
3. If you have any local modules pointing to a directory you should update this to point to the entry file:

```diff
  export default defineNuxtConfig({
    modules: [
-     '~/modules/my-module'
+     '~/modules/my-module/index'
    ]
  })
```

::tip
If you are a module author, you can check out [more information about module compatibility](https://nuxt.com/docs/migration/module-authors) and [our module author guide](https://nuxt.com/docs/guide/going-further/modules).
::

## Directory Changes

The `static/` (for storing static assets) has been renamed to `public/`. You can either rename your `static` directory to `public`, or keep the name by setting `dir.public` in your `nuxt.config`.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/public"}
::

## TypeScript

It will be much easier to migrate your application if you use Nuxt's TypeScript integration. This does not mean you need to write your application in TypeScript, just that Nuxt will provide automatic type hints for your editor.

You can read more about Nuxt's TypeScript support [in the docs](https://nuxt.com/docs/guide/concepts/typescript).

::note
Nuxt can type-check your app using [`vue-tsc`](https://github.com/vuejs/language-tools/tree/master/packages/tsc){rel="nofollow"} with `nuxt typecheck` command.
::

### Migration

1. Create a `tsconfig.json` with the following content:
   ```json
   {
     "files": [],
     "references": [
       {
         "path": "./.nuxt/tsconfig.app.json"
       },
       {
         "path": "./.nuxt/tsconfig.server.json"
       },
       {
         "path": "./.nuxt/tsconfig.shared.json"
       },
       {
         "path": "./.nuxt/tsconfig.node.json"
       }
     ]
   }
   ```
2. Run `npx nuxt prepare` to generate the tsconfig files.
3. Install Volar following the instructions in the [docs](https://nuxt.com/docs/getting-started/introduction#prerequisites).

## Vue Changes

There are a number of changes to what is recommended Vue best practice, as well as a number of breaking changes between Vue 2 and 3.

It is recommended to read the [Vue 3 migration guide](https://v3-migration.vuejs.org){rel="nofollow"} and in particular the [breaking changes list](https://v3-migration.vuejs.org/breaking-changes){rel="nofollow"}.

It is not currently possible to use the [Vue 3 migration build](https://v3-migration.vuejs.org/migration-build.html){rel="nofollow"} with Nuxt 3.

## Vuex

Nuxt no longer provides a Vuex integration. Instead, the official Vue recommendation is to use `pinia`, which has built-in Nuxt support via a [Nuxt module](https://pinia.vuejs.org/ssr/nuxt.html){rel="nofollow"}. [Find out more about pinia here](https://pinia.vuejs.org){rel="nofollow"}.

A simple way to provide global state management with pinia would be:

Install the [`@pinia/nuxt`](https://nuxt.com/modules/pinia) module:

```bash [Terminal]
yarn add pinia @pinia/nuxt
```

Enable the module in your nuxt configuration:

```ts [nuxt.config.ts]
import { defineNuxtConfig } from 'nuxt/config';

export default defineNuxtConfig({
  modules: ['@pinia/nuxt']
})
```

Create a `store` folder at the root of your application:

```ts [store/index.ts]
import { defineStore } from 'pinia'

export const useMainStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  actions: {
    increment() {
      // `this` is the store instance
      this.counter++
    },
  },
})
```

Create a [plugin](https://nuxt.com/docs/guide/directory-structure/plugins) file to globalize your store:

```ts [app/plugins/pinia.ts]
import { useMainStore } from '~/store'

export default defineNuxtPlugin(({ $pinia }) => {
  return {
    provide: {
      store: useMainStore($pinia)
    }
  }
})
```

If you want to keep using Vuex, you can manually migrate to Vuex 4 following [these steps](https://vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html){rel="nofollow"}.

Once it's done you will need to add the following plugin to your Nuxt app:

```ts [app/plugins/vuex.ts]
import store from '~/store'

export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.vueApp.use(store);
})
```

For larger apps, this migration can entail a lot of work. If updating Vuex still creates roadblocks, you may want to use the community module: [nuxt3-vuex-module](https://github.com/vedmant/nuxt3-vuex#nuxt3-vuex-module){rel="nofollow"}, which should work out of the box.


# Modules

## Module Compatibility

Nuxt 3 has a basic backward compatibility layer for Nuxt 2 modules using `@nuxt/kit` auto wrappers. But there are usually steps to follow to make modules compatible with Nuxt 3 and sometimes, using Nuxt Bridge is required for cross-version compatibility.

We have prepared a [Dedicated Guide](https://nuxt.com/docs/guide/going-further/modules) for authoring Nuxt 3 ready modules using `@nuxt/kit`. Currently best migration path is to follow it and rewrite your modules. Rest of this guide includes preparation steps if you prefer to avoid a full rewrite yet making modules compatible with Nuxt 3.

::tip{icon="i-lucide-puzzle" to="https://nuxt.com/modules"}
Explore Nuxt 3 compatible modules.
::

### Plugin Compatibility

Nuxt 3 plugins are **not** fully backward compatible with Nuxt 2.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

### Vue Compatibility

Plugins or components using the Composition API need exclusive Vue 2 or Vue 3 support.

By using [vue-demi](https://github.com/vueuse/vue-demi){rel="nofollow"} they should be compatible with both Nuxt 2 and 3.

## Module Migration

When Nuxt 3 users add your module, you will not have access to the module container (`this.*`) so you will need to use utilities from `@nuxt/kit` to access the container functionality.

### Test with `@nuxt/bridge`

Migrating to `@nuxt/bridge` is the first and most important step for supporting Nuxt 3.

If you have a fixture or example in your module, add `@nuxt/bridge` package to its config (see [example](https://nuxt.com/docs/bridge/overview#update-nuxtconfig))

### Migrate from CommonJS to ESM

Nuxt 3 natively supports TypeScript and ECMAScript Modules. Please check [Native ES Modules](https://nuxt.com/docs/guide/concepts/esm) for more info and upgrading.

### Ensure Plugins Default Export

If you inject a Nuxt plugin that does not have `export default` (such as global Vue plugins), ensure you add `export default () => { }` to the end of it.

::code-group
```js [Before]
// ~/plugins/vuelidate.js
import Vue from 'vue'
import Vuelidate from 'vuelidate'

Vue.use(Vuelidate)
```

```js [After]
// ~/plugins/vuelidate.js
import Vue from 'vue'
import Vuelidate from 'vuelidate'

Vue.use(Vuelidate)

export default () => { }
```
::

### Avoid Runtime Modules

With Nuxt 3, Nuxt is now a build-time-only dependency, which means that modules shouldn't attempt to hook into the Nuxt runtime.

Your module should work even if it's only added to [`buildModules`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig) (instead of `modules`). For example:

- Avoid updating `process.env` within a Nuxt module and reading by a Nuxt plugin; use [`runtimeConfig`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig) instead.
- (\*) Avoid depending on runtime hooks like `vue-renderer:*` for production
- (\*) Avoid adding `serverMiddleware` by importing them inside the module. Instead, add them by referencing a file path so that they are independent of the module's context

(\*) Unless it is for `nuxt dev` purpose only and guarded with `if (nuxt.options.dev) { }`.

::tip
Continue reading about Nuxt 3 modules in the [Modules Author Guide](https://nuxt.com/docs/guide/going-further/modules).
::

### Use TypeScript (Optional)

While it is not essential, most of the Nuxt ecosystem is shifting to use TypeScript, so it is highly recommended to consider migration.

::tip
You can start migration by renaming `.js` files, to `.ts`. TypeScript is designed to be progressive!
::

::tip
You can use TypeScript syntax for Nuxt 2 and 3 modules and plugins without any extra dependencies.
::


# Auto Imports

::note
In the rest of the migration documentation, you will notice that key Nuxt and Vue utilities do not have explicit imports. This is not a typo; Nuxt will automatically import them for you, and you should get full type hinting if you have followed [the instructions](https://nuxt.com/docs/migration/configuration#typescript) to use Nuxt's TypeScript support.
::

[Read more about auto imports](https://nuxt.com/docs/guide/concepts/auto-imports)

## Migration

1. If you have been using `@nuxt/components` in Nuxt 2, you can remove `components: true` in your `nuxt.config`. If you had a more complex setup, then note that the component options have changed somewhat. See the [components documentation](https://nuxt.com/docs/guide/directory-structure/app/components) for more information.

::tip
You can look at `.nuxt/types/components.d.ts` and `.nuxt/types/imports.d.ts` to see how Nuxt has resolved your components and composable auto-imports.
::


# Meta Tags

Nuxt 3 provides several different ways to manage your meta tags:

1. Through your `nuxt.config`.
2. Through the [`useHead`](https://nuxt.com/docs/api/composables/use-head) [composable](https://nuxt.com/docs/getting-started/seo-meta)
3. Through [global meta components](https://nuxt.com/docs/getting-started/seo-meta)

You can customize `title`, `titleTemplate`, `base`, `script`, `noscript`, `style`, `meta`, `link`, `htmlAttrs` and `bodyAttrs`.

::tip
Nuxt currently uses [`Unhead`](https://github.com/unjs/unhead){rel="nofollow"} to manage your meta tags, but implementation details may change.
::

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Migration

1. In your `nuxt.config`, rename `head` to `meta`. Consider moving this shared meta configuration into your `app.vue` instead. (Note that objects no longer have a `hid` key for deduplication.)
2. If you need to access the component state with `head`, you should migrate to using [`useHead`](https://nuxt.com/docs/api/composables/use-head) . You might also consider using the built-in meta-components.
3. If you need to use the Options API, there is a `head()` method you can use when you use `defineNuxtComponent`.

### useHead

::code-group
```vue [Nuxt 2]
<script>
export default {
  data: () => ({
    title: 'My App',
    description: 'My App Description'
  })
  head () {
    return {
      title: this.title,
      meta: [{
        hid: 'description',
        name: 'description',
        content: this.description
      }]
    }
  }
}
</script>
```

```vue [Nuxt 3]
<script setup lang="ts">
const title = ref('My App')
const description = ref('My App Description')

// This will be reactive when you change title/description above
useHead({
  title,
  meta: [{
    name: 'description',
    content: description
  }]
})
</script>
```
::

### Meta-components

Nuxt 3 also provides meta components that you can use to accomplish the same task. While these components look similar to HTML tags, they are provided by Nuxt and have similar functionality.

::code-group
```vue [Nuxt 2]
<script>
export default {
  head () {
    return {
      title: 'My App',
      meta: [{
        hid: 'description',
        name: 'description',
        content: 'My App Description'
      }]
    }
  }
}
</script>
```

```vue [Nuxt 3]
<template>
  <div>
    <Head>
      <Title>My App</Title>
      <Meta name="description" content="My app description"/>
    </Head>
    <!-- -->
  </div>
</template>
```
::

::important
1. Make sure you use capital letters for these component names to distinguish them from native HTML elements (`<Title>` rather than `<title>`).
2. You can place these components anywhere in your template for your page.
::

### Options API

```vue [Nuxt 3 (Options API)]
<script>
// if using options API `head` method you must use `defineNuxtComponent`
export default defineNuxtComponent({
  head (nuxtApp) {
    // `head` receives the nuxt app but cannot access the component instance
    return {
      meta: [{
        name: 'description',
        content: 'This is my page description.'
      }]
    }
  }
})
</script>
```


# Plugins and Middleware

## Plugins

Plugins now have a different format, and take only one argument (`nuxtApp`).

::code-group
```js [Nuxt 2]
export default (ctx, inject) => {
  inject('injected', () => 'my injected function')
})
```

```ts [Nuxt 3]
export default defineNuxtPlugin(nuxtApp => {
  // now available on `nuxtApp.$injected`
  nuxtApp.provide('injected', () => 'my injected function')

  // You can alternatively use this format, which comes with automatic type support
  return {
    provide: {
      injected: () => 'my injected function'
    }
  }
})
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

::read-more{to="https://nuxt.com/docs/api/composables/use-nuxt-app"}
Read more about the format of `nuxtApp`.
::

### Migration

1. Migrate your plugins to use the `defineNuxtPlugin` helper function.
2. Remove any entries in your `nuxt.config` plugins array that are located in your `app/plugins/` folder. All files in this directory at the top level (and any index files in any subdirectories) will be automatically registered. Instead of setting `mode` to `client` or `server`, you can indicate this in the file name. For example, `~/plugins/my-plugin.client.ts` will only be loaded on client-side.

## Route Middleware

Route middleware has a different format.

::code-group
```js [Nuxt 2]
export default function ({ store, redirect }) {
  // If the user is not authenticated
  if (!store.state.authenticated) {
    return redirect('/login')
  }
}
```

```ts [Nuxt 3]
export default defineNuxtRouteMiddleware((to, from) => {
  const auth = useState('auth')
  if (!auth.value.authenticated) {
    return navigateTo('/login')
  }
})
```
::

Much like Nuxt 2, route middleware placed in your `~/middleware` folder is automatically registered. You can then specify it by name in a component. However, this is done with `definePageMeta` rather than as a component option.

`navigateTo` is one of a number of route helper functions.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app/middleware"}
::

### Migration

1. Migrate your route middleware to use the `defineNuxtRouteMiddleware` helper function.
2. Any global middleware (such as in your `nuxt.config`) can be placed in your `~/middleware` folder with a `.global` extension, for example `~/middleware/auth.global.ts`.


# Pages and Layouts

## `app.vue`

Nuxt 3 provides a central entry point to your app via `~/app.vue`.

::note
If you don't have an `app.vue` file in your source directory, Nuxt will use its own default version.
::

This file is a great place to put any custom code that needs to be run once when your app starts up, as well as any components that are present on every page of your app. For example, if you only have one layout, you can move this to `app.vue` instead.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app"}
::

::link-example{to="https://nuxt.com/docs/examples/hello-world"}
::

### Migration

Consider creating an `app.vue` file and including any logic that needs to run once at the top-level of your app. You can check out [an example here](https://nuxt.com/docs/guide/directory-structure/app).

## Layouts

If you are using layouts in your app for multiple pages, there is only a slight change required.

In Nuxt 2, the `<Nuxt>` component is used within a layout to render the current page. In Nuxt 3, layouts use slots instead, so you will have to replace that component with a `<slot />`. This also allows advanced use cases with named and scoped slots. [Read more about layouts](https://nuxt.com/docs/guide/directory-structure/app/layouts).

You will also need to change how you define the layout used by a page using the `definePageMeta` compiler macro. Layouts will be kebab-cased. So `app/layouts/customLayout.vue` becomes `custom-layout` when referenced in your page.

### Migration

1. Replace `<Nuxt />` with `<slot />`
   ```diff [app/layouts/custom.vue]
     <template>
       <div id="app-layout">
         <main>
   -       <Nuxt />
   +       <slot />
         </main>
       </div>
     </template>
   ```
2. Use [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) to select the layout used by your page.

   ```diff [app/pages/index.vue]
   + <script setup>
   + definePageMeta({
   +   layout: 'custom'
   + })
   - <script>
   - export default {
   -   layout: 'custom'
   - }
     </script>
   ```
3. Move `~/layouts/_error.vue` to `~/error.vue`. See [the error handling docs](https://nuxt.com/docs/getting-started/error-handling). If you want to ensure that this page uses a layout, you can use [`<NuxtLayout>`](https://nuxt.com/docs/guide/directory-structure/app/layouts) directly within `error.vue`:

   ```vue [error.vue]
   <template>
     <div>
       <NuxtLayout name="default">
         <!-- -->
       </NuxtLayout>
     </div>
   </template>
   ```

## Pages

Nuxt 3 ships with an optional `vue-router` integration triggered by the existence of a [`app/pages/`](https://nuxt.com/docs/guide/directory-structure/app/pages) directory in your source directory. If you only have a single page, you may consider instead moving it to `app.vue` for a lighter build.

### Dynamic Routes

The format for defining dynamic routes in Nuxt 3 is slightly different from Nuxt 2, so you may need to rename some of the files within `app/pages/`.

1. Where you previously used `_id` to define a dynamic route parameter you now use `[id]`.
2. Where you previously used `_.vue` to define a catch-all route, you now use `[...slug].vue`.

### Nested Routes

In Nuxt 2, you will have defined any nested routes (with parent and child components) using `<Nuxt>` and `<NuxtChild>`. In Nuxt 3, these have been replaced with a single `<NuxtPage>` component.

### Page Keys and Keep-alive Props

If you were passing a custom page key or keep-alive props to `<Nuxt>`, you will now use `definePageMeta` to set these options.

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/app/pages#special-metadata
---
::

### Page and Layout Transitions

If you have been defining transitions for your page or layout directly in your component options, you will now need to use `definePageMeta` to set the transition. Since Vue 3, [-enter and -leave CSS classes have been renamed](https://v3-migration.vuejs.org/breaking-changes/transition.html){rel="nofollow"}. The `style` prop from `<Nuxt>` no longer applies to transition when used on `<slot>`, so move the styles to your `-active` class.

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

### Migration

1. Rename any pages with dynamic parameters to match the new format.
2. Update `<Nuxt>` and `<NuxtChild>` to be `<NuxtPage>`.
3. If you're using the Composition API, you can also migrate `this.$route` and `this.$router` to use [`useRoute`](https://nuxt.com/docs/api/composables/use-route) and [`useRouter`](https://nuxt.com/docs/api/composables/use-router) composables.

#### Example: Dynamic Routes

::code-group
```text [Nuxt 2]
- URL: /users
- Page: /pages/users/index.vue

- URL: /users/some-user-name
- Page: /pages/users/_user.vue
- Usage: params.user

- URL: /users/some-user-name/edit
- Page: /pages/users/_user/edit.vue
- Usage: params.user

- URL: /users/anything-else
- Page: /pages/users/_.vue
- Usage: params.pathMatch
```

```text [Nuxt 3]
- URL: /users
- Page: /pages/users/index.vue

- URL: /users/some-user-name
- Page: /pages/users/[user].vue
- Usage: params.user

- URL: /users/some-user-name/edit
- Page: /pages/users/[user]/edit.vue
- Usage: params.user

- URL: /users/anything-else
- Page: /pages/users/[...slug].vue
- Usage: params.slug
```
::

#### Example: Nested Routes and `definePageMeta`

::code-group
```vue [Nuxt 2]
<template>
  <div>
    <NuxtChild keep-alive :keep-alive-props="{ exclude: ['modal'] }" :nuxt-child-key="$route.slug" />
  </div>
</template>

<script>
export default {
  transition: 'page' // or { name: 'page' }
}
</script>
```

```vue [Nuxt 3]
<template>
  <div>
    <NuxtPage />
  </div>
</template>

<script setup lang="ts">
// This compiler macro works in both <script> and <script setup>
definePageMeta({
  // you can also pass a string or a computed property
  key: route => route.slug,
  transition: {
    name: 'page',
  },
  keepalive: {
    exclude: ['modal']
  },
})
</script>
```
::

## `<NuxtLink>` Component

Most of the syntax and functionality are the same for the global [NuxtLink](https://nuxt.com/docs/api/components/nuxt-link) component. If you have been using the shortcut `<NLink>` format, you should update this to use `<NuxtLink>`.

`<NuxtLink>` is now a drop-in replacement for *all* links, even external ones. You can read more about it, and how to extend it to provide your own link component.

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
::

## Programmatic Navigation

When migrating from Nuxt 2 to Nuxt 3, you will have to update how you programmatically navigate your users. In Nuxt 2, you had access to the underlying Vue Router with `this.$router`. In Nuxt 3, you can use the `navigateTo()` utility method which allows you to pass a route and parameters to Vue Router.

::warning
Make sure to always `await` on [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) or chain its result by returning from functions.
::

::code-group
```vue [Nuxt 2]
<script>
export default {
  methods: {
    navigate(){
      this.$router.push({
        path: '/search',
        query: {
          name: 'first name',
          type: '1'
        }
      })
    }
  }
}
</script>
```

```vue [Nuxt 3]
<script setup lang="ts">
function navigate(){
  return navigateTo({
    path: '/search',
    query: {
      name: 'first name',
      type: '1'
    }
  })
}
</script>
```
::


# Component Options

## `asyncData` and `fetch`

Nuxt 3 provides new options for [fetching data from an API](https://nuxt.com/docs/getting-started/data-fetching).

### Isomorphic Fetch

In Nuxt 2 you might use `@nuxtjs/axios` or `@nuxt/http` to fetch your data - or just the polyfilled global `fetch`.

In Nuxt 3 you can use a globally available `fetch` method that has the same API as [the Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch){rel="nofollow"} or [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) method which is using [unjs/ofetch](https://github.com/unjs/ofetch){rel="nofollow"}. It has a number of benefits, including:

1. It will handle 'smartly' making [direct API calls](https://nuxt.com/docs/guide/concepts/server-engine#direct-api-calls) if it's running on the server, or making a client-side call to your API if it's running on the client. (It can also handle calling third-party APIs.)
2. Plus, it comes with convenience features including automatically parsing responses and stringifying data.

You can read more [about direct API calls](https://nuxt.com/docs/guide/concepts/server-engine#direct-api-calls) or [fetching data](https://nuxt.com/docs/getting-started/data-fetching).

### Composables

Nuxt 3 provides new composables for fetching data: [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) and `useFetch`. They each have 'lazy' variants (`useLazyAsyncData` and `useLazyFetch`), which do not block client-side navigation.

In Nuxt 2, you'd fetch your data in your component using a syntax similar to:

```ts
export default {
  async asyncData({ params, $http }) {
    const post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
    return { post }
  },
  // or alternatively
  fetch () {
    this.post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
  }
}
```

Within your methods and templates, you could use the `post` variable similar how you'd use any other piece of data provided by your component.

With Nuxt 3, you can perform this data fetching using composables in your `setup()` method or `<script setup>` tag:

```vue
<script setup lang="ts">
// Define params wherever, through `defineProps()`, `useRoute()`, etc.
const { data: post, refresh } = await useAsyncData('post', () => $fetch(`https://api.nuxtjs.dev/posts/${params.id}`) )
// Or instead - useFetch is a convenience wrapper around useAsyncData when you're just performing a simple fetch
const { data: post, refresh } = await useFetch(`https://api.nuxtjs.dev/posts/${params.id}`)
</script>
```

You can now use `post` inside of your Nuxt 3 template, or call `refresh` to update the data.

::note
Despite the names, [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) is not a direct replacement of the `fetch()` hook. Rather, [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) replaces both hooks and is more customizable; it can do more than simply fetching data from an endpoint. [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) is a convenience wrapper around [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) for simply fetching data from an endpoint.
::

### Migration

1. Replace the `asyncData` hook with [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) or [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) in your page/component.
2. Replace the `fetch` hook with [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) or [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) in your component.

## `head`

::read-more{to="https://nuxt.com/docs/migration/meta"}
::

## `key`

You can now define a key within the [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) compiler macro.

```diff [app/pages/index.vue]
- <script>
- export default {
-   key: 'index'
-   // or a method
-   // key: route => route.fullPath
- }
+ <script setup>
+ definePageMeta({
+   key: 'index'
+   // or a method
+   // key: route => route.fullPath
+ })
</script>
```

## `layout`

::read-more{to="https://nuxt.com/docs/migration/pages-and-layouts"}
::

## `loading`

This feature is not yet supported in Nuxt 3.

## `middleware`

::read-more{to="https://nuxt.com/docs/migration/plugins-and-middleware"}
::

## `scrollToTop`

This feature is not yet supported in Nuxt 3. If you want to overwrite the default scroll behavior of `vue-router`, you can do so in an `~/router.options.ts` (see [docs](https://nuxt.com/docs/guide/recipes/custom-routing#router-options)) for more info.
Similar to `key`, specify it within the [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) compiler macro.

```diff [app/pages/index.vue]
- <script>
- export default {
-   scrollToTop: false
- }
+ <script setup>
+ definePageMeta({
+   scrollToTop: false
+ })
</script>
```

## `transition`

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

## `validate`

The validate hook in Nuxt 3 only accepts a single argument, the `route`. Just as in Nuxt 2, you can return a boolean value. If you return false and another match can't be found, this will mean a 404. You can also directly return an object with `statusCode`/`statusMessage` to respond immediately with an error (other matches will not be checked).

```diff [app/pages/users/[id\\].vue]
- <script>
- export default {
-   async validate({ params }) {
-     return /^\d+$/.test(params.id)
-   }
- }
+ <script setup>
+ definePageMeta({
+   validate: async (route) => {
+     const nuxtApp = useNuxtApp()
+     return /^\d+$/.test(route.params.id)
+   }
+ })
  </script>
```

## `watchQuery`

This is not supported in Nuxt 3. Instead, you can directly use a watcher to trigger refetching data.

```vue [app/pages/users/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data, refresh } = await useFetch('/api/user')
watch(() => route.query, () => refresh())
</script>
```


# Runtime Config

If you wish to reference environment variables within your Nuxt 3 app, you will need to use runtime config.

When referencing these variables within your components, you will have to use the [`useRuntimeConfig`](https://nuxt.com/docs/api/composables/use-runtime-config) composable in your setup method (or Nuxt plugin).

In the `server/` portion of your app, you can use [`useRuntimeConfig`](https://nuxt.com/docs/api/composables/use-runtime-config) without any import.

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## Migration

1. Add any environment variables that you use in your app to the `runtimeConfig` property of the `nuxt.config` file.
2. Migrate `process.env` to [`useRuntimeConfig`](https://nuxt.com/docs/api/composables/use-runtime-config) throughout the Vue part of your app.

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // Private config that is only available on the server
    apiSecret: '123',
    // Config within public will be also exposed to the client
    public: {
      apiBase: '/api'
    }
  }
})
```

```vue [app/pages/index.vue]
<script setup lang="ts">
const config = useRuntimeConfig()

// instead of process.env you will now access config.public.apiBase
console.log(config.public.apiBase)
</script>
```

```ts [server/api/hello.ts]
export default defineEventhandler((event) => {
  const config = useRuntimeConfig(event)
  // In server, you can now access config.apiSecret, in addition to config.public
  console.log(config.apiSecret)
  console.log(config.public.apiBase)
})
```

```ini [.env]
# Runtime config values are automatically replaced by matching environment variables at runtime
NUXT_API_SECRET=api_secret_token
NUXT_PUBLIC_API_BASE=https://nuxtjs.org
```
::


# Nuxt Docs

This repository contains the documentation of Nuxt hosted on <https://nuxt.com/docs>{rel="nofollow"}

## Contributing

Have a look at <https://github.com/nuxt/nuxt.com>{rel="nofollow"} to run the website locally.


# Introduction

Nuxt là một framework miễn phí và [mã nguồn mở](https://github.com/nuxt/nuxt){rel="nofollow"} với cách thức trực quan và có thể mở rộng để tạo ra các ứng dụng web full-stack và website an toàn kiểu dữ liệu, hiệu suất cao và sẵn sàng cho production với [Vue.js](https://vuejs.org){rel="nofollow"}.

Chúng tôi đã làm mọi thứ để bạn có thể bắt đầu viết các file `.vue` ngay từ đầu trong khi tận hưởng hot module replacement trong quá trình phát triển và một ứng dụng hiệu suất cao trong production với server-side rendering theo mặc định.

Nuxt không có vendor lock-in, cho phép bạn deploy ứng dụng của mình [**ở mọi nơi, thậm chí trên edge**](https://nuxt.com/blog/nuxt-on-the-edge).

::tip
Nếu bạn muốn thử nghiệm với Nuxt trên trình duyệt, bạn có thể [thử nó trong một trong những sandbox online của chúng tôi](https://nuxt.com/docs/getting-started/installation#play-online).
::

## Automation and Conventions

Nuxt sử dụng các quy ước và cấu trúc thư mục có ý kiến để tự động hóa các tác vụ lặp đi lặp lại và cho phép các developer tập trung vào việc phát triển tính năng. File cấu hình vẫn có thể tùy chỉnh và ghi đè các hành vi mặc định của nó.

- **File-based routing:** định nghĩa các route dựa trên cấu trúc thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) của bạn. Điều này có thể giúp tổ chức ứng dụng dễ dàng hơn và tránh việc phải cấu hình route thủ công.
- **Code splitting:** Nuxt tự động chia code của bạn thành các chunk nhỏ hơn, điều này có thể giúp giảm thời gian tải ban đầu của ứng dụng.
- **Server-side rendering out of the box:** Nuxt đi kèm với khả năng SSR tích hợp sẵn, vì vậy bạn không cần phải thiết lập server riêng.
- **Auto-imports:** viết các Vue composable và component trong các thư mục tương ứng và sử dụng chúng mà không cần import với lợi ích của tree-shaking và các JS bundle được tối ưu hóa.
- **Data-fetching utilities:** Nuxt cung cấp các composable để xử lý data fetching tương thích với SSR cũng như các chiến lược khác nhau.
- **Zero-config TypeScript support:** viết code an toàn kiểu dữ liệu mà không cần học TypeScript với các type được tự động tạo và `tsconfig.json` của chúng tôi.
- **Configured build tools:** chúng tôi sử dụng [Vite](https://vite.dev){rel="nofollow"} theo mặc định để hỗ trợ hot module replacement (HMR) trong development và đóng gói code cho production với các best-practice được tích hợp sẵn.

Nuxt xử lý tất cả những điều này và cung cấp chức năng cả frontend và backend để bạn có thể tập trung vào điều quan trọng: **tạo ra ứng dụng web của bạn**.

## Server-Side Rendering

Nuxt đi kèm với khả năng server-side rendering (SSR) tích hợp sẵn theo mặc định, mà không cần phải tự cấu hình server, điều này mang lại nhiều lợi ích cho các ứng dụng web:

- **Thời gian tải trang ban đầu nhanh hơn:** Nuxt gửi một trang HTML được render đầy đủ đến trình duyệt, có thể được hiển thị ngay lập tức. Điều này có thể cung cấp thời gian tải trang nhanh hơn về mặt cảm nhận và trải nghiệm người dùng (UX) tốt hơn, đặc biệt trên các mạng chậm hoặc thiết bị yếu.
- **SEO được cải thiện:** các công cụ tìm kiếm có thể index các trang SSR tốt hơn vì nội dung HTML có sẵn ngay lập tức, thay vì yêu cầu JavaScript để render nội dung ở phía client.
- **Hiệu suất tốt hơn trên các thiết bị yếu:** nó giảm lượng JavaScript cần được tải xuống và thực thi ở phía client, điều này có thể có lợi cho các thiết bị yếu có thể gặp khó khăn khi xử lý các ứng dụng JavaScript nặng.
- **Khả năng truy cập tốt hơn:** nội dung có sẵn ngay lập tức khi tải trang ban đầu, cải thiện khả năng truy cập cho người dùng dựa vào screen reader hoặc các công nghệ hỗ trợ khác.
- **Caching dễ dàng hơn:** các trang có thể được cache ở phía server, điều này có thể cải thiện hiệu suất hơn nữa bằng cách giảm thời gian tạo và gửi nội dung đến client.

Nhìn chung, server-side rendering có thể cung cấp trải nghiệm người dùng nhanh hơn và hiệu quả hơn, cũng như cải thiện tối ưu hóa công cụ tìm kiếm và khả năng truy cập.

Vì Nuxt là một framework linh hoạt, nó cung cấp cho bạn khả năng render tĩnh toàn bộ ứng dụng thành static hosting với `nuxt generate`, tắt SSR toàn cầu với tùy chọn `ssr: false` hoặc tận dụng hybrid rendering bằng cách thiết lập tùy chọn `routeRules`.

::read-more
---
title: Nuxt rendering modes
to: https://nuxt.com/docs/guide/concepts/rendering
---
::

### Server engine

Server engine Nuxt [Nitro](https://nitro.build/){rel="nofollow"} mở khóa các khả năng full-stack mới.

Trong development, nó sử dụng Rollup và Node.js workers cho server code và context isolation. Nó cũng tạo server API của bạn bằng cách đọc các file trong `server/api/` và server middleware từ `server/middleware/`.

Trong production, Nitro build ứng dụng và server của bạn thành một thư mục `.output` universal duy nhất. Output này nhẹ: được minify và loại bỏ khỏi bất kỳ Node.js module nào (trừ polyfill). Bạn có thể deploy output này trên bất kỳ hệ thống nào hỗ trợ JavaScript, từ Node.js, Serverless, Workers, Edge-side rendering hoặc hoàn toàn tĩnh.

::read-more
---
title: Nuxt server engine
to: https://nuxt.com/docs/guide/concepts/server-engine
---
::

### Production-ready

Một ứng dụng Nuxt có thể được deploy trên Node hoặc Deno server, pre-render để được host trong môi trường tĩnh, hoặc deploy đến các serverless và edge provider.

::read-more
---
title: Deployment section
to: https://nuxt.com/docs/getting-started/deployment
---
::

### Modular

Hệ thống module cho phép bạn mở rộng Nuxt với các tính năng tùy chỉnh và tích hợp với các dịch vụ bên thứ ba.

::read-more
---
title: Nuxt Modules Concept
to: https://nuxt.com/docs/guide/concepts/modules
---
::

### Architecture

Nuxt được cấu tạo từ các [core package](https://github.com/nuxt/nuxt/tree/main/packages){rel="nofollow"} khác nhau:

- Core engine: [nuxt](https://github.com/nuxt/nuxt/tree/main/packages/nuxt){rel="nofollow"}
- Bundlers: [@nuxt/vite-builder](https://github.com/nuxt/nuxt/tree/main/packages/vite){rel="nofollow"}, [@nuxt/rspack-builder](https://github.com/nuxt/nuxt/tree/main/packages/rspack){rel="nofollow"} và [@nuxt/webpack-builder](https://github.com/nuxt/nuxt/tree/main/packages/webpack){rel="nofollow"}
- Command line interface: [@nuxt/cli](https://github.com/nuxt/cli){rel="nofollow"}
- Server engine: [nitro](https://github.com/nitrojs/nitro){rel="nofollow"}
- Development kit: [@nuxt/kit](https://github.com/nuxt/nuxt/tree/main/packages/kit){rel="nofollow"}

Chúng tôi khuyến nghị đọc từng khái niệm để có cái nhìn đầy đủ về khả năng của Nuxt và phạm vi của từng package.


# Installation

## Play Online

If you just want to play around with Nuxt in your browser without setting up a project, you can use one of our online sandboxes:

::card-group
  :::card
  ---
  icon: i-simple-icons-stackblitz
  target: _blank
  title: Open on StackBlitz
  to: https://nuxt.new/s/v4
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-codesandbox
  target: _blank
  title: Open on CodeSandbox
  to: https://nuxt.new/c/v4
  ---
  :::
::

Or follow the steps below to set up a new Nuxt project on your computer.

## New Project

#### Prerequisites

- **Node.js** - [`20.x`](https://nodejs.org/en){rel="nofollow"} or newer (but we recommend the [active LTS release](https://github.com/nodejs/release#release-schedule){rel="nofollow"})
- **Text editor** - There is no IDE requirement, but we recommend [Visual Studio Code](https://code.visualstudio.com/){rel="nofollow"} with the [official Vue extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar){rel="nofollow"} (previously known as Volar) or [WebStorm](https://www.jetbrains.com/webstorm/){rel="nofollow"}, which, along with [other JetBrains IDEs](https://www.jetbrains.com/ides/){rel="nofollow"}, offers great Nuxt support right out-of-the-box.
- **Terminal** - In order to run Nuxt commands

::note
Additional notes for an optimal setup:

- **Node.js**: Make sure to use an even numbered version (18, 20, etc)
- **Nuxtr**: Install the community-developed [Nuxtr extension](https://marketplace.visualstudio.com/items?itemName=Nuxtr.nuxtr-vscode){rel="nofollow"}
- **WSL**: If you are using Windows and experience slow HMR, you may want to try using [WSL (Windows Subsystem for Linux)](https://docs.microsoft.com/en-us/windows/wsl/install){rel="nofollow"} which may solve some performance issues.
::

Open a terminal (if you're using [Visual Studio Code](https://code.visualstudio.com){rel="nofollow"}, you can open an [integrated terminal](https://code.visualstudio.com/docs/editor/integrated-terminal){rel="nofollow"}) and use the following command to create a new starter project:

::code-group{sync="pm"}
```bash [npm]
npm create nuxt@latest <project-name>
```

```bash [yarn]
yarn create nuxt@latest <project-name>
```

```bash [pnpm]
pnpm create nuxt@latest <project-name>
```

```bash [bun]
bun create nuxt@latest <project-name>
```

```bash [deno]
deno -A npm:create-nuxt@latest <project-name>
```
::

::tip
Alternatively, you can find other starters or themes by opening [nuxt.new](https://nuxt.new){rel="nofollow"} and following the instructions there.
::

Open your project folder in Visual Studio Code:

```bash [Terminal]
code <project-name>
```

Or change directory into your new project from your terminal:

```bash
cd <project-name>
```

## Development Server

Now you'll be able to start your Nuxt app in development mode:

::code-group{sync="pm"}
```bash [npm]
npm run dev -- -o
```

```bash [yarn]
yarn dev --open
```

```bash [pnpm]
pnpm dev -o
```

```bash [bun]
bun run dev -o

# To use the Bun runtime during development
# bun --bun run dev -o
```

```bash [deno]
deno run dev -o
```
::

::tip{icon="i-lucide-circle-check"}
Well done! A browser window should automatically open for <http://localhost:3000>{rel="nofollow"}.
::

## Next Steps

Now that you've created your Nuxt project, you are ready to start building your application.

::read-more{title="Nuxt Concepts" to="https://nuxt.com/docs/guide/concepts"}
::


# Configuration

Theo mặc định, Nuxt được cấu hình để bao phủ hầu hết các trường hợp sử dụng. File [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) có thể ghi đè hoặc mở rộng cấu hình mặc định này.

## Nuxt Configuration

File [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) được đặt tại thư mục gốc của dự án Nuxt và có thể ghi đè hoặc mở rộng hành vi của ứng dụng.

Một file cấu hình tối thiểu export hàm `defineNuxtConfig` chứa một object với cấu hình của bạn. Helper `defineNuxtConfig` có sẵn toàn cục mà không cần import.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  // My Nuxt config
})
```

File này sẽ thường xuyên được đề cập trong tài liệu, ví dụ để thêm custom script, đăng ký module hoặc thay đổi chế độ rendering.

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config"}
Mọi tùy chọn đều được mô tả trong **Configuration Reference**.
::

::note
Bạn không cần phải sử dụng TypeScript để xây dựng ứng dụng với Nuxt. Tuy nhiên, rất khuyến khích sử dụng phần mở rộng `.ts` cho file `nuxt.config`. Bằng cách này, bạn có thể hưởng lợi từ các gợi ý trong IDE để tránh lỗi chính tả và sai sót khi chỉnh sửa cấu hình.
::

### Environment Overrides

Bạn có thể cấu hình các override được type đầy đủ, theo từng môi trường trong nuxt.config của mình

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  $production: {
    routeRules: {
      '/**': { isr: true }
    }
  },
  $development: {
    //
  },
  $env: {
    staging: {
      // 
    }
  },
})
```

Để chọn một môi trường khi chạy lệnh Nuxt CLI, chỉ cần truyền tên vào flag `--envName`, như: `nuxt build --envName staging`.

Để tìm hiểu thêm về cơ chế đằng sau các override này, vui lòng tham khảo tài liệu `c12` về [environment-specific configuration](https://github.com/unjs/c12?tab=readme-ov-file#environment-specific-configuration){rel="nofollow"}.

::video-accordion
---
title: Watch a video from Alexander Lichter about the env-aware nuxt.config.ts
video-id: DFZI2iVCrNc
---
::

::note
Nếu bạn đang tạo layer, bạn cũng có thể sử dụng key `$meta` để cung cấp metadata mà bạn hoặc người sử dụng layer của bạn có thể sử dụng.
::

### Environment Variables and Private Tokens

API `runtimeConfig` expose các giá trị như biến môi trường cho phần còn lại của ứng dụng. Theo mặc định, các key này chỉ có sẵn ở phía server. Các key trong `runtimeConfig.public` và `runtimeConfig.app` (được Nuxt sử dụng nội bộ) cũng có sẵn ở phía client.

Những giá trị này nên được định nghĩa trong `nuxt.config` và có thể được ghi đè bằng cách sử dụng biến môi trường.

::code-group
```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  runtimeConfig: {
    // The private keys which are only available server-side
    apiSecret: '123',
    // Keys within public are also exposed client-side
    public: {
      apiBase: '/api'
    }
  }
})
```

```ini [.env]
# This will override the value of apiSecret
NUXT_API_SECRET=api_secret_token
```
::

Các biến này được expose cho phần còn lại của ứng dụng bằng cách sử dụng composable [`useRuntimeConfig()`](https://nuxt.com/docs/api/composables/use-runtime-config).

```vue [pages/index.vue]
<script setup lang="ts">
const runtimeConfig = useRuntimeConfig()
</script>
```

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## App Configuration

File `app.config.ts`, nằm trong thư mục source (mặc định là thư mục gốc của dự án), được sử dụng để expose các biến public có thể được xác định tại thời điểm build. Trái ngược với tùy chọn `runtimeConfig`, những biến này không thể được ghi đè bằng biến môi trường.

Một file cấu hình tối thiểu export hàm `defineAppConfig` chứa một object với cấu hình của bạn. Helper `defineAppConfig` có sẵn toàn cục mà không cần import.

```ts [app.config.ts]
export default defineAppConfig({
  title: 'Hello Nuxt',
  theme: {
    dark: true,
    colors: {
      primary: '#ff0000'
    }
  }
})
```

Các biến này được expose cho phần còn lại của ứng dụng bằng cách sử dụng composable [`useAppConfig`](https://nuxt.com/docs/api/composables/use-app-config).

```vue [pages/index.vue]
<script setup lang="ts">
const appConfig = useAppConfig()
</script>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
::

## `runtimeConfig` vs. `app.config`

Như đã nêu ở trên, cả `runtimeConfig` và `app.config` đều được sử dụng để expose biến cho phần còn lại của ứng dụng. Để xác định xem bạn nên sử dụng cái nào, đây là một số hướng dẫn:

- `runtimeConfig`: Token private hoặc public cần được chỉ định sau khi build bằng biến môi trường.
- `app.config`: Token public được xác định tại thời điểm build, cấu hình website như biến thể theme, title và bất kỳ cấu hình dự án nào không nhạy cảm.

| Feature                   | `runtimeConfig` | `app.config` |
| ------------------------- | --------------- | ------------ |
| Client Side               | Hydrated        | Bundled      |
| Environment Variables     | ✅ Yes           | ❌ No         |
| Reactive                  | ✅ Yes           | ✅ Yes        |
| Types support             | ✅ Partial       | ✅ Yes        |
| Configuration per Request | ❌ No            | ✅ Yes        |
| Hot Module Replacement    | ❌ No            | ✅ Yes        |
| Non primitive JS types    | ❌ No            | ✅ Yes        |

## External Configuration Files

Nuxt sử dụng file [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) làm single source of truth cho cấu hình và bỏ qua việc đọc các file cấu hình bên ngoài. Trong quá trình xây dựng dự án, bạn có thể cần cấu hình những file đó. Bảng sau đây làm nổi bật các cấu hình phổ biến và, nếu có thể, cách chúng có thể được cấu hình với Nuxt.

| Name                                              | Config File             | How To Configure                                                                      |
| ------------------------------------------------- | ----------------------- | ------------------------------------------------------------------------------------- |
| [Nitro](https://nitro.build){rel="nofollow"}      | ~~`nitro.config.ts`~~   | Use [`nitro`](https://nuxt.com/docs/api/nuxt-config#nitro) key in `nuxt.config`       |
| [PostCSS](https://postcss.org){rel="nofollow"}    | ~~`postcss.config.js`~~ | Use [`postcss`](https://nuxt.com/docs/api/nuxt-config#postcss) key in `nuxt.config`   |
| [Vite](https://vite.dev){rel="nofollow"}          | ~~`vite.config.ts`~~    | Use [`vite`](https://nuxt.com/docs/api/nuxt-config#vite) key in `nuxt.config`         |
| [webpack](https://webpack.js.org){rel="nofollow"} | ~~`webpack.config.ts`~~ | Use [`webpack`](https://nuxt.com/docs/api/nuxt-config#webpack-1) key in `nuxt.config` |

Đây là danh sách các file config phổ biến khác:

| Name                                                         | Config File           | How To Configure                                                                              |
| ------------------------------------------------------------ | --------------------- | --------------------------------------------------------------------------------------------- |
| [TypeScript](https://www.typescriptlang.org){rel="nofollow"} | `tsconfig.json`       | [More Info](https://nuxt.com/docs/guide/concepts/typescript#nuxttsconfigjson)                 |
| [ESLint](https://eslint.org){rel="nofollow"}                 | `eslint.config.js`    | [More Info](https://eslint.org/docs/latest/use/configure/configuration-files){rel="nofollow"} |
| [Prettier](https://prettier.io){rel="nofollow"}              | `prettier.config.js`  | [More Info](https://prettier.io/docs/en/configuration.html){rel="nofollow"}                   |
| [Stylelint](https://stylelint.io){rel="nofollow"}            | `stylelint.config.js` | [More Info](https://stylelint.io/user-guide/configure){rel="nofollow"}                        |
| [TailwindCSS](https://tailwindcss.com){rel="nofollow"}       | `tailwind.config.js`  | [More Info](https://tailwindcss.nuxtjs.org/tailwindcss/configuration){rel="nofollow"}         |
| [Vitest](https://vitest.dev){rel="nofollow"}                 | `vitest.config.ts`    | [More Info](https://vitest.dev/config/){rel="nofollow"}                                       |

## Vue Configuration

### With Vite

Nếu bạn cần truyền tùy chọn cho `@vitejs/plugin-vue` hoặc `@vitejs/plugin-vue-jsx`, bạn có thể làm điều này trong file `nuxt.config` của mình.

- `vite.vue` cho `@vitejs/plugin-vue`. Kiểm tra [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue){rel="nofollow"}.
- `vite.vueJsx` cho `@vitejs/plugin-vue-jsx`. Kiểm tra [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  vite: {
    vue: {
      customElement: true
    },
    vueJsx: {
      mergeProps: true
    }
  }
})
```

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config#vue"}
::

### With webpack

Nếu bạn sử dụng webpack và cần cấu hình `vue-loader`, bạn có thể làm điều này bằng cách sử dụng key `webpack.loaders.vue` bên trong file `nuxt.config` của mình. Các tùy chọn có sẵn được [định nghĩa tại đây](https://github.com/vuejs/vue-loader/blob/main/src/index.ts#L32-L62){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  webpack: {
    loaders: {
      vue: {
        hotReload: true,
      }
    }
  }
})
```

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config#loaders"}
::

### Enabling Experimental Vue Features

Bạn có thể cần bật các tính năng thử nghiệm trong Vue, chẳng hạn như `propsDestructure`. Nuxt cung cấp một cách dễ dàng để làm điều đó trong `nuxt.config.ts`, bất kể bạn đang sử dụng builder nào:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  vue: {
    propsDestructure: true
  }
})
```

#### experimental `reactivityTransform` migration from Vue 3.4 and Nuxt 3.9

Kể từ Nuxt 3.9 và Vue 3.4, `reactivityTransform` đã được di chuyển từ Vue sang Vue Macros có [Nuxt integration](https://vue-macros.dev/guide/nuxt-integration.html){rel="nofollow"}.

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config#vue-1"}
::


# Views

## `app.vue`

![The app.vue file is the entry point of your application](https://nuxt.com/assets/docs/getting-started/views/app.svg)

Theo mặc định, Nuxt sẽ coi file này là **entrypoint** và render nội dung của nó cho mọi route của ứng dụng.

```vue [app.vue]
<template>
  <div>
   <h1>Welcome to the homepage</h1>
  </div>
</template>
```

::tip
Nếu bạn quen thuộc với Vue, bạn có thể thắc mắc `main.js` ở đâu (file thường tạo Vue app). Nuxt làm điều này ở phía sau.
::

## Components

![Components are reusable pieces of UI](https://nuxt.com/assets/docs/getting-started/views/components.svg)

Hầu hết các component là những phần giao diện người dùng có thể tái sử dụng, như button và menu. Trong Nuxt, bạn có thể tạo các component này trong thư mục [`components/`](https://nuxt.com/docs/guide/directory-structure/components), và chúng sẽ tự động có sẵn trong toàn bộ ứng dụng mà không cần phải import một cách rõ ràng.

::code-group
```vue [app.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component.
    </AppAlert>
  </div>
</template>
```

```vue [components/AppAlert.vue]
<template>
  <span>
    <slot />
  </span>
</template>
```
::

## Pages

![Pages are views tied to a specific route](https://nuxt.com/assets/docs/getting-started/views/pages.svg)

Page đại diện cho view cho mỗi route pattern cụ thể. Mọi file trong thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) đại diện cho một route khác nhau hiển thị nội dung của nó.

Để sử dụng page, tạo file `pages/index.vue` và thêm component `<NuxtPage />` vào [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) (hoặc xóa `app.vue` để sử dụng entry mặc định). Bây giờ bạn có thể tạo thêm page và các route tương ứng bằng cách thêm file mới trong thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages).

::code-group
```vue [pages/index.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component
    </AppAlert>
  </div>
</template>
```

```vue [pages/about.vue]
<template>
  <section>
    <p>This page will be displayed at the /about route.</p>
  </section>
</template>
```
::

::read-more
---
title: Routing Section
to: https://nuxt.com/docs/getting-started/routing
---
::

## Layouts

![Layouts are wrapper around pages](https://nuxt.com/assets/docs/getting-started/views/layouts.svg)

Layout là wrapper xung quanh page chứa giao diện người dùng chung cho nhiều page, chẳng hạn như hiển thị header và footer. Layout là các file Vue sử dụng component `<slot />` để hiển thị nội dung **page**. File `layouts/default.vue` sẽ được sử dụng theo mặc định. Custom layout có thể được đặt như một phần của metadata page của bạn.

::note
Nếu bạn chỉ có một layout duy nhất trong ứng dụng, chúng tôi khuyến nghị sử dụng [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) với [`<NuxtPage />`](https://nuxt.com/docs/api/components/nuxt-page) thay thế.
::

::code-group
```vue [app.vue]
<template>
  <div>
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>
```

```vue [layouts/default.vue]
<template>
  <div>
    <AppHeader />
    <slot />
    <AppFooter />
  </div>
</template>
```

```vue [pages/index.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component
    </AppAlert>
  </div>
</template>
```

```vue [pages/about.vue]
<template>
  <section>
    <p>This page will be displayed at the /about route.</p>
  </section>
</template>
```
::

Nếu bạn muốn tạo thêm layout và tìm hiểu cách sử dụng chúng trong page của mình, hãy tìm thêm thông tin trong [Layouts section](https://nuxt.com/docs/guide/directory-structure/layouts).

## Advanced: Extending the HTML Template

::note
Nếu bạn chỉ cần sửa đổi `<head>`, bạn có thể tham khảo [SEO and meta section](https://nuxt.com/docs/getting-started/seo-meta).
::

Bạn có thể có toàn quyền kiểm soát HTML template bằng cách thêm Nitro plugin đăng ký một hook. Callback function của hook `render:html` cho phép bạn thay đổi HTML trước khi nó được gửi đến client.

```ts [server/plugins/extend-html.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:html', (html, { event }) => {
    // This will be an object representation of the html template.
    console.log(html)
    html.head.push(`<meta name="description" content="My custom description" />`)
  })
  // You can also intercept the response here.
  nitroApp.hooks.hook('render:response', (response, { event }) => { console.log(response) })
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/hooks"}
::


# Assets

Nuxt sử dụng hai thư mục để xử lý asset như stylesheet, font hoặc hình ảnh.

- Nội dung thư mục [`public/`](https://nuxt.com/docs/guide/directory-structure/public) được phục vụ tại server root như nguyên bản.
- Thư mục [`assets/`](https://nuxt.com/docs/guide/directory-structure/assets) chứa theo quy ước mọi asset mà bạn muốn build tool (Vite hoặc webpack) xử lý.

## Public Directory

Thư mục [`public/`](https://nuxt.com/docs/guide/directory-structure/public) được sử dụng như một public server cho các static asset có sẵn công khai tại URL được định nghĩa của ứng dụng.

Bạn có thể lấy một file trong thư mục [`public/`](https://nuxt.com/docs/guide/directory-structure/public) từ code ứng dụng hoặc từ trình duyệt bằng root URL `/`.

### Example

Ví dụ, tham chiếu một file hình ảnh trong thư mục `public/img/`, có sẵn tại static URL `/img/nuxt.png`:

```vue [app.vue]
<template>
  <img src="/img/nuxt.png" alt="Discover Nuxt" />
</template>
```

## Assets Directory

Nuxt sử dụng [Vite](https://vite.dev/guide/assets.html){rel="nofollow"} (mặc định) hoặc [webpack](https://webpack.js.org/guides/asset-management){rel="nofollow"} để build và bundle ứng dụng của bạn. Chức năng chính của các build tool này là xử lý các file JavaScript, nhưng chúng có thể được mở rộng thông qua [plugin](https://vite.dev/plugins){rel="nofollow"} (cho Vite) hoặc [loader](https://webpack.js.org/loaders){rel="nofollow"} (cho webpack) để xử lý các loại asset khác, như stylesheet, font hoặc SVG. Bước này chuyển đổi file gốc, chủ yếu vì mục đích hiệu suất hoặc caching (như minification stylesheet hoặc browser cache invalidation).

Theo quy ước, Nuxt sử dụng thư mục [`assets/`](https://nuxt.com/docs/guide/directory-structure/assets) để lưu trữ các file này nhưng không có chức năng auto-scan cho thư mục này, và bạn có thể sử dụng bất kỳ tên nào khác cho nó.

Trong code ứng dụng, bạn có thể tham chiếu một file nằm trong thư mục [`assets/`](https://nuxt.com/docs/guide/directory-structure/assets) bằng cách sử dụng đường dẫn `~/assets/`.

### Example

Ví dụ, tham chiếu một file hình ảnh sẽ được xử lý nếu build tool được cấu hình để xử lý phần mở rộng file này:

```vue [app.vue]
<template>
  <img src="~/assets/img/nuxt.png" alt="Discover Nuxt" />
</template>
```

::note
Nuxt sẽ không phục vụ các file trong thư mục [`assets/`](https://nuxt.com/docs/guide/directory-structure/assets) tại static URL như `/assets/my-file.png`. Nếu bạn cần static URL, hãy sử dụng thư mục [`public/`](https://nuxt.com/#public-directory).
::


# Styling

Nuxt rất linh hoạt khi nói đến styling. Viết style riêng của bạn, hoặc tham chiếu đến local và external stylesheet. Bạn có thể sử dụng CSS preprocessor, CSS framework, UI library và Nuxt module để style ứng dụng của mình.

## Local Stylesheets

Nếu bạn đang viết local stylesheet, vị trí tự nhiên để đặt chúng là thư mục [`assets/`](https://nuxt.com/docs/guide/directory-structure/assets).

### Importing Within Components

Bạn có thể import stylesheet trong page, layout và component của mình trực tiếp. Bạn có thể sử dụng JavaScript import, hoặc CSS [`@import` statement](https://developer.mozilla.org/en-US/docs/Web/CSS/@import){rel="nofollow"}.

```vue [pages/index.vue]
<script>
// Use a static import for server-side compatibility
import '~/assets/css/first.css'

// Caution: Dynamic imports are not server-side compatible
import('~/assets/css/first.css')
</script>

<style>
@import url("~/assets/css/second.css");
</style>
```

::tip
Các stylesheet sẽ được inline trong HTML được render bởi Nuxt.
::

### The CSS Property

Bạn cũng có thể sử dụng property `css` trong cấu hình Nuxt. Vị trí tự nhiên cho stylesheet của bạn là thư mục [`assets/`](https://nuxt.com/docs/guide/directory-structure/assets). Sau đó bạn có thể tham chiếu đường dẫn của nó và Nuxt sẽ include nó vào tất cả các page của ứng dụng.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/css/main.css']
})
```

::tip
Các stylesheet sẽ được inline trong HTML được render bởi Nuxt, inject toàn cục và có mặt trong tất cả page.
::

### Working With Fonts

Đặt các file font local của bạn trong thư mục `public/`, ví dụ trong `public/fonts`. Sau đó bạn có thể tham chiếu chúng trong stylesheet bằng `url()`.

```css [assets/css/main.css]
@font-face {
  font-family: 'FarAwayGalaxy';
  src: url('/fonts/FarAwayGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
```

Sau đó tham chiếu font của bạn bằng tên trong stylesheet, page hoặc component:

```vue
<style>
h1 {
  font-family: 'FarAwayGalaxy', sans-serif;
}
</style>
```

### Stylesheets Distributed Through NPM

Bạn cũng có thể tham chiếu đến stylesheet được phân phối thông qua npm. Hãy sử dụng thư viện phổ biến `animate.css` làm ví dụ.

::code-group{sync="pm"}
```bash [npm]
npm install animate.css
```

```bash [yarn]
yarn add animate.css
```

```bash [pnpm]
pnpm install animate.css
```

```bash [bun]
bun install animate.css
```
::

Sau đó bạn có thể tham chiếu nó trực tiếp trong page, layout và component:

```vue [app.vue]
<script>
import 'animate.css'
</script>

<style>
@import url("animate.css");
</style>
```

Package cũng có thể được tham chiếu dưới dạng string trong property css của cấu hình Nuxt.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['animate.css']
})
```

## External Stylesheets

Bạn có thể include external stylesheet trong ứng dụng bằng cách thêm link element trong head section của file nuxt.config. Bạn có thể đạt được kết quả này bằng các phương pháp khác nhau. Lưu ý rằng local stylesheet cũng có thể được include theo cách này.

Bạn có thể thao tác head với property [`app.head`](https://nuxt.com/docs/api/nuxt-config#head) của cấu hình Nuxt:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    head: {
      link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
    }
  }
})
```

### Dynamically Adding Stylesheets

Bạn có thể sử dụng composable useHead để dynamically set giá trị trong head của bạn trong code.

::read-more{to="https://nuxt.com/docs/api/composables/use-head"}
::

```ts twoslash
useHead({
  link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]
})
```

Nuxt sử dụng `unhead` bên dưới, và bạn có thể tham khảo [tài liệu đầy đủ của nó](https://unhead.unjs.io){rel="nofollow"}.

### Modifying The Rendered Head With A Nitro Plugin

Nếu bạn cần kiểm soát nâng cao hơn, bạn có thể intercept rendered html với hook và modify head một cách lập trình.

Tạo plugin trong `~/server/plugins/my-plugin.ts` như thế này:

```ts [server/plugins/my-plugin.ts]
export default defineNitroPlugin((nitro) => {
  nitro.hooks.hook('render:html', (html) => {
    html.head.push('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">')
  })
})
```

External stylesheet là render-blocking resource: chúng phải được load và process trước khi trình duyệt render page. Các trang web chứa style lớn không cần thiết sẽ mất nhiều thời gian hơn để render. Bạn có thể đọc thêm về nó trên [web.dev](https://web.dev/defer-non-critical-css){rel="nofollow"}.

## Using Preprocessors

Để sử dụng preprocessor như SCSS, Sass, Less hoặc Stylus, hãy cài đặt nó trước.

::code-group
```bash [Sass & SCSS]
npm install -D sass
```

```bash [Less]
npm install -D less
```

```bash [Stylus]
npm install -D stylus
```
::

Vị trí tự nhiên để viết stylesheet của bạn là thư mục `assets`. Sau đó bạn có thể import source file trong `app.vue` (hoặc layout file) bằng cú pháp preprocessor.

```vue [pages/app.vue]
<style lang="scss">
@use "~/assets/scss/main.scss";
</style>
```

Hoặc, bạn có thể sử dụng property `css` của cấu hình Nuxt.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  css: ['~/assets/scss/main.scss']
})
```

::tip
Trong cả hai trường hợp, các stylesheet được compile sẽ được inline trong HTML được render bởi Nuxt.
::

Nếu bạn cần inject code trong pre-processed file, như [Sass partial](https://sass-lang.com/documentation/at-rules/use#partials){rel="nofollow"} với color variable, bạn có thể làm như vậy với Vite [preprocessors options](https://vite.dev/config/shared-options.html#css-preprocessoroptions){rel="nofollow"}.

Tạo một số partial trong thư mục `assets`:

::code-group{sync="preprocessor"}
```scss [assets/_colors.scss]
$primary: #49240F;
$secondary: #E4A79D;
```

```sass [assets/_colors.sass]
$primary: #49240F
$secondary: #E4A79D
```
::

Sau đó trong `nuxt.config`:

::code-group
```ts [SCSS] twoslash
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "~/assets/_colors.scss" as *;'
        }
      }
    }
  }
})
```

```ts [SASS] twoslash
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        sass: {
          additionalData: '@use "~/assets/_colors.sass" as *\n'
        }
      }
    }
  }
})
```
::

Nuxt sử dụng Vite theo mặc định. Nếu bạn muốn sử dụng webpack thay thế, hãy tham khảo [tài liệu](https://webpack.js.org/loaders/sass-loader){rel="nofollow"} của từng preprocessor loader.

### Preprocessor Workers (Experimental)

Vite đã cung cấp [tùy chọn thử nghiệm](https://vite.dev/config/shared-options.html#css-preprocessormaxworkers){rel="nofollow"} có thể tăng tốc việc sử dụng preprocessor.

Bạn có thể enable điều này trong `nuxt.config`:

```ts

export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorMaxWorkers: true // number of CPUs minus 1
    }
  }
})
```

::note
Đây là tùy chọn thử nghiệm và bạn nên tham khảo tài liệu Vite và [cung cấp phản hồi](https://github.com/vitejs/vite/discussions/15835){rel="nofollow"}.
::

## Single File Components (SFC) Styling

Một trong những điều tuyệt vời nhất về Vue và SFC là nó rất tuyệt vời trong việc xử lý styling một cách tự nhiên. Bạn có thể viết CSS hoặc preprocessor code trực tiếp trong style block của component file, do đó bạn sẽ có developer experience tuyệt vời mà không cần sử dụng thứ gì như CSS-in-JS. Tuy nhiên, nếu bạn muốn sử dụng CSS-in-JS, bạn có thể tìm thấy các thư viện và module bên thứ ba hỗ trợ nó, chẳng hạn như [pinceau](https://github.com/Tahul/pinceau){rel="nofollow"}.

Bạn có thể tham khảo [Vue docs](https://vuejs.org/api/sfc-css-features.html){rel="nofollow"} để có tài liệu tham khảo toàn diện về styling component trong SFC.

### Class And Style Bindings

Bạn có thể tận dụng các tính năng Vue SFC để style component với class và style attribute.

::code-group
```vue [Ref and Reactive]
<script setup lang="ts">
const isActive = ref(true)
const hasError = ref(false)
const classObject = reactive({
  active: true,
  'text-danger': false
})
</script>

<template>
  <div class="static" :class="{ active: isActive, 'text-danger': hasError }"></div>
  <div :class="classObject"></div>
</template>
```

```vue [Computed]
<script setup lang="ts">
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
</script>

<template>
  <div :class="classObject"></div>
</template>
```

```vue [Array]
<script setup lang="ts">
const isActive = ref(true)
const errorClass = ref('text-danger')
</script>

<template>
  <div :class="[{ active: isActive }, errorClass]"></div>
</template>
```

```vue [Style]
<script setup lang="ts">
const activeColor = ref('red')
const fontSize = ref(30)
const styleObject = reactive({ color: 'red', fontSize: '13px' })
</script>

<template>
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
  <div :style="[baseStyles, overridingStyles]"></div>
  <div :style="styleObject"></div>
</template>
```
::

Tham khảo [Vue docs](https://vuejs.org/guide/essentials/class-and-style.html){rel="nofollow"} để biết thêm thông tin.

### Dynamic Styles With `v-bind`

Bạn có thể tham chiếu biến JavaScript và expression trong style block với hàm v-bind. Binding sẽ là dynamic, có nghĩa là nếu giá trị biến thay đổi, style sẽ được cập nhật.

```vue
<script setup lang="ts">
const color = ref("red")
</script>

<template>
  <div class="text">hello</div>
</template>

<style>
.text {
  color: v-bind(color);
}
</style>
```

### Scoped Styles

Thuộc tính scoped cho phép bạn style component một cách riêng biệt. Các style được khai báo với thuộc tính này sẽ chỉ áp dụng cho component này.

```vue
<template>
  <div class="example">hi</div>
</template>

<style scoped>
.example {
  color: red;
}
</style>
```

### CSS Modules

Bạn có thể sử dụng [CSS Modules](https://github.com/css-modules/css-modules){rel="nofollow"} với thuộc tính module. Truy cập nó với biến `$style` được inject.

```vue
<template>
  <p :class="$style.red">This should be red</p>
</template>

<style module>
.red {
  color: red;
}
</style>
```

### Preprocessors Support

SFC style block hỗ trợ cú pháp preprocessor. Vite đi kèm với hỗ trợ tích hợp cho file .scss, .sass, .less, .styl và .stylus mà không cần cấu hình. Bạn chỉ cần cài đặt chúng trước, và chúng sẽ có sẵn trực tiếp trong SFC với thuộc tính lang.

::code-group
```vue [SCSS]
<style lang="scss">
  /* Write scss here */
</style>
```

```vue [Sass]
<style lang="sass">
  /* Write sass here */
</style>
```

```vue [LESS]
<style lang="less">
  /* Write less here */
</style>
```

```vue [Stylus]
<style lang="stylus">
  /* Write stylus here */
</style>
```
::

Bạn có thể tham khảo [Vite CSS docs](https://vite.dev/guide/features.html#css){rel="nofollow"} và [@vitejs/plugin-vue docs](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue){rel="nofollow"}. Đối với người dùng webpack, hãy tham khảo [vue loader docs](https://vue-loader.vuejs.org){rel="nofollow"}.

## Using PostCSS

Nuxt đi kèm với postcss tích hợp sẵn. Bạn có thể cấu hình nó trong file `nuxt.config`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  postcss: {
    plugins: {
      'postcss-nested': {},
      'postcss-custom-media': {}
    }
  }
})
```

Để syntax highlighting phù hợp trong SFC, bạn có thể sử dụng thuộc tính postcss lang.

```vue
<style lang="postcss">
  /* Write postcss here */
</style>
```

Theo mặc định, Nuxt đi kèm với các plugin sau đã được cấu hình sẵn:

- [postcss-import](https://github.com/postcss/postcss-import){rel="nofollow"}: Cải thiện `@import` rule
- [postcss-url](https://github.com/postcss/postcss-url){rel="nofollow"}: Transform `url()` statement
- [autoprefixer](https://github.com/postcss/autoprefixer){rel="nofollow"}: Tự động thêm vendor prefix
- [cssnano](https://cssnano.github.io/cssnano){rel="nofollow"}: Minification và purge

## Leveraging Layouts For Multiple Styles

Nếu bạn cần style các phần khác nhau của ứng dụng hoàn toàn khác nhau, bạn có thể sử dụng layout. Sử dụng style khác nhau cho layout khác nhau.

```vue
<template>
  <div class="default-layout">
    <h1>Default Layout</h1>
    <slot />
  </div>
</template>

<style>
.default-layout {
  color: red;
}
</style>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/layouts"}
::

## Third Party Libraries And Modules

Nuxt không có ý kiến cụ thể khi nói đến styling và cung cấp cho bạn nhiều tùy chọn đa dạng. Bạn có thể sử dụng bất kỳ styling tool nào bạn muốn, chẳng hạn như các thư viện phổ biến như [UnoCSS](https://unocss.dev){rel="nofollow"} hoặc [Tailwind CSS](https://tailwindcss.com){rel="nofollow"}.

Cộng đồng và team Nuxt đã phát triển rất nhiều Nuxt module để làm cho việc tích hợp dễ dàng hơn. Bạn có thể khám phá chúng trên [modules section](https://nuxt.com/modules) của website. Đây là một số module giúp bạn bắt đầu:

- [UnoCSS](https://nuxt.com/modules/unocss): Instant on-demand atomic CSS engine
- [Tailwind CSS](https://nuxt.com/modules/tailwindcss): Utility-first CSS framework
- [Fontaine](https://github.com/nuxt-modules/fontaine){rel="nofollow"}: Font metric fallback
- [Pinceau](https://github.com/Tahul/pinceau){rel="nofollow"}: Adaptable styling framework
- [Nuxt UI](https://ui.nuxt.com){rel="nofollow"}: A UI Library for Modern Web Apps
- [Panda CSS](https://panda-css.com/docs/installation/nuxt){rel="nofollow"}: CSS-in-JS engine that generates atomic CSS at build time

Nuxt module cung cấp cho bạn developer experience tốt ngay từ đầu, nhưng hãy nhớ rằng nếu công cụ yêu thích của bạn không có module, điều đó không có nghĩa là bạn không thể sử dụng nó với Nuxt! Bạn có thể tự cấu hình nó cho dự án của riêng mình. Tùy thuộc vào công cụ, bạn có thể cần sử dụng [Nuxt plugin](https://nuxt.com/docs/guide/directory-structure/plugins) và/hoặc [tự tạo module](https://nuxt.com/docs/guide/going-further/modules). Chia sẻ chúng với [cộng đồng](https://nuxt.com/modules) nếu bạn làm!

### Easily Load Webfonts

Bạn có thể sử dụng [Nuxt Google Fonts module](https://github.com/nuxt-modules/google-fonts){rel="nofollow"} để load Google Fonts.

Nếu bạn đang sử dụng [UnoCSS](https://unocss.dev/integrations/nuxt){rel="nofollow"}, lưu ý rằng nó đi kèm với [web fonts presets](https://unocss.dev/presets/web-fonts){rel="nofollow"} để tiện lợi load font từ các nhà cung cấp phổ biến, bao gồm Google Fonts và nhiều hơn nữa.

## Advanced

### Transitions

Nuxt đi kèm với element `<Transition>` giống như Vue có, và cũng hỗ trợ [View Transitions API](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental) thử nghiệm.

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

### Font Advanced Optimization

Chúng tôi khuyến nghị sử dụng [Fontaine](https://github.com/nuxt-modules/fontaine){rel="nofollow"} để giảm [CLS](https://web.dev/cls){rel="nofollow"} của bạn. Nếu bạn cần thứ gì đó nâng cao hơn, hãy cân nhắc tạo Nuxt module để mở rộng build process hoặc Nuxt runtime.

::tip
Luôn nhớ tận dụng các công cụ và kỹ thuật khác nhau có sẵn trong hệ sinh thái Web nói chung để làm cho việc styling ứng dụng của bạn dễ dàng và hiệu quả hơn. Cho dù bạn đang sử dụng native CSS, preprocessor, postcss, UI library hoặc module, Nuxt đều hỗ trợ bạn. Chúc styling vui vẻ!
::

### LCP Advanced Optimizations

Bạn có thể làm như sau để tăng tốc download của global CSS file:

- Sử dụng CDN để file gần hơn về mặt vật lý với người dùng
- Compress asset của bạn, lý tưởng nhất là sử dụng Brotli
- Sử dụng HTTP2/HTTP3 để delivery
- Host asset trên cùng domain (không sử dụng subdomain khác)

Hầu hết những điều này sẽ được thực hiện tự động nếu bạn đang sử dụng các platform hiện đại như Cloudflare, Netlify hoặc Vercel. Bạn có thể tìm hướng dẫn tối ưu LCP trên [web.dev](https://web.dev/optimize-lcp){rel="nofollow"}.

Nếu tất cả CSS của bạn được inline bởi Nuxt, bạn có thể (thử nghiệm) hoàn toàn ngừng tham chiếu external CSS file trong HTML được render. Bạn có thể đạt được điều đó với hook, mà bạn có thể đặt trong module, hoặc trong file cấu hình Nuxt.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'build:manifest': (manifest) => {
      // find the app entry, css list
      const css = Object.values(manifest).find(options => options.isEntry)?.css
      if (css) {
        // start from the end of the array and go to the beginning
        for (let i = css.length - 1; i >= 0; i--) {
          // if it starts with 'entry', remove it from the list
          if (css[i].startsWith('entry')) css.splice(i, 1)
        }
      }
    },
  },
})
```


# Routing

Một tính năng cốt lõi của Nuxt là file system router. Mỗi file Vue bên trong thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) tạo một URL tương ứng (hoặc route) hiển thị nội dung của file. Bằng cách sử dụng dynamic import cho mỗi page, Nuxt tận dụng code-splitting để ship lượng JavaScript tối thiểu cho route được yêu cầu.

## Pages

Nuxt routing dựa trên [vue-router](https://router.vuejs.org){rel="nofollow"} và tạo route từ mỗi component được tạo trong [`pages/ directory`](https://nuxt.com/docs/guide/directory-structure/pages), dựa trên tên file của chúng.

File system routing này sử dụng quy ước đặt tên để tạo dynamic và nested route:

::code-group
```bash [Directory Structure]
-| pages/
---| about.vue
---| index.vue
---| posts/
-----| [id].vue
```

```json [Generated Router File]
{
  "routes": [
    {
      "path": "/about",
      "component": "pages/about.vue"
    },
    {
      "path": "/",
      "component": "pages/index.vue"
    },
    {
      "path": "/posts/:id",
      "component": "pages/posts/[id].vue"
    }
  ]
}
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/pages"}
::

## Navigation

Component [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link) liên kết các page với nhau. Nó render thẻ `<a>` với thuộc tính `href` được đặt thành route của page. Khi ứng dụng đã được hydrate, page transition được thực hiện trong JavaScript bằng cách cập nhật URL trình duyệt. Điều này ngăn chặn full-page refresh và cho phép animated transition.

Khi [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link) vào viewport ở phía client, Nuxt sẽ tự động prefetch component và payload (generated page) của các linked page trước, dẫn đến navigation nhanh hơn.

```vue [pages/app.vue]
<template>
  <header>
    <nav>
      <ul>
        <li><NuxtLink to="/about">About</NuxtLink></li>
        <li><NuxtLink to="/posts/1">Post 1</NuxtLink></li>
        <li><NuxtLink to="/posts/2">Post 2</NuxtLink></li>
      </ul>
    </nav>
  </header>
</template>
```

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
::

## Route Parameters

Composable [`useRoute()`](https://nuxt.com/docs/api/composables/use-route) có thể được sử dụng trong block `<script setup>` hoặc method `setup()` của Vue component để truy cập chi tiết route hiện tại.

```vue [pages/posts/[id\\].vue] twoslash
<script setup lang="ts">
const route = useRoute()

// When accessing /posts/1, route.params.id will be 1
console.log(route.params.id)
</script>
```

::read-more{to="https://nuxt.com/docs/api/composables/use-route"}
::

## Route Middleware

Nuxt cung cấp framework route middleware có thể tùy chỉnh mà bạn có thể sử dụng trong toàn bộ ứng dụng, lý tưởng để trích xuất code mà bạn muốn chạy trước khi điều hướng đến một route cụ thể.

::note
Route middleware chạy trong phần Vue của ứng dụng Nuxt. Mặc dù có tên tương tự, chúng hoàn toàn khác với server middleware, được chạy trong phần Nitro server của ứng dụng.
::

Có ba loại route middleware:

1. Anonymous (hoặc inline) route middleware, được định nghĩa trực tiếp trong page nơi chúng được sử dụng.
2. Named route middleware, được đặt trong thư mục [`middleware/`](https://nuxt.com/docs/guide/directory-structure/middleware) và sẽ được tự động load thông qua asynchronous import khi được sử dụng trên page. (**Lưu ý**: Tên route middleware được normalize thành kebab-case, vì vậy `someMiddleware` trở thành `some-middleware`.)
3. Global route middleware, được đặt trong thư mục [`middleware/`](https://nuxt.com/docs/guide/directory-structure/middleware) (với suffix `.global`) và sẽ tự động chạy trên mỗi route change.

Ví dụ về middleware `auth` bảo vệ page `/dashboard`:

::code-group
```ts [middleware/auth.ts] twoslash
function isAuthenticated(): boolean { return false }
// ---cut---
export default defineNuxtRouteMiddleware((to, from) => {
  // isAuthenticated() is an example method verifying if a user is authenticated
  if (isAuthenticated() === false) {
    return navigateTo('/login')
  }
})
```

```vue [pages/dashboard.vue] twoslash
<script setup lang="ts">
definePageMeta({
  middleware: 'auth'
})
</script>

<template>
  <h1>Welcome to your dashboard</h1>
</template>
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/middleware"}
::

## Route Validation

Nuxt cung cấp route validation thông qua property `validate` trong [`definePageMeta()`](https://nuxt.com/docs/api/utils/define-page-meta) trong mỗi page bạn muốn validate.

The `validate` property accepts the `route` as an argument. You can return a boolean value to determine whether or not this is a valid route to be rendered with this page. If you return `false`, this will cause a 404 error. You can also directly return an object with `statusCode`/`statusMessage` to customize the error returned.

If you have a more complex use case, then you can use anonymous route middleware instead.

```vue [pages/posts/[id\\].vue] twoslash
<script setup lang="ts">
definePageMeta({
  validate: async (route) => {
    // Check if the id is made up of digits
    return typeof route.params.id === 'string' && /^\d+$/.test(route.params.id)
  }
})
</script>
```

::read-more{to="https://nuxt.com/docs/api/utils/define-page-meta"}
::


# SEO and Meta

Quản lý thẻ head của Nuxt được hỗ trợ bởi [Unhead](https://unhead.unjs.io){rel="nofollow"}. Nó cung cấp các giá trị mặc định hợp lý, một số composable mạnh mẽ và nhiều tùy chọn cấu hình để quản lý các thẻ head và meta SEO của ứng dụng.

## Nuxt Config

Việc cung cấp thuộc tính [`app.head`](https://nuxt.com/docs/api/nuxt-config#head) trong [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) cho phép bạn tùy chỉnh tĩnh head cho toàn bộ ứng dụng.

::important
Phương thức này không cho phép bạn cung cấp dữ liệu reactive. Chúng tôi khuyên dùng `useHead()` trong `app.vue`.
::

Việc đặt các thẻ ở đây là thực hành tốt đối với những thẻ không thay đổi như tiêu đề trang mặc định, ngôn ngữ và favicon.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    head: {
      title: "Nuxt", // tiêu đề fallback mặc định
      htmlAttrs: {
        lang: "en",
      },
      link: [{ rel: "icon", type: "image/x-icon", href: "/favicon.ico" }],
    },
  },
});
```

Bạn cũng có thể cung cấp bất kỳ khóa nào được liệt kê bên dưới trong [Types](https://nuxt.com/#types).

### Defaults Tags

Một số thẻ được Nuxt cung cấp mặc định để đảm bảo trang web hoạt động tốt ngay từ đầu.

- `viewport`: `width=device-width, initial-scale=1`
- `charset`: `utf-8`

Mặc dù hầu hết các trang web không cần ghi đè các giá trị mặc định này, bạn có thể cập nhật chúng bằng cách sử dụng các shortcut có khóa.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    head: {
      // cập nhật các giá trị mặc định của Nuxt
      charset: "utf-16",
      viewport: "width=device-width, initial-scale=1, maximum-scale=1",
    },
  },
});
```

## `useHead`

Hàm composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) hỗ trợ đầu vào reactive, cho phép bạn quản lý các thẻ head một cách có chương trình.

```vue [app.vue] twoslash
<script setup lang="ts">
useHead({
  title: "My App",
  meta: [{ name: "description", content: "My amazing site." }],
  bodyAttrs: {
    class: "test",
  },
  script: [{ innerHTML: "console.log('Hello world')" }],
});
</script>
```

Chúng tôi khuyên bạn nên xem qua các composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) và [`useHeadSafe`](https://nuxt.com/docs/api/composables/use-head-safe).

## `useSeoMeta`

Composable [`useSeoMeta`](https://nuxt.com/docs/api/composables/use-seo-meta) cho phép bạn định nghĩa các thẻ meta SEO của trang web dưới dạng một đối tượng với tính năng type safety đầy đủ.

Điều này giúp bạn tránh lỗi chính tả và những sai lầm phổ biến, chẳng hạn như sử dụng `name` thay vì `property`.

```vue [app.vue] twoslash
<script setup lang="ts">
useSeoMeta({
  title: "My Amazing Site",
  ogTitle: "My Amazing Site",
  description: "This is my amazing site, let me tell you all about it.",
  ogDescription: "This is my amazing site, let me tell you all about it.",
  ogImage: "https://example.com/image.png",
  twitterCard: "summary_large_image",
});
</script>
```

::read-more{to="https://nuxt.com/docs/api/composables/use-seo-meta"}
::

## Components

Mặc dù việc sử dụng [`useHead`](https://nuxt.com/docs/api/composables/use-head) được khuyến nghị trong mọi trường hợp, bạn có thể có sở thích cá nhân trong việc định nghĩa các thẻ head trong template của mình bằng các component.

Nuxt cung cấp các component sau cho mục đích này: `<Title>`, `<Base>`, `<NoScript>`, `<Style>`, `<Meta>`, `<Link>`, `<Body>`, `<Html>` và `<Head>`. Lưu ý việc viết hoa các component này đảm bảo chúng ta không sử dụng các thẻ HTML native không hợp lệ.

`<Head>` và `<Body>` có thể chấp nhận các thẻ meta lồng nhau (vì lý do thẩm mỹ) nhưng điều này không ảnh hưởng đến *vị trí* các thẻ meta lồng nhau được render trong HTML cuối cùng.

```vue [app.vue]
<script setup lang="ts">
const title = ref("Hello World");
</script>

<template>
  <div>
    <Head>
      <Title>{{ title }}</Title>
      <Meta name="description" :content="title" />
      <Style> body { background-color: green; } </Style>
    </Head>

    <h1>{{ title }}</h1>
  </div>
</template>
```

Được khuyên là bọc các component của bạn trong một component `<Head>` hoặc `<Html>` vì các thẻ sẽ được dedupe một cách trực quan hơn.

## Types

Dưới đây là các kiểu non-reactive được sử dụng cho [`useHead`](https://nuxt.com/docs/api/composables/use-head), [`app.head`](https://nuxt.com/docs/api/nuxt-config#head) và các component.

```ts
interface MetaObject {
  title?: string;
  titleTemplate?: string | ((title?: string) => string);
  templateParams?: Record<string, string | Record<string, string>>;
  base?: Base;
  link?: Link[];
  meta?: Meta[];
  style?: Style[];
  script?: Script[];
  noscript?: Noscript[];
  htmlAttrs?: HtmlAttributes;
  bodyAttrs?: BodyAttributes;
}
```

Xem [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/schema.ts){rel="nofollow"} để biết thêm các kiểu chi tiết.

## Features

### Reactivity

Tính reactive được hỗ trợ trên tất cả các thuộc tính, bằng cách cung cấp một giá trị computed, một getter, hoặc một đối tượng reactive.

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
const description = ref("My amazing site.");

useHead({
  meta: [{ name: "description", content: description }],
});
</script>
```

```vue [useSeoMeta] twoslash
<script setup lang="ts">
const description = ref("My amazing site.");

useSeoMeta({
  description,
});
</script>
```

```vue [Components]
<script setup lang="ts">
const description = ref("My amazing site.");
</script>

<template>
  <div>
    <Meta name="description" :content="description" />
  </div>
</template>
```
::

### Title Template

Bạn có thể sử dụng tùy chọn `titleTemplate` để cung cấp một template động cho việc tùy chỉnh tiêu đề trang web của bạn. Ví dụ, bạn có thể thêm tên trang web vào tiêu đề của mọi trang.

`titleTemplate` có thể là một chuỗi, trong đó `%s` được thay thế bằng tiêu đề, hoặc một hàm.

Nếu bạn muốn sử dụng một hàm (để kiểm soát hoàn toàn), thì điều này không thể được đặt trong `nuxt.config` của bạn. Thay vào đó, được khuyến nghị đặt nó trong file `app.vue` nơi nó sẽ áp dụng cho tất cả các trang trên trang web:

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} - Site Title` : "Site Title";
  },
});
</script>
```
::

Bây giờ, nếu bạn đặt tiêu đề thành `My Page` với [`useHead`](https://nuxt.com/docs/api/composables/use-head) trên một trang khác của trang web, tiêu đề sẽ xuất hiện dưới dạng 'My Page - Site Title' trong tab trình duyệt. Bạn cũng có thể truyền `null` để mặc định thành 'Site Title'.

### Template Params

Bạn có thể sử dụng `templateParams` để cung cấp các placeholder bổ sung trong `titleTemplate` ngoài `%s` mặc định. Điều này cho phép tạo tiêu đề động hơn.

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} %separator %siteName` : "%siteName";
  },
  templateParams: {
    siteName: "Site Title",
    separator: "-",
  },
});
</script>
```
::

### Body Tags

Bạn có thể sử dụng tùy chọn `tagPosition: 'bodyClose'` trên các thẻ có thể áp dụng để thêm chúng vào cuối thẻ `<body>`.

Ví dụ:

```vue twoslash
<script setup lang="ts">
useHead({
  script: [
    {
      src: "https://third-party-script.com",
      // các tùy chọn hợp lệ là: 'head' | 'bodyClose' | 'bodyOpen'
      tagPosition: "bodyClose",
    },
  ],
});
</script>
```

## Examples

### With `definePageMeta`

Trong thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) của bạn, bạn có thể sử dụng `definePageMeta` cùng với [`useHead`](https://nuxt.com/docs/api/composables/use-head) để đặt metadata dựa trên route hiện tại.

Ví dụ, trước tiên bạn có thể đặt tiêu đề trang hiện tại (điều này được trích xuất tại thời điểm build thông qua macro, vì vậy nó không thể được đặt động):

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  title: "Some Page",
});
</script>
```

Và sau đó trong file layout, bạn có thể sử dụng metadata của route mà bạn đã đặt trước đó:

```vue [layouts/default.vue] twoslash
<script setup lang="ts">
const route = useRoute();

useHead({
  meta: [{ property: "og:title", content: `App Name - ${route.meta.title}` }],
});
</script>
```

::link-example{to="https://nuxt.com/docs/examples/features/meta-tags"}
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/pages/#page-metadata
---
::

### Dynamic Title

Trong ví dụ bên dưới, `titleTemplate` được đặt dưới dạng một chuỗi với placeholder `%s` hoặc dưới dạng một `hàm`, điều này cho phép linh hoạt lớn hơn trong việc đặt tiêu đề trang một cách động cho mỗi route của ứng dụng Nuxt:

```vue [app.vue] twoslash
<script setup lang="ts">
useHead({
  // dưới dạng chuỗi,
  // trong đó `%s` được thay thế bằng tiêu đề
  titleTemplate: "%s - Site Title",
});
</script>
```

```vue [app.vue] twoslash
<script setup lang="ts">
useHead({
  // hoặc dưới dạng hàm
  titleTemplate: (productCategory) => {
    return productCategory ? `${productCategory} - Site Title` : "Site Title";
  },
});
</script>
```

`nuxt.config` cũng được sử dụng như một cách thay thế để đặt tiêu đề trang. Tuy nhiên, `nuxt.config` không cho phép tiêu đề trang được động. Do đó, được khuyến nghị sử dụng `titleTemplate` trong file `app.vue` để thêm tiêu đề động, sau đó được áp dụng cho tất cả các route của ứng dụng Nuxt.

### External CSS

Ví dụ bên dưới cho thấy cách bạn có thể kích hoạt Google Fonts bằng cách sử dụng thuộc tính `link` của composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) hoặc sử dụng component `<Link>`:

::code-group
```vue [useHead] twoslash
<script setup lang="ts">
useHead({
  link: [
    {
      rel: "preconnect",
      href: "https://fonts.googleapis.com",
    },
    {
      rel: "stylesheet",
      href: "https://fonts.googleapis.com/css2?family=Roboto&display=swap",
      crossorigin: "",
    },
  ],
});
</script>
```

```vue [Components]
<template>
  <div>
    <Link rel="preconnect" href="https://fonts.googleapis.com" />
    <Link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"
      crossorigin=""
    />
  </div>
</template>
```
::


# Transitions

::note
Nuxt tận dụng component [`<Transition>`](https://vuejs.org/guide/built-ins/transition.html#the-transition-component){rel="nofollow"} của Vue để áp dụng transitions giữa các trang và layout.
::

## Page Transitions

Bạn có thể kích hoạt page transitions để áp dụng transition tự động cho tất cả các [trang](https://nuxt.com/docs/guide/directory-structure/pages).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: { name: "page", mode: "out-in" },
  },
});
```

::note
Nếu bạn cũng đang thay đổi layout cũng như trang, page transition bạn đặt ở đây sẽ không chạy. Thay vào đó, bạn nên đặt [layout transition](https://nuxt.com/docs/getting-started/transitions#layout-transitions).
::

Để bắt đầu thêm transition giữa các trang, thêm CSS sau vào [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app):

::code-group
```vue [app.vue]
<template>
  <NuxtPage />
</template>

<style>
.page-enter-active,
.page-leave-active {
  transition: all 0.4s;
}
.page-enter-from,
.page-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
```

```vue [pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [pages/about.vue]
<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```
::

Điều này tạo ra kết quả sau khi điều hướng giữa các trang:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665061349/nuxt3/nuxt3-page-transitions_umwvmh.jpg"}

Để đặt transition khác cho một trang, đặt khóa `pageTransition` trong [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) của trang:

::code-group
```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: "rotate",
  },
});
</script>
```

```vue [app.vue]
<template>
  <NuxtPage />
</template>

<style>
/* ... */
.rotate-enter-active,
.rotate-leave-active {
  transition: all 0.4s;
}
.rotate-enter-from,
.rotate-leave-to {
  opacity: 0;
  transform: rotate3d(1, 1, 1, 15deg);
}
</style>
```
::

Chuyển đến trang about sẽ thêm hiệu ứng xoay 3d:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665063233/nuxt3/nuxt3-page-transitions-cutom.jpg"}

## Layout Transitions

Bạn có thể kích hoạt layout transitions để áp dụng transition tự động cho tất cả các [layout](https://nuxt.com/docs/guide/directory-structure/layouts).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    layoutTransition: { name: "layout", mode: "out-in" },
  },
});
```

Để bắt đầu thêm transition giữa các trang và layout, thêm CSS sau vào [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app):

::code-group
```vue [app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>

<style>
.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}
.layout-enter-from,
.layout-leave-to {
  filter: grayscale(1);
}
</style>
```

```vue [layouts/default.vue]
<template>
  <div>
    <pre>default layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: lightgreen;
}
</style>
```

```vue [layouts/orange.vue]
<template>
  <div>
    <pre>orange layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: #eebb90;
  padding: 20px;
  height: 100vh;
}
</style>
```

```vue [pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: "orange",
});
</script>

<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```
::

Điều này tạo ra kết quả sau khi điều hướng giữa các trang:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665065289/nuxt3/nuxt3-layouts-transitions_c9hwlx.jpg"}

Tương tự như `pageTransition`, bạn có thể áp dụng `layoutTransition` tùy chỉnh cho page component bằng cách sử dụng `definePageMeta`:

```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  layout: "orange",
  layoutTransition: {
    name: "slide-in",
  },
});
</script>
```

## Global Settings

Bạn có thể tùy chỉnh các tên transition mặc định này một cách global bằng cách sử dụng `nuxt.config`.

Cả khóa `pageTransition` và `layoutTransition` đều chấp nhận [`TransitionProps`](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"} dưới dạng giá trị JSON serializable nơi bạn có thể truyền `name`, `mode` và các transition-props hợp lệ khác của custom CSS transition.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: {
      name: "fade",
      mode: "out-in", // mặc định
    },
    layoutTransition: {
      name: "slide",
      mode: "out-in", // mặc định
    },
  },
});
```

::warning
Nếu bạn thay đổi thuộc tính `name`, bạn cũng phải đổi tên các lớp CSS tương ứng.
::

Để ghi đè thuộc tính transition global, sử dụng `definePageMeta` để định nghĩa page hoặc layout transitions cho một trang Nuxt duy nhất và ghi đè bất kỳ page hoặc layout transitions nào được định nghĩa global trong file `nuxt.config`.

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: "bounce",
    mode: "out-in", // mặc định
  },
});
</script>
```

## Disable Transitions

`pageTransition` và `layoutTransition` có thể được vô hiệu hóa cho một route cụ thể:

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: false,
  layoutTransition: false,
});
</script>
```

Hoặc globally trong `nuxt.config`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: false,
    layoutTransition: false,
  },
});
```

## JavaScript Hooks

Đối với các trường hợp sử dụng nâng cao, bạn có thể sử dụng JavaScript hooks để tạo ra các transition rất động và tùy chỉnh cho các trang Nuxt.

Cách này trình bày các trường hợp sử dụng hoàn hảo cho các thư viện animation JavaScript như [GSAP](https://gsap.com){rel="nofollow"}.

```vue [pages/some-page.vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: "custom-flip",
    mode: "out-in",
    onBeforeEnter: (el) => {
      console.log("Before enter...");
    },
    onEnter: (el, done) => {},
    onAfterEnter: (el) => {},
  },
});
</script>
```

::tip
Tìm hiểu thêm về các [JavaScript hooks](https://vuejs.org/guide/built-ins/transition.html#javascript-hooks){rel="nofollow"} bổ sung có sẵn trong component `Transition`.
::

## Dynamic Transitions

Để áp dụng dynamic transitions bằng cách sử dụng logic có điều kiện, bạn có thể tận dụng inline [middleware](https://nuxt.com/docs/guide/directory-structure/middleware) để gán một tên transition khác cho `to.meta.pageTransition`.

::code-group
```vue [pages/[id\\].vue] twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: "slide-right",
    mode: "out-in",
  },
  middleware(to, from) {
    if (to.meta.pageTransition && typeof to.meta.pageTransition !== "boolean")
      to.meta.pageTransition.name =
        +to.params.id! > +from.params.id! ? "slide-left" : "slide-right";
  },
});
</script>

<template>
  <h1>#{{ $route.params.id }}</h1>
</template>

<style>
.slide-left-enter-active,
.slide-left-leave-active,
.slide-right-enter-active,
.slide-right-leave-active {
  transition: all 0.2s;
}
.slide-left-enter-from {
  opacity: 0;
  transform: translate(50px, 0);
}
.slide-left-leave-to {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-enter-from {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-leave-to {
  opacity: 0;
  transform: translate(50px, 0);
}
</style>
```

```vue [layouts/default.vue]
<script setup lang="ts">
const route = useRoute();
const id = computed(() => Number(route.params.id || 1));
const prev = computed(() => "/" + (id.value - 1));
const next = computed(() => "/" + (id.value + 1));
</script>

<template>
  <div>
    <slot />
    <div v-if="$route.params.id">
      <NuxtLink :to="prev">⬅️</NuxtLink> |
      <NuxtLink :to="next">➡️</NuxtLink>
    </div>
  </div>
</template>
```
::

Trang bây giờ áp dụng transition `slide-left` khi đi đến id tiếp theo và `slide-right` cho id trước đó:

:video{.rounded controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/v1665069410/nuxt3/nuxt-dynamic-page-transitions.jpg"}

## Transition with NuxtPage

Khi `<NuxtPage />` được sử dụng trong `app.vue`, transitions có thể được cấu hình với prop `transition` để kích hoạt transitions toàn cầu.

```vue [app.vue]
<template>
  <div>
    <NuxtLayout>
      <NuxtPage
        :transition="{
          name: 'bounce',
          mode: 'out-in',
        }"
      />
    </NuxtLayout>
  </div>
</template>
```

::note
Nhớ rằng, page transition này không thể được ghi đè bằng `definePageMeta` trên các trang riêng lẻ.
::

## View Transitions API (experimental)

Nuxt được trang bị một implementation thử nghiệm của [**View Transitions API**](https://developer.chrome.com/docs/web-platform/view-transitions){rel="nofollow"} (xem [MDN](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API){rel="nofollow"}). Đây là một cách mới thú vị để implement native browser transitions có khả năng (cùng với những thứ khác) chuyển đổi giữa các phần tử không liên quan trên các trang khác nhau.

Bạn có thể kiểm tra demo tại <https://nuxt-view-transitions.surge.sh>{rel="nofollow"} và [source trên StackBlitz](https://stackblitz.com/edit/nuxt-view-transitions){rel="nofollow"}.

Tích hợp Nuxt đang được phát triển tích cực, nhưng có thể được kích hoạt với tùy chọn `experimental.viewTransition` trong file cấu hình của bạn:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    viewTransition: true,
  },
});
```

Các giá trị có thể là: `false`, `true`, hoặc `'always'`.

Nếu được đặt thành true, Nuxt sẽ không áp dụng transitions nếu trình duyệt của người dùng khớp với `prefers-reduced-motion: reduce` (được khuyến nghị). Nếu được đặt thành `always`, Nuxt sẽ luôn áp dụng transition và việc tôn trọng sở thích của người dùng là tùy thuộc vào bạn.

Theo mặc định, view transitions được bật cho tất cả các [trang](https://nuxt.com/docs/guide/directory-structure/pages), nhưng bạn có thể đặt một giá trị mặc định global khác.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  app: {
    // Vô hiệu hóa view transitions toàn cầu, và opt-in trên cơ sở từng trang
    viewTransition: false,
  },
});
```

Có thể ghi đè giá trị `viewTransition` mặc định cho một trang bằng cách đặt khóa `viewTransition` trong [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) của trang:

```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  viewTransition: false,
});
</script>
```

::warning
Việc ghi đè view transitions trên cơ sở từng trang sẽ chỉ có hiệu lực nếu bạn đã bật tùy chọn `experimental.viewTransition`.
::

Nếu bạn cũng đang sử dụng Vue transitions như `pageTransition` và `layoutTransition` (xem ở trên) để đạt được kết quả tương tự như View Transitions API mới, thì bạn có thể muốn *vô hiệu hóa* Vue transitions nếu trình duyệt của người dùng hỗ trợ web API native mới hơn. Bạn có thể làm điều này bằng cách tạo `~/middleware/disable-vue-transitions.global.ts` với nội dung sau:

```ts
export default defineNuxtRouteMiddleware((to) => {
  if (import.meta.server || !document.startViewTransition) {
    return;
  }

  // Vô hiệu hóa Vue transitions tích hợp
  to.meta.pageTransition = false;
  to.meta.layoutTransition = false;
});
```

### Known Issues

- Nếu bạn thực hiện data fetching trong các hàm setup trang của mình, bạn có thể muốn xem xét lại việc sử dụng tính năng này vào lúc này. (Theo thiết kế, View Transitions hoàn toàn đóng băng các cập nhật DOM trong khi chúng diễn ra.) Chúng tôi đang xem xét việc hạn chế View Transition đến những khoảnh khắc cuối cùng trước khi `<Suspense>` resolves, nhưng trong thời gian tạm thời, bạn có thể muốn xem xét cẩn thận việc có nên áp dụng tính năng này nếu điều này mô tả bạn.


# Data Fetching

Nuxt đi kèm với hai composable và một thư viện tích hợp để thực hiện data-fetching trong môi trường trình duyệt hoặc server: `useFetch`, [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và `$fetch`.

Tóm lại:

- [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) là cách đơn giản nhất để tạo một network request.
- [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) là một wrapper xung quanh `$fetch` chỉ fetch data một lần trong [universal rendering](https://nuxt.com/docs/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) tương tự như `useFetch` nhưng cung cấp kiểm soát chi tiết hơn.

Cả `useFetch` và `useAsyncData` đều chia sẻ một tập hợp chung các tùy chọn và patterns mà chúng ta sẽ chi tiết trong các phần cuối.

## The need for `useFetch` and `useAsyncData`

Nuxt là một framework có thể chạy mã isomorphic (hoặc universal) trong cả môi trường server và client. Nếu hàm [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) được sử dụng để thực hiện data fetching trong setup function của một Vue component, điều này có thể khiến data được fetch hai lần, một lần trên server (để render HTML) và một lần nữa trên client (khi HTML được hydrated). Điều này có thể gây ra vấn đề hydration, tăng thời gian để tương tác và gây ra hành vi không thể đoán trước.

Các composable [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) và [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) giải quyết vấn đề này bằng cách đảm bảo rằng nếu một API call được thực hiện trên server, data sẽ được chuyển tiếp đến client trong payload.

Payload là một JavaScript object có thể truy cập thông qua [`useNuxtApp().payload`](https://nuxt.com/docs/api/composables/use-nuxt-app#payload). Nó được sử dụng trên client để tránh refetching cùng một data khi mã được thực thi trong trình duyệt [trong quá trình hydration](https://nuxt.com/docs/guide/concepts/rendering#universal-rendering).

::tip
Sử dụng [Nuxt DevTools](https://devtools.nuxt.com){rel="nofollow"} để kiểm tra data này trong **Payload tab**.
::

```vue [app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit() {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // My form data
    }
  })
}
</script>

<template>
  <div v-if="data == undefined">
    No data
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- form input tags -->
    </form>
  </div>
</template>
```

Trong ví dụ trên, `useFetch` sẽ đảm bảo rằng request sẽ xảy ra trong server và được chuyển tiếp đúng cách đến trình duyệt. `$fetch` không có cơ chế như vậy và là lựa chọn tốt hơn để sử dụng khi request chỉ được thực hiện từ trình duyệt.

### Suspense

Nuxt sử dụng component [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense){rel="nofollow"} của Vue để ngăn navigation trước khi mọi async data có sẵn cho view. Các data fetching composable có thể giúp bạn tận dụng tính năng này và sử dụng những gì phù hợp nhất trên cơ sở mỗi call.

::note
Bạn có thể thêm [`<NuxtLoadingIndicator>`](https://nuxt.com/docs/api/components/nuxt-loading-indicator) để thêm thanh tiến trình giữa các navigation trang.
::

## `$fetch`

Nuxt bao gồm thư viện [ofetch](https://github.com/unjs/ofetch){rel="nofollow"}, và được auto-imported dưới dạng alias `$fetch` trên toàn cầu trong ứng dụng của bạn.

```vue [pages/todos.vue] twoslash
<script setup lang="ts">
async function addTodo() {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // My todo data
    }
  })
}
</script>
```

::warning
Hãy cẩn thận rằng việc chỉ sử dụng `$fetch` sẽ không cung cấp [network calls de-duplication và navigation prevention](https://nuxt.com/#the-need-for-usefetch-and-useasyncdata). :br
Được khuyến nghị sử dụng `$fetch` cho các tương tác phía client (dựa trên sự kiện) hoặc kết hợp với [`useAsyncData`](https://nuxt.com/#useasyncdata) khi fetching data component ban đầu.
::

::read-more{to="https://nuxt.com/docs/api/utils/dollarfetch"}
Read more about `$fetch`.
::

### Pass Client Headers to the API

Khi gọi `useFetch` trên server, Nuxt sẽ sử dụng [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) để proxy client headers và cookies (ngoại trừ các headers không được dành để forward, như `host`).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo');
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

Hoặc, ví dụ bên dưới cho thấy cách sử dụng [`useRequestHeaders`](https://nuxt.com/docs/api/composables/use-request-headers) để truy cập và gửi cookies đến API từ một server-side request (bắt nguồn từ client). Sử dụng một isomorphic `$fetch` call, chúng ta đảm bảo rằng API endpoint có quyền truy cập vào cùng một `cookie` header ban đầu được gửi bởi trình duyệt của người dùng. Điều này chỉ cần thiết nếu bạn không sử dụng `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser() {
  return await $fetch('/api/me', { headers })
}
</script>
```

::tip
Bạn cũng có thể sử dụng [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) để proxy headers đến call một cách tự động.
::

::caution
Hãy rất cẩn thận trước khi proxy headers đến một external API và chỉ bao gồm các headers mà bạn cần. Không phải tất cả headers đều an toàn để được bypassed và có thể giới thiệu hành vi không mong muốn. Đây là danh sách các headers phổ biến mà KHÔNG nên được proxy:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`
::

## `useFetch`

Composable [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) sử dụng `$fetch` bên trong để thực hiện các network call an toàn SSR trong setup function.

```vue [app.vue] twoslash
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Page visits: {{ count }}</p>
</template>
```

Composable này là một wrapper xung quanh composable [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và utility `$fetch`.

::video-accordion
---
title: Watch a video from Alexander Lichter to avoid using useFetch the wrong way
video-id: njsGVmcWviY
---
::

::read-more{to="https://nuxt.com/docs/api/composables/use-fetch"}
::

::link-example{to="https://nuxt.com/docs/examples/features/data-fetching"}
::

## `useAsyncData`

Composable `useAsyncData` chịu trách nhiệm bao bọc async logic và trả về kết quả khi nó được resolved.

::tip
`useFetch(url)` gần như tương đương với `useAsyncData(url, () => event.$fetch(url))`. :br
Đó là developer experience sugar cho trường hợp sử dụng phổ biến nhất. (Bạn có thể tìm hiểu thêm về `event.fetch` tại [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch).)
::

::video-accordion
---
title: Watch a video from Alexander Lichter to dig deeper into the difference
  between useFetch and useAsyncData
video-id: 0X-aOpSGabA
---
::

Có một số trường hợp khi việc sử dụng composable [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) không phù hợp, ví dụ khi một CMS hoặc bên thứ ba cung cấp query layer riêng của họ. Trong trường hợp này, bạn có thể sử dụng [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) để bao bọc các call của mình và vẫn giữ các lợi ích được cung cấp bởi composable.

```vue [pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// Điều này cũng có thể:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

::note
Đối số đầu tiên của [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) là một key duy nhất được sử dụng để cache response của đối số thứ hai, querying function. Key này có thể được bỏ qua bằng cách truyền trực tiếp querying function, key sẽ được tự động tạo.
:br :br
Vì key được tự động tạo chỉ tính đến file và line nơi `useAsyncData` được gọi, nên khuyến nghị luôn tạo key riêng của bạn để tránh hành vi không mong muốn, như khi bạn đang tạo custom composable riêng bao bọc `useAsyncData`.
:br :br
Đặt một key có thể hữu ích để chia sẻ cùng một data giữa các component bằng cách sử dụng [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data) hoặc để [refresh data cụ thể](https://nuxt.com/docs/api/utils/refresh-nuxt-data#refresh-specific-data).
::

```vue [pages/users/[id\\].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

Composable `useAsyncData` là cách tuyệt vời để bao bọc và chờ nhiều `$fetch` request hoàn thành, sau đó xử lý kết quả.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async () => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons'),
    $fetch('/cart/offers')
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

::note
`useAsyncData` dành cho fetching và caching data, không phải triggering side effects như gọi Pinia actions, vì điều này có thể gây ra hành vi không mong muốn như thực thi lặp lại với giá trị nullish. Nếu bạn cần trigger side effects, hãy sử dụng utility [`callOnce`](https://nuxt.com/docs/api/utils/call-once) để làm như vậy.

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// bạn không thể làm điều này
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```
::

::read-more{to="https://nuxt.com/docs/api/composables/use-async-data"}
Read more about `useAsyncData`.
::

## Return Values

`useFetch` và `useAsyncData` có cùng return values được liệt kê bên dưới.

- `data`: kết quả của asynchronous function được truyền vào.
- `refresh`/`execute`: một hàm có thể được sử dụng để refresh data được trả về bởi hàm `handler`.
- `clear`: một hàm có thể được sử dụng để đặt `data` thành `undefined` (hoặc giá trị của `options.default()` nếu được cung cấp), đặt `error` thành `undefined`, đặt `status` thành `idle`, và đánh dấu bất kỳ request nào đang pending là cancelled.
- `error`: một error object nếu data fetching thất bại.
- `status`: một chuỗi chỉ ra trạng thái của data request (`"idle"`, `"pending"`, `"success"`, `"error"`).

::note
`data`, `error` và `status` là Vue refs có thể truy cập bằng `.value` trong `<script setup>`
::

Theo mặc định, Nuxt chờ đến khi một `refresh` hoàn thành trước khi nó có thể được thực thi lại.

::note
Nếu bạn chưa fetch data trên server (ví dụ, với `server: false`), thì data *sẽ không* được fetched cho đến khi hydration hoàn thành. Điều này có nghĩa là ngay cả khi bạn await `useFetch` trên client-side, `data` sẽ vẫn là null trong `<script setup>`.
::

## Options

[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) trả về cùng object type và chấp nhận một tập hợp chung các tùy chọn như đối số cuối cùng của chúng. Chúng có thể giúp bạn kiểm soát hành vi của composable, chẳng hạn như navigation blocking, caching hoặc execution.

### Lazy

Theo mặc định, data fetching composable sẽ chờ resolution của asynchronous function của chúng trước khi điều hướng đến trang mới bằng cách sử dụng Suspense của Vue. Tính năng này có thể được bỏ qua trên client-side navigation với tùy chọn `lazy`. Trong trường hợp đó, bạn sẽ phải xử lý loading state một cách thủ công bằng cách sử dụng giá trị `status`.

```vue [app.vue] twoslash
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true
})
</script>

<template>
  <!-- bạn sẽ cần xử lý loading state -->
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

Bạn có thể sử dụng [`useLazyFetch`](https://nuxt.com/docs/api/composables/use-lazy-fetch) và `useLazyAsyncData` như các phương thức tiện lợi để thực hiện tương tự.

```vue twoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

::read-more{to="https://nuxt.com/docs/api/composables/use-lazy-fetch"}
Read more about `useLazyFetch`.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-lazy-async-data"}
Read more about `useLazyAsyncData`.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on blocking vs. non-blocking (lazy) requests
video-id: "1022000555"
---
::

### Client-only fetching

Theo mặc định, data fetching composable sẽ thực hiện asynchronous function của chúng trên cả môi trường client và server. Đặt tùy chọn `server` thành `false` để chỉ thực hiện call trên client-side. Trên initial load, data sẽ không được fetched trước khi hydration hoàn thành vì vậy bạn phải xử lý pending state, mặc dù trên subsequent client-side navigation, data sẽ được awaited trước khi load trang.

Kết hợp với tùy chọn `lazy`, điều này có thể hữu ích cho data không cần thiết trên render đầu tiên (ví dụ, data không nhạy cảm với SEO).

```ts twoslash
/* Call này được thực hiện trước hydration */
const articles = await useFetch('/api/article')

/* Call này sẽ chỉ được thực hiện trên client */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false
})
```

Composable `useFetch` được dành để được gọi trong setup method hoặc gọi trực tiếp ở cấp độ top của một hàm trong lifecycle hooks, nếu không bạn nên sử dụng [phương thức `$fetch`](https://nuxt.com/#fetch).

### Minimize payload size

Tùy chọn `pick` giúp bạn giảm thiểu kích thước payload được lưu trữ trong tài liệu HTML bằng cách chỉ chọn các field mà bạn muốn trả về từ các composable.

```vue
<script setup lang="ts">
/* chỉ pick các field được sử dụng trong template của bạn */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description']
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

Nếu bạn cần nhiều kiểm soát hơn hoặc map qua nhiều object, bạn có thể sử dụng hàm `transform` để thay đổi kết quả của query.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  }
})
```

::note
Cả `pick` và `transform` không ngăn unwanted data được fetched ban đầu. Nhưng chúng sẽ ngăn unwanted data được thêm vào payload chuyển từ server đến client.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on minimizing payload size
video-id: "1026410430"
---
::

### Caching and refetching

#### Keys

[`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) và [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) sử dụng keys để ngăn refetching cùng data.

- [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) sử dụng URL được cung cấp làm key. Hoặc, một giá trị `key` có thể được cung cấp trong object `options` được truyền như đối số cuối cùng.
- [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) sử dụng đối số đầu tiên của nó làm key nếu nó là một chuỗi. Nếu đối số đầu tiên là handler function thực hiện query, thì một key duy nhất cho file name và line number của instance `useAsyncData` sẽ được tạo cho bạn.

::tip
Để lấy cached data theo key, bạn có thể sử dụng [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data)
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on caching data with the key option
video-id: "1026410044"
---
::

#### Shared State and Option Consistency

Khi nhiều component sử dụng cùng key với `useAsyncData` hoặc `useFetch`, chúng sẽ chia sẻ cùng `data`, `error` và `status` refs. Điều này đảm bảo tính nhất quán giữa các component nhưng yêu cầu một số tùy chọn phải nhất quán.

Các tùy chọn sau **phải nhất quán** trên tất cả các call với cùng key:

- hàm `handler`
- tùy chọn `deep`
- hàm `transform`
- mảng `pick`
- hàm `getCachedData`
- giá trị `default`

```ts
// ❌ Điều này sẽ kích hoạt warning phát triển
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
```

Các tùy chọn sau **có thể khác nhau một cách an toàn** mà không kích hoạt warning:

- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ Điều này được phép
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: true })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: false })
```

Nếu bạn cần các instance độc lập, sử dụng các key khác nhau:

```ts
// Đây là các instance hoàn toàn độc lập
const { data: users1 } = useAsyncData('users-1', () => $fetch('/api/users'))
const { data: users2 } = useAsyncData('users-2', () => $fetch('/api/users'))
```

#### Reactive Keys

Bạn có thể sử dụng computed refs, plain refs hoặc getter functions làm keys, cho phép dynamic data fetching tự động cập nhật khi dependencies thay đổi:

```ts
// Sử dụng computed property làm key
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value)
)

// Khi userId thay đổi, data sẽ tự động được refetched
// và old data sẽ được dọn dẹp nếu không có component nào khác sử dụng nó
userId.value = '456'
```

#### Refresh and execute

Nếu bạn muốn fetch hoặc refresh data một cách thủ công, hãy sử dụng hàm `execute` hoặc `refresh` được cung cấp bởi các composable.

```vue twoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">Refresh data</button>
  </div>
</template>
```

Hàm `execute` là một alias cho `refresh` hoạt động hoàn toàn giống nhau nhưng có tính semantic hơn cho các trường hợp khi fetch [không immediate](https://nuxt.com/#not-immediate).

::tip
Để globally refetch hoặc invalidate cached data, xem [`clearNuxtData`](https://nuxt.com/docs/api/utils/clear-nuxt-data) và [`refreshNuxtData`](https://nuxt.com/docs/api/utils/refresh-nuxt-data).
::

#### Clear

Nếu bạn muốn clear data được cung cấp, vì bất kỳ lý do gì, mà không cần biết key cụ thể để truyền cho `clearNuxtData`, bạn có thể sử dụng hàm `clear` được cung cấp bởi các composable.

```vue twoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') clear()
})
</script>
```

#### Watch

Để re-run fetching function mỗi khi các reactive values khác trong ứng dụng thay đổi, hãy sử dụng tùy chọn `watch`. Bạn có thể sử dụng nó cho một hoặc nhiều elements *watchable*.

```vue twoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Thay đổi id sẽ kích hoạt refetch */
  watch: [id]
})
</script>
```

Lưu ý rằng **watching một reactive value sẽ không thay đổi URL được fetched**. Ví dụ, điều này sẽ tiếp tục fetching cùng ID ban đầu của user bởi vì URL được xây dựng tại thời điểm hàm được gọi.

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id]
})
</script>
```

Nếu bạn cần thay đổi URL dựa trên một reactive value, bạn có thể muốn sử dụng một [computed URL](https://nuxt.com/#computed-url) thay thế.

#### Computed URL

Đôi khi bạn cần tính toán một URL từ các giá trị reactive, và làm mới dữ liệu mỗi khi các giá trị đó thay đổi. Thay vì phải xử lý phức tạp, bạn có thể gắn trực tiếp từng tham số như một giá trị reactive. Nuxt sẽ tự động sử dụng giá trị reactive và re-fetch mỗi khi nó thay đổi.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id
  }
})
</script>
```

Trong trường hợp việc xây dựng URL phức tạp hơn, bạn có thể dùng callback như một [computed getter](https://vuejs.org/guide/essentials/computed.html){rel="nofollow"} để trả về chuỗi URL.

Mỗi khi một dependency thay đổi, dữ liệu sẽ được fetch bằng URL mới. Kết hợp với [not-immediate](https://nuxt.com/#not-immediate), bạn có thể chờ đến khi phần tử reactive thay đổi mới tiến hành fetch.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false
})

const pending = computed(() => status.value === 'pending');
</script>

<template>
  <div>
    <!-- disable the input while fetching -->
    <input v-model="id" type="number" :disabled="pending"/>

    <div v-if="status === 'idle'">
      Type an user ID
    </div>

    <div v-else-if="pending">
      Loading ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

Nếu bạn cần ép buộc refresh khi các giá trị reactive khác thay đổi, bạn cũng có thể [watch các giá trị khác](https://nuxt.com/#watch).

### Not immediate

Composable `useFetch` sẽ bắt đầu fetch dữ liệu ngay khi được gọi. Bạn có thể ngăn việc này bằng cách đặt `immediate: false`, ví dụ, để chờ người dùng tương tác.

Với cách này, bạn cần cả `status` để xử lý vòng đời fetch, và `execute` để bắt đầu fetch dữ liệu.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/comments', {
  immediate: false
})
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">Get data</button>
  </div>

  <div v-else-if="status === 'pending'">
    Loading comments...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

Để kiểm soát chi tiết hơn, biến `status` có thể là:

- `idle` khi fetch chưa bắt đầu
- `pending` khi fetch đã bắt đầu nhưng chưa hoàn tất
- `error` khi fetch thất bại
- `success` khi fetch hoàn tất thành công

## Passing Headers and Cookies

Khi gọi `$fetch` trong browser, các header của người dùng như `cookie` sẽ được gửi trực tiếp đến API.

Thông thường, trong quá trình server-side-rendering, vì lý do bảo mật, `$fetch` sẽ không bao gồm cookie của browser, cũng như không truyền cookie từ phản hồi fetch.

Tuy nhiên, khi gọi `useFetch` với URL tương đối trên server, Nuxt sẽ sử dụng [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) để proxy headers và cookies (ngoại trừ các header không nên chuyển tiếp như `host`).

### Pass Cookies From Server-side API Calls on SSR Response

Nếu bạn muốn truyền/proxy cookies theo hướng ngược lại, từ một request nội bộ trả về client, bạn cần tự xử lý.

```ts [composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Get the response from the server endpoint */
  const res = await $fetch.raw(url)
  /* Get the cookies from the response */
  const cookies = res.headers.getSetCookie()
  /* Attach each cookie to our incoming Request */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  /* Return the data of the response */
  return res._data
}
```

```vue
<script setup lang="ts">
// This composable will automatically pass cookies to the client
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Options API Support

Nuxt cung cấp cách thực hiện `asyncData` fetching trong Options API. Bạn phải bọc định nghĩa component bằng `defineNuxtComponent` để nó hoạt động.

```vue
<script>
export default defineNuxtComponent({
  /* Use the fetchKey option to provide a unique key */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

::note
Sử dụng `<script setup>` hoặc `<script setup lang="ts">` là cách khuyến nghị để khai báo Vue component trong Nuxt.
::

::read-more{to="https://nuxt.com/docs/api/utils/define-nuxt-component"}
::

## Serializing Data From Server to Client

Khi dùng `useAsyncData` và `useLazyAsyncData` để truyền dữ liệu fetch từ server sang client (cũng như các trường hợp khác sử dụng [Nuxt payload](https://nuxt.com/docs/api/composables/use-nuxt-app#payload)), payload sẽ được serialize bằng [`devalue`](https://github.com/Rich-Harris/devalue){rel="nofollow"}. Điều này cho phép truyền không chỉ JSON cơ bản mà còn serialize/deserialize các loại dữ liệu nâng cao như regular expressions, Dates, Map, Set, `ref`, `reactive`, `shallowRef`, `shallowReactive` và `NuxtError`, v.v.

Bạn cũng có thể định nghĩa serializer/deserializer riêng cho các kiểu dữ liệu mà Nuxt không hỗ trợ. Tham khảo thêm trong tài liệu [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app#payload).

Lưu ý rằng điều này *không áp dụng* cho dữ liệu được trả về từ server routes khi fetch bằng `$fetch` hoặc `useFetch` – xem phần tiếp theo để biết thêm chi tiết.
\::

## Serializing Data From API Routes

Khi fetch dữ liệu từ thư mục `server`, response sẽ được serialize bằng `JSON.stringify`. Tuy nhiên, do giới hạn của việc serialize chỉ với các kiểu primitive của JavaScript, Nuxt sẽ cố gắng chuyển đổi giá trị trả về của `$fetch` và [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) sao cho khớp với giá trị thực.

Tìm hiểu thêm về giới hạn của `JSON.stringify`.
\::

### Example

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as string even though we returned a Date object
const { data } = await useFetch('/api/foo')
</script>
```

### Custom serializer function

Để tùy chỉnh hành vi serialize, bạn có thể định nghĩa hàm `toJSON` trong object được trả về. Nếu có `toJSON`, Nuxt sẽ sử dụng kết quả của hàm đó và không cố gắng chuyển đổi kiểu nữa.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON() {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})
```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Using an alternative serializer

Nuxt hiện chưa hỗ trợ serializer thay thế cho `JSON.stringify`. Tuy nhiên, bạn có thể trả payload dưới dạng chuỗi bình thường và dùng `toJSON` để giữ an toàn kiểu dữ liệu.

Ví dụ dưới đây sử dụng [superjson](https://github.com/blitz-js/superjson){rel="nofollow"} làm serializer.

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Workaround the type conversion
    toJSON() {
      return this
    }
  }

  // Serialize the output to string, using superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Recipes

### Consuming SSE (Server-Sent Events) via POST request

::tip
Nếu bạn dùng SSE qua GET request, bạn có thể sử dụng [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource){rel="nofollow"} hoặc VueUse composable [`useEventSource`](https://vueuse.org/core/useEventSource/){rel="nofollow"}.
::

Khi dùng SSE qua POST request, bạn cần tự xử lý kết nối. Ví dụ:

```ts
// Make a POST request to the SSE endpoint
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: "Hello AI, how are you?",
  },
  responseType: 'stream',
})

// Create a new ReadableStream from the response with TextDecoderStream to get the data as text
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

// Read the chunk of data as we get it
while (true) {
  const { value, done } = await reader.read()

  if (done)
    break

  console.log('Received:', value)
}
```

### Making parallel requests

Khi các request không phụ thuộc lẫn nhau, bạn có thể chạy song song bằng `Promise.all()` để cải thiện hiệu năng.

```ts
const { data } = await useAsyncData(() => {
  return Promise.all([
    $fetch("/api/comments/"), 
    $fetch("/api/author/12")
  ]);
});

const comments = computed(() => data.value?.[0]);
const author = computed(() => data.value?.[1]);
```

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on parallel data fetching
video-id: "1024262536"
---
::


# State Management

Nuxt cung cấp composable [`useState`](https://nuxt.com/docs/api/composables/use-state) để tạo ra một shared state phản ứng và thân thiện với SSR qua các component.

[`useState`](https://nuxt.com/docs/api/composables/use-state) là một thay thế thân thiện với SSR cho [`ref`](https://vuejs.org/api/reactivity-core.html#ref){rel="nofollow"}. Giá trị của nó sẽ được bảo toàn sau server-side rendering (trong quá trình client-side hydration) và được chia sẻ qua tất cả các component sử dụng một key duy nhất.

::video-accordion
---
title: Xem video từ Alexander Lichter về tại sao và khi nào nên sử dụng useState
video-id: mv0WcBABcIk
---
::

::important
Vì dữ liệu bên trong [`useState`](https://nuxt.com/docs/api/composables/use-state) sẽ được serialize thành JSON, điều quan trọng là nó không được chứa bất cứ thứ gì không thể serialize được, chẳng hạn như class, function hoặc symbol.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-state"}
Đọc thêm về composable `useState`.
::

## Best Practices

::warning
Không bao giờ định nghĩa `const state = ref()` bên ngoài `<script setup>` hoặc function `setup()`. :br
Ví dụ, việc làm `export myState = ref({})` sẽ dẫn đến state được chia sẻ qua các request trên server và có thể gây ra memory leak.
::

::tip{icon="i-lucide-circle-check"}
Thay vào đó hãy sử dụng `const useX = () => useState('x')`
::

## Examples

### Basic Usage

Trong ví dụ này, chúng ta sử dụng một counter state cục bộ của component. Bất kỳ component nào khác sử dụng `useState('counter')` sẽ chia sẻ cùng một reactive state.

```vue [app.vue] twoslash
<script setup lang="ts">
const counter = useState('counter', () => Math.round(Math.random() * 1000))
</script>

<template>
  <div>
    Counter: {{ counter }}
    <button @click="counter++">
      +
    </button>
    <button @click="counter--">
      -
    </button>
  </div>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/features/state-management"}
::

::note
Để vô hiệu hóa cached state toàn cục, xem util [`clearNuxtState`](https://nuxt.com/docs/api/utils/clear-nuxt-state).
::

### Initializing State

Hầu hết thời gian, bạn sẽ muốn khởi tạo state của mình với dữ liệu resolve bất đồng bộ. Bạn có thể sử dụng component [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) với util [`callOnce`](https://nuxt.com/docs/api/utils/call-once) để làm điều này.

```vue [app.vue] twoslash
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

::tip
Điều này tương tự như [`nuxtServerInit` action](https://v2.nuxt.com/docs/directory-structure/store/#the-nuxtserverinit-action){rel="nofollow"} trong Nuxt 2, cho phép điền initial state của store ở phía server trước khi render trang.
::

::read-more{to="https://nuxt.com/docs/api/utils/call-once"}
::

### Usage with Pinia

Trong ví dụ này, chúng ta tận dụng [Pinia module](https://nuxt.com/modules/pinia) để tạo một global store và sử dụng nó trong toàn bộ app.

::important
Hãy chắc chắn cài đặt Pinia module với `npx nuxt module add pinia` hoặc làm theo [các bước cài đặt của module](https://pinia.vuejs.org/ssr/nuxt.html#Installation){rel="nofollow"}.
::

::code-group
```ts [stores/website.ts]
export const useWebsiteStore = defineStore('websiteStore', {
  state: () => ({
    name: '',
    description: ''
  }),
  actions: {
    async fetch() {
      const infos = await $fetch('https://api.nuxt.com/modules/pinia')

      this.name = infos.name
      this.description = infos.description
    }
  }
})
```

```vue [app.vue]
<script setup lang="ts">
const website = useWebsiteStore()

await callOnce(website.fetch)
</script>

<template>
  <main>
    <h1>{{ website.name }}</h1>
    <p>{{ website.description }}</p>
  </main>
</template>
```
::

## Advanced Usage

::code-group
```ts [composables/locale.ts]
import type { Ref } from 'vue'

export const useLocale = () => {
  return useState<string>('locale', () => useDefaultLocale().value)
}

export const useDefaultLocale = (fallback = 'en-US') => {
  const locale = ref(fallback)
  if (import.meta.server) {
    const reqLocale = useRequestHeaders()['accept-language']?.split(',')[0]
    if (reqLocale) {
      locale.value = reqLocale
    }
  } else if (import.meta.client) {
    const navLang = navigator.language
    if (navLang) {
      locale.value = navLang
    }
  }
  return locale
}

export const useLocales = () => {
  const locale = useLocale()
  const locales = ref([
    'en-US',
    'en-GB',
    ...
    'ja-JP-u-ca-japanese'
  ])
  if (!locales.value.includes(locale.value)) {
    locales.value.unshift(locale.value)
  }
  return locales
}

export const useLocaleDate = (date: Ref<Date> | Date, locale = useLocale()) => {
  return computed(() => new Intl.DateTimeFormat(locale.value, { dateStyle: 'full' }).format(unref(date)))
}
```

```vue [app.vue]
<script setup lang="ts">
const locales = useLocales()
const locale = useLocale()
const date = useLocaleDate(new Date('2016-10-26'))
</script>

<template>
  <div>
    <h1>Nuxt birthday</h1>
    <p>{{ date }}</p>
    <label for="locale-chooser">Xem trước một locale khác</label>
    <select id="locale-chooser" v-model="locale">
      <option v-for="locale of locales" :key="locale" :value="locale">
        {{ locale }}
      </option>
    </select>
  </div>
</template>
```
::

::link-example{to="https://nuxt.com/docs/examples/advanced/locale"}
::

## Shared State

Bằng cách sử dụng [auto-imported composables](https://nuxt.com/docs/guide/directory-structure/composables), chúng ta có thể định nghĩa các global state type-safe và import chúng trong toàn bộ app.

```ts [composables/states.ts] twoslash
export const useColor = () => useState<string>('color', () => 'pink')
```

```vue [app.vue]
<script setup lang="ts">
// ---cut-start---
const useColor = () => useState<string>('color', () => 'pink')
// ---cut-end---
const color = useColor() // Giống như useState('color')
</script>

<template>
  <p>Màu hiện tại: {{ color }}</p>
</template>
```

::video-accordion
---
title: Xem video từ Daniel Roe về cách xử lý global state và SSR trong Nuxt
video-id: dZSNW07sO-A
---
::

## Using third-party libraries

Nuxt **đã từng dựa vào** thư viện Vuex để cung cấp quản lý global state. Nếu bạn đang migration từ Nuxt 2, vui lòng tham khảo [hướng dẫn migration](https://nuxt.com/docs/migration/configuration#vuex).

Nuxt không có quan điểm cố định về quản lý state, vì vậy hãy thoải mái chọn giải pháp phù hợp với nhu cầu của bạn. Có nhiều tích hợp với các thư viện quản lý state phổ biến nhất, bao gồm:

- [Pinia](https://nuxt.com/modules/pinia) - khuyến nghị chính thức của Vue
- [Harlem](https://nuxt.com/modules/harlem) - quản lý immutable global state
- [XState](https://nuxt.com/modules/xstate) - phương pháp state machine với các công cụ để visualize và test logic state của bạn


# Error Handling

Nuxt là một full-stack framework, điều này có nghĩa là có một số nguồn lỗi runtime của người dùng không thể tránh khỏi có thể xảy ra ở các ngữ cảnh khác nhau:

- Errors during the Vue rendering lifecycle (SSR & CSR)
- Server and client startup errors (SSR + CSR)
- Errors during Nitro server lifecycle ([`server/`](https://nuxt.com/docs/guide/directory-structure/server) directory)
- Errors downloading JS chunks

::tip
**SSR** là viết tắt của **Server-Side Rendering** và **CSR** là **Client-Side Rendering**.
::

## Vue Errors

Bạn có thể bắt lỗi Vue bằng cách sử dụng [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"}.

Ngoài ra, Nuxt cung cấp hook [`vue:error`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) sẽ được gọi nếu bất kỳ lỗi nào lan truyền lên cấp cao nhất.

Nếu bạn đang sử dụng một framework báo cáo lỗi, bạn có thể cung cấp một global handler thông qua [`vueApp.config.errorHandler`](https://vuejs.org/api/application.html#app-config-errorhandler){rel="nofollow"}. Nó sẽ nhận tất cả lỗi Vue, ngay cả khi những lỗi đó đã được xử lý.

```ts [plugins/error-handler.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.config.errorHandler = (error, instance, info) => {
    // handle error, e.g. report to a service
  }

  // Also possible
  nuxtApp.hook('vue:error', (error, instance, info) => {
    // handle error, e.g. report to a service
  })
})
```

::note
Lưu ý rằng hook `vue:error` dựa trên lifecycle hook [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"}.
::

## Startup Errors

Nuxt sẽ gọi hook `app:error` nếu có bất kỳ lỗi nào khi khởi động ứng dụng Nuxt của bạn.

Điều này bao gồm:

- running [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins)
- processing `app:created` and `app:beforeMount` hooks
- rendering your Vue app to HTML (during SSR)
- mounting the app (on client-side), though you should handle this case with `onErrorCaptured` or with `vue:error`
- processing the `app:mounted` hook

## Nitro Server Errors

Bạn hiện không thể định nghĩa một server-side handler cho những lỗi này, nhưng có thể render một trang lỗi — xem mục [Render an Error Page](https://nuxt.com/#error-page).

## Errors with JS Chunks

Bạn có thể gặp lỗi tải chunk do sự cố kết nối mạng hoặc do một lần triển khai mới (làm cho các URL JS chunk cũ có hash bị vô hiệu). Nuxt cung cấp hỗ trợ sẵn để xử lý lỗi tải chunk bằng cách thực hiện reload cứng khi một chunk không thể tải trong quá trình điều hướng route.

Bạn có thể thay đổi hành vi này bằng cách đặt `experimental.emitRouteChunkError` thành `false` (để vô hiệu hóa hoàn toàn việc hook vào các lỗi này) hoặc thành `manual` nếu bạn muốn tự xử lý. Nếu bạn muốn xử lý lỗi tải chunk thủ công, bạn có thể tham khảo [the automatic implementation](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/plugins/chunk-reload.client.ts){rel="nofollow"} để lấy ý tưởng.

## Error Page

::note
Khi Nuxt gặp lỗi nghiêm trọng (bất kỳ lỗi nào không được xử lý trên server, hoặc một lỗi được tạo với `fatal: true` trên client) nó sẽ hoặc render phản hồi JSON (nếu được yêu cầu với header `Accept: application/json`) hoặc hiển thị một trang lỗi toàn màn hình.
::

Một lỗi có thể xảy ra trong vòng đời server khi:

- processing your Nuxt plugins
- rendering your Vue app into HTML
- a server API route throws an error

Nó cũng có thể xảy ra ở phía client khi:

- processing your Nuxt plugins
- before mounting the application (`app:beforeMount` hook)
- mounting your app if the error was not handled with `onErrorCaptured` or `vue:error` hook
- the Vue app is initialized and mounted in browser (`app:mounted`).

::read-more{to="https://nuxt.com/docs/api/advanced/hooks"}
Khám phá tất cả lifecycle hook của Nuxt.
::

Tùy chỉnh trang lỗi mặc định bằng cách thêm `~/error.vue` vào thư mục source của ứng dụng, cùng cấp với `app.vue`.

```vue [error.vue]
<script setup lang="ts">
import type { NuxtError } from '#app'

const props = defineProps({
  error: Object as () => NuxtError
})

const handleError = () => clearError({ redirect: '/' })
</script>

<template>
  <div>
    <h2>{{ error?.statusCode }}</h2>
    <button @click="handleError">Clear errors</button>
  </div>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/error"}
Đọc thêm về `error.vue` và cách sử dụng.
::

Với các lỗi tuỳ chỉnh, chúng tôi rất khuyến nghị sử dụng composable `onErrorCaptured` — có thể gọi trong hàm setup của page/component — hoặc hook runtime `vue:error` có thể cấu hình trong một Nuxt plugin.

```ts [plugins/error-handler.ts] twoslash
export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.hook('vue:error', (err) => {
    //
  })
})
```

Khi bạn muốn loại bỏ trang lỗi, bạn có thể gọi helper [`clearError`](https://nuxt.com/docs/api/utils/clear-error), helper này nhận một path tuỳ chọn để redirect (ví dụ, nếu bạn muốn điều hướng đến một trang "an toàn").

::important
Hãy chắc chắn kiểm tra trước khi sử dụng bất kỳ thứ gì phụ thuộc vào Nuxt plugins, chẳng hạn như `$route` hoặc `useRouter`, bởi vì nếu một plugin ném lỗi, nó sẽ không được chạy lại cho đến khi bạn xoá lỗi.
::

::note
Render một trang lỗi là một lần load trang hoàn toàn riêng biệt, có nghĩa là mọi middleware đã đăng ký sẽ chạy lại. Bạn có thể sử dụng [`useError`](https://nuxt.com/#useerror) trong middleware để kiểm tra xem có lỗi đang được xử lý hay không.
::

::note
Nếu bạn đang chạy trên Node 16 và bạn set bất kỳ cookie nào khi render trang lỗi, chúng sẽ [ghi đè cookie đã set trước đó](https://github.com/nuxt/nuxt/pull/20585){rel="nofollow"}. Chúng tôi khuyến nghị sử dụng phiên bản Node mới hơn vì Node 16 đã hết vòng đời vào tháng 9 năm 2023.
::

## Error Utils

### `useError`

```ts [TS Signature]
function useError (): Ref<Error | { url, statusCode, statusMessage, message, description, data }>
```

Hàm này sẽ trả về lỗi Nuxt toàn cục đang được xử lý.

::read-more{to="https://nuxt.com/docs/api/composables/use-error"}
Đọc thêm về composable `useError`.
::

### `createError`

```ts [TS Signature]
function createError (err: string | { cause, data, message, name, stack, statusCode, statusMessage, fatal }): Error
```

Tạo một đối tượng lỗi với metadata bổ sung. Bạn có thể truyền một chuỗi để đặt `message` của lỗi hoặc một object chứa các thuộc tính lỗi. Hàm này có thể sử dụng được cả ở phần Vue và phần Server của ứng dụng của bạn, và được thiết kế để được `throw`.

Nếu bạn `throw` một lỗi được tạo bằng `createError`:

- on server-side, it will trigger a full-screen error page which you can clear with [`clearError`](https://nuxt.com/#clearerror).
- on client-side, it will throw a non-fatal error for you to handle. If you need to trigger a full-screen error page, then you can do this by setting `fatal: true`.

```vue [pages/movies/[slug\\].vue] twoslash
<script setup lang="ts">
const route = useRoute()
const { data } = await useFetch(`/api/movies/${route.params.slug}`)

if (!data.value) {
  throw createError({
    statusCode: 404,
    statusMessage: 'Page Not Found'
  })
}
</script>
```

::read-more{to="https://nuxt.com/docs/api/utils/create-error"}
Đọc thêm về tiện ích `createError`.
::

### `showError`

```ts [TS Signature]
function showError (err: string | Error | { statusCode, statusMessage }): Error
```

Bạn có thể gọi hàm này ở bất kỳ điểm nào phía client, hoặc (ở phía server) trực tiếp trong middleware, plugin hoặc hàm `setup()`. Hàm này sẽ kích hoạt trang lỗi toàn màn hình mà bạn có thể xoá bằng [`clearError`](https://nuxt.com/#clearerror).

Chúng tôi khuyến nghị sử dụng `throw createError()` thay cho `showError` khi có thể.

::read-more{to="https://nuxt.com/docs/api/utils/show-error"}
Đọc thêm về tiện ích `showError`.
::

### `clearError`

```ts [TS Signature]
function clearError (options?: { redirect?: string }): Promise<void>
```

Hàm này sẽ xoá lỗi Nuxt hiện tại đang được xử lý. Nó cũng nhận một path tuỳ chọn để redirect (ví dụ, điều hướng đến một trang "an toàn").

::read-more{to="https://nuxt.com/docs/api/utils/clear-error"}
Đọc thêm về tiện ích `clearError`.
::

## Render Error in Component

Nuxt cũng cung cấp component [`<NuxtErrorBoundary>`](https://nuxt.com/docs/api/components/nuxt-error-boundary) cho phép bạn xử lý lỗi phía client trong ứng dụng của mình, mà không cần thay thế toàn bộ site bằng một trang lỗi.

Component này chịu trách nhiệm xử lý lỗi xảy ra trong default slot của nó. Ở phía client, nó sẽ ngăn lỗi lan truyền lên cấp cao nhất và sẽ render slot `#error` thay thế.

Slot `#error` sẽ nhận `error` như một prop. (Nếu bạn đặt `error = null` thì nó sẽ kích hoạt render lại default slot; bạn cần đảm bảo lỗi đã thực sự được giải quyết trước, nếu không slot lỗi sẽ chỉ được render lại lần nữa.)

::tip
Nếu bạn điều hướng sang một route khác, lỗi sẽ tự động được xoá.
::

```vue [pages/index.vue]
<template>
  <!-- some content -->
  <NuxtErrorBoundary @error="someErrorLogger">
    <!-- You use the default slot to render your content -->
    <template #error="{ error, clearError }">
      You can display the error locally here: {{ error }}
      <button @click="clearError">
        This will clear the error.
      </button>
    </template>
  </NuxtErrorBoundary>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/advanced/error-handling"}
::


# Server

::read-more{to="https://nuxt.com/docs/guide/directory-structure/server"}
::

## Powered by Nitro

![Server engine](https://nuxt.com/assets/docs/getting-started/server.svg)

Server của Nuxt là [Nitro](https://github.com/nitrojs/nitro){rel="nofollow"}. Ban đầu nó được tạo ra cho Nuxt nhưng bây giờ là một phần của [UnJS](https://unjs.io){rel="nofollow"} và mở cho các framework khác - và thậm chí có thể được sử dụng độc lập.

Sử dụng Nitro mang lại cho Nuxt những siêu năng lực:

- Kiểm soát hoàn toàn phần phía server của ứng dụng
- Triển khai universal trên bất kỳ provider nào (nhiều cấu hình zero-config)
- Hybrid rendering

Nitro sử dụng nội bộ [h3](https://github.com/h3js/h3){rel="nofollow"}, một H(TTP) framework tối giản được xây dựng cho hiệu suất cao và tính di động.

::video-accordion
---
title: Xem video từ Alexander Lichter để hiểu trách nhiệm của Nuxt và Nitro
  trong ứng dụng của bạn
video-id: DkvgJa-X31k
---
::

## Server Endpoints & Middleware

Bạn có thể dễ dàng quản lý phần chỉ dành cho server của ứng dụng Nuxt, từ API endpoint đến middleware.

Cả endpoint và middleware đều có thể được định nghĩa như thế này:

```ts [server/api/test.ts] twoslash
export default defineEventHandler(async (event) => {
  // ... Làm bất cứ điều gì bạn muốn ở đây
})
```

Và bạn có thể trực tiếp trả về `text`, `json`, `html` hoặc thậm chí là `stream`.

Ngay từ đầu, nó hỗ trợ **hot module replacement** và **auto-import** như các phần khác của ứng dụng Nuxt.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/server"}
::

## Universal Deployment

Nitro cung cấp khả năng triển khai ứng dụng Nuxt của bạn ở bất cứ đâu, từ bare metal server đến edge network, với thời gian khởi động chỉ vài millisecond. Thật nhanh!

::read-more{to="https://nuxt.com/blog/nuxt-on-the-edge"}
::

Có hơn 15 preset để build ứng dụng Nuxt của bạn cho các cloud provider và server khác nhau, bao gồm:

- [Cloudflare Workers](https://workers.cloudflare.com){rel="nofollow"}
- [Netlify Functions](https://www.netlify.com/products/functions){rel="nofollow"}
- [Vercel Edge Network](https://vercel.com/docs/edge-network){rel="nofollow"}

Hoặc cho các runtime khác:

::card-group
  :::card{icon="i-logos-deno" target="_blank" title="Deno" to="https://deno.land"}
  :::

  :::card{icon="i-logos-bun" target="_blank" title="Bun" to="https://bun.sh"}
  :::
::

::read-more{to="https://nuxt.com/docs/getting-started/deployment"}
::

## Hybrid Rendering

Nitro có một tính năng mạnh mẽ gọi là `routeRules` cho phép bạn định nghĩa một tập hợp các quy tắc để tùy chỉnh cách mỗi route của ứng dụng Nuxt được render (và nhiều hơn nữa).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  routeRules: {
    // Generated tại build time cho mục đích SEO
    '/': { prerender: true },
    // Cached trong 1 giờ
    '/api/*': { cache: { maxAge: 60 * 60 } },
    // Redirection để tránh 404
    '/old-page': {
      redirect: { to: '/new-page', statusCode: 302 }
    }
    // ...
  }
})
```

::read-more
---
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
Tìm hiểu về tất cả các route rule có sẵn để tùy chỉnh rendering mode của các route.
::

Ngoài ra, có một số route rule (ví dụ: `ssr`, `appMiddleware`, và `noScripts`) dành riêng cho Nuxt để thay đổi hành vi khi render các trang thành HTML.

Một số route rule (`appMiddleware`, `redirect` và `prerender`) cũng ảnh hưởng đến hành vi phía client.

Nitro được sử dụng để build ứng dụng cho server side rendering cũng như pre-rendering.

::read-more{to="https://nuxt.com/docs/guide/concepts/rendering"}
::


# Layers

Một trong những tính năng cốt lõi của Nuxt là layers và hỗ trợ extending. Bạn có thể mở rộng một ứng dụng Nuxt mặc định để tái sử dụng component, util, và cấu hình. Cấu trúc layers gần như giống hệt với một ứng dụng Nuxt tiêu chuẩn, điều này khiến chúng dễ tác giả và bảo trì.

## Use Cases

- Chia sẻ các preset cấu hình có thể tái sử dụng qua các dự án sử dụng `nuxt.config` và `app.config`
- Tạo một thư viện component sử dụng thư mục [`components/`](https://nuxt.com/docs/guide/directory-structure/components)
- Tạo thư viện utility và composable sử dụng thư mục [`composables/`](https://nuxt.com/docs/guide/directory-structure/composables) và [`utils/`](https://nuxt.com/docs/guide/directory-structure/utils)
- Tạo các preset Nuxt module
- Chia sẻ thiết lập tiêu chuẩn qua các dự án
- Tạo theme Nuxt
- Cải thiện tổ chức code bằng cách triển khai kiến trúc modular và hỗ trợ pattern Domain-Driven Design (DDD) trong các dự án quy mô lớn.

## Usage

Theo mặc định, bất kỳ layer nào trong dự án của bạn trong thư mục `~~/layers` sẽ tự động được đăng ký làm layer trong dự án của bạn.

::note
Layer auto-registration được giới thiệu trong Nuxt v3.12.0.
::

Ngoài ra, các alias layer có tên cho `srcDir` của mỗi layer này sẽ tự động được tạo. Ví dụ, bạn sẽ có thể truy cập layer `~~/layers/test` qua `#layers/test`.

::note
Named layer alias được giới thiệu trong Nuxt v3.16.0.
::

Ngoài ra, bạn có thể mở rộng từ một layer bằng cách thêm thuộc tính [extends](https://nuxt.com/docs/api/nuxt-config#extends) vào file [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) của bạn.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    '../base',                     // Extend từ một layer cục bộ
    '@my-themes/awesome',          // Extend từ một npm package đã cài đặt
    'github:my-themes/awesome#v1', // Extend từ một git repository
  ]
})
```

Bạn cũng có thể truyền một authentication token nếu bạn đang extending từ một GitHub repository riêng tư:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // cấu hình theo từng layer
    ['github:my-themes/private-awesome', { auth: process.env.GITHUB_TOKEN }]
  ]
})
```

::tip
Bạn có thể override alias của một layer bằng cách chỉ định nó trong các tùy chọn bên cạnh source của layer.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    [
      'github:my-themes/awesome',
      { 
        meta: {
          name: 'my-awesome-theme',
        },
      },
    ],
  ]
})
```
::

Nuxt sử dụng [unjs/c12](https://c12.unjs.io){rel="nofollow"} và [unjs/giget](https://giget.unjs.io){rel="nofollow"} để extending các remote layer. Kiểm tra tài liệu để biết thêm thông tin và tất cả các tùy chọn có sẵn.

::read-more{to="https://nuxt.com/docs/guide/going-further/layers"}
Đọc thêm về layers trong **Layer Author Guide**.
::

::video-accordion
---
title: Xem video từ Learn Vue về Nuxt Layers
video-id: lnFCM7c9f7I
---
::

::video-accordion
---
title: Xem video từ Alexander Lichter về Nuxt Layers
video-id: fr5yo3aVkfA
---
::

## Examples

::card-group
  :::card
  ---
  icon: i-simple-icons-github
  target: _blank
  title: Content Wind
  to: https://github.com/Atinux/content-wind
  ---
  Một theme Nuxt nhẹ để xây dựng trang web được điều khiển bởi Markdown. Được hỗ trợ bởi Nuxt Content, TailwindCSS và Iconify.
  :::
::


# Prerendering

Nuxt cho phép các trang được chọn từ ứng dụng của bạn được render tại thời điểm build. Nuxt sẽ phục vụ các trang đã được prebuilt khi được yêu cầu thay vì tạo chúng một cách tự động.

::read-more
---
title: Nuxt rendering modes
to: https://nuxt.com/docs/guide/concepts/rendering
---
::

## Crawl-based Pre-rendering

Sử dụng lệnh [`nuxt generate`](https://nuxt.com/docs/api/commands/generate) để build và pre-render ứng dụng của bạn bằng cách sử dụng [Nitro](https://nuxt.com/docs/guide/concepts/server-engine) crawler. Lệnh này tương tự như `nuxt build` với tùy chọn `nitro.static` được đặt thành `true`, hoặc chạy `nuxt build --prerender`.

Điều này sẽ build trang web của bạn, khởi tạo một instance nuxt, và theo mặc định, prerender trang root `/` cùng với bất kỳ trang nào của trang web mà nó liên kết đến, bất kỳ trang nào của trang web mà chúng liên kết đến, và tiếp tục như vậy.

::code-group{sync="pm"}
```bash [npm]
npx nuxt generate
```

```bash [yarn]
yarn nuxt generate
```

```bash [pnpm]
pnpm nuxt generate
```

```bash [bun]
bun x nuxt generate
```
::

Bây giờ bạn có thể triển khai thư mục `.output/public` đến bất kỳ dịch vụ hosting tĩnh nào hoặc xem trước cục bộ với `npx serve .output/public`.

Cách hoạt động của Nitro crawler:

1. Tải HTML của route root ứng dụng (`/`), bất kỳ trang không động nào trong thư mục `~/pages` của bạn, và bất kỳ route nào khác trong mảng `nitro.prerender.routes`.
2. Lưu HTML và `payload.json` vào thư mục `~/.output/public/` để được phục vụ tĩnh.
3. Tìm tất cả các thẻ anchor (`<a href="...">`) trong HTML để điều hướng đến các route khác.
4. Lặp lại các bước 1-3 cho mỗi thẻ anchor được tìm thấy cho đến khi không còn thẻ anchor nào để crawl.

Điều này quan trọng để hiểu vì các trang không được liên kết đến một trang có thể khám phá được không thể tự động pre-render.

::read-more{to="https://nuxt.com/docs/api/commands/generate#nuxt-generate"}
Đọc thêm về lệnh `nuxt generate`.
::

### Selective Pre-rendering

Bạn có thể chỉ định thủ công các route mà [Nitro](https://nuxt.com/docs/guide/concepts/server-engine) sẽ fetch và pre-render trong quá trình build hoặc bỏ qua các route mà bạn không muốn pre-render như `/dynamic` trong file `nuxt.config`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  nitro: {
    prerender: {
      routes: ["/user/1", "/user/2"],
      ignore: ["/dynamic"],
    },
  },
});
```

Bạn có thể kết hợp điều này với tùy chọn `crawlLinks` để pre-render một tập hợp các route mà crawler không thể khám phá như `/sitemap.xml` hoặc `/robots.txt` của bạn:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  nitro: {
    prerender: {
      crawlLinks: true,
      routes: ["/sitemap.xml", "/robots.txt"],
    },
  },
});
```

Đặt `nitro.prerender` thành `true` tương tự như đặt `nitro.prerender.crawlLinks` thành `true`.

::read-more{to="https://nitro.build/config#prerender"}
Đọc thêm về pre-rendering trong tài liệu Nitro.
::

Cuối cùng, bạn có thể cấu hình thủ công điều này bằng cách sử dụng routeRules.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  routeRules: {
    // Đặt prerender thành true để cấu hình nó được prerendered
    "/rss.xml": { prerender: true },
    // Đặt nó thành false để cấu hình nó bị bỏ qua cho prerendering
    "/this-DOES-NOT-get-prerendered": { prerender: false },
    // Mọi thứ dưới /blog được prerendered miễn là nó
    // được liên kết từ một trang khác
    "/blog/**": { prerender: true },
  },
});
```

::read-more{to="https://nitro.build/config#routerules"}
Đọc thêm về cấu hình `routeRules` của Nitro.
::

Như một shorthand, bạn cũng có thể cấu hình điều này trong file trang bằng cách sử dụng [`defineRouteRules`](https://nuxt.com/docs/api/utils/define-route-rules).

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#inlinerouterules
---
Tính năng này là thử nghiệm và để sử dụng nó bạn phải kích hoạt tùy chọn `experimental.inlineRouteRules` trong `nuxt.config` của bạn.
::

```vue [pages/index.vue]
<script setup>
// Hoặc đặt ở cấp độ trang
defineRouteRules({
  prerender: true,
});
</script>

<template>
  <div>
    <h1>Homepage</h1>
    <p>Pre-rendered tại thời điểm build</p>
  </div>
</template>
```

Điều này sẽ được chuyển đổi thành:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    "/": { prerender: true },
  },
});
```

## Runtime Prerender Configuration

### `prerenderRoutes`

Bạn có thể sử dụng điều này tại runtime trong một [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context) để thêm nhiều route hơn cho Nitro để prerender.

```vue [pages/index.vue]
<script setup>
prerenderRoutes(["/some/other/url"]);
prerenderRoutes("/api/content/article/my-article");
</script>

<template>
  <div>
    <h1>Điều này sẽ đăng ký các route khác để prerendering khi được prerendered</h1>
  </div>
</template>
```

::read-more
---
title: prerenderRoutes
to: https://nuxt.com/docs/api/utils/prerender-routes
---
::

### `prerender:routes` Nuxt hook

Điều này được gọi trước khi prerendering để các route bổ sung được đăng ký.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    async "prerender:routes"(ctx) {
      const { pages } = await fetch("https://api.some-cms.com/pages").then(
        (res) => res.json(),
      );
      for (const page of pages) {
        ctx.routes.add(`/${page.name}`);
      }
    },
  },
});
```

### `prerender:generate` Nitro hook

Điều này được gọi cho mỗi route trong quá trình prerendering. Bạn có thể sử dụng điều này để xử lý chi tiết cho từng route được prerendered.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    hooks: {
      "prerender:generate"(route) {
        if (route.route?.includes("private")) {
          route.skip = true;
        }
      },
    },
  },
});
```


# Deployment

Một ứng dụng Nuxt có thể được triển khai trên Node.js server, pre-render cho static hosting, hoặc triển khai đến serverless hoặc edge (CDN) environment.

::tip
Nếu bạn đang tìm kiếm danh sách các cloud provider hỗ trợ Nuxt, xem phần [Hosting providers](https://nuxt.com/deploy).
::

## Node.js Server

Khám phá preset Node.js server với Nitro để triển khai trên bất kỳ Node hosting nào.

- **Định dạng output mặc định** nếu không có định dạng nào được chỉ định hoặc tự động phát hiện :br
- Chỉ tải các chunk cần thiết để render request cho thời gian cold start tối ưu :br
- Hữu ích để triển khai ứng dụng Nuxt đến bất kỳ Node.js hosting nào

### Entry Point

Khi chạy `nuxt build` với preset Node server, kết quả sẽ là một entry point khởi chạy một Node server sẵn sàng chạy.

```bash [Terminal]
node .output/server/index.mjs
```

Điều này sẽ khởi chạy production Nuxt server của bạn, lắng nghe trên port 3000 theo mặc định.

Nó tôn trọng các runtime environment variable sau:

- `NITRO_PORT` hoặc `PORT` (mặc định là `3000`)
- `NITRO_HOST` hoặc `HOST` (mặc định là `'0.0.0.0'`)
- `NITRO_SSL_CERT` và `NITRO_SSL_KEY` - nếu cả hai đều có mặt, điều này sẽ khởi chạy server trong chế độ HTTPS. Trong đa số trường hợp, điều này không nên được sử dụng ngoài việc testing, và Nitro server nên được chạy phía sau một reverse proxy như nginx hoặc Cloudflare để kết thúc SSL.

### PM2

[PM2](https://pm2.keymetrics.io/){rel="nofollow"} (Process Manager 2) là một giải pháp nhanh và dễ dàng để hosting ứng dụng Nuxt của bạn trên server hoặc VM.

Để sử dụng `pm2`, hãy sử dụng `ecosystem.config.cjs`:

```ts [ecosystem.config.cjs]
module.exports = {
  apps: [
    {
      name: 'NuxtAppName',
      port: '3000',
      exec_mode: 'cluster',
      instances: 'max',
      script: './.output/server/index.mjs'
    }
  ]
}
```

### Cluster Mode

Bạn có thể sử dụng `NITRO_PRESET=node_cluster` để tận dụng hiệu suất đa tiến trình bằng cách sử dụng module [cluster](https://nodejs.org/dist/latest/docs/api/cluster.html){rel="nofollow"} của Node.js.

Theo mặc định, workload được phân phối cho các worker với chiến lược round robin.

### Learn More

::read-more
---
title: tài liệu Nitro cho preset node-server
to: https://nitro.build/deploy/runtimes/node
---
::

::video-accordion
---
title: Xem video ngắn của Daniel Roe về chủ đề này
video-id: 0x1H6K5yOfs
---
::

## Static Hosting

Có hai cách để triển khai ứng dụng Nuxt đến bất kỳ dịch vụ static hosting nào:

- Static site generation (SSG) với `ssr: true` pre-render các route của ứng dụng tại thời điểm build. (Đây là hành vi mặc định khi chạy `nuxt generate`.) Nó cũng sẽ tạo ra các trang single-page app fallback `/200.html` và `/404.html`, có thể render các route động hoặc lỗi 404 trên client (mặc dù bạn có thể cần cấu hình điều này trên static host của bạn).
- Alternativel, bạn có thể prerender trang web của mình với `ssr: false` (static single-page app). Điều này sẽ tạo ra các trang HTML với một `<div id="__nuxt"></div>` trống nơi Vue app của bạn thường được render. Bạn sẽ mất nhiều lợi ích SEO của việc prerender trang web, vì vậy thay vào đó được khuyến nghị sử dụng [`<ClientOnly>`](https://nuxt.com/docs/api/components/client-only) để wrap các phần của trang web không thể được server render (nếu có).

::read-more
---
title: Nuxt prerendering
to: https://nuxt.com/docs/getting-started/prerendering
---
::

### Client-side Only Rendering

Nếu bạn không muốn pre-render các route của mình, cách khác để sử dụng static hosting là đặt thuộc tính `ssr` thành `false` trong file `nuxt.config`. Lệnh `nuxt generate` sau đó sẽ xuất ra một entrypoint `.output/public/index.html` và các JavaScript bundle giống như một ứng dụng Vue.js client-side cổ điển.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  ssr: false
})
```

## Hosting Providers

Nuxt có thể được triển khai đến nhiều cloud provider với lượng cấu hình tối thiểu:

::read-more{to="https://nuxt.com/deploy"}
::

## Presets

Ngoài Node.js server và dịch vụ static hosting, một dự án Nuxt có thể được triển khai với nhiều preset đã được kiểm tra kỹ và lượng cấu hình tối thiểu.

Bạn có thể chỉ định rõ ràng preset mong muốn trong file [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config):

```js [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  nitro: {
    preset: 'node-server'
  }
})
```

... hoặc sử dụng biến môi trường `NITRO_PRESET` khi chạy `nuxt build`:

```bash [Terminal]
NITRO_PRESET=node-server nuxt build
```

🔎 Kiểm tra [Nitro deployment](https://nitro.build/deploy){rel="nofollow"} cho tất cả các deployment preset và provider có thể.

## CDN Proxy

Trong hầu hết các trường hợp, Nuxt có thể hoạt động với nội dung bên thứ ba không được tạo hoặc tạo ra bởi chính Nuxt. Nhưng đôi khi nội dung như vậy có thể gây ra vấn đề, đặc biệt là "Minification and Security Options" của Cloudflare.

Theo đó, bạn nên đảm bảo rằng các tùy chọn sau không được check / disabled trong Cloudflare. Nếu không, việc re-rendering không cần thiết hoặc lỗi hydration có thể ảnh hưởng đến ứng dụng production của bạn.

1. Speed > Optimization > Content Optimization > Disable "Rocket Loader™"
2. Speed > Optimization > Image Optimization > Disable "Mirage"
3. Scrape Shield > Disable "Email Address Obfuscation"

Với những cài đặt này, bạn có thể chắc chắn rằng Cloudflare sẽ không inject script vào ứng dụng Nuxt của bạn có thể gây ra các tác dụng phụ không mong muốn.

::tip
Vị trí của chúng trên dashboard Cloudflare đôi khi thay đổi, vì vậy đừng ngần ngại tìm kiếm xung quanh.
::


# Testing

::tip
Nếu bạn là một module author, bạn có thể tìm thông tin cụ thể hơn trong [Module Author's guide](https://nuxt.com/docs/guide/going-further/modules#testing).
::

Nuxt cung cấp hỗ trợ first-class cho end-to-end và unit testing của ứng dụng Nuxt thông qua `@nuxt/test-utils`, một thư viện các utility và cấu hình test hiện đang được sử dụng trong [các test mà chúng tôi sử dụng trên chính Nuxt](https://github.com/nuxt/nuxt/tree/main/test){rel="nofollow"} và các test trong toàn bộ hệ sinh thái module.

::video-accordion
---
title: Xem video từ Alexander Lichter về việc bắt đầu với @nuxt/test-utils
video-id: yGzwk9xi9gU
---
::

## Installation

Để cho phép bạn quản lý các dependency testing khác, `@nuxt/test-utils` đi kèm với các optional peer dependency khác nhau. Ví dụ:

- bạn có thể chọn giữa `happy-dom` và `jsdom` cho runtime Nuxt environment
- bạn có thể chọn giữa `vitest`, `cucumber`, `jest` và `playwright` cho end-to-end test runner
- `playwright-core` chỉ cần thiết nếu bạn muốn sử dụng built-in browser testing utility (và không sử dụng `@playwright/test` làm test runner)

::code-group{sync="pm"}
```bash [npm]
npm i --save-dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```

```bash [yarn]
yarn add --dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```

```bash [pnpm]
pnpm add -D @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```

```bash [bun]
bun add --dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```
::

## Unit Testing

Hiện tại chúng tôi cung cấp một environment cho unit testing code cần [Nuxt](https://nuxt.com){rel="nofollow"} runtime environment. Hiện tại nó &#x2A;chỉ hỗ trợ `vitest`* (mặc dù contribution để thêm các runtime khác sẽ được chào đón).

### Setup

1. Thêm `@nuxt/test-utils/module` vào file `nuxt.config` của bạn (tùy chọn). Nó thêm tích hợp Vitest vào Nuxt DevTools của bạn để hỗ trợ chạy unit test trong development.
   ```ts twoslash
   export default defineNuxtConfig({
     modules: [
       '@nuxt/test-utils/module'
     ]
   })
   ```
2. Tạo file `vitest.config.ts` với nội dung sau:
   ```ts twoslash
   import { defineConfig } from 'vitest/config'
   import { defineVitestProject } from '@nuxt/test-utils/config'

   export default defineConfig({
     test: {
       projects: [
         {
           test: {
             name: 'unit',
             include: ['test/{e2e,unit}/*.{test,spec}.ts'],
             environment: 'node',
           },
         },
         await defineVitestProject({
           test: {
             name: 'nuxt',
             include: ['test/nuxt/*.{test,spec}.ts'],
             environment: 'nuxt',
           },
         }),
       ],
     },
   })
   ```

::tip
Khi import `@nuxt/test-utils` trong vitest config của bạn, cần thiết phải có `"type": "module"` được chỉ định trong `package.json` hoặc đổi tên file vitest config một cách thích hợp.

> tức là, `vitest.config.m{ts,js}`.
::

::tip
Có thể đặt biến môi trường cho testing bằng cách sử dụng file `.env.test`.
::

### Using a Nuxt Runtime Environment

Sử dụng [Vitest projects](https://vitest.dev/guide/projects.html#test-projects){rel="nofollow"}, bạn có kiểm soát chi tiết về test nào chạy trong environment nào:

- **Unit tests**: Đặt các regular unit test trong `test/unit/` - những test này chạy trong Node environment để có tốc độ
- **Nuxt tests**: Đặt các test dựa vào Nuxt runtime environment trong `test/nuxt/` - những test này sẽ chạy trong Nuxt runtime environment

#### Alternative: Simple Setup

Nếu bạn thích thiết lập đơn giản hơn và muốn tất cả test chạy trong Nuxt environment, bạn có thể sử dụng cấu hình cơ bản:

```ts twoslash
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    environment: 'nuxt',
    // bạn có thể tùy chọn đặt các tùy chọn environment cụ thể của Nuxt
    // environmentOptions: {
    //   nuxt: {
    //     rootDir: fileURLToPath(new URL('./playground', import.meta.url)),
    //     domEnvironment: 'happy-dom', // 'happy-dom' (mặc định) hoặc 'jsdom'
    //     overrides: {
    //       // cấu hình Nuxt khác bạn muốn truyền
    //     }
    //   }
    // }
  }
})
```

Nếu bạn đang sử dụng simple setup với `environment: 'nuxt'` theo mặc định, bạn có thể opt *out* khỏi [Nuxt environment](https://vitest.dev/guide/environment.html#test-environment){rel="nofollow"} cho từng test file khi cần.

```ts twoslash
// @vitest-environment node
import { test } from 'vitest'

test('my test', () => {
  // ... test không có Nuxt environment!
})
```

::warning
Cách tiếp cận này không được khuyến nghị vì nó tạo ra một hybrid environment nơi Nuxt Vite plugin chạy nhưng Nuxt entry và `nuxtApp` không được khởi tạo. Điều này có thể dẫn đến các lỗi khó debug.
::

### Organizing Your Tests

Với thiết lập dựa trên project, bạn có thể tổ chức test như sau:

```bash [Directory structure]
test/
├── e2e/
│   └── ssr.test.ts
├── nuxt/
│   ├── components.test.ts
│   └── composables.test.ts
├── unit/
│   └── utils.test.ts
```

Bạn có thể tùy chọn bất kỳ cấu trúc test nào, nhưng việc giữ Nuxt runtime environment tách biệt khỏi Nuxt end-to-end test là quan trọng cho tính ổn định của test.

#### Running Tests

Với project setup, bạn có thể chạy các test suite khác nhau:

```bash
# Chạy tất cả test
npx vitest

# Chỉ chạy unit test
npx vitest --project unit

# Chỉ chạy Nuxt test
npx vitest --project nuxt

# Chạy test trong watch mode
npx vitest --watch
```

::warning
Khi bạn chạy test trong Nuxt environment, chúng sẽ chạy trong môi trường [`happy-dom`](https://github.com/capricorn86/happy-dom){rel="nofollow"} hoặc [`jsdom`](https://github.com/jsdom/jsdom){rel="nofollow"}. Trước khi test chạy, một global Nuxt app sẽ được khởi tạo (bao gồm, ví dụ, chạy bất kỳ plugin hoặc code nào bạn đã định nghĩa trong `app.vue`).

Điều này có nghĩa là bạn nên đặc biệt cẩn thận để không thay đổi global state trong test (hoặc, nếu cần, reset nó sau đó).
::

### 🎭 Built-In Mocks

`@nuxt/test-utils` cung cấp một số built-in mock cho DOM environment.

#### `intersectionObserver`

Mặc định `true`, tạo một dummy class không có chức năng gì cho IntersectionObserver API

#### `indexedDB`

Mặc định `false`, sử dụng [`fake-indexeddb`](https://github.com/dumbmatter/fakeIndexedDB){rel="nofollow"} để tạo một mock chức năng của IndexedDB API

Những thứ này có thể được cấu hình trong phần `environmentOptions` của file `vitest.config.ts`:

```ts twoslash
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    environmentOptions: {
      nuxt: {
        mock: {
          intersectionObserver: true,
          indexedDb: true,
        }
      }
    }
  }
})
```

### 🛠️ Helpers

`@nuxt/test-utils` cung cấp một số helper để làm cho việc test Nuxt app dễ dàng hơn.

#### `mountSuspended`

`mountSuspended` cho phép bạn mount bất kỳ Vue component nào trong Nuxt environment, cho phép async setup và truy cập vào injection từ Nuxt plugin của bạn.

::note
Bên dưới, `mountSuspended` wrap `mount` từ `@vue/test-utils`, vì vậy bạn có thể xem [tài liệu Vue Test Utils](https://test-utils.vuejs.org/guide/){rel="nofollow"} để biết thêm về các tùy chọn bạn có thể truyền, và cách sử dụng utility này.
::

Ví dụ:

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
import type { Component } from 'vue'
declare module '#components' {
  export const SomeComponent: Component
}
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { mountSuspended } from '@nuxt/test-utils/runtime'
import { SomeComponent } from '#components'

it('can mount some component', async () => {
    const component = await mountSuspended(SomeComponent)
    expect(component.text()).toMatchInlineSnapshot(
        '"This is an auto-imported component"'
    )
})

```

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { mountSuspended } from '@nuxt/test-utils/runtime'
import App from '~/app.vue'

// tests/App.nuxt.spec.ts
it('can also mount an app', async () => {
    const component = await mountSuspended(App, { route: '/test' })
    expect(component.html()).toMatchInlineSnapshot(`
      "<div>This is an auto-imported component</div>
      <div> I am a global component </div>
      <div>/</div>
      <a href="/test"> Test link </a>"
    `)
})
```

#### `renderSuspended`

`renderSuspended` cho phép bạn render bất kỳ Vue component nào trong Nuxt environment sử dụng `@testing-library/vue`, cho phép async setup và truy cập vào injection từ Nuxt plugin của bạn.

Điều này nên được sử dụng cùng với các utility từ Testing Library, ví dụ `screen` và `fireEvent`. Cài đặt [@testing-library/vue](https://testing-library.com/docs/vue-testing-library/intro){rel="nofollow"} trong dự án của bạn để sử dụng những thứ này.

Ngoài ra, Testing Library cũng dựa vào testing global để cleanup. Bạn nên bật những thứ này trong [Vitest config](https://vitest.dev/config/#globals){rel="nofollow"} của bạn.

Component được truyền vào sẽ được render bên trong `<div id="test-wrapper"></div>`.

Ví dụ:

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
import type { Component } from 'vue'
declare module '#components' {
  export const SomeComponent: Component
}
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { renderSuspended } from '@nuxt/test-utils/runtime'
import { SomeComponent } from '#components'
import { screen } from '@testing-library/vue'

it('can render some component', async () => {
  await renderSuspended(SomeComponent)
  expect(screen.getByText('This is an auto-imported component')).toBeDefined()
})
```

```ts twoslash
// @noErrors
import { it, expect } from 'vitest'
// ---cut---
// tests/App.nuxt.spec.ts
import { renderSuspended } from '@nuxt/test-utils/runtime'
import App from '~/app.vue'

it('can also render an app', async () => {
  const html = await renderSuspended(App, { route: '/test' })
  expect(html).toMatchInlineSnapshot(`
    "<div id="test-wrapper">
      <div>This is an auto-imported component</div>
      <div> I am a global component </div>
      <div>Index page</div><a href="/test"> Test link </a>
    </div>"
  `)
})
```

#### `mockNuxtImport`

`mockNuxtImport` cho phép bạn mock chức năng auto import của Nuxt. Ví dụ, để mock `useStorage`, bạn có thể làm như thế này:

```ts twoslash
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

mockNuxtImport('useStorage', () => {
  return () => {
    return { value: 'mocked storage' }
  }
})

// test của bạn ở đây
```

::note
`mockNuxtImport` chỉ có thể được sử dụng một lần cho mỗi mocked import cho mỗi test file. Nó thực sự là một macro được chuyển đổi thành `vi.mock` và `vi.mock` được hoisted, như được mô tả [trong Vitest docs](https://vitest.dev/api/vi.html#vi-mock){rel="nofollow"}.
::

Nếu bạn cần mock một Nuxt import và cung cấp implementation khác nhau giữa các test, bạn có thể làm điều đó bằng cách tạo và expose mock của bạn sử dụng [`vi.hoisted`](https://vitest.dev/api/vi.html#vi-hoisted){rel="nofollow"}, và sau đó sử dụng những mock đó trong `mockNuxtImport`. Sau đó bạn có quyền truy cập vào mocked import, và có thể thay đổi implementation giữa các test. Hãy cẩn thận [restore mock](https://vitest.dev/api/mock.html#mockrestore){rel="nofollow"} trước hoặc sau mỗi test để hoàn tác thay đổi mock state giữa các lần chạy.

```ts twoslash
import { vi } from 'vitest'
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

const { useStorageMock } = vi.hoisted(() => {
  return {
    useStorageMock: vi.fn(() => {
      return { value: 'mocked storage'}
    })
  }
})

mockNuxtImport('useStorage', () => {
  return useStorageMock
})

// Sau đó, bên trong một test
useStorageMock.mockImplementation(() => {
  return { value: 'something else' }
})
```

#### `mockComponent`

`mockComponent` cho phép bạn mock component của Nuxt.
Argument đầu tiên có thể là tên component trong PascalCase, hoặc relative path của component.
Argument thứ hai là một factory function trả về mocked component.

Ví dụ, để mock `MyComponent`, bạn có thể:

```ts twoslash
import { mockComponent } from '@nuxt/test-utils/runtime'

mockComponent('MyComponent', {
  props: {
    value: String
  },
  setup(props) {
    // ...
  }
})

// relative path hoặc alias cũng hoạt động
mockComponent('~/components/my-component.vue', async () => {
  // hoặc một factory function
  return defineComponent({
    setup(props) {
      // ...
    }
  })
})

// hoặc bạn có thể sử dụng SFC để redirect đến một mock component
mockComponent('MyComponent', () => import('./MockComponent.vue'))

// test của bạn ở đây
```

> **Lưu ý**: Bạn không thể tham chiếu local variable trong factory function vì chúng được hoisted. Nếu bạn cần truy cập Vue API hoặc các variable khác, bạn cần import chúng trong factory function của bạn.

```ts twoslash
import { mockComponent } from '@nuxt/test-utils/runtime'

mockComponent('MyComponent', async () => {
  const { ref, h } = await import('vue')

  return defineComponent({
    setup(props) {
      const counter = ref(0)
      return () => h('div', null, counter.value)
    }
  })
})
```

#### `registerEndpoint`

`registerEndpoint` cho phép bạn tạo Nitro endpoint trả về mocked data. Nó có thể hữu ích nếu bạn muốn test một component thực hiện request đến API để hiển thị một số dữ liệu.

Argument đầu tiên là tên endpoint (ví dụ `/test/`).
Argument thứ hai là một factory function trả về mocked data.

Ví dụ, để mock endpoint `/test/`, bạn có thể làm:

```ts twoslash
import { registerEndpoint } from '@nuxt/test-utils/runtime'

registerEndpoint('/test/', () => ({
  test: 'test-field'
}))
```

Theo mặc định, request của bạn sẽ được thực hiện sử dụng method `GET`. Bạn có thể sử dụng method khác bằng cách đặt một object làm argument thứ hai thay vì function.

```ts twoslash
import { registerEndpoint } from '@nuxt/test-utils/runtime'

registerEndpoint('/test/', {
  method: 'POST',
  handler: () => ({ test: 'test-field' })
})
```

> **Lưu ý**: Nếu request trong component đi đến external API, bạn có thể sử dụng `baseURL` và sau đó làm nó trống sử dụng [Nuxt Environment Override Config](https://nuxt.com/docs/getting-started/configuration#environment-overrides) (`$test`) để tất cả request của bạn sẽ đi đến Nitro server.

#### Conflict with End-To-End Testing

`@nuxt/test-utils/runtime` và `@nuxt/test-utils/e2e` cần chạy trong các testing environment khác nhau và do đó không thể được sử dụng trong cùng một file.

Nếu bạn muốn sử dụng cả end-to-end và unit testing functionality của `@nuxt/test-utils`, bạn có thể tách test của mình thành các file riêng biệt. Sau đó bạn chỉ định test environment per-file với comment đặc biệt `// @vitest-environment nuxt`, hoặc đặt tên các runtime unit test file với extension `.nuxt.spec.ts`.

`app.nuxt.spec.ts`

```ts twoslash
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

mockNuxtImport('useStorage', () => {
  return () => {
    return { value: 'mocked storage' }
  }
})

```

`app.e2e.spec.ts`

```ts twoslash
import { setup, $fetch } from '@nuxt/test-utils/e2e'

await setup({
  setupTimeout: 10000,
})

// ...
```

### Using `@vue/test-utils`

Nếu bạn thích sử dụng `@vue/test-utils` một mình cho unit testing trong Nuxt, và bạn chỉ test các component không dựa vào Nuxt composable, auto-import hoặc context, bạn có thể làm theo các bước này để thiết lập.

1. Cài đặt các dependency cần thiết :code-group[```bash \[npm\]
   npm i --save-dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ``````bash \[yarn\]
   yarn add --dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ``````bash \[pnpm\]
   pnpm add -D vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ``````bash \[bun\]
   bun add --dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ```]{sync="pm"}
2. Tạo `vitest.config.ts` với nội dung sau:
   ```ts
   import { defineConfig } from 'vitest/config'
   import vue from '@vitejs/plugin-vue'

   export default defineConfig({
     plugins: [vue()],
     test: {
       environment: 'happy-dom',
     },
   });
   ```
3. Thêm command mới cho test trong `package.json`
   ```json
   "scripts": {
     "build": "nuxt build",
     "dev": "nuxt dev",
     ...
     "test": "vitest"
   },
   ```
4. Tạo một component `<HelloWorld>` đơn giản `components/HelloWorld.vue` với nội dung sau:
   ```vue
   <template>
     <p>Hello world</p>
   </template>
   ```
5. Tạo một unit test đơn giản cho component mới được tạo này `~/components/HelloWorld.spec.ts`
   ```ts twoslash
   import { describe, it, expect } from 'vitest'
   import { mount } from '@vue/test-utils'

   import HelloWorld from './HelloWorld.vue'

   describe('HelloWorld', () => {
     it('component renders Hello world properly', () => {
       const wrapper = mount(HelloWorld)
       expect(wrapper.text()).toContain('Hello world')
     })
   })
   ```
6. Chạy lệnh vitest :code-group[```bash \[npm\]
   npm run test
   ``````bash \[yarn\]
   yarn test
   ``````bash \[pnpm\]
   pnpm run test
   ``````bash \[bun\]
   bun run test
   ```]{sync="pm"}

Chúc mừng, bạn đã sẵn sàng để bắt đầu unit testing với `@vue/test-utils` trong Nuxt! Happy testing!

## End-To-End Testing

Cho end-to-end testing, chúng tôi hỗ trợ [Vitest](https://github.com/vitest-dev/vitest){rel="nofollow"}, [Jest](https://jestjs.io){rel="nofollow"}, [Cucumber](https://cucumber.io/){rel="nofollow"} và [Playwright](https://playwright.dev/){rel="nofollow"} làm test runner.

### Setup

Trong mỗi block `describe` nơi bạn đang tận dụng các helper method `@nuxt/test-utils/e2e`, bạn sẽ cần thiết lập test context trước khi bắt đầu.

```ts [test/my-test.spec.ts] twoslash
import { describe, test } from 'vitest'
import { setup, $fetch } from '@nuxt/test-utils/e2e'

describe('My test', async () => {
  await setup({
    // test context options
  })

  test('my test', () => {
    // ...
  })
})
```

Đằng sau hậu trường, `setup` thực hiện một số tác vụ trong `beforeAll`, `beforeEach`, `afterEach` và `afterAll` để thiết lập Nuxt test environment một cách chính xác.

Vui lòng sử dụng các tùy chọn dưới đây cho method `setup`.

#### Nuxt Config

- `rootDir`: Path đến thư mục với Nuxt app được đưa vào test.

  - Type: `string`
  - Default: `'.'`
- `configFile`: Tên của configuration file.

  - Type: `string`
  - Default: `'nuxt.config'`

#### Timings

- `setupTimeout`: Lượng thời gian (tính bằng millisecond) cho phép `setupTest` hoàn thành công việc của nó (có thể bao gồm building hoặc generating file cho Nuxt application, tùy thuộc vào các tùy chọn được truyền).
  - Type: `number`
  - Default: `120000` hoặc `240000` trên windows
- `teardownTimeout`: Lượng thời gian (tính bằng millisecond) để cho phép tearing down test environment, chẳng hạn như đóng browser.
  - Type: `number`
  - Default: `30000`

#### Features

- `build`: Có chạy một build step riêng biệt hay không.
  - Type: `boolean`
  - Default: `true` (`false` nếu `browser` hoặc `server` bị disable, hoặc nếu `host` được cung cấp)
- `server`: Có khởi chạy server để respond request trong test suite hay không.
  - Type: `boolean`
  - Default: `true` (`false` nếu `host` được cung cấp)
- `port`: Nếu được cung cấp, đặt port của test server được khởi chạy thành giá trị này.
  - Type: `number | undefined`
  - Default: `undefined`
- `host`: Nếu được cung cấp, một URL để sử dụng làm test target thay vì building và chạy server mới. Hữu ích để chạy "thật" end-to-end test với phiên bản deployed của ứng dụng, hoặc với local server đang chạy (có thể cung cấp giảm đáng kể thời gian thực thi test). Xem [target host end-to-end example bên dưới](https://nuxt.com/#target-host-end-to-end-example).
  - Type: `string`
  - Default: `undefined`
- `browser`: Đằng sau hậu trường, Nuxt test utils sử dụng [`playwright`](https://playwright.dev){rel="nofollow"} để thực hiện browser testing. Nếu tùy chọn này được đặt, một browser sẽ được khởi chạy và có thể được kiểm soát trong test suite tiếp theo.
  - Type: `boolean`
  - Default: `false`
- `browserOptions`
  - Type: `object` với các thuộc tính sau

    - `type`: Loại browser để khởi chạy - `chromium`, `firefox` hoặc `webkit`
    - `launch`: `object` các tùy chọn sẽ được truyền cho playwright khi khởi chạy browser. Xem [full API reference](https://playwright.dev/docs/api/class-browsertype#browser-type-launch){rel="nofollow"}.
- `runner`: Chỉ định runner cho test suite. Hiện tại, [Vitest](https://vitest.dev){rel="nofollow"} được khuyến nghị.
  - Type: `'vitest' | 'jest' | 'cucumber'`
  - Default: `'vitest'`

##### Target `host` end-to-end example

Một use-case phổ biến cho end-to-end testing là chạy test với deployed application chạy trong cùng environment thường được sử dụng cho Production.

Cho local development hoặc automated deploy pipeline, testing với separate local server có thể hiệu quả hơn và thường nhanh hơn so với việc cho phép test framework rebuild giữa các test.

Để sử dụng separate target host cho end-to-end test, chỉ cần cung cấp thuộc tính `host` của function `setup` với URL mong muốn.

```ts
import { setup, createPage } from '@nuxt/test-utils/e2e'
import { describe, it, expect } from 'vitest'

describe('login page', async () => {
  await setup({
    host: 'http://localhost:8787',
  })

  it('displays the email and password fields', async () => {
    const page = await createPage('/login')
    expect(await page.getByTestId('email').isVisible()).toBe(true)
    expect(await page.getByTestId('password').isVisible()).toBe(true)
  })
})
```

### APIs

#### `$fetch(url)`

Lấy HTML của server-rendered page.

```ts twoslash
import { $fetch } from '@nuxt/test-utils/e2e'

const html = await $fetch('/')
```

#### `fetch(url)`

Lấy response của server-rendered page.

```ts twoslash
import { fetch } from '@nuxt/test-utils/e2e'

const res = await fetch('/')
const { body, headers } = res
```

#### `url(path)`

Lấy URL đầy đủ cho một trang nhất định (bao gồm cả port mà server test đang chạy).

```ts twoslash
import { url } from '@nuxt/test-utils/e2e'

const pageUrl = url('/page')
// 'http://localhost:6840/page'
```

### Testing in a Browser

Chúng tôi cung cấp hỗ trợ tích hợp sẵn bằng Playwright trong `@nuxt/test-utils`, có thể sử dụng qua code hoặc thông qua Playwright test runner.

#### `createPage(url)`

Trong `vitest`, `jest` hoặc `cucumber`, bạn có thể tạo một instance trình duyệt Playwright đã được cấu hình với `createPage`, và (tuỳ chọn) trỏ nó đến một đường dẫn từ server đang chạy. Bạn có thể tìm hiểu thêm về các phương thức API có sẵn trong [tài liệu Playwright](https://playwright.dev/docs/api/class-page){rel="nofollow"}.

```ts twoslash
import { createPage } from '@nuxt/test-utils/e2e'

const page = await createPage('/page')
// bạn có thể truy cập tất cả API của Playwright từ biến `page`
```

#### Testing with Playwright Test Runner

Chúng tôi cũng cung cấp hỗ trợ trực tiếp cho việc test Nuxt bằng [Playwright test runner](https://playwright.dev/docs/intro){rel="nofollow"}.

::code-group{sync="pm"}
```bash [npm]
npm i --save-dev @playwright/test @nuxt/test-utils
```

```bash [yarn]
yarn add --dev @playwright/test @nuxt/test-utils
```

```bash [pnpm]
pnpm add -D @playwright/test @nuxt/test-utils
```

```bash [bun]
bun add --dev @playwright/test @nuxt/test-utils
```
::

Bạn có thể cung cấp cấu hình Nuxt toàn cục, với chi tiết cấu hình giống như hàm `setup()` đã đề cập ở phần trước.

```ts [playwright.config.ts]
import { fileURLToPath } from 'node:url'
import { defineConfig, devices } from '@playwright/test'
import type { ConfigOptions } from '@nuxt/test-utils/playwright'

export default defineConfig<ConfigOptions>({
  use: {
    nuxt: {
      rootDir: fileURLToPath(new URL('.', import.meta.url))
    }
  },
  // ...
})
```

::read-more
---
target: _blank
title: See full example config
to: https://github.com/nuxt/test-utils/blob/main/examples/app-playwright/playwright.config.ts
---
::

File test của bạn sau đó nên sử dụng `expect` và `test` trực tiếp từ `@nuxt/test-utils/playwright`:

```ts [tests/example.test.ts]
import { expect, test } from '@nuxt/test-utils/playwright'

test('test', async ({ page, goto }) => {
  await goto('/', { waitUntil: 'hydration' })
  await expect(page.getByRole('heading')).toHaveText('Welcome to Playwright!')
})
```

Ngoài ra, bạn cũng có thể cấu hình Nuxt server trực tiếp trong file test của mình:

```ts [tests/example.test.ts]
import { expect, test } from '@nuxt/test-utils/playwright'

test.use({
  nuxt: {
    rootDir: fileURLToPath(new URL('..', import.meta.url))
  }
})

test('test', async ({ page, goto }) => {
  await goto('/', { waitUntil: 'hydration' })
  await expect(page.getByRole('heading')).toHaveText('Welcome to Playwright!')
})
```


# Upgrade Guide

## Nâng cấp Nuxt

### Bản phát hành mới nhất

Để nâng cấp Nuxt lên [bản phát hành mới nhất](https://github.com/nuxt/nuxt/releases){rel="nofollow"}, hãy sử dụng lệnh `nuxt upgrade`.

::code-group{sync="pm"}
```bash [npm]
npx nuxt upgrade
```

```bash [yarn]
yarn nuxt upgrade
```

```bash [pnpm]
pnpm nuxt upgrade
```

```bash [bun]
bun x nuxt upgrade
```
::

### Kênh phát hành hàng đêm

Để sử dụng bản build Nuxt mới nhất và kiểm tra các tính năng trước khi chúng được phát hành, hãy đọc về hướng dẫn [kênh phát hành hàng đêm](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

## Di chuyển sang Nuxt 4

Nuxt 4 bao gồm các cải tiến và thay đổi đáng kể. Hướng dẫn này sẽ giúp bạn di chuyển ứng dụng Nuxt 3 hiện tại sang Nuxt 4.

Đầu tiên, nâng cấp lên Nuxt 4:

::code-group{sync="pm"}
```bash [npm]
npm install nuxt@^4.0.0
```

```bash [yarn]
yarn add nuxt@^4.0.0
```

```bash [pnpm]
pnpm add nuxt@^4.0.0
```

```bash [bun]
bun add nuxt@^4.0.0
```
::

Sau khi nâng cấp, hầu hết các hành vi của Nuxt 4 giờ đây là mặc định. Tuy nhiên, một số tính năng vẫn có thể được cấu hình nếu bạn cần duy trì khả năng tương thích ngược trong quá trình di chuyển.

Các phần sau đây mô tả chi tiết về những thay đổi chính và việc di chuyển cần thiết khi nâng cấp lên Nuxt 4.

Các thay đổi phá vỡ hoặc đáng kể được ghi lại bên dưới cùng với các bước di chuyển và tùy chọn cấu hình có sẵn.

### Di chuyển sử dụng Codemods

Để tạo điều kiện cho quá trình nâng cấp, chúng tôi đã hợp tác với nhóm [Codemod](https://github.com/codemod-com/codemod){rel="nofollow"} để tự động hóa nhiều bước di chuyển với một số codemods mã nguồn mở.

::note
Nếu bạn gặp bất kỳ vấn đề nào, vui lòng báo cáo chúng cho nhóm Codemod với `npx codemod feedback` 🙏
::

Để có danh sách đầy đủ các codemods của Nuxt 4, thông tin chi tiết về từng codemod, nguồn của chúng và các cách khác nhau để chạy chúng, hãy truy cập [Codemod Registry](https://go.codemod.com/codemod-registry){rel="nofollow"}.

Bạn có thể chạy tất cả các codemods được đề cập trong hướng dẫn này bằng cách sử dụng `codemod` recipe sau:

::code-group
```bash [npm]
npx codemod@latest nuxt/4/migration-recipe
```

```bash [yarn]
yarn dlx codemod@latest nuxt/4/migration-recipe
```

```bash [pnpm]
pnpm dlx codemod@latest nuxt/4/migration-recipe
```

```bash [bun]
bun x codemod@latest nuxt/4/migration-recipe
```
::

Lệnh này sẽ thực thi tất cả các codemods theo trình tự, với tùy chọn bỏ chọn bất kỳ codemod nào mà bạn không muốn chạy. Mỗi codemod cũng được liệt kê bên dưới cùng với thay đổi tương ứng của nó và có thể được thực thi độc lập.

### Cấu trúc thư mục mới

🚦 **Mức độ tác động**: Đáng kể

Nuxt giờ đây mặc định sử dụng cấu trúc thư mục mới, với khả năng tương thích ngược (vì vậy nếu Nuxt phát hiện bạn đang sử dụng cấu trúc cũ, chẳng hạn như thư mục `pages/` ở cấp cao nhất, cấu trúc mới này sẽ không áp dụng).

👉 [Xem RFC đầy đủ](https://github.com/nuxt/nuxt/issues/26444){rel="nofollow"}

#### Những gì đã thay đổi

- `srcDir` mặc định mới của Nuxt là `app/` theo mặc định, và hầu hết mọi thứ đều được giải quyết từ đó.
- `serverDir` giờ đây mặc định là `<rootDir>/server` thay vì `<srcDir>/server`
- `layers/`, `modules/` và `public/` được giải quyết tương đối so với `<rootDir>` theo mặc định
- nếu sử dụng [Nuxt Content v2.13+](https://github.com/nuxt/content/pull/2649){rel="nofollow"}, `content/` được giải quyết tương đối so với `<rootDir>`
- một `dir.app` mới được thêm vào, đây là thư mục chúng tôi tìm kiếm `router.options.ts` và `spa-loading-template.html` - mặc định này là `<srcDir>/`

Một ví dụ về cấu trúc thư mục v4.

```sh
.output/
.nuxt/
app/
  assets/
  components/
  composables/
  layouts/
  middleware/
  pages/
  plugins/
  utils/
  app.config.ts
  app.vue
  router.options.ts
content/
layers/
modules/
node_modules/
public/
shared/
server/
  api/
  middleware/
  plugins/
  routes/
  utils/
nuxt.config.ts
```

::note
Với cấu trúc mới này, alias `~` giờ đây trỏ đến thư mục `app/` theo mặc định (`srcDir` của bạn). Điều này có nghĩa là `~/components` giải quyết thành `app/components/`, `~/pages` thành `app/pages/`, v.v.
::

👉 Để biết thêm chi tiết, xem [PR thực hiện thay đổi này](https://github.com/nuxt/nuxt/pull/27029){rel="nofollow"}.

#### Lý do thay đổi

1. **Hiệu suất** - đặt tất cả mã của bạn trong thư mục gốc của repo gây ra vấn đề với các thư mục `.git/` và `node_modules/` được quét/bao gồm bởi FS watchers có thể làm chậm đáng kể việc khởi động trên các hệ điều hành không phải Mac.
2. **Tính an toàn kiểu IDE** - `server/` và phần còn lại của ứng dụng của bạn đang chạy trong hai ngữ cảnh hoàn toàn khác nhau với các import toàn cục khác nhau có sẵn, và đảm bảo `server/` không nằm *trong* cùng thư mục với phần còn lại của ứng dụng là bước đầu tiên quan trọng để đảm bảo bạn nhận được auto-completes tốt trong IDE.

::video-accordion
---
platform: vimeo
title: Xem video từ Vue School về cấu trúc thư mục mới
video-id: "1031028378"
---
::

#### Bước di chuyển

1. Tạo một thư mục mới có tên `app/`.
2. Di chuyển các thư mục `assets/`, `components/`, `composables/`, `layouts/`, `middleware/`, `pages/`, `plugins/` và `utils/` của bạn vào dưới nó, cũng như `app.vue`, `error.vue`, `app.config.ts`. Nếu bạn có `app/router-options.ts` hoặc `app/spa-loading-template.html`, các đường dẫn này vẫn giữ nguyên.
3. Đảm bảo các thư mục `nuxt.config.ts`, `content/`, `layers/`, `modules/`, `public/` và `server/` của bạn vẫn ở bên ngoài thư mục `app/`, trong thư mục gốc của dự án.
4. Nhớ cập nhật bất kỳ tệp cấu hình của bên thứ ba nào để hoạt động với cấu trúc thư mục mới, chẳng hạn như cấu hình `tailwindcss` hoặc `eslint` của bạn (nếu cần - `@nuxtjs/tailwindcss` sẽ tự động cấu hình `tailwindcss` một cách chính xác).

::tip
Bạn có thể tự động hóa việc di chuyển này bằng cách chạy `npx codemod@latest nuxt/4/file-structure`
::

Tuy nhiên, việc di chuyển *không bắt buộc*. Nếu bạn muốn giữ cấu trúc thư mục hiện tại, Nuxt sẽ tự động phát hiện nó. (Nếu không, vui lòng tạo issue.) Ngoại lệ duy nhất là nếu bạn *đã* có một `srcDir` tùy chỉnh. Trong trường hợp này, bạn nên biết rằng các thư mục `modules/`, `public/` và `server/` của bạn sẽ được giải quyết từ `rootDir` thay vì từ `srcDir` tùy chỉnh của bạn. Bạn có thể ghi đè điều này bằng cách cấu hình `dir.modules`, `dir.public` và `serverDir` nếu cần.

Bạn cũng có thể buộc cấu trúc thư mục v3 với cấu hình sau:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // Điều này hoàn nguyên srcDir mặc định mới từ `app` về thư mục gốc của bạn
  srcDir: '.',
  // Điều này chỉ định tiền tố thư mục cho `router.options.ts` và `spa-loading-template.html`
  dir: {
    app: 'app'
  }
})
```

### Lớp Data Fetching đơn lẻ

🚦 **Mức độ tác động**: Vừa phải

#### Những gì đã thay đổi

Hệ thống data fetching của Nuxt (`useAsyncData` và `useFetch`) đã được tổ chức lại đáng kể để có hiệu suất và tính nhất quán tốt hơn:

1. **Shared refs cho cùng key**: Tất cả các lời gọi đến `useAsyncData` hoặc `useFetch` với cùng key giờ đây chia sẻ cùng `data`, `error` và `status` refs. Điều này có nghĩa là việc tất cả các lời gọi với key rõ ràng không được có các tùy chọn `deep`, `transform`, `pick`, `getCachedData` hoặc `default` xung đột là quan trọng.
2. **Kiểm soát nhiều hơn đối với `getCachedData`**: Hàm `getCachedData` giờ đây được gọi mỗi khi dữ liệu được lấy, ngay cả khi điều này do watcher hoặc gọi `refreshNuxtData` gây ra. (Trước đây, dữ liệu mới luôn được lấy và hàm này không được gọi trong những trường hợp này.) Để cho phép kiểm soát nhiều hơn về thời điểm sử dụng dữ liệu đã cache và khi nào refetch, hàm giờ đây nhận một đối tượng context với nguyên nhân của yêu cầu.
3. **Hỗ trợ reactive key**: Bạn giờ đây có thể sử dụng computed refs, plain refs hoặc getter functions làm keys, điều này cho phép tự động refetching dữ liệu (và lưu trữ dữ liệu riêng biệt).
4. **Dọn dẹp dữ liệu**: Khi component cuối cùng sử dụng dữ liệu được lấy với `useAsyncData` bị unmount, Nuxt sẽ loại bỏ dữ liệu đó để tránh việc sử dụng bộ nhớ tăng liên tục.

#### Lý do thay đổi

Những thay đổi này được thực hiện để cải thiện việc sử dụng bộ nhớ và tăng tính nhất quán với các trạng thái loading qua các lời gọi của `useAsyncData`.

#### Bước di chuyển

1. **Kiểm tra các tùy chọn không nhất quán**: Xem lại bất kỳ component nào sử dụng cùng key với các tùy chọn hoặc fetch functions khác nhau.
   ```ts
   // Điều này giờ đây sẽ kích hoạt cảnh báo
   const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
   const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
   ```
   :brCó thể có lợi khi trích xuất bất kỳ lời gọi nào đến `useAsyncData` chia sẻ key rõ ràng (và có tùy chọn tùy chỉnh) vào composable riêng của chúng:
   ```ts [composables/useUserData.ts]
   export function useUserData(userId: string) {
     return useAsyncData(
       `user-${userId}`,
       () => fetchUser(userId),
       { 
         deep: true,
         transform: (user) => ({ ...user, lastAccessed: new Date() })
       }
     )
   }
   ```
2. **Cập nhật các implementations của `getCachedData`**:
   ```diff
   useAsyncData('key', fetchFunction, {
   -  getCachedData: (key, nuxtApp) => {
   -    return cachedData[key]
   -  }
   +  getCachedData: (key, nuxtApp, ctx) => {
   +    // ctx.cause - có thể là 'initial' | 'refresh:hook' | 'refresh:manual' | 'watch'
   +    
   +    // Ví dụ: Không sử dụng cache khi refresh thủ công
   +    if (ctx.cause === 'refresh:manual') return undefined
   +    
   +    return cachedData[key]
   +  }
   })
   ```

Thay vào đó, hiện tại, bạn có thể tắt hành vi này với:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    granularCachedData: false,
    purgeCachedData: false
  }
})
```

### Thứ tự tải Module được sửa chữa trong Layers

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Thứ tự mà các modules được tải khi sử dụng [Nuxt layers](https://nuxt.com/docs/guide/going-further/layers) đã được sửa chữa. Trước đây, các modules từ project root được tải trước các modules từ extended layers, điều này ngược lại với hành vi mong đợi.

Giờ đây các modules được tải theo thứ tự đúng:

1. **Layer modules trước** (theo thứ tự extend - deeper layers trước)
2. **Project modules cuối** (ưu tiên cao nhất)

Điều này ảnh hưởng đến cả:

- Các modules được định nghĩa trong mảng `modules` trong `nuxt.config.ts`
- Các modules được tự động khám phá từ thư mục `modules/`

#### Lý do thay đổi

Thay đổi này đảm bảo rằng:

- Các extended layers có ưu tiên thấp hơn dự án tiêu thụ
- Thứ tự thực thi module phù hợp với mô hình kế thừa layer trực quan
- Cấu hình module và hooks hoạt động như mong đợi trong các thiết lập đa layer

#### Bước di chuyển

**Hầu hết các dự án sẽ không cần thay đổi**, vì điều này sửa chữa thứ tự tải để phù hợp với hành vi mong đợi.

Tuy nhiên, nếu dự án của bạn đã dựa vào thứ tự không đúng trước đây, bạn có thể cần:

1. **Xem lại các dependencies của module**: Kiểm tra xem có modules nào phụ thuộc vào thứ tự tải cụ thể không
2. **Điều chỉnh cấu hình module**: Nếu các modules được cấu hình để làm việc xung quanh thứ tự không đúng
3. **Kiểm tra kỹ lưỡng**: Đảm bảo tất cả chức năng hoạt động như mong đợi với thứ tự được sửa chữa

Ví dụ về thứ tự đúng mới:

```ts
// Layer: my-layer/nuxt.config.ts
export default defineNuxtConfig({
  modules: ['layer-module-1', 'layer-module-2']
})

// Project: nuxt.config.ts
export default defineNuxtConfig({
  extends: ['./my-layer'],
  modules: ['project-module-1', 'project-module-2']
})

// Thứ tự tải (đã sửa chữa):
// 1. layer-module-1
// 2. layer-module-2  
// 3. project-module-1 (có thể ghi đè layer modules)
// 4. project-module-2 (có thể ghi đè layer modules)
```

Nếu bạn gặp vấn đề với các dependencies thứ tự module do cần đăng ký một hook, hãy xem xét sử dụng [`modules:done` hook](https://nuxt.com/docs/guide/going-further/modules#custom-hooks) cho các modules cần gọi một hook. Hook này được chạy sau khi tất cả các modules khác đã được tải, có nghĩa là việc sử dụng nó là an toàn.

👉 Xem [PR #31507](https://github.com/nuxt/nuxt/pull/31507){rel="nofollow"} và [issue #25719](https://github.com/nuxt/nuxt/issues/25719){rel="nofollow"} để biết thêm chi tiết.

### Khử trùng Route Metadata

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Có thể thiết lập một số metadata route bằng `definePageMeta`, chẳng hạn như `name`, `path`, v.v. Trước đây chúng có sẵn cả trên route và trên route metadata (ví dụ, `route.name` và `route.meta.name`).

Giờ đây, chúng chỉ có thể truy cập được trên đối tượng route.

#### Lý do thay đổi

Đây là kết quả của việc kích hoạt `experimental.scanPageMeta` theo mặc định, và là một tối ưu hóa hiệu suất.

#### Bước di chuyển

Việc di chuyển nên đơn giản:

```diff
  const route = useRoute()
  
- console.log(route.meta.name)
+ console.log(route.name)
```

### Tên Component được chuẩn hóa

🚦 **Mức độ tác động**: Vừa phải

Vue giờ đây sẽ tạo ra các tên component phù hợp với mô hình Nuxt cho việc đặt tên component.

#### Những gì đã thay đổi

Theo mặc định, nếu bạn chưa thiết lập nó thủ công, Vue sẽ gán một tên component phù hợp với tên tệp của component.

```bash [Directory structure]
├─ components/
├── SomeFolder/
├──── MyComponent.vue
```

Trong trường hợp này, tên component sẽ là `MyComponent`, theo như Vue quan tâm. Nếu bạn muốn sử dụng `<KeepAlive>` với nó, hoặc xác định nó trong Vue DevTools, bạn sẽ cần sử dụng tên này.

Nhưng để auto-import nó, bạn sẽ cần sử dụng `SomeFolderMyComponent`.

Với thay đổi này, hai giá trị này sẽ khớp, và Vue sẽ tạo ra một tên component phù hợp với mô hình Nuxt cho việc đặt tên component.

#### Bước di chuyển

Đảm bảo rằng bạn sử dụng tên đã cập nhật trong bất kỳ bài test nào sử dụng `findComponent` từ `@vue/test-utils` và trong bất kỳ `<KeepAlive>` nào phụ thuộc vào tên của component.

Thay vào đó, hiện tại, bạn có thể tắt hành vi này với:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

### Unhead v2

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

[Unhead](https://unhead.unjs.io/){rel="nofollow"}, được sử dụng để tạo các thẻ `<head>`, đã được cập nhật lên phiên bản 2. Mặc dù chủ yếu tương thích nhưng nó bao gồm một số thay đổi phá vỡ cho các API cấp thấp hơn.

- Các props đã loại bỏ: `vmid`, `hid`, `children`, `body`.
- Promise input không còn được hỗ trợ.
- Các thẻ giờ đây được sắp xếp bằng Capo.js theo mặc định.

#### Bước di chuyển

Các thay đổi trên nên có tác động tối thiểu đến ứng dụng của bạn.

Nếu bạn có vấn đề, bạn nên xác minh:

- Bạn không sử dụng bất kỳ props nào đã bị loại bỏ.

```diff
useHead({
  meta: [{ 
    name: 'description', 
    // meta tags không cần vmid, hoặc key    
-   vmid: 'description' 
-   hid: 'description'
  }]
})
```

- Nếu bạn đang sử dụng [Template Params](https://unhead.unjs.io/docs/head/guides/plugins/template-params){rel="nofollow"} hoặc [Alias Tag Sorting](https://unhead.unjs.io/docs/head/guides/plugins/alias-sorting){rel="nofollow"}, bạn sẽ cần rõ ràng opt in vào các tính năng này ngay bây giờ.

```ts
import { TemplateParamsPlugin, AliasSortingPlugin } from '@unhead/vue/plugins'

export default defineNuxtPlugin({
  setup() {
    const unhead = injectHead()
    unhead.use(TemplateParamsPlugin)
    unhead.use(AliasSortingPlugin)
  }
})
```

Mặc dù không bắt buộc, nhưng được khuyến nghị cập nhật bất kỳ imports nào từ `@unhead/vue` sang `#imports` hoặc `nuxt/app`.

```diff
-import { useHead } from '@unhead/vue'
+import { useHead } from '#imports'
```

Nếu bạn vẫn có vấn đề, bạn có thể hoàn nguyên về hành vi v1 bằng cách kích hoạt cấu hình `head.legacy`.

```ts
export default defineNuxtConfig({
  unhead: {
    legacy: true,
  }
})
```

### Vị trí DOM mới cho SPA Loading Screen

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Khi render một trang chỉ dành cho client (với `ssr: false`), chúng tôi tùy ý render một màn hình loading (từ `~/app/spa-loading-template.html` - lưu ý rằng điều này cũng đã thay đổi thành `~/spa-loading-template.html` trong Nuxt 4), bên trong Nuxt app root:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Giờ đây, chúng tôi mặc định render template cùng với Nuxt app root:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

#### Lý do thay đổi

Điều này cho phép spa loading template vẫn còn trong DOM cho đến khi Vue app suspense resolves, ngăn chặn flash màu trắng.

#### Bước di chuyển

Nếu bạn đang nhắm mục tiêu spa loading template với CSS hoặc `document.queryElement`, bạn sẽ cần cập nhật các selectors của mình. Cho mục đích này, bạn có thể sử dụng các tùy chọn cấu hình mới `app.spaLoaderTag` và `app.spaLoaderAttrs`.

Thay vào đó, bạn có thể hoàn nguyên về hành vi trước đây với:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    spaLoadingTemplateLocation: 'within',
  }
})
```

### `error.data` được Parse

🚦 **Mức độ tác động**: Tối thiểu

Có thể throw một error với thuộc tính `data`, nhưng điều này không được parsed. Giờ đây, nó được parsed và có sẵn trong đối tượng `error`. Mặc dù là một bản sửa lỗi, nhưng về mặt kỹ thuật đây là một thay đổi phá vỡ nếu bạn đã dựa vào hành vi trước đây và tự parse nó.

#### Bước di chuyển

Cập nhật `error.vue` tùy chỉnh của bạn để loại bỏ bất kỳ parsing bổ sung nào của `error.data`:

```diff
  <script setup lang="ts">
  import type { NuxtError } from '#app'

  const props = defineProps({
    error: Object as () => NuxtError
  })

- const data = JSON.parse(error.data)
+ const data = error.data
  </script>
```

### Inline Styles chi tiết hơn

🚦 **Mức độ tác động**: Vừa phải

Nuxt giờ đây sẽ chỉ inline styles cho các Vue components, không phải CSS toàn cục.

#### Những gì đã thay đổi

Trước đây, Nuxt sẽ inline tất cả CSS, bao gồm global styles, và loại bỏ các phần tử `<link>` đến các tệp CSS riêng biệt. Giờ đây, Nuxt sẽ chỉ làm điều này cho các Vue components (trước đây tạo ra các chunks CSS riêng biệt). Chúng tôi nghĩ đây là sự cân bằng tốt hơn trong việc giảm các yêu cầu mạng riêng biệt (giống như trước đây, sẽ không có các yêu cầu riêng biệt cho các tệp `.css` riêng lẻ theo từng trang hoặc từng component khi tải ban đầu), cũng như cho phép caching của một tệp CSS toàn cục duy nhất và giảm kích thước tải xuống document của yêu cầu ban đầu.

#### Bước di chuyển

Tính năng này có thể cấu hình đầy đủ và bạn có thể hoàn nguyên về hành vi trước đây bằng cách thiết lập `inlineStyles: true` để inline global CSS cũng như per-component CSS.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  features: {
    inlineStyles: true
  }
})
```

### Quét Page Meta sau Resolution

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Chúng tôi giờ đây quét page metadata (được định nghĩa trong `definePageMeta`) *sau khi* gọi hook `pages:extend` thay vì trước đó.

#### Lý do thay đổi

Điều này nhằm cho phép quét metadata cho các pages mà người dùng muốn thêm vào trong `pages:extend`. Chúng tôi vẫn cung cấp cơ hội thay đổi hoặc ghi đè page metadata trong một hook `pages:resolved` mới.

#### Bước di chuyển

Nếu bạn muốn ghi đè page metadata, hãy làm điều đó trong `pages:resolved` thay vì trong `pages:extend`.

```diff
  export default defineNuxtConfig({
    hooks: {
-     'pages:extend'(pages) {
+     'pages:resolved'(pages) {
        const myPage = pages.find(page => page.path === '/')
        myPage.meta ||= {}
        myPage.meta.layout = 'overridden-layout'
      }
    }
  })
```

Thay vào đó, bạn có thể hoàn nguyên về hành vi trước đây với:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: true
  }
})
```

### Chia sẻ Prerender Data

🚦 **Mức độ tác động**: Trung bình

#### Những gì đã thay đổi

Chúng tôi đã kích hoạt một tính năng thử nghiệm trước đây để chia sẻ dữ liệu từ các lời gọi `useAsyncData` và `useFetch`, qua các pages khác nhau. Xem [PR gốc](https://github.com/nuxt/nuxt/pull/24894){rel="nofollow"}.

#### Lý do thay đổi

Tính năng này tự động chia sẻ payload *data* giữa các pages được prerender. Điều này có thể dẫn đến cải thiện hiệu suất đáng kể khi prerender các sites sử dụng `useAsyncData` hoặc `useFetch` và fetch cùng dữ liệu trong các pages khác nhau.

Ví dụ, nếu site của bạn yêu cầu lời gọi `useFetch` cho mọi page (ví dụ, để lấy dữ liệu điều hướng cho menu, hoặc cài đặt site từ CMS), dữ liệu này sẽ chỉ được lấy một lần khi prerender page đầu tiên sử dụng nó, và sau đó được cached để sử dụng khi prerender các pages khác.

#### Bước di chuyển

Đảm bảo rằng bất kỳ key duy nhất nào của dữ liệu của bạn luôn có thể resolve thành cùng dữ liệu. Ví dụ, nếu bạn đang sử dụng `useAsyncData` để fetch dữ liệu liên quan đến một page cụ thể, bạn nên cung cấp key phù hợp duy nhất với dữ liệu đó. (`useFetch` nên làm điều này tự động cho bạn.)

```ts [app/pages/test/[slug\\].vue]
// Điều này sẽ không an toàn trong một dynamic page (ví dụ `[slug].vue`) vì route slug tạo ra sự khác biệt
// với dữ liệu được lấy, nhưng Nuxt không thể biết điều đó vì nó không được phản ánh trong key.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Thay vào đó, bạn nên sử dụng key xác định duy nhất dữ liệu được lấy.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

Thay vào đó, bạn có thể tắt tính năng này với:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

### Giá trị `data` và `error` mặc định trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Các đối tượng `data` và `error` được trả về từ `useAsyncData` giờ đây sẽ mặc định là `undefined`.

#### Lý do thay đổi

Trước đây `data` được khởi tạo thành `null` nhưng được reset trong `clearNuxtData` thành `undefined`. `error` được khởi tạo thành `null`. Thay đổi này nhằm mang lại tính nhất quán cao hơn.

#### Bước di chuyển

Nếu bạn đang kiểm tra xem `data.value` hoặc `error.value` có phải `null` không, bạn có thể cập nhật các kiểm tra này để kiểm tra `undefined` thay thế.

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/default-data-error-value`
::

Nếu bạn gặp bất kỳ vấn đề nào, bạn có thể hoàn nguyên về hành vi trước đây với:

```ts [nuxt.config.ts] twoslash
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    defaults: {
      useAsyncData: {
        value: 'null',
        errorValue: 'null'
      }
    }
  }
})
```

Vui lòng báo cáo issue nếu bạn làm điều này, vì chúng tôi không có kế hoạch giữ điều này có thể cấu hình.

### Loại bỏ các giá trị `boolean` deprecated cho tùy chọn `dedupe` khi gọi `refresh` trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Trước đây có thể truyền `dedupe: boolean` đến `refresh`. Đây là các aliases của `cancel` (`true`) và `defer` (`false`).

```ts [app.vue] twoslash
// @errors: 2322
const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt!' }))

async function refreshData () {
  await refresh({ dedupe: true })
}
```

#### Lý do thay đổi

Những aliases này đã được loại bỏ, để có sự rõ ràng hơn.

Vấn đề nảy sinh khi thêm `dedupe` như một tùy chọn vào `useAsyncData`, và chúng tôi đã loại bỏ các giá trị boolean vì chúng kết thúc là *đối lập*.

`refresh({ dedupe: false })` có nghĩa là **không *hủy* các yêu cầu hiện có để ưu tiên cái mới này**. Nhưng việc truyền `dedupe: true` trong tùy chọn của `useAsyncData` có nghĩa là &#x2A;*không thực hiện bất kỳ yêu cầu mới nào nếu có yêu cầu đang chờ hiện tại.** (Xem [PR](https://github.com/nuxt/nuxt/pull/24564#pullrequestreview-1764584361){rel="nofollow"}.)

#### Bước di chuyển

Việc di chuyển nên đơn giản:

```diff
  const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))
  
  async function refreshData () {
-   await refresh({ dedupe: true })
+   await refresh({ dedupe: 'cancel' })

-   await refresh({ dedupe: false })
+   await refresh({ dedupe: 'defer' })
  }
```

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/deprecated-dedupe-value`
::

### Tôn trọng defaults khi xóa `data` trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Nếu bạn cung cấp giá trị `default` tùy chỉnh cho `useAsyncData`, giờ đây giá trị này sẽ được sử dụng khi gọi `clear` hoặc `clearNuxtData` và nó sẽ được reset về giá trị mặc định thay vì đơn giản bỏ thiết lập.

#### Lý do thay đổi

Thường người dùng thiết lập một giá trị trống phù hợp, chẳng hạn như mảng trống, để tránh cần kiểm tra `null`/`undefined` khi lặp qua nó. Điều này nên được tôn trọng khi reset/xóa dữ liệu.

### Căn chỉnh giá trị `pending` trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Trung bình

Đối tượng `pending` được trả về từ `useAsyncData`, `useFetch`, `useLazyAsyncData` và `useLazyFetch` giờ đây là một computed property chỉ `true` khi `status` cũng đang pending.

#### Những gì đã thay đổi

Giờ đây, khi `immediate: false` được truyền, `pending` sẽ là `false` cho đến khi yêu cầu đầu tiên được thực hiện. Đây là sự thay đổi từ hành vi trước đây, khi `pending` luôn là `true` cho đến khi yêu cầu đầu tiên được thực hiện.

#### Lý do thay đổi

Điều này căn chỉnh ý nghĩa của `pending` với thuộc tính `status`, cũng là `pending` khi yêu cầu đang trong quá trình thực hiện.

#### Bước di chuyển

Nếu bạn dựa vào thuộc tính `pending`, hãy đảm bảo logic của bạn tính đến hành vi mới khi `pending` sẽ chỉ là `true` khi status cũng đang pending.

```diff
  <template>
-   <div v-if="!pending">
+   <div v-if="status === 'success'">
      <p>Data: {{ data }}</p>
    </div>
    <div v-else>
      <p>Loading...</p>
    </div>
  </template>
  <script setup lang="ts">
  const { data, pending, execute, status } = await useAsyncData(() => fetch('/api/data'), {
    immediate: false
  })
  onMounted(() => execute())
  </script>
```

Thay vào đó, bạn có thể tạm thời hoàn nguyên về hành vi trước đây với:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: true
  }
})
```

### Hành vi thay đổi Key trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Trung bình

#### Những gì đã thay đổi

Khi sử dụng reactive keys trong `useAsyncData` hoặc `useFetch`, Nuxt tự động refetch dữ liệu khi key thay đổi. Khi `immediate: false` được thiết lập, `useAsyncData` sẽ chỉ fetch dữ liệu khi key thay đổi nếu dữ liệu đã được fetch một lần.

Trước đây, `useFetch` có hành vi hơi khác. Nó sẽ luôn fetch dữ liệu khi key thay đổi.

Giờ đây, `useFetch` và `useAsyncData` hành xử nhất quán - bằng cách chỉ fetch dữ liệu khi key thay đổi nếu dữ liệu đã được fetch một lần.

#### Lý do thay đổi

Điều này đảm bảo hành vi nhất quán giữa `useAsyncData` và `useFetch`, và ngăn chặn các fetches không mong muốn. Nếu bạn đã thiết lập `immediate: false`, thì bạn phải gọi `refresh` hoặc `execute` hoặc dữ liệu sẽ không bao giờ được fetch trong `useFetch` hoặc `useAsyncData`.

#### Bước di chuyển

Thay đổi này nói chung nên cải thiện hành vi mong đợi, nhưng nếu bạn mong đợi việc thay đổi key hoặc options của một `useFetch` không immediate, giờ đây bạn sẽ cần kích hoạt nó thủ công lần đầu tiên.

```diff
  const id = ref('123')
  const { data, execute } = await useFetch('/api/test', {
    query: { id },
    immediate: false
  )
+ watch(id, () => execute(), { once: true })
```

Để opt out khỏi hành vi này:

```ts
// Hoặc toàn cục trong Nuxt config của bạn
export default defineNuxtConfig({
  experimental: {
    alwaysRunFetchOnKeyChange: true
  }
})
```

### Shallow Data Reactivity trong `useAsyncData` và `useFetch`

🚦 **Mức độ tác động**: Tối thiểu

Đối tượng `data` được trả về từ `useAsyncData`, `useFetch`, `useLazyAsyncData` và `useLazyFetch` giờ đây là một `shallowRef` thay vì một `ref`.

#### Những gì đã thay đổi

Khi dữ liệu mới được fetch, bất cứ thứ gì phụ thuộc vào `data` vẫn sẽ là reactive vì toàn bộ đối tượng được thay thế. Nhưng nếu mã của bạn thay đổi một thuộc tính *trong* cấu trúc dữ liệu đó, điều này sẽ không kích hoạt bất kỳ reactivity nào trong ứng dụng của bạn.

#### Lý do thay đổi

Điều này mang lại cải thiện hiệu suất **đáng kể** cho các đối tượng và mảng lồng sâu vì Vue không cần theo dõi từng thuộc tính/mảng đơn lẻ để sửa đổi. Trong hầu hết các trường hợp, `data` cũng nên là immutable.

#### Bước di chuyển

Trong hầu hết các trường hợp, không cần bước di chuyển nào, nhưng nếu bạn dựa vào reactivity của đối tượng data thì bạn có hai tùy chọn:

1. Bạn có thể chi tiết opt in vào deep reactivity trên cơ sở từng composable:

   ```diff
   - const { data } = useFetch('/api/test')
   + const { data } = useFetch('/api/test', { deep: true })
   ```
2. Bạn có thể thay đổi hành vi mặc định trên cơ sở toàn dự án (không được khuyến nghị):

   ```ts [nuxt.config.ts] twoslash
   export default defineNuxtConfig({
     experimental: {
       defaults: {
         useAsyncData: {
           deep: true
         }
       }
     }
   })
   ```

::tip
Nếu cần, bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/shallow-function-reactivity`
::

### Đường dẫn Watch tuyệt đối trong `builder:watch`

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Hook `builder:watch` của Nuxt giờ đây emit một path tuyệt đối thay vì tương đối so với `srcDir` dự án của bạn.

#### Lý do thay đổi

Điều này cho phép chúng tôi hỗ trợ theo dõi các paths bên ngoài `srcDir` của bạn, và cung cấp hỗ trợ tốt hơn cho layers và các mẫu phức tạp khác.

#### Bước di chuyển

Chúng tôi đã chủ động di chuyển các modules Nuxt công khai mà chúng tôi biết sử dụng hook này. Xem [issue #25339](https://github.com/nuxt/nuxt/issues/25339){rel="nofollow"}.

Tuy nhiên, nếu bạn là tác giả module sử dụng hook `builder:watch` và muốn duy trì khả năng tương thích ngược/tiến, bạn có thể sử dụng mã sau để đảm bảo mã của bạn hoạt động giống nhau trong cả Nuxt v3 và Nuxt v4:

```diff
+ import { relative, resolve } from 'node:fs'
  // ...
  nuxt.hook('builder:watch', async (event, path) => {
+   path = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, path))
    // ...
  })
```

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/absolute-watch-path`
::

### Loại bỏ đối tượng `window.__NUXT__`

#### Những gì đã thay đổi

Chúng tôi đang loại bỏ đối tượng toàn cục `window.__NUXT__` sau khi ứng dụng hoàn thành hydration.

#### Lý do thay đổi

Điều này mở đường cho các mẫu multi-app ([#21635](https://github.com/nuxt/nuxt/issues/21635){rel="nofollow"}) và cho phép chúng tôi tập trung vào một cách duy nhất để truy cập dữ liệu Nuxt app - `useNuxtApp()`.

#### Bước di chuyển

Dữ liệu vẫn có sẵn, nhưng có thể được truy cập với `useNuxtApp().payload`:

```diff
- console.log(window.__NUXT__)
+ console.log(useNuxtApp().payload)
```

### Quét index thư mục

🚦 **Mức độ tác động**: Trung bình

#### Những gì đã thay đổi

Các thư mục con trong thư mục `middleware/` của bạn cũng được quét để tìm các tệp `index` và chúng giờ đây cũng được đăng ký làm middleware trong dự án của bạn.

#### Lý do thay đổi

Nuxt tự động quét một số thư mục, bao gồm `middleware/` và `plugins/`.

Các thư mục con trong thư mục `plugins/` của bạn được quét để tìm các tệp `index` và chúng tôi muốn làm cho hành vi này nhất quán giữa các thư mục được quét.

#### Bước di chuyển

Có lẽ không cần di chuyển gì nhưng nếu bạn muốn hoàn nguyên về hành vi trước đây, bạn có thể thêm một hook để lọc ra những middleware này:

```ts
export default defineNuxtConfig({
  hooks: {
    'app:resolve'(app) {
      app.middleware = app.middleware.filter(mw => !/\/index\.[^/]+$/.test(mw.path))
    }
  }
})
```

### Thay đổi Template Compilation

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

Trước đây, Nuxt sử dụng `lodash/template` để biên dịch các templates nằm trên hệ thống tệp bằng định dạng/cú pháp tệp `.ejs`.

Ngoài ra, chúng tôi cung cấp một số utilities template (`serialize`, `importName`, `importSources`) có thể được sử dụng để tạo mã trong những templates này, giờ đây đang được loại bỏ.

#### Lý do thay đổi

Trong Nuxt v3 chúng tôi chuyển sang cú pháp 'ảo' với hàm `getContents()` linh hoạt và hiệu suất hơn nhiều.

Ngoài ra, `lodash/template` đã có một loạt các vấn đề bảo mật. Những vấn đề này không thực sự áp dụng cho các dự án Nuxt vì nó được sử dụng tại thời điểm build, không phải runtime, và bởi mã đáng tin cậy. Tuy nhiên, chúng vẫn xuất hiện trong các kiểm tra bảo mật. Hơn nữa, `lodash` là một dependency nặng và không được sử dụng bởi hầu hết các dự án.

Cuối cùng, việc cung cấp các hàm serialization mã trực tiếp trong Nuxt là không lý tưởng. Thay vào đó, chúng tôi duy trì các dự án như [unjs/knitwork](http://github.com/unjs/knitwork){rel="nofollow"} có thể là dependencies của dự án bạn, và nơi các vấn đề bảo mật có thể được báo cáo/giải quyết trực tiếp mà không yêu cầu nâng cấp Nuxt.

#### Bước di chuyển

Chúng tôi đã tạo các PR để cập nhật các modules sử dụng cú pháp EJS, nhưng nếu bạn cần tự làm điều này, bạn có ba lựa chọn tương thích ngược/tiến:

- Di chuyển logic string interpolation của bạn trực tiếp vào `getContents()`.
- Sử dụng hàm tùy chỉnh để xử lý việc thay thế, như trong <https://github.com/nuxt-modules/color-mode/pull/240>{rel="nofollow"}.
- Sử dụng `es-toolkit/compat` (thay thế drop-in cho lodash template), như một dependency của dự án *bạn* thay vì Nuxt:

```diff
+ import { readFileSync } from 'node:fs'
+ import { template } from 'es-toolkit/compat'
  // ...
  addTemplate({
    fileName: 'appinsights-vue.js'
    options: { /* some options */ },
-   src: resolver.resolve('./runtime/plugin.ejs'),
+   getContents({ options }) {
+     const contents = readFileSync(resolver.resolve('./runtime/plugin.ejs'), 'utf-8')
+     return template(contents)({ options })
+   },
  })
```

Cuối cùng, nếu bạn đang sử dụng các template utilities (`serialize`, `importName`, `importSources`), bạn có thể thay thế chúng như sau với các utilities từ `knitwork`:

```ts
import { genDynamicImport, genImport, genSafeVariableName } from 'knitwork'

const serialize = (data: any) => JSON.stringify(data, null, 2).replace(/"{(.+)}"(?=,?$)/gm, r => JSON.parse(r).replace(/^{(.*)}$/, '$1'))

const importSources = (sources: string | string[], { lazy = false } = {}) => {
  return toArray(sources).map((src) => {
    if (lazy) {
      return `const ${genSafeVariableName(src)} = ${genDynamicImport(src, { comment: `webpackChunkName: ${JSON.stringify(src)}` })}`
    }
    return genImport(src, genSafeVariableName(src))
  }).join('\n')
}

const importName = genSafeVariableName
```

::tip
Bạn có thể tự động hóa bước này bằng cách chạy `npx codemod@latest nuxt/4/template-compilation-changes`
::

### Thay đổi cấu hình TypeScript mặc định

🚦 **Mức độ tác động**: Tối thiểu

#### Những gì đã thay đổi

`compilerOptions.noUncheckedIndexedAccess` giờ đây là `true` thay vì `false`.

#### Lý do thay đổi

Thay đổi này là phần tiếp theo của [cập nhật cấu hình 3.12](https://github.com/nuxt/nuxt/pull/27485){rel="nofollow"} trước đây khi chúng tôi cải thiện các mặc định của mình, chủ yếu tuân thủ [khuyến nghị của TotalTypeScript](https://www.totaltypescript.com/tsconfig-cheat-sheet){rel="nofollow"}.

#### Bước di chuyển

Có hai cách tiếp cận:

1. Chạy typecheck trên ứng dụng của bạn và sửa bất kỳ lỗi mới nào (được khuyến nghị).
2. Ghi đè mặc định mới trong `nuxt.config.ts` của bạn:
   ```ts
   export default defineNuxtConfig({
     typescript: {
       tsConfig: {
         compilerOptions: {
           noUncheckedIndexedAccess: false
         }
       }
     }
   })
   ```

### Chia tách cấu hình TypeScript

🚦 **Mức độ tác động**: Tối thiểu

#### What Changed

Nuxt hiện tại tạo ra các cấu hình TypeScript riêng biệt cho các ngữ cảnh khác nhau để cung cấp trải nghiệm kiểm tra kiểu tốt hơn:

1. **Các file cấu hình TypeScript mới**: Nuxt hiện tại tạo ra các cấu hình TypeScript bổ sung:
   - `.nuxt/tsconfig.app.json` - Cho mã ứng dụng của bạn (các component Vue, composables, v.v.)
   - `.nuxt/tsconfig.server.json` - Cho mã phía server của bạn (thư mục Nitro/server)
   - `.nuxt/tsconfig.node.json` - Cho mã build-time của bạn (modules, `nuxt.config.ts`, v.v.)
   - `.nuxt/tsconfig.shared.json` - Cho mã được chia sẻ giữa ngữ cảnh app và server (như types và các tiện ích không phụ thuộc môi trường)
   - `.nuxt/tsconfig.json` - Cấu hình legacy để tương thích ngược
2. **Tương thích ngược**: Các dự án hiện tại mở rộng `.nuxt/tsconfig.json` sẽ tiếp tục hoạt động như trước.
3. **Opt-in project references**: Các dự án mới hoặc những dự án muốn kiểm tra kiểu tốt hơn có thể áp dụng tính năng project references của TypeScript.
4. **Kiểm tra kiểu theo ngữ cảnh cụ thể**: Mỗi ngữ cảnh hiện có các tùy chọn compiler phù hợp và includes/excludes cho môi trường cụ thể của nó.
5. **Tùy chọn `typescript.nodeTsConfig` mới**: Bạn hiện có thể tùy chỉnh cấu hình TypeScript cho mã build-time Node.js.

#### Reasons for Change

Thay đổi này mang lại một số lợi ích:

1. **An toàn kiểu tốt hơn**: Mỗi ngữ cảnh (app, server, build-time) được kiểm tra kiểu phù hợp với các globals và APIs cụ thể theo ngữ cảnh.
2. **Trải nghiệm IDE được cải thiện**: IntelliSense và báo lỗi tốt hơn cho các phần khác nhau của codebase.
3. **Tách biệt rõ ràng hơn**: Mã server sẽ không đề xuất sai các API phía client và ngược lại.
4. **Hiệu suất**: TypeScript có thể kiểm tra mã hiệu quả hơn với các cấu hình được phạm vi hóa đúng cách.

Ví dụ, auto-imports không khả dụng trong `nuxt.config.ts` của bạn (nhưng trước đây điều này không được TypeScript báo cờ). Và trong khi IDEs nhận ra ngữ cảnh riêng biệt được gợi ý bởi `tsconfig.json` trong thư mục `server/` của bạn, điều này không được phản ánh trong kiểm tra kiểu (yêu cầu một bước riêng biệt).

#### Migration Steps

**Không cần migration** - các dự án hiện tại sẽ tiếp tục hoạt động như trước.

Tuy nhiên, để tận dụng việc kiểm tra kiểu được cải thiện, bạn có thể opt-in vào phương pháp project references mới:

1. **Cập nhật `tsconfig.json` gốc của bạn** để sử dụng project references:
   ```json
   {
     "files": [],
     "references": [
       { "path": "./.nuxt/tsconfig.app.json" },
       { "path": "./.nuxt/tsconfig.server.json" },
       { "path": "./.nuxt/tsconfig.shared.json" },
       { "path": "./.nuxt/tsconfig.node.json" }
     ]
   }
   ```
2. **Xóa bất kỳ file `tsconfig.json` server thủ công** (như `server/tsconfig.json`) đã mở rộng `.nuxt/tsconfig.server.json`.
3. **Cập nhật scripts kiểm tra kiểu của bạn** để sử dụng build flag cho project references:
   ```diff
   - "typecheck": "nuxt prepare && vue-tsc --noEmit"
   + "typecheck": "nuxt prepare && vue-tsc -b --noEmit"
   ```
4. **Di chuyển tất cả type augmentations vào ngữ cảnh phù hợp**:
   - Nếu bạn đang augment types cho ngữ cảnh app, di chuyển các file vào thư mục `app/`.
   - Nếu bạn đang augment types cho ngữ cảnh server, di chuyển các file vào thư mục `server/`.
   - Nếu bạn đang augment types được **chia sẻ giữa app và server**, di chuyển các file vào thư mục `shared/`.
   :warning[Augmenting types từ bên ngoài thư mục `app/`, `server/`, hoặc `shared/` sẽ không hoạt động với thiết lập project references mới.]
5. **Cấu hình tùy chọn Node.js TypeScript** nếu cần:
   ```ts
   export default defineNuxtConfig({
     typescript: {
       // Tùy chỉnh cấu hình TypeScript cho app/server
       tsConfig: {
         compilerOptions: {
           strict: true
         }
       },
       // Tùy chỉnh cấu hình TypeScript cho build-time  
       nodeTsConfig: {
         compilerOptions: {
           strict: true
         }
       }
     }
   })
   ```
6. **Cập nhật bất kỳ CI/build scripts** chạy kiểm tra TypeScript để đảm bảo chúng sử dụng phương pháp project references mới.

Cấu hình mới cung cấp an toàn kiểu và IntelliSense tốt hơn cho các dự án opt-in, đồng thời duy trì tương thích ngược đầy đủ cho các thiết lập hiện tại.

### Removal of Experimental Features

🚦 **Impact Level**: Tối thiểu

#### What Changed

Bốn tính năng thử nghiệm không còn có thể cấu hình trong Nuxt 4:

- `experimental.treeshakeClientOnly` sẽ là `true` (mặc định từ v3.0)
- `experimental.configSchema` sẽ là `true` (mặc định từ v3.3)
- `experimental.polyfillVueUseHead` sẽ là `false` (mặc định từ v3.4)
- `experimental.respectNoSSRHeader` sẽ là `false` (mặc định từ v3.4)
- `vite.devBundler` không còn có thể cấu hình - nó sẽ sử dụng `vite-node` theo mặc định

#### Reasons for Change

Các tùy chọn này đã được đặt thành giá trị hiện tại trong một thời gian và chúng tôi không có lý do để tin rằng chúng cần phải vẫn có thể cấu hình.

#### Migration Steps

- `polyfillVueUseHead` có thể được triển khai trong user-land với [plugin này](https://github.com/nuxt/nuxt/blob/f209158352b09d1986aa320e29ff36353b91c358/packages/nuxt/src/head/runtime/plugins/vueuse-head-polyfill.ts#L10-L11){rel="nofollow"}
- `respectNoSSRHeader` có thể được triển khai trong user-land với [server middleware](https://github.com/nuxt/nuxt/blob/c660b39447f0d5b8790c0826092638d321cd6821/packages/nuxt/src/core/runtime/nitro/no-ssr.ts#L8-L9){rel="nofollow"}

### Removal of Top-Level `generate` Configuration

🚦 **Impact Level**: Tối thiểu

#### What Changed

Tùy chọn cấu hình `generate` cấp cao nhất không còn khả dụng trong Nuxt 4. Điều này bao gồm tất cả các thuộc tính của nó:

- `generate.exclude` - để loại trừ các routes khỏi prerendering
- `generate.routes` - để chỉ định các routes cần prerender

#### Reasons for Change

Cấu hình `generate` cấp cao là di sản từ Nuxt 2. Chúng tôi đã hỗ trợ `nitro.prerender` trong một thời gian và đó là cách ưa thích để cấu hình prerendering trong Nuxt 3+.

#### Migration Steps

Thay thế cấu hình `generate` bằng các tùy chọn `nitro.prerender` tương ứng:

```diff
export default defineNuxtConfig({
- generate: {
-   exclude: ['/admin', '/private'],
-   routes: ['/sitemap.xml', '/robots.txt']
- }
+ nitro: {
+   prerender: {
+     ignore: ['/admin', '/private'],
+     routes: ['/sitemap.xml', '/robots.txt']
+   }
+ }
})
```

::read-more{to="https://nitro.build/config#prerender"}
Đọc thêm về các tùy chọn cấu hình prerender của Nitro.
::

## Nuxt 2 vs. Nuxt 3+

Trong bảng dưới đây, có một so sánh nhanh giữa 3 phiên bản của Nuxt:

| Feature / Version       | Nuxt 2      | Nuxt Bridge  | Nuxt 3+       |
| ----------------------- | ----------- | ------------ | ------------- |
| Vue                     | 2           | 2            | 3             |
| Stability               | 😊 Ổn định  | 😊 Ổn định   | 😊 Ổn định    |
| Performance             | 🏎 Nhanh    | ✈️ Nhanh hơn | 🚀 Nhanh nhất |
| Nitro Engine            | ❌           | ✅            | ✅             |
| ESM support             | 🌙 Một phần | 👍 Tốt hơn   | ✅             |
| TypeScript              | ☑️ Opt-in   | 🚧 Một phần  | ✅             |
| Composition API         | ❌           | 🚧 Một phần  | ✅             |
| Options API             | ✅           | ✅            | ✅             |
| Components Auto Import  | ✅           | ✅            | ✅             |
| `<script setup>` syntax | ❌           | 🚧 Một phần  | ✅             |
| Auto Imports            | ❌           | ✅            | ✅             |
| webpack                 | 4           | 4            | 5             |
| Vite                    | ⚠️ Một phần | 🚧 Một phần  | ✅             |
| Nuxt CLI                | ❌ Cũ        | ✅ nuxt       | ✅ nuxt        |
| Static sites            | ✅           | ✅            | ✅             |

## Nuxt 2 to Nuxt 3+

Hướng dẫn migration cung cấp so sánh từng bước các tính năng của Nuxt 2 với các tính năng Nuxt 3+ và hướng dẫn để thích ứng ứng dụng hiện tại của bạn.

::read-more{to="https://nuxt.com/docs/migration/overview"}
Kiểm tra **hướng dẫn migration từ Nuxt 2 sang Nuxt 3**.
::

## Nuxt 2 to Nuxt Bridge

Nếu bạn muốn từ từ migration ứng dụng Nuxt 2 của mình sang Nuxt 3, bạn có thể sử dụng Nuxt Bridge. Nuxt Bridge là một lớp tương thích cho phép bạn sử dụng các tính năng Nuxt 3+ trong Nuxt 2 với cơ chế opt-in.

::read-more{to="https://nuxt.com/docs/bridge/overview"}
**Migration từ Nuxt 2 sang Nuxt Bridge**
::


# Nuxt Guide

::card-group{.sm:grid-cols-1}
  :::card
  ---
  icon: i-lucide-medal
  title: Key Concepts
  to: https://nuxt.com/docs/guide/concepts
  ---
  Discover the main concepts behind Nuxt, from auto-import, hybrid rendering to its TypeScript support.
  :::

  :::card
  ---
  icon: i-lucide-folders
  title: Directory Structure
  to: https://nuxt.com/docs/guide/directory-structure
  ---
  Learn about Nuxt directory structure and what benefits each directory or file offers.
  :::

  :::card
  ---
  icon: i-lucide-star
  title: Going Further
  to: https://nuxt.com/docs/guide/going-further
  ---
  Master Nuxt with advanced concepts like experimental features, hooks, modules, and more.
  :::

  :::card
  ---
  icon: i-lucide-book-open
  title: Recipes
  to: https://nuxt.com/docs/guide/recipes
  ---
  Find solutions to common problems and learn how to implement them in your Nuxt project.
  :::

  :::card
  ---
  icon: i-lucide-square-check
  title: Best Practices
  to: https://nuxt.com/docs/guide/best-practices
  ---
  Learn about best practices when developing with Nuxt
  :::
::


# Auto-imports

Nuxt tự động import các component, composable và [Vue.js API](https://vuejs.org/api){rel="nofollow"} để sử dụng trong toàn bộ ứng dụng của bạn mà không cần import chúng một cách tường minh.

```vue [app.vue] twoslash
<script setup lang="ts">
const count = ref(1) // ref được auto-imported
</script>
```

Nhờ vào cấu trúc thư mục có định hướng của nó, Nuxt có thể tự động import các [`components/`](https://nuxt.com/docs/guide/directory-structure/components), [`composables/`](https://nuxt.com/docs/guide/directory-structure/composables) và [`utils/`](https://nuxt.com/docs/guide/directory-structure/utils) của bạn.

Trái ngược với khai báo global truyền thống, Nuxt bảo tồn kiểu dữ liệu, hoàn thiện IDE và gợi ý, và **chỉ bao gồm những gì được sử dụng trong code production của bạn**.

::note
Trong tài liệu, mọi hàm không được import tường minh đều được auto-imported bởi Nuxt và có thể được sử dụng như vậy trong code của bạn. Bạn có thể tìm thấy tài liệu tham khảo cho các component, composable và utility được auto-imported trong [phần API](https://nuxt.com/docs/api).
::

::note
Trong thư mục [`server`](https://nuxt.com/docs/guide/directory-structure/server), Nuxt tự động import các hàm và biến được export từ `server/utils/`.
::

::note
Bạn cũng có thể tự động import các hàm được export từ các thư mục tùy chỉnh hoặc package third-party bằng cách cấu hình phần [`imports`](https://nuxt.com/docs/api/nuxt-config#imports) trong file `nuxt.config` của bạn.
::

## Built-in Auto-imports

Nuxt tự động import các hàm và composable để thực hiện [data fetching](https://nuxt.com/docs/getting-started/data-fetching), truy cập vào [app context](https://nuxt.com/docs/api/composables/use-nuxt-app) và [runtime config](https://nuxt.com/docs/guide/going-further/runtime-config), quản lý [state](https://nuxt.com/docs/getting-started/state-management) hoặc định nghĩa component và plugin.

```vue twoslash
<script setup lang="ts">
/* useFetch() được auto-imported */
const { data, refresh, status } = await useFetch('/api/hello')
</script>
```

Vue expose các Reactivity API như `ref` hoặc `computed`, cũng như các lifecycle hook và helper được auto-imported bởi Nuxt.

```vue twoslash
<script setup lang="ts">
/* ref() và computed() được auto-imported */
const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Vue and Nuxt Composables

Khi bạn sử dụng các composable Composition API có sẵn được cung cấp bởi Vue và Nuxt, hãy lưu ý rằng nhiều trong số chúng phụ thuộc vào việc được gọi trong đúng *context*.

Trong quá trình lifecycle của component, Vue theo dõi instance tạm thời của component hiện tại (và tương tự, Nuxt theo dõi instance tạm thời của `nuxtApp`) thông qua một biến global, và sau đó bỏ thiết lập nó trong cùng tick. Điều này rất quan trọng khi server rendering, cả để tránh ô nhiễm state giữa các request (rò rỉ tham chiếu được chia sẻ giữa hai người dùng) và để tránh rò rỉ giữa các component khác nhau.

Điều đó có nghĩa là (với rất ít ngoại lệ) bạn không thể sử dụng chúng bên ngoài Nuxt plugin, Nuxt route middleware hoặc Vue setup function. Hơn nữa, bạn phải sử dụng chúng một cách đồng bộ - tức là, bạn không thể sử dụng `await` trước khi gọi composable, ngoại trừ trong các block `<script setup>`, trong setup function của component được khai báo với `defineNuxtComponent`, trong `defineNuxtPlugin` hoặc trong `defineNuxtRouteMiddleware`, nơi chúng tôi thực hiện transform để giữ context đồng bộ ngay cả sau `await`.

Nếu bạn gặp thông báo lỗi như `Nuxt instance is unavailable` thì có thể có nghĩa là bạn đang gọi Nuxt composable ở sai vị trí trong lifecycle Vue hoặc Nuxt.

::video-accordion
---
title: Xem video từ Alexander Lichter về việc tránh lỗi 'Nuxt instance is unavailable'
video-id: ofuKRZLtOdY
---
::

::tip
Khi sử dụng composable yêu cầu Nuxt context bên trong component không phải SFC, bạn cần wrap component của mình với `defineNuxtComponent` thay vì `defineComponent`
::

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#asynccontext
---
Kiểm tra tính năng thử nghiệm `asyncContext` để sử dụng Nuxt composable trong các hàm async.
::

::read-more
---
target: _blank
to: https://github.com/nuxt/nuxt/issues/14269#issuecomment-1397352832
---
Xem giải thích đầy đủ trong GitHub comment này.
::

**Ví dụ về code bị lỗi:**

```ts [composables/example.ts] twoslash
// cố gắng truy cập runtime config bên ngoài composable
const config = useRuntimeConfig()

export const useMyComposable = () => {
  // truy cập runtime config ở đây
}
```

**Ví dụ về code hoạt động:**

```ts [composables/example.ts] twoslash
export const useMyComposable = () => {
  // Bởi vì composable của bạn được gọi ở đúng vị trí trong lifecycle,
  // useRuntimeConfig sẽ hoạt động ở đây
  const config = useRuntimeConfig()

  // ...
}
```

## Directory-based Auto-imports

Nuxt trực tiếp tự động import các file được tạo trong các thư mục được định nghĩa:

- `components/` cho [Vue components](https://nuxt.com/docs/guide/directory-structure/components).
- `composables/` cho [Vue composables](https://nuxt.com/docs/guide/directory-structure/composables).
- `utils/` cho các helper function và utility khác.

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

::warning
**`ref` và `computed` được auto-imported sẽ không được unwrap trong `<template>` của component.** :br
Điều này là do cách Vue hoạt động với các ref không phải top-level với template. Bạn có thể đọc thêm về điều này [trong tài liệu Vue](https://vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-when-unwrapping-in-templates){rel="nofollow"}.
::

### Explicit Imports

Nuxt expose mọi auto-import với alias `#imports` có thể được sử dụng để làm cho import trở nên tường minh nếu cần:

```vue
<script setup lang="ts">
import { ref, computed } from '#imports'

const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Disabling Auto-imports

Nếu bạn muốn vô hiệu hóa việc auto-importing composable và utility, bạn có thể đặt `imports.autoImport` thành `false` trong file `nuxt.config`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  imports: {
    autoImport: false
  }
})
```

Điều này sẽ vô hiệu hóa hoàn toàn auto-imports nhưng vẫn có thể sử dụng [explicit imports](https://nuxt.com/#explicit-imports) từ `#imports`.

### Partially Disabling Auto-imports

Nếu bạn muốn các hàm đặc thù framework như `ref` vẫn được auto-imported nhưng muốn vô hiệu hóa auto-imports cho code của riêng bạn (ví dụ: composable tùy chỉnh), bạn có thể đặt tùy chọn `imports.scan` thành `false` trong file `nuxt.config.ts` của bạn:

```ts
export default defineNuxtConfig({
  imports: {
    scan: false
  }
})
```

Với cấu hình này:

- Các hàm framework như `ref`, `computed`, hoặc `watch` sẽ vẫn hoạt động mà không cần import thủ công.
- Code tùy chỉnh, chẳng hạn như composable, sẽ cần được import thủ công trong các file của bạn.

::warning
**Cảnh báo:** Thiết lập này có một số hạn chế nhất định:

- Nếu bạn cấu trúc dự án của mình với layer, bạn sẽ cần phải import tường minh các composable từ mỗi layer, thay vì dựa vào auto-imports.
- Điều này phá vỡ tính năng override của layer system. Nếu bạn sử dụng `imports.scan: false`, hãy đảm bảo bạn hiểu tác dụng phụ này và điều chỉnh kiến trúc của bạn cho phù hợp.
::

## Auto-imported Components

Nuxt cũng tự động import các component từ thư mục `~/components` của bạn, mặc dù điều này được cấu hình riêng biệt với việc auto-importing composable và utility function.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/components"}
::

Để vô hiệu hóa việc auto-importing component từ thư mục `~/components` của riêng bạn, bạn có thể đặt `components.dirs` thành một mảng rỗng (lưu ý rằng điều này sẽ không ảnh hưởng đến các component được thêm bởi module).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: {
    dirs: []
  }
})
```

## Auto-import from Third-Party Packages

Nuxt cũng cho phép auto-importing từ các package third-party.

::tip
Nếu bạn đang sử dụng Nuxt module cho package đó, có khả năng module đã cấu hình auto-imports cho package đó rồi.
::

Ví dụ, bạn có thể bật auto-import của composable `useI18n` từ package `vue-i18n` như thế này:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  imports: {
    presets: [
      {
        from: 'vue-i18n',
        imports: ['useI18n']
      }
    ]
  }
})
```

::video-accordion
---
title: Xem video từ Alexander Lichter về cách dễ dàng thiết lập custom auto imports
video-id: FT2LQJ2NvVI
---
::


# Nuxt Lifecycle

Mục tiêu của chương này là cung cấp một tổng quan high-level về các phần khác nhau của framework, thứ tự thực thi của chúng và cách chúng hoạt động cùng nhau.

## Server

Trên server, các bước sau được thực thi cho mọi request ban đầu đến ứng dụng của bạn:

### Step 1: Setup Nitro Server and Nitro Plugins (Once)

Nuxt được hỗ trợ bởi [Nitro](https://nitro.build/){rel="nofollow"}, một modern server engine.

Khi Nitro khởi động, nó sẽ initialize và thực thi các plugins dưới thư mục `/server/plugins`. Những plugins này có thể:

- Capture và handle các lỗi toàn ứng dụng.
- Register hooks thực thi khi Nitro tắt.
- Register hooks cho các sự kiện request lifecycle, chẳng hạn như modify responses.

::callout{icon="i-lucide-lightbulb"}
Nitro plugins chỉ được thực thi một lần khi server khởi động. Trong môi trường serverless, server boot trên mỗi incoming request, và Nitro plugins cũng vậy. Tuy nhiên, chúng không được awaited.
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/server#server-plugins
---
::

### Step 2: Nitro Server Middleware

Sau khi initialize Nitro server, middleware dưới `server/middleware/` được thực thi cho mọi request. Middleware có thể được sử dụng cho các tác vụ như authentication, logging, hoặc request transformation.

::warning
Trả về value từ middleware sẽ terminate request và gửi returned value làm response. Hành vi này thường nên tránh để đảm bảo xử lý request đúng cách!
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/server#server-middleware
---
::

### Step 3: Initialize Nuxt and Execute Nuxt App Plugins

Các Vue và Nuxt instances được tạo trước. Sau đó, Nuxt thực thi các server plugins của nó. Điều này bao gồm:

- Built-in plugins, chẳng hạn như Vue Router và `unhead`.
- Custom plugins nằm trong thư mục `plugins/`, bao gồm những plugins không có suffix (ví dụ: `myPlugin.ts`) và những plugins có suffix `.server` (ví dụ: `myServerPlugin.server.ts`).

Plugins thực thi theo một thứ tự cụ thể và có thể có dependencies lẫn nhau. Để biết thêm chi tiết, bao gồm thứ tự thực thi và parallelism, tham khảo [tài liệu Plugins](https://nuxt.com/docs/guide/directory-structure/plugins).

::callout{icon="i-lucide-lightbulb"}
Sau bước này, Nuxt gọi hook [`app:created`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime), có thể được sử dụng để thực thi logic bổ sung.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

### Step 4: Route Validation

Sau khi initialize plugins và trước khi thực thi middleware, Nuxt gọi method `validate` nếu nó được define trong function `definePageMeta`. Method `validate`, có thể là synchronous hoặc asynchronous, thường được sử dụng để validate các dynamic route parameters.

- Function `validate` nên trả về `true` nếu các parameters hợp lệ.
- Nếu validation thất bại, nó nên trả về `false` hoặc một object chứa `statusCode` và/hoặc `statusMessage` để terminate request.

Để biết thêm thông tin, xem [tài liệu Route Validation](https://nuxt.com/docs/getting-started/routing#route-validation).

::read-more{to="https://nuxt.com/docs/getting-started/routing#route-validation"}
::

### Step 5: Execute Nuxt App Middleware

Middleware cho phép bạn chạy code trước khi navigate đến một route cụ thể. Nó thường được sử dụng cho các tác vụ như authentication, redirection, hoặc logging.

Trong Nuxt, có ba loại middleware:

- **Global route middleware**
- **Named route middleware**
- **Anonymous (or inline) route middleware**

Nuxt thực thi tất cả global middleware khi load trang ban đầu (cả trên server và client) và sau đó lại trước bất kỳ client-side navigation nào. Named và anonymous middleware chỉ được thực thi trên các routes được chỉ định trong middleware property của page(route) meta được define trong các page components tương ứng.

Để biết chi tiết về từng loại và ví dụ, xem [tài liệu Middleware](https://nuxt.com/docs/guide/directory-structure/middleware).

Bất kỳ redirection nào trên server sẽ dẫn đến việc gửi header `Location:` đến browser; browser sau đó thực hiện request mới đến location mới này. Tất cả application state sẽ được reset khi điều này xảy ra, trừ khi được persist trong một cookie.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/middleware"}
::

### Step 6: Render Page and Components

Nuxt render page và các components của nó và fetch bất kỳ data cần thiết nào với `useFetch` và `useAsyncData` trong bước này. Vì không có dynamic updates và không có DOM operations xảy ra trên server, các Vue lifecycle hooks như `onBeforeMount`, `onMounted`, và các hooks tiếp theo **KHÔNG** được thực thi trong SSR.

Theo mặc định, Vue tạm dừng dependency tracking trong SSR để có hiệu suất tốt hơn.

::callout{icon="i-lucide-lightbulb"}
Không có reactivity ở phía server vì Vue SSR render ứng dụng từ trên xuống dưới như static HTML, làm cho việc quay lại và modify content đã được render trở nên không thể.
::

::important
Bạn nên tránh code tạo ra side effects cần cleanup trong root scope của `<script setup>`. Một ví dụ về những side effects như vậy là thiết lập timers với `setInterval`. Trong client-side only code chúng ta có thể thiết lập timer và sau đó tear it down trong `onBeforeUnmount` hoặc `onUnmounted`. Tuy nhiên, vì các unmount hooks sẽ không bao giờ được gọi trong SSR, các timers sẽ tồn tại mãi mãi. Để tránh điều này, hãy chuyển side-effect code của bạn vào `onMounted` thay thế.
::

::tip{icon="i-lucide-video" target="_blank" to="https://youtu.be/dZSNW07sO-A"}
Xem video từ Daniel Roe giải thích về Server Rendering và Global State.
::

### Step 7: Generate HTML Output

Sau khi tất cả data cần thiết được fetch và các components được render, Nuxt kết hợp các rendered components với settings từ `unhead` để tạo ra một HTML document hoàn chỉnh. HTML này, cùng với data liên quan, sau đó được gửi trả về client để hoàn thành quá trình SSR.

::callout{icon="i-lucide-lightbulb"}
Sau khi render Vue application thành HTML, Nuxt gọi hook [`app:rendered`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime).
::

::callout{icon="i-lucide-lightbulb"}
Trước khi finalize và gửi HTML, Nitro sẽ gọi hook [`render:html`](https://nuxt.com/docs/api/advanced/hooks#nitro-app-hooks-runtime-server-side). Hook này cho phép bạn manipulate HTML được tạo, chẳng hạn như inject thêm scripts hoặc modify meta tags.
::

## Client (browser)

Phần này của lifecycle được thực thi hoàn toàn trong browser, bất kể bạn đã chọn Nuxt mode nào.

### Step 1: Initialize Nuxt and Execute Nuxt App Plugins

Bước này tương tự như server-side execution và bao gồm cả built-in và custom plugins.

Custom plugins trong thư mục `plugins/`, như những plugins không có suffix (ví dụ: `myPlugin.ts`) và với suffix `.client` (ví dụ: `myClientPlugin.client.ts`), được thực thi ở phía client.

::callout{icon="i-lucide-lightbulb"}
Sau bước này, Nuxt gọi hook [`app:created`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime), có thể được sử dụng để thực thi logic bổ sung.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

### Step 2: Route Validation

Bước này giống như server-side execution và bao gồm method `validate` nếu được define trong function `definePageMeta`.

### Step 3: Execute Nuxt App Middleware

Nuxt middleware chạy trên cả server và client. Nếu bạn muốn code nhất định chạy trong các môi trường cụ thể, hãy cân nhắc chia nó bằng cách sử dụng `import.meta.client` cho client và `import.meta.server` cho server.

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/middleware#when-middleware-runs
---
::

### Step 4: Mount Vue Application and Hydration

Gọi `app.mount('#__nuxt')` mount Vue application vào DOM. Nếu ứng dụng sử dụng SSR hoặc SSG mode, Vue thực hiện bước hydration để làm cho client-side application trở nên interactive. Trong hydration, Vue tạo lại ứng dụng (loại trừ [Server Components](https://nuxt.com/docs/guide/directory-structure/components#server-components)), match từng component với DOM nodes tương ứng của nó, và attach DOM event listeners.

Để đảm bảo hydration đúng cách, điều quan trọng là duy trì tính nhất quán giữa data trên server và client. Đối với API requests, khuyến nghị sử dụng `useAsyncData`, `useFetch`, hoặc các composables SSR-friendly khác. Những methods này đảm bảo rằng data được fetch ở phía server được tái sử dụng trong hydration, tránh các requests lặp lại. Bất kỳ requests mới nào chỉ nên được trigger sau hydration, ngăn ngừa hydration errors.

::callout{icon="i-lucide-lightbulb"}
Trước khi mount Vue application, Nuxt gọi hook [`app:beforeMount`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime).
::

::callout{icon="i-lucide-lightbulb"}
Sau khi mount Vue application, Nuxt gọi hook [`app:mounted`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime).
::

### Step 5: Vue Lifecycle

Không giống như trên server, browser thực thi đầy đủ [Vue lifecycle](https://vuejs.org/guide/essentials/lifecycle){rel="nofollow"}.


# Vue.js Development

Nuxt tích hợp Vue 3, phiên bản major mới của Vue cho phép các pattern mới cho người dùng Nuxt.

::note
Mặc dù kiến thức sâu về Vue không bắt buộc để sử dụng Nuxt, chúng tôi khuyên bạn nên đọc tài liệu và xem qua một số ví dụ trên [vuejs.org](https://vuejs.org){rel="nofollow"}.
::

Nuxt luôn sử dụng Vue làm frontend framework.

Chúng tôi chọn xây dựng Nuxt trên nền tảng Vue vì những lý do sau:

- Mô hình reactivity của Vue, nơi một thay đổi trong dữ liệu tự động kích hoạt một thay đổi trong giao diện.
- Template dựa trên component, trong khi vẫn giữ HTML làm ngôn ngữ chung của web, cho phép các pattern trực quan để giữ giao diện của bạn nhất quán, nhưng vẫn mạnh mẽ.
- Từ các dự án nhỏ đến các ứng dụng web lớn, Vue vẫn hoạt động tốt ở quy mô lớn để đảm bảo ứng dụng của bạn tiếp tục mang lại giá trị cho người dùng.

## Vue with Nuxt

### Single File Components

[Single-file component của Vue](https://vuejs.org/guide/scaling-up/sfc.html){rel="nofollow"} (SFC hoặc file `*.vue`) đóng gói markup (`<template>`), logic (`<script>`) và styling (`<style>`) của một Vue component. Nuxt cung cấp trải nghiệm zero-config cho SFC với [Hot Module Replacement](https://vite.dev/guide/features.html#hot-module-replacement){rel="nofollow"} mang lại trải nghiệm developer liền mạch.

### Auto-imports

Mọi Vue component được tạo trong thư mục [`components/`](https://nuxt.com/docs/guide/directory-structure/components) của dự án Nuxt sẽ có sẵn trong dự án của bạn mà không cần phải import nó. Nếu một component không được sử dụng ở đâu, code production của bạn sẽ không bao gồm nó.

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::

### Vue Router

Hầu hết các ứng dụng cần nhiều trang và cách để điều hướng giữa chúng. Điều này được gọi là **routing**. Nuxt sử dụng thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) và các quy ước đặt tên để trực tiếp tạo route ánh xạ tới file của bạn bằng cách sử dụng [thư viện Vue Router](https://router.vuejs.org){rel="nofollow"} chính thức.

::read-more{to="https://nuxt.com/docs/getting-started/routing"}
::

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

## Differences with Nuxt 2 / Vue 2

Nuxt 3+ dựa trên Vue 3. Phiên bản major mới của Vue giới thiệu một số thay đổi mà Nuxt tận dụng:

- Hiệu suất tốt hơn
- Composition API
- Hỗ trợ TypeScript

### Faster Rendering

Vue Virtual DOM (VDOM) đã được viết lại từ đầu và cho phép hiệu suất rendering tốt hơn. Hơn nữa, khi làm việc với các Single-File Component đã được compiled, Vue compiler có thể tối ưu hóa thêm chúng tại thời điểm build bằng cách tách markup static và dynamic.

Điều này dẫn đến rendering đầu tiên nhanh hơn (tạo component) và cập nhật, và ít sử dụng bộ nhớ hơn. Trong Nuxt 3, nó cũng cho phép server-side rendering nhanh hơn.

### Smaller Bundle

Với Vue 3 và Nuxt 3, trọng tâm đã được đặt vào việc giảm kích thước bundle. Với phiên bản 3, hầu hết chức năng của Vue, bao gồm template directive và built-in component, đều có thể tree-shake. Bundle production của bạn sẽ không bao gồm chúng nếu bạn không sử dụng.

Bằng cách này, một ứng dụng Vue 3 tối thiểu có thể được giảm xuống 12 kb gzipped.

### Composition API

Cách duy nhất để cung cấp dữ liệu và logic cho component trong Vue 2 là thông qua Options API, cho phép bạn trả về data và method cho template với các thuộc tính được định nghĩa trước như `data` và `methods`:

```vue twoslash
<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  methods: {
    increment(){
      this.count++
    }
  }
}
</script>
```

[Composition API](https://vuejs.org/guide/extras/composition-api-faq.html){rel="nofollow"} được giới thiệu trong Vue 3 không phải là sự thay thế cho Options API, nhưng nó cho phép tái sử dụng logic tốt hơn trong toàn bộ ứng dụng, và là cách tự nhiên hơn để nhóm code theo mối quan tâm trong các component phức tạp.

Được sử dụng với từ khóa `setup` trong định nghĩa `<script>`, đây là component trên được viết lại với Composition API và các Reactivity API được auto-imported của Nuxt 3:

```vue [components/Counter.vue] twoslash
<script setup lang="ts">
const count = ref(0)
const increment = () => count.value++
</script>
```

Mục tiêu của Nuxt là cung cấp trải nghiệm developer tuyệt vời xung quanh Composition API.

- Sử dụng các [Reactivity function](https://vuejs.org/api/reactivity-core.html){rel="nofollow"} được auto-imported từ Vue và [built-in composable](https://nuxt.com/docs/api/composables/use-async-data) của Nuxt.
- Viết các hàm có thể tái sử dụng được auto-imported của riêng bạn trong [thư mục `composables/`](https://nuxt.com/docs/guide/directory-structure/composables).

### TypeScript Support

Cả Vue 3 và Nuxt 3+ đều được viết bằng TypeScript. Một codebase được typed đầy đủ ngăn chặn lỗi và ghi lại việc sử dụng API. Điều này không có nghĩa là bạn phải viết ứng dụng của mình bằng TypeScript để tận dụng nó. Với Nuxt 3, bạn có thể opt-in bằng cách đổi tên file từ `.js` thành `.ts`, hoặc thêm `<script setup lang="ts">` trong một component.

::read-more{to="https://nuxt.com/docs/guide/concepts/typescript"}
Đọc chi tiết về TypeScript trong Nuxt
::


# Rendering Modes

Nuxt hỗ trợ các chế độ render khác nhau, [universal rendering](https://nuxt.com/#universal-rendering), [client-side rendering](https://nuxt.com/#client-side-rendering) nhưng cũng cung cấp [hybrid-rendering](https://nuxt.com/#hybrid-rendering) và khả năng render ứng dụng của bạn trên [CDN Edge Servers](https://nuxt.com/#edge-side-rendering).

Cả browser và server đều có thể hiểu mã JavaScript để biến đổi các component Vue.js thành các element HTML. Bước này được gọi là **rendering**. Nuxt hỗ trợ cả **universal** và **client-side** rendering. Hai phương pháp này đều có lợi ích và nhược điểm mà chúng tôi sẽ đề cập.

Theo mặc định, Nuxt sử dụng **universal rendering** để cung cấp trải nghiệm người dùng tốt hơn, hiệu suất và tối ưu hóa việc lập chỉ mục của công cụ tìm kiếm, nhưng bạn có thể chuyển đổi chế độ rendering trong [một dòng cấu hình](https://nuxt.com/docs/api/nuxt-config#ssr).

## Universal Rendering

Bước này tương tự như **server-side rendering** truyền thống được thực hiện bởi các ứng dụng PHP hoặc Ruby. Khi browser yêu cầu một URL với universal rendering được kích hoạt, Nuxt chạy mã JavaScript (Vue.js) trong môi trường server và trả về một trang HTML được render đầy đủ cho browser. Nuxt cũng có thể trả về một trang HTML được render đầy đủ từ cache nếu trang đã được tạo trước.

Người dùng ngay lập tức nhận được toàn bộ nội dung ban đầu của ứng dụng, ngược lại với client-side rendering.

Khi tài liệu HTML đã được tải xuống, browser diễn giải điều này và Vue.js tiếp quản tài liệu. Cùng một mã JavaScript đã từng chạy trên server bây giờ chạy trên client (browser) **lại** ở chế độ nền để kích hoạt tính tương tác (do đó **Universal rendering**) bằng cách gắn các listener của nó vào HTML. Điều này được gọi là **Hydration**. Khi hydration hoàn tất, trang có thể tận hưởng các lợi ích như giao diện động và chuyển tiếp trang.

Universal rendering cho phép ứng dụng Nuxt cung cấp thời gian tải trang nhanh trong khi vẫn giữ được lợi ích của client-side rendering. Hơn nữa, vì nội dung đã có sẵn trong tài liệu HTML, các crawler có thể lập chỉ mục mà không cần overhead.

![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](https://nuxt.com/assets/docs/concepts/rendering/ssr.svg)

**Cái gì được server-rendered và cái gì được client-rendered?**

Thật bình thường khi hỏi những phần nào của file Vue chạy trên server và/hoặc client trong chế độ universal rendering.

```vue [app.vue]
<script setup lang="ts">
const counter = ref(0); // thực thi trong môi trường server và client

const handleClick = () => {
  counter.value++; // chỉ thực thi trong môi trường client
};
</script>

<template>
  <div>
    <p>Count: {{ counter }}</p>
    <button @click="handleClick">Increment</button>
  </div>
</template>
```

Trong yêu cầu ban đầu, `counter` ref được khởi tạo trong server vì nó được render bên trong thẻ `<p>`. Nội dung của `handleClick` không bao giờ được thực thi ở đây. Trong quá trình hydration trong browser, `counter` ref được khởi tạo lại. `handleClick` cuối cùng gắn chính nó vào button; Do đó, hợp lý khi suy luận rằng nội dung của `handleClick` sẽ luôn chạy trong môi trường browser.

[Middlewares](https://nuxt.com/docs/guide/directory-structure/middleware) và [pages](https://nuxt.com/docs/guide/directory-structure/pages) chạy trong server và trên client trong quá trình hydration. [Plugins](https://nuxt.com/docs/guide/directory-structure/plugins) có thể được render trên server hoặc client hoặc cả hai. [Components](https://nuxt.com/docs/guide/directory-structure/components) có thể bị buộc chỉ chạy trên client. [Composables](https://nuxt.com/docs/guide/directory-structure/composables) và [utilities](https://nuxt.com/docs/guide/directory-structure/utils) được render dựa trên ngữ cảnh sử dụng của chúng.

**Lợi ích của server-side rendering:**

- **Hiệu suất**: Người dùng có thể truy cập ngay lập tức vào nội dung của trang vì browser có thể hiển thị nội dung tĩnh nhanh hơn nhiều so với nội dung được tạo bởi JavaScript. Đồng thời, Nuxt bảo tồn tính tương tác của ứng dụng web trong quá trình hydration.
- **Tối ưu hóa Công cụ Tìm kiếm**: Universal rendering cung cấp toàn bộ nội dung HTML của trang cho browser như một ứng dụng server cổ điển. Web crawler có thể lập chỉ mục trực tiếp nội dung của trang, điều này làm cho Universal rendering trở thành lựa chọn tuyệt vời cho bất kỳ nội dung nào mà bạn muốn lập chỉ mục nhanh chóng.

**Nhược điểm của server-side rendering:**

- **Ràng buộc phát triển:** Môi trường server và browser không cung cấp cùng các API, và có thể khó khăn để viết mã có thể chạy mượt mà trên cả hai phía. May mắn thay, Nuxt cung cấp hướng dẫn và các biến cụ thể để giúp bạn xác định nơi một đoạn mã được thực thi.
- **Chi phí:** Một server cần phải chạy để render các trang một cách tức thì. Điều này tăng thêm chi phí hàng tháng như bất kỳ server truyền thống nào. Tuy nhiên, các lệnh gọi server được giảm đáng kể nhờ universal rendering với browser tiếp quản việc điều hướng phía client. Việc giảm chi phí là có thể bằng cách tận dụng [edge-side-rendering](https://nuxt.com/#edge-side-rendering).

Universal rendering rất linh hoạt và có thể phù hợp với hầu hết mọi trường hợp sử dụng, và đặc biệt thích hợp cho bất kỳ trang web hướng nội dung nào: &#x2A;*blog, trang web marketing, portfolio, trang thương mại điện tử, và marketplace.**

::tip
Để biết thêm ví dụ về việc viết mã Vue mà không có hydration mismatch, xem [Vue docs](https://vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch){rel="nofollow"}.
::

::important
Khi import một thư viện dựa vào browser APIs và có tác dụng phụ, hãy đảm bảo component import nó chỉ được gọi phía client. Bundler không treeshake import của các module chứa tác dụng phụ.
::

## Client-Side Rendering

Ngay từ đầu, một ứng dụng Vue.js truyền thống được render trong browser (hoặc **client**). Sau đó, Vue.js tạo các element HTML sau khi browser tải xuống và phân tích tất cả mã JavaScript chứa hướng dẫn để tạo giao diện hiện tại.

![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](https://nuxt.com/assets/docs/concepts/rendering/csr.svg)

**Lợi ích của client-side rendering:**

- **Tốc độ phát triển**: Khi làm việc hoàn toàn ở phía client, chúng ta không phải lo lắng về tính tương thích server của mã, ví dụ, bằng cách sử dụng các API chỉ dành cho browser như object `window`.
- **Rẻ hơn:** Chạy một server tăng thêm chi phí cơ sở hạ tầng vì bạn sẽ cần chạy trên một nền tảng hỗ trợ JavaScript. Chúng ta có thể host các ứng dụng chỉ client trên bất kỳ static server nào với file HTML, CSS, và JavaScript.
- **Offline:** Vì mã chạy hoàn toàn trong browser, nó có thể tiếp tục hoạt động tốt khi internet không khả dụng.

**Nhược điểm của client-side rendering:**

- **Hiệu suất**: Người dùng phải chờ browser tải xuống, phân tích và chạy file JavaScript. Tùy thuộc vào mạng cho phần tải xuống và thiết bị của người dùng cho việc phân tích và thực thi, điều này có thể mất một thời gian và ảnh hưởng đến trải nghiệm người dùng.
- **Tối ưu hóa Công cụ Tìm kiếm**: Lập chỉ mục và cập nhật nội dung được cung cấp qua client-side rendering mất nhiều thời gian hơn so với một tài liệu HTML được server-rendered. Điều này liên quan đến nhược điểm về hiệu suất mà chúng ta đã thảo luận, vì search engine crawler sẽ không chờ giao diện được render đầy đủ trong lần thử đầu tiên để lập chỉ mục trang. Nội dung của bạn sẽ mất nhiều thời gian hơn để hiển thị và cập nhật trong trang kết quả tìm kiếm với pure client-side rendering.

Client-side rendering là lựa chọn tốt cho các **ứng dụng web** có tính tương tác cao không cần lập chỉ mục hoặc những người dùng thường xuyên truy cập. Nó có thể tận dụng browser caching để bỏ qua giai đoạn tải xuống trong các lần truy cập tiếp theo, chẳng hạn như **SaaS, ứng dụng back-office, hoặc game online**.

Bạn có thể kích hoạt chỉ client-side rendering với Nuxt trong `nuxt.config.ts` của bạn:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false
})
```

::note
Nếu bạn sử dụng `ssr: false`, bạn cũng nên đặt một file HTML trong `~/spa-loading-template.html` với một số HTML mà bạn muốn sử dụng để render màn hình loading sẽ được render cho đến khi ứng dụng của bạn được hydrated.

  :::read-more
  ---
  title: SPA Loading Template
  to: https://nuxt.com/docs/api/configuration/nuxt-config#spaloadingtemplate
  ---
  :::
::

::video-accordion
---
title: Watch a video from Alexander Lichter about Building a plain SPA with Nuxt
video-id: 7Lr0QTP1Ro8
---
::

### Deploying a Static Client-Rendered App

Nếu bạn deploy ứng dụng của mình lên [static hosting](https://nuxt.com/docs/getting-started/deployment#static-hosting) với lệnh `nuxt generate` hoặc `nuxt build --prerender`, thì theo mặc định, Nuxt sẽ render mỗi trang như một file HTML tĩnh riêng biệt.

::warning
Nếu bạn prerender ứng dụng của mình với lệnh `nuxt generate` hoặc `nuxt build --prerender`, thì bạn sẽ không thể sử dụng bất kỳ server endpoint nào vì không có server nào sẽ được bao gồm trong thư mục output của bạn. Nếu bạn cần chức năng server, hãy sử dụng `nuxt build` thay thế.
::

Nếu bạn đang sử dụng hoàn toàn client-side rendering, thì điều này có thể không cần thiết. Bạn có thể chỉ cần một file `index.html` duy nhất, cộng với `200.html` và `404.html` fallback, mà bạn có thể yêu cầu static web host của mình phục vụ cho tất cả các request.

Để đạt được điều này, chúng ta có thể thay đổi cách các route được prerendered. Chỉ cần thêm điều này vào [hooks của bạn](https://nuxt.com/docs/api/advanced/hooks#nuxt-hooks-build-time) trong `nuxt.config.ts` của bạn:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  hooks: {
    'prerender:routes' ({ routes }) {
      routes.clear() // Không tạo bất kỳ route nào (trừ những cái mặc định)
    }
  },
})
```

Điều này sẽ tạo ra ba file:

- `index.html`
- `200.html`
- `404.html`

`200.html` và `404.html` có thể hữu ích cho nhà cung cấp hosting mà bạn đang sử dụng.

#### Skipping Client Fallback Generation

Khi prerendering một ứng dụng client-rendered, Nuxt sẽ tạo file `index.html`, `200.html` và `404.html` theo mặc định. Tuy nhiên, nếu bạn cần ngăn chặn bất kỳ (hoặc tất cả) những file này khỏi được tạo trong build của bạn, bạn có thể sử dụng hook `'prerender:generate'` từ [Nitro](https://nuxt.com/docs/getting-started/prerendering#prerendergenerate-nitro-hook).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  ssr: false,
  nitro: {
    hooks: {
      'prerender:generate'(route) {
        const routesToSkip = ['/index.html', '/200.html', '/404.html']
        if (routesToSkip.includes(route.route)) {
          route.skip = true
        }
      }
    }
  }
})
```

## Hybrid Rendering

Hybrid rendering cho phép các quy tắc caching khác nhau cho mỗi route sử dụng **Route Rules** và quyết định cách server nên phản hồi với một request mới trên một URL nhất định.

Trước đây, mọi route/page của ứng dụng Nuxt và server phải sử dụng cùng một chế độ rendering, universal hoặc client-side. Trong nhiều trường hợp khác nhau, một số trang có thể được tạo tại build time, trong khi những trang khác nên được client-side rendered. Ví dụ, hãy nghĩ về một trang web nội dung với một phần admin. Mọi trang nội dung nên chủ yếu là tĩnh và được tạo một lần, nhưng phần admin yêu cầu đăng ký và hoạt động giống như một ứng dụng động hơn.

Nuxt bao gồm route rules và hỗ trợ hybrid rendering. Sử dụng route rules, bạn có thể định nghĩa các quy tắc cho một nhóm nuxt routes, thay đổi chế độ rendering hoặc gán một chiến lược cache dựa trên route!

Nuxt server sẽ tự động đăng ký middleware tương ứng và bọc routes với cache handlers sử dụng [Nitro caching layer](https://nitro.build/guide/cache){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  routeRules: {
    // Homepage pre-rendered tại build time
    '/': { prerender: true },
    // Products page được tạo theo yêu cầu, revalidates ở background, cached cho đến khi API response thay đổi
    '/products': { swr: true },
    // Product pages được tạo theo yêu cầu, revalidates ở background, cached trong 1 giờ (3600 giây)
    '/products/**': { swr: 3600 },
    // Blog posts page được tạo theo yêu cầu, revalidates ở background, cached trên CDN trong 1 giờ (3600 giây)
    '/blog': { isr: 3600 },
    // Blog post page được tạo theo yêu cầu một lần cho đến deployment tiếp theo, cached trên CDN
    '/blog/**': { isr: true },
    // Admin dashboard chỉ renders ở client-side
    '/admin/**': { ssr: false },
    // Thêm cors headers trên API routes
    '/api/**': { cors: true },
    // Redirects legacy urls
    '/old-page': { redirect: '/new-page' }
  }
})
```

### Route Rules

Các thuộc tính khác nhau mà bạn có thể sử dụng là:

- `redirect: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Định nghĩa server-side redirects.
- `ssr: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Vô hiệu hóa server-side rendering của HTML cho các phần của ứng dụng và làm chúng chỉ render trong browser với `ssr: false`
- `cors: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Tự động thêm cors headers với `cors: true` - bạn có thể tùy chỉnh output bằng cách ghi đè với `headers`
- `headers: object`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Thêm headers cụ thể vào các phần của trang web của bạn - ví dụ, assets của bạn
- `swr: number | boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Thêm cache headers vào server response và cache nó trên server hoặc reverse proxy cho một TTL có thể cấu hình (time to live). Preset `node-server` của Nitro có thể cache toàn bộ response. Khi TTL hết hạn, cached response sẽ được gửi trong khi trang sẽ được tái tạo ở background. Nếu true được sử dụng, một header `stale-while-revalidate` được thêm mà không có MaxAge.
- `isr: number | boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Hành vi giống như `swr` ngoại trừ việc chúng ta có thể thêm response vào CDN cache trên các nền tảng hỗ trợ điều này (hiện tại là Netlify hoặc Vercel). Nếu `true` được sử dụng, nội dung tồn tại cho đến deployment tiếp theo bên trong CDN.
- `prerender: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Prerenders các routes tại build time và bao gồm chúng trong build của bạn như static assets
- `noScripts: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Vô hiệu hóa rendering của Nuxt scripts và JS resource hints cho các phần của trang web của bạn.
- `appMiddleware: string | string[] | Record<string, boolean>`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} - Cho phép bạn định nghĩa middleware nên hoặc không nên chạy cho page paths trong phần Vue app của ứng dụng của bạn (nghĩa là, không phải Nitro routes của bạn)

Bất cứ khi nào có thể, route rules sẽ được tự động áp dụng cho các quy tắc gốc của deployment platform để có hiệu suất tối ưu (Netlify và Vercel hiện được hỗ trợ).

::important
Lưu ý rằng Hybrid Rendering không khả dụng khi sử dụng [`nuxt generate`](https://nuxt.com/docs/api/commands/generate).
::

**Ví dụ:**

::card-group
  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: Nuxt Vercel ISR
  to: https://github.com/danielroe/nuxt-vercel-isr
  ---
  Ví dụ về ứng dụng Nuxt với hybrid rendering được deploy trên Vercel.
  :::
::

## Edge-Side Rendering

Edge-Side Rendering (ESR) là một tính năng mạnh mẽ được giới thiệu trong Nuxt cho phép rendering ứng dụng Nuxt của bạn gần người dùng hơn thông qua edge servers của Content Delivery Network (CDN). Bằng cách tận dụng ESR, bạn có thể đảm bảo hiệu suất được cải thiện và giảm độ trễ, từ đó cung cấp trải nghiệm người dùng nâng cao.

Với ESR, quá trình rendering được đẩy đến 'edge' của mạng - các edge servers của CDN. Lưu ý rằng ESR là một deployment target hơn là một chế độ rendering thực tế.

Khi một request cho một trang được thực hiện, thay vì đi tất cả đường đến server gốc, nó bị chặn bởi edge server gần nhất. Server này tạo HTML cho trang và gửi nó trở lại cho người dùng. Quá trình này giảm thiểu khoảng cách vật lý mà dữ liệu phải di chuyển, **giảm độ trễ và tải trang nhanh hơn**.

Edge-side rendering có thể nhờ [Nitro](https://nitro.build/){rel="nofollow"}, [server engine](https://nuxt.com/docs/guide/concepts/server-engine) cung cấp sức mạnh cho Nuxt. Nó cung cấp hỗ trợ đa nền tảng cho Node.js, Deno, Cloudflare Workers, và nhiều hơn nữa.

Các nền tảng hiện tại mà bạn có thể tận dụng ESR là:

- [Cloudflare Pages](https://pages.cloudflare.com){rel="nofollow"} với zero configuration sử dụng git integration và lệnh `nuxt build`
- [Vercel Edge Functions](https://vercel.com/features/edge-functions){rel="nofollow"} sử dụng lệnh `nuxt build` và biến môi trường `NITRO_PRESET=vercel-edge`
- [Netlify Edge Functions](https://www.netlify.com/products/#netlify-edge-functions){rel="nofollow"} sử dụng lệnh `nuxt build` và biến môi trường `NITRO_PRESET=netlify-edge`

Lưu ý rằng **Hybrid Rendering** có thể được sử dụng khi sử dụng Edge-Side Rendering với route rules.

Bạn có thể khám phá các ví dụ open source được deploy trên một số nền tảng được đề cập ở trên:

::card-group
  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: Nuxt Todos Edge
  to: https://github.com/atinux/nuxt-todos-edge
  ---
  Ứng dụng todos với user authentication, SSR và SQLite.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: Atinotes
  to: https://github.com/atinux/atinotes
  ---
  Trang web có thể chỉnh sửa với universal rendering dựa trên Cloudflare KV.
  :::
::


# Server Engine

Trong khi xây dựng Nuxt, chúng tôi đã tạo ra một server engine mới: [Nitro](https://nitro.build/){rel="nofollow"}.

Nó được giao kèm với nhiều tính năng:

- Hỗ trợ đa nền tảng cho Node.js, browser, service worker và nhiều hơn nữa.
- Hỗ trợ serverless ngay từ đầu.
- Hỗ trợ API routes.
- Tự động code-splitting và các chunk được load bất đồng bộ.
- Chế độ Hybrid cho static + serverless sites.
- Development server với hot module reloading.

## API Layer

Server [API endpoints](https://nuxt.com/docs/guide/directory-structure/server#api-routes) và [Middleware](https://nuxt.com/docs/guide/directory-structure/server#server-middleware) được thêm bởi Nitro mà bên trong sử dụng [h3](https://github.com/h3js/h3){rel="nofollow"}.

Các tính năng chính bao gồm:

- Handlers có thể trực tiếp trả về objects/arrays cho một JSON response được xử lý tự động
- Handlers có thể trả về promises, sẽ được awaited (`res.end()` và `next()` cũng được hỗ trợ)
- Các helper functions cho body parsing, cookie handling, redirects, headers và nhiều hơn nữa

Xem [h3 docs](https://github.com/h3js/h3){rel="nofollow"} để biết thêm thông tin.

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/server#server-routes
---
Tìm hiểu thêm về API layer trong thư mục `server/`.
::

## Direct API Calls

Nitro cho phép gọi 'trực tiếp' các routes thông qua helper [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) có sẵn toàn cục. Điều này sẽ thực hiện một API call đến server nếu chạy trên browser, nhưng sẽ gọi trực tiếp function liên quan nếu chạy trên server, **tiết kiệm một API call bổ sung**.

[`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) API đang sử dụng [ofetch](https://github.com/unjs/ofetch){rel="nofollow"}, với các tính năng chính bao gồm:

- Tự động parsing JSON responses (với quyền truy cập vào raw response nếu cần)
- Request body và params được xử lý tự động, với headers `Content-Type` chính xác

Để biết thêm thông tin về các tính năng `$fetch`, xem [ofetch](https://github.com/unjs/ofetch){rel="nofollow"}.

## Typed API Routes

Khi sử dụng API routes (hoặc middleware), Nitro sẽ tạo typings cho những routes này miễn là bạn đang trả về một giá trị thay vì sử dụng `res.end()` để gửi một response.

Bạn có thể truy cập những types này khi sử dụng [`$fetch()`](https://nuxt.com/docs/api/utils/dollarfetch) hoặc [`useFetch()`](https://nuxt.com/docs/api/composables/use-fetch).

## Standalone Server

Nitro tạo ra một standalone server dist độc lập với `node_modules`.

Server trong Nuxt 2 không standalone và yêu cầu một phần của Nuxt core được liên quan bằng cách chạy `nuxt start` (với [`nuxt-start`](https://www.npmjs.com/package/nuxt-start){rel="nofollow"} hoặc [`nuxt`](https://www.npmjs.com/package/nuxt){rel="nofollow"} distributions) hoặc sử dụng programmatic tùy chỉnh, điều này dễ vỡ và dễ bị hỏng và không phù hợp cho môi trường serverless và service worker.

Nuxt tạo ra dist này khi chạy `nuxt build` vào một thư mục [`.output`](https://nuxt.com/docs/guide/directory-structure/output).

Output chứa runtime code để chạy Nuxt server của bạn trong bất kỳ môi trường nào (kể cả thử nghiệm chạy trong service worker của trình duyệt!) và phục vụ các tệp tĩnh, biến Nuxt trở thành một framework lai thực thụ cho JAMstack. Bên cạnh đó, Nuxt còn tích hợp một tầng lưu trữ gốc, hỗ trợ nhiều driver nguồn và cả tài nguyên cục bộ.

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nitrojs/nitro
---
Read more about Nitro engine on GitHub.
::


# Modules

## Exploring Nuxt Modules

Khi phát triển các ứng dụng cấp sản xuất với Nuxt, bạn có thể nhận thấy rằng chức năng cốt lõi của framework là chưa đủ. Nuxt có thể được mở rộng thông qua các tùy chọn cấu hình và plugin, nhưng việc duy trì những tùy chỉnh này trên nhiều dự án có thể tẻ nhạt, lặp lại và tốn thời gian. Mặt khác, hỗ trợ mọi nhu cầu của dự án ngay từ đầu sẽ khiến Nuxt trở nên rất phức tạp và khó sử dụng.

Đây là một trong những lý do tại sao Nuxt cung cấp hệ thống mô-đun cho phép mở rộng phần lõi. Các mô-đun Nuxt là các hàm async chạy tuần tự khi khởi động Nuxt ở chế độ phát triển bằng [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) hoặc xây dựng dự án cho sản xuất với [`nuxt build`](https://nuxt.com/docs/api/commands/build). Chúng có thể ghi đè lên các mẫu, cấu hình trình tải webpack, thêm các thư viện CSS và thực hiện nhiều tác vụ hữu ích khác.

Điều tuyệt vời nhất là các mô-đun Nuxt có thể được phân phối dưới dạng các gói npm. Điều này cho phép chúng được tái sử dụng trên nhiều dự án và chia sẻ với cộng đồng, góp phần tạo ra một hệ sinh thái các tiện ích bổ sung chất lượng cao.

::read-more{to="https://nuxt.com/modules"}
Khám phá các Mô-đun Nuxt
::

## Add Nuxt Modules

Sau khi cài đặt các mô-đun, bạn có thể thêm chúng vào tệp [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) của bạn dưới thuộc tính `modules`. Các nhà phát triển mô-đun thường cung cấp các bước và chi tiết bổ sung cho việc sử dụng.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  modules: [
    // Using package name (recommended usage)
    '@nuxtjs/example',

    // Load a local module
    './modules/example',

    // Add module with inline-options
    ['./modules/example', { token: '123' }],

    // Inline module definition
    async (inlineOptions, nuxt) => { }
  ]
})
```

::warning
Các mô-đun Nuxt hiện chỉ chạy trong thời gian xây dựng (build-time-only), và thuộc tính `buildModules` được sử dụng trong Nuxt 2 đã bị loại bỏ thay thế bằng `modules`.
::

## Create a Nuxt Module

Mọi người đều có cơ hội phát triển các mô-đun và chúng tôi không thể chờ đợi để xem bạn sẽ xây dựng điều gì.

::read-more
---
title: Hướng dẫn Tác giả Mô-đun
to: https://nuxt.com/docs/guide/going-further/modules
---
::


# ES Modules

Hướng dẫn này giúp giải thích về ES Modules và cách làm cho ứng dụng Nuxt (hoặc thư viện upstream) tương thích với ESM.

## Background

### CommonJS Modules

CommonJS (CJS) là định dạng được giới thiệu bởi Node.js, cho phép chia sẻ chức năng giữa các mô-đun JavaScript độc lập ([read more](https://nodejs.org/api/modules.html){rel="nofollow"}).
Bạn có thể đã quen thuộc với cú pháp này:

```js
const a = require('./a')

module.exports.a = a
```

Các trình đóng gói (bundlers) như webpack và Rollup hỗ trợ cú pháp này và cho phép bạn sử dụng các mô-đun được viết bằng CommonJS trong trình duyệt.

### ESM Syntax

Hầu hết thời gian, khi mọi người nói về ESM so với CJS, họ đang đề cập đến một cú pháp khác để viết [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules){rel="nofollow"}.

```js
import a from './a'

export { a }
```

Trước khi ECMAScript Modules (ESM) trở thành tiêu chuẩn (mất hơn 10 năm!), các công cụ như [webpack](https://webpack.js.org/guides/ecma-script-modules){rel="nofollow"} và thậm chí các ngôn ngữ như TypeScript đã bắt đầu hỗ trợ **ESM syntax**.
Tuy nhiên, có một số khác biệt quan trọng với đặc tả thực tế; đây là [một giải thích hữu ích](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive){rel="nofollow"}.

### What is 'Native' ESM?

Bạn có thể đã viết ứng dụng của mình bằng ESM syntax từ lâu. Sau tất cả, nó được hỗ trợ gốc bởi trình duyệt, và trong Nuxt 2 chúng tôi đã biên dịch tất cả mã bạn viết sang định dạng phù hợp (CJS cho server, ESM cho browser).

Khi thêm các module vào package, mọi thứ hơi khác một chút. Một thư viện mẫu có thể xuất cả phiên bản CJS và ESM, và cho phép chúng ta chọn phiên bản muốn sử dụng:

```json
{
  "name": "sample-library",
  "main": "dist/sample-library.cjs.js",
  "module": "dist/sample-library.esm.js"
}
```

Vì vậy trong Nuxt 2, trình đóng gói (webpack) sẽ lấy tệp CJS ('main') cho bản build server và sử dụng tệp ESM ('module') cho bản build client.

Tuy nhiên, trong các phiên bản LTS gần đây của Node.js, giờ đây có thể [sử dụng native ESM module](https://nodejs.org/api/esm.html){rel="nofollow"} bên trong Node.js. Điều này có nghĩa là Node.js tự xử lý JavaScript bằng ESM syntax, mặc dù nó không làm điều này theo mặc định. Hai cách phổ biến nhất để kích hoạt ESM syntax là:

- đặt `"type": "module"` trong `package.json` và tiếp tục sử dụng phần mở rộng `.js`
- sử dụng phần mở rộng tệp `.mjs` (được khuyến nghị)

Đây là những gì chúng tôi làm cho Nuxt Nitro; chúng tôi xuất tệp `.output/server/index.mjs`. Điều này báo cho Node.js biết xử lý tệp này như một native ES module.

### What Are Valid Imports in a Node.js Context?

Khi bạn `import` một module thay vì `require` nó, Node.js phân giải nó khác đi. Ví dụ, khi bạn import `sample-library`, Node.js sẽ tìm không phải `main` mà là mục `exports` hoặc `module` trong `package.json` của thư viện đó.

Điều này cũng đúng với dynamic imports, như `const b = await import('sample-library')`.

Node hỗ trợ các loại import sau (xem [docs](https://nodejs.org/api/packages.html#determining-module-system){rel="nofollow"}):

1. tệp kết thúc bằng `.mjs` - những tệp này được kỳ vọng sử dụng ESM syntax
2. tệp kết thúc bằng `.cjs` - những tệp này được kỳ vọng sử dụng CJS syntax
3. tệp kết thúc bằng `.js` - những tệp này được kỳ vọng sử dụng CJS syntax trừ khi `package.json` có `"type": "module"`

### What Kinds of Problems Can There Be?

Trong một thời gian dài, các tác giả module đã sản xuất các bản build ESM syntax nhưng sử dụng quy ước như `.esm.js` hoặc `.es.js`, mà họ đã thêm vào trường `module` trong `package.json`. Điều này không thành vấn đề cho đến nay vì chúng chỉ được sử dụng bởi các trình đóng gói như webpack, không đặc biệt quan tâm đến phần mở rộng tệp.

Tuy nhiên, nếu bạn cố import một package có tệp `.esm.js` trong ngữ cảnh Node.js ESM, nó sẽ không hoạt động, và bạn sẽ nhận được lỗi như:

```bash [Terminal]
(node:22145) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
/path/to/index.js:1

export default {}
^^^^^^

SyntaxError: Unexpected token 'export'
    at wrapSafe (internal/modules/cjs/loader.js:1001:16)
    at Module._compile (internal/modules/cjs/loader.js:1049:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    ....
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

Bạn cũng có thể nhận được lỗi này nếu bạn có named import từ bản build ESM syntax mà Node.js nghĩ là CJS:

```bash [Terminal]
file:///path/to/index.mjs:5
import { named } from 'sample-library'
         ^^^^^
SyntaxError: Named export 'named' not found. The requested module 'sample-library' is a CommonJS module, which may not support all module.exports as named exports.

CommonJS modules can always be imported via the default export, for example using:

import pkg from 'sample-library';
const { named } = pkg;

    at ModuleJob._instantiate (internal/modules/esm/module_job.js:120:21)
    at async ModuleJob.run (internal/modules/esm/module_job.js:165:5)
    at async Loader.import (internal/modules/esm/loader.js:177:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

## Troubleshooting ESM Issues

Nếu bạn gặp các lỗi này, vấn đề gần như chắc chắn nằm ở thư viện upstream. Họ cần [sửa thư viện của họ](https://nuxt.com/#library-author-guide) để hỗ trợ được import bởi Node.

### Transpiling Libraries

Trong lúc chờ đợi, bạn có thể bảo Nuxt không cố import các thư viện này bằng cách thêm chúng vào `build.transpile`:

```ts twoslash
export default defineNuxtConfig({
  build: {
    transpile: ['sample-library']
  }
})
```

Bạn có thể thấy rằng bạn *cũng* cần thêm các package khác đang được import bởi các thư viện này.

### Aliasing Libraries

Trong một số trường hợp, bạn cũng có thể cần alias thủ công thư viện sang phiên bản CJS, ví dụ:

```ts twoslash
export default defineNuxtConfig({
  alias: {
    'sample-library': 'sample-library/dist/sample-library.cjs.js'
  }
})
```

### Default Exports

Một dependency với định dạng CommonJS, có thể sử dụng `module.exports` hoặc `exports` để cung cấp default export:

```js [node_modules/cjs-pkg/index.js]
module.exports = { test: 123 }
// or
exports.test = 123
```

Điều này thường hoạt động tốt nếu chúng ta `require` dependency đó:

```js [test.cjs]
const pkg = require('cjs-pkg')

console.log(pkg) // { test: 123 }
```

[Node.js trong chế độ native ESM](https://nodejs.org/api/esm.html#interoperability-with-commonjs){rel="nofollow"}, [typescript với `esModuleInterop` được bật](https://www.typescriptlang.org/tsconfig#esModuleInterop){rel="nofollow"} và các trình đóng gói như webpack, cung cấp cơ chế tương thích để chúng ta có thể default import thư viện đó.
Cơ chế này thường được gọi là "interop require default":

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { test: 123 }
```

Tuy nhiên, do sự phức tạp của việc phát hiện cú pháp và các định dạng bundle khác nhau, luôn có khả năng cơ chế interop default thất bại và chúng ta kết thúc với điều này:

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { default: { test: 123 } }
```

Cũng khi sử dụng dynamic import syntax (trong cả tệp CJS và ESM), chúng ta luôn gặp tình huống này:

```js
import('cjs-pkg').then(console.log) // [Module: null prototype] { default: { test: '123' } }
```

Trong trường hợp này, chúng ta cần interop default export thủ công:

```js
// Static import
import { default as pkg } from 'cjs-pkg'

// Dynamic import
import('cjs-pkg').then(m => m.default || m).then(console.log)
```

Để xử lý các tình huống phức tạp hơn và an toàn hơn, chúng tôi khuyến nghị và sử dụng nội bộ [mlly](https://github.com/unjs/mlly){rel="nofollow"} trong Nuxt có thể bảo tồn named exports.

```js
import { interopDefault } from 'mlly'

// Assuming the shape is { default: { foo: 'bar' }, baz: 'qux' }
import myModule from 'my-module'

console.log(interopDefault(myModule)) // { foo: 'bar', baz: 'qux' }
```

## Library Author Guide

Tin tốt là việc sửa các vấn đề tương thích ESM tương đối đơn giản. Có hai lựa chọn chính:

1. **Bạn có thể đổi tên các tệp ESM của bạn để kết thúc bằng `.mjs`.**:br&#x2A;Đây là cách tiếp cận được khuyến nghị và đơn giản nhất.* Bạn có thể phải giải quyết các vấn đề với các dependency của thư viện và có thể với hệ thống build của bạn, nhưng trong hầu hết các trường hợp, điều này sẽ giải quyết vấn đề cho bạn. Cũng được khuyến nghị đổi tên các tệp CJS để kết thúc bằng `.cjs`, để rõ ràng nhất.
2. **Bạn có thể chọn làm cho toàn bộ thư viện của bạn chỉ hỗ trợ ESM**. :br Điều này có nghĩa là đặt `"type": "module"` trong `package.json` và đảm bảo rằng thư viện được build của bạn sử dụng ESM syntax. Tuy nhiên, bạn có thể gặp vấn đề với các dependency của mình - và cách tiếp cận này có nghĩa thư viện của bạn *chỉ* có thể được tiêu thụ trong ngữ cảnh ESM.

### Migration

Bước đầu tiên từ CJS sang ESM là cập nhật bất kỳ việc sử dụng `require` nào để sử dụng `import` thay thế:

::code-group
```js [Before]
module.exports = ...

exports.hello = ...
```

```js [After]
export default ...

export const hello = ...
```
::

::code-group
```js [Before]
const myLib = require('my-lib')
```

```js [After]
import myLib from 'my-lib'
// or
const myLib = await import('my-lib').then(lib => lib.default || lib)
```
::

Trong ESM Modules, không giống CJS, các global `require`, `require.resolve`, `__filename` và `__dirname` không có sẵn
và nên được thay thế bằng `import()` và `import.meta.filename`.

::code-group
```js [Before]
import { join } from 'path'

const newDir = join(__dirname, 'new-dir')
```

```js [After]
import { fileURLToPath } from 'node:url'

const newDir = fileURLToPath(new URL('./new-dir', import.meta.url))
```
::

::code-group
```js [Before]
const someFile = require.resolve('./lib/foo.js')
```

```js [After]
import { resolvePath } from 'mlly'

const someFile = await resolvePath('my-lib', { url: import.meta.url })
```
::

### Best Practices

- Ưu tiên named exports thay vì default export. Điều này giúp giảm xung đột CJS. (xem phần [Default exports](https://nuxt.com/#default-exports))
- Tránh phụ thuộc vào các built-in của Node.js và các dependency chỉ dành cho CommonJS hoặc Node.js nhiều nhất có thể để làm cho thư viện của bạn có thể sử dụng được trong Trình duyệt và Edge Workers mà không cần các polyfill của Nitro.
- Sử dụng trường `exports` mới với conditional exports. ([đọc thêm](https://nodejs.org/api/packages.html#conditional-exports){rel="nofollow"}).

```json
{
  "exports": {
    ".": {
      "import": "./dist/mymodule.mjs"
    }
  }
}
```


# TypeScript

## Type-checking

Theo mặc định, Nuxt không kiểm tra types khi bạn chạy [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) hoặc [`nuxt build`](https://nuxt.com/docs/api/commands/build), vì lý do hiệu suất.

Để bật type-checking tại thời điểm build hoặc development, hãy cài đặt `vue-tsc` và `typescript` như development dependency:

::code-group{sync="pm"}
```bash [npm]
npm install --save-dev vue-tsc typescript
```

```bash [yarn]
yarn add --dev vue-tsc typescript
```

```bash [pnpm]
pnpm add -D vue-tsc typescript
```

```bash [bun]
bun add -D vue-tsc typescript
```
::

Sau đó, chạy lệnh [`nuxt typecheck`](https://nuxt.com/docs/api/commands/typecheck) để kiểm tra types của bạn:

```bash [Terminal]
npx nuxt typecheck
```

Để bật type-checking tại thời điểm build hoặc development, bạn cũng có thể sử dụng tùy chọn [`typescript.typeCheck`](https://nuxt.com/docs/api/nuxt-config#typecheck) trong file `nuxt.config` của bạn:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  typescript: {
    typeCheck: true
  }
})
```

## Auto-generated Types

Khi bạn chạy `nuxt dev` hoặc `nuxt build`, Nuxt sẽ tạo ra các file sau để hỗ trợ type cho IDE (và type checking):

### `.nuxt/nuxt.d.ts`

File này chứa các types của bất kỳ module nào bạn đang sử dụng, cũng như các key types mà Nuxt yêu cầu. IDE của bạn sẽ tự động nhận dạng các types này.

Một số tham chiếu trong file chỉ đến các file chỉ được tạo trong `buildDir` (`.nuxt`) của bạn và do đó để có typings đầy đủ, bạn sẽ cần chạy `nuxt dev` hoặc `nuxt build`.

### `.nuxt/tsconfig.app.json`

File này chứa cấu hình TypeScript cơ bản được khuyến nghị cho project của bạn, bao gồm các alias đã được resolve được inject bởi Nuxt hoặc các module bạn đang sử dụng, vì vậy bạn có thể nhận được hỗ trợ type đầy đủ và path auto-complete cho các alias như `~/file` hoặc `#build/file`.

::note
Hãy cân nhắc sử dụng section `imports` của [nuxt.config](https://nuxt.com/docs/api/nuxt-config#imports) để bao gồm các thư mục ngoài những thư mục mặc định. Điều này có thể hữu ích để tự động import các types mà bạn đang sử dụng trong toàn bộ ứng dụng.
::

[Đọc thêm về cách mở rộng cấu hình này](https://nuxt.com/docs/guide/directory-structure/tsconfig).

::tip{icon="i-lucide-video" target="_blank" to="https://youtu.be/umLI7SlPygY"}
Xem video từ Daniel Roe giải thích về các alias có sẵn trong Nuxt.
::

::note
Nitro cũng [tự động tạo types](https://nuxt.com/docs/guide/concepts/server-engine#typed-api-routes) cho các API routes. Thêm vào đó, Nuxt cũng tạo types cho các component có sẵn globally và [auto-imports từ các composables](https://nuxt.com/docs/guide/directory-structure/composables) của bạn, cộng với các chức năng core khác.
::

::note
Để tương thích ngược, Nuxt vẫn tạo `./.nuxt/tsconfig.json`. Tuy nhiên, chúng tôi khuyến nghị sử dụng [TypeScript project references](https://nuxt.com/docs/guide/directory-structure/tsconfig) với các file cấu hình mới (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, v.v.) để có type safety và hiệu suất tốt hơn.

Nếu bạn extend từ `./.nuxt/tsconfig.json`, hãy nhớ rằng tất cả các options sẽ được ghi đè bởi những options được định nghĩa trong `tsconfig.json` của bạn. Việc ghi đè các options như `"compilerOptions.paths"` bằng cấu hình riêng của bạn sẽ khiến TypeScript không tính đến các module resolutions, có thể làm cho các module resolutions như `#imports` không được nhận dạng.

Trong trường hợp bạn cần mở rộng options hơn nữa, bạn có thể sử dụng [`alias` property](https://nuxt.com/docs/api/nuxt-config#alias) trong `nuxt.config` của bạn. Nuxt sẽ nhận chúng và mở rộng các cấu hình TypeScript được tạo tương ứng.
::

## Project References

Nuxt sử dụng [TypeScript project references](https://www.typescriptlang.org/docs/handbook/project-references.html){rel="nofollow"} để cải thiện hiệu suất type-checking và cung cấp hỗ trợ IDE tốt hơn. Tính năng này cho phép TypeScript chia codebase của bạn thành các phần nhỏ hơn, dễ quản lý hơn.

### Cách Nuxt Sử Dụng Project References

Khi bạn chạy `nuxt dev` hoặc `nuxt build`, Nuxt sẽ tạo ra nhiều file `tsconfig.json` cho các phần khác nhau của ứng dụng.

- **`.nuxt/tsconfig.app.json`** - Cấu hình cho application code của bạn
- **`.nuxt/tsconfig.node.json`** - Cấu hình cho `nuxt.config` và modules của bạn
- **`.nuxt/tsconfig.server.json`** - Cấu hình cho server-side code (khi áp dụng)
- **`.nuxt/tsconfig.shared.json`** - Cho code được chia sẻ giữa app và server contexts (như types và các utilities không phụ thuộc environment cụ thể)
- **`.nuxt/tsconfig.json`** - Cấu hình legacy để tương thích ngược

Mỗi file này được cấu hình để tham chiếu đến các dependencies thích hợp và cung cấp type-checking tối ưu cho context cụ thể của chúng.

### Lợi Ích Của Project References

- **Build nhanh hơn**: TypeScript có thể bỏ qua việc rebuild các projects không thay đổi
- **Hiệu suất IDE tốt hơn**: IDE của bạn có thể cung cấp IntelliSense và error checking nhanh hơn
- **Compilation tách biệt**: Lỗi ở một phần của ứng dụng không ngăn compilation của các phần khác
- **Quản lý dependency rõ ràng hơn**: Mỗi project khai báo rõ ràng các dependencies của nó

::note
Thiết lập project reference được Nuxt xử lý tự động. Thông thường bạn không cần chỉnh sửa các cấu hình này thủ công, nhưng hiểu cách chúng hoạt động có thể giúp bạn troubleshoot các vấn đề type-checking.
::

### Augmenting Types với Project References

Vì project được chia thành **nhiều type contexts**, điều quan trọng là **augment types trong đúng context** để đảm bảo chúng được nhận dạng đúng cách.

Ví dụ, nếu bạn muốn augment types cho `app` context, file augmentation nên được đặt trong thư mục `app/`.

Tương tự:

- Đối với `server` context, đặt file augmentation trong thư mục `server/`.
- Đối với types được **chia sẻ giữa app và server**, đặt file trong thư mục `shared/`.

::warning
Augmenting types bên ngoài các thư mục này sẽ không được TypeScript nhận dạng.
::

## Strict Checks

TypeScript đi kèm với một số checks nhất định để mang lại sự an toàn và phân tích tốt hơn cho chương trình của bạn.

[Strict checks](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks){rel="nofollow"} được bật mặc định trong Nuxt để cung cấp type safety tốt hơn cho bạn.

Nếu bạn hiện đang chuyển đổi codebase sang TypeScript, bạn có thể tạm thời tắt strict checks bằng cách đặt `strict` thành `false` trong `nuxt.config` của bạn:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  typescript: {
    strict: false
  }
})
```


# Code Style

## ESLint

Cách tiếp cận được khuyến nghị cho Nuxt là bật hỗ trợ ESLint bằng cách sử dụng module [`@nuxt/eslint`](https://eslint.nuxt.com/packages/module){rel="nofollow"}, sẽ thiết lập cấu hình ESLint nhận biết project cho bạn.

::callout{icon="i-lucide-lightbulb"}
Module này được thiết kế cho [định dạng flat config mới của ESLint](https://eslint.org/docs/latest/use/configure/configuration-files-new){rel="nofollow"} đây là [định dạng mặc định kể từ ESLint v9](https://eslint.org/blog/2024/04/eslint-v9.0.0-released/){rel="nofollow"}. Nếu bạn đang sử dụng legacy `.eslintrc` config, bạn sẽ cần [cấu hình thủ công với `@nuxt/eslint-config`](https://eslint.nuxt.com/packages/config#legacy-config-format){rel="nofollow"}. Chúng tôi thực sự khuyến nghị bạn di chuyển sang flat config để có tương lai bền vững.
::

## Quick Setup

```bash
npx nuxt module add eslint
```

Khởi động ứng dụng Nuxt của bạn, một file `eslint.config.mjs` sẽ được tạo ra dưới thư mục gốc của project. Bạn có thể tùy chỉnh nó theo nhu cầu.

Bạn có thể tìm hiểu thêm về module và các tùy chỉnh trong [tài liệu của Nuxt ESLint](https://eslint.nuxt.com/packages/module){rel="nofollow"}.


# .nuxt

::important
Thư mục này nên được thêm vào file [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) để tránh push kết quả build dev lên repository của bạn.
::

Thư mục này rất thú vị nếu bạn muốn tìm hiểu thêm về các file mà Nuxt tạo ra dựa trên cấu trúc thư mục của bạn.

Nuxt cũng cung cấp một Hệ thống File Ảo (VFS) cho các module để thêm template vào thư mục này mà không cần ghi chúng vào đĩa.

Bạn có thể khám phá các file được tạo ra bằng cách mở [Nuxt DevTools](https://devtools.nuxt.com){rel="nofollow"} trong chế độ development và điều hướng đến tab **Virtual Files**.

::warning
Bạn không nên chạm vào bất kỳ file nào bên trong vì toàn bộ thư mục sẽ được tạo lại khi chạy [`nuxt dev`](https://nuxt.com/docs/api/commands/dev).
::


# .output

::important
Thư mục này nên được thêm vào file [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) để tránh push kết quả build lên repository của bạn.
::

Sử dụng thư mục này để deploy ứng dụng Nuxt của bạn lên production.

::read-more{to="https://nuxt.com/docs/getting-started/deployment"}
::

::warning
Bạn không nên chạm vào bất kỳ file nào bên trong vì toàn bộ thư mục sẽ được tạo lại khi chạy [`nuxt build`](https://nuxt.com/docs/api/commands/build).
::


# assets

The directory usually contains the following types of files:

- Stylesheets (CSS, SASS, etc.)
- Fonts
- Images that won't be served from the [`public/`](https://nuxt.com/docs/guide/directory-structure/public) directory.

If you want to serve assets from the server, we recommend taking a look at the [`public/`](https://nuxt.com/docs/guide/directory-structure/public) directory.

::read-more{to="https://nuxt.com/docs/getting-started/assets"}
::


# components

Nuxt tự động nhập bất kỳ component nào trong thư mục này (cùng với các component được đăng ký bởi bất kỳ module nào bạn có thể đang sử dụng).

```bash [Directory Structure]
-| components/
---| AppHeader.vue
---| AppFooter.vue
```

```html [app.vue]
<template>
  <div>
    <AppHeader />
    <NuxtPage />
    <AppFooter />
  </div>
</template>
```

## Component Names

Nếu bạn có một component trong các thư mục lồng nhau như:

```bash [Directory Structure]
-| components/
---| base/
-----| foo/
-------| Button.vue
```

... thì tên của component sẽ dựa trên đường dẫn thư mục và tên tệp của chính nó, với các đoạn trùng lặp được loại bỏ. Do đó, tên của component sẽ là:

```html
<BaseFooButton />
```

::note
Để rõ ràng, chúng tôi khuyên rằng tên tệp của component nên khớp với tên của nó. Vì vậy, trong ví dụ trên, bạn có thể đổi tên `Button.vue` thành `BaseFooButton.vue`.
::

Nếu bạn muốn tự động nhập các component chỉ dựa trên tên của nó, không phải đường dẫn, thì bạn cần đặt tùy chọn `pathPrefix` thành `false` bằng cách sử dụng dạng mở rộng của đối tượng cấu hình:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      pathPrefix: false, // [!code ++]
    },
  ],
});
```

Điều này đăng ký các component bằng cách sử dụng cùng chiến lược như được sử dụng trong Nuxt 2. Ví dụ, `~/components/Some/MyComponent.vue` sẽ có thể sử dụng được dưới dạng `<MyComponent>` chứ không phải `<SomeMyComponent>`.

## Dynamic Components

Nếu bạn muốn sử dụng cú pháp Vue `<component :is="someComputedComponent">`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="vue"}, bạn cần sử dụng helper `resolveComponent` được cung cấp bởi Vue hoặc nhập component trực tiếp từ `#components` và truyền nó vào prop `is`.

Ví dụ:

```vue [pages/index.vue]
<script setup lang="ts">
import { SomeComponent } from '#components'

const MyButton = resolveComponent('MyButton')
</script>

<template>
  <component :is="clickable ? MyButton : 'div'" />
  <component :is="SomeComponent" />
</template>
```

::important
Nếu bạn đang sử dụng `resolveComponent` để xử lý các component động, hãy đảm bảo không chèn bất cứ thứ gì ngoài tên của component, tên này phải là một chuỗi ký tự theo nghĩa đen và không phải là hoặc chứa một biến. Chuỗi được phân tích tĩnh tại bước biên dịch.
::

::video-accordion
---
title: Xem video ngắn của Daniel Roe về resolveComponent()
video-id: 4kq8E5IUM2U
---
::

Ngoài ra, mặc dù không được khuyến nghị, bạn có thể đăng ký tất cả các component của mình toàn cục, điều này sẽ tạo ra các chunk async cho tất cả các component của bạn và làm cho chúng có sẵn trong toàn bộ ứng dụng của bạn.

```diff
  export default defineNuxtConfig({
    components: {
+     global: true,
+     dirs: ['~/components']
    },
  })
```

Bạn cũng có thể đăng ký có chọn lọc một số component toàn cục bằng cách đặt chúng trong thư mục `~/components/global`, hoặc bằng cách sử dụng hậu tố `.global.vue` trong tên tệp. Như đã lưu ý ở trên, mỗi component toàn cục được render trong một chunk riêng biệt, vì vậy hãy cẩn thận không lạm dụng tính năng này.

::note
Tùy chọn `global` cũng có thể được đặt cho mỗi thư mục component.
::

## Dynamic Imports

Để nhập động một component (cũng được gọi là lazy-loading một component), tất cả những gì bạn cần làm là thêm tiền tố `Lazy` vào tên của component. Điều này đặc biệt hữu ích nếu component không luôn được cần đến.

Bằng cách sử dụng tiền tố `Lazy`, bạn có thể trì hoãn việc tải mã component cho đến thời điểm phù hợp, điều này có thể hữu ích để tối ưu hóa kích thước bundle JavaScript của bạn.

```vue [pages/index.vue]
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
  </div>
</template>
```

## Delayed (or Lazy) Hydration

Các component lazy rất tuyệt vời để kiểm soát kích thước chunk trong ứng dụng của bạn, nhưng chúng không luôn cải thiện hiệu suất runtime, vì chúng vẫn tải eagerly trừ khi được render có điều kiện. Trong các ứng dụng thực tế, một số trang có thể bao gồm nhiều nội dung và nhiều component, và hầu hết thời gian không phải tất cả chúng đều cần tương tác ngay khi trang được tải. Việc tải tất cả chúng eagerly có thể ảnh hưởng tiêu cực đến hiệu suất.

Để tối ưu hóa ứng dụng của bạn, bạn có thể muốn trì hoãn hydration của một số component cho đến khi chúng hiển thị, hoặc cho đến khi trình duyệt hoàn thành các tác vụ quan trọng hơn.

Nuxt hỗ trợ điều này bằng cách sử dụng lazy (hoặc delayed) hydration, cho phép bạn kiểm soát khi nào các component trở nên tương tác.

### Hydration Strategies

Nuxt cung cấp một loạt các chiến lược hydration tích hợp. Chỉ một chiến lược có thể được sử dụng cho mỗi component lazy.

::warning
Hiện tại, lazy hydration tích hợp của Nuxt chỉ hoạt động trong các component tệp đơn (SFCs), và yêu cầu bạn định nghĩa prop trong template (thay vì spread một đối tượng props qua `v-bind`). Nó cũng không hoạt động với các import trực tiếp từ `#components`.
::

#### `hydrate-on-visible`

Hydrate component khi nó trở nên hiển thị trong viewport.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

::read-more
---
title: IntersectionObserver options
to: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver
---
::

Đọc thêm về các tùy chọn cho `hydrate-on-visible`.
\::

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnVisible` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-visible){rel="nofollow"}.
::

#### `hydrate-on-idle`

Hydrate component khi trình duyệt ở trạng thái idle. Điều này phù hợp nếu bạn cần component tải càng sớm càng tốt, nhưng không chặn đường dẫn render quan trọng.

Bạn cũng có thể truyền một số đóng vai trò là timeout tối đa.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-idle />
  </div>
</template>
```

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnIdle` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-idle){rel="nofollow"}.
::

#### `hydrate-on-interaction`

Hydrate component sau một tương tác được chỉ định (ví dụ: click, mouseover).

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

Nếu bạn không truyền một sự kiện hoặc danh sách sự kiện, nó mặc định hydrate trên `pointerenter`, `click` và `focus`.

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnInteraction` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-interaction){rel="nofollow"}.
::

#### `hydrate-on-media-query`

Hydrate component khi cửa sổ khớp với một media query.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-media-query="(max-width: 768px)" />
  </div>
</template>
```

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnMediaQuery` tích hợp của Vue](https://vuejs.org/guide/components/async.html#hydrate-on-media-query){rel="nofollow"}.
::

#### `hydrate-after`

Hydrate component sau một độ trễ được chỉ định (tính bằng mili giây).

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-after="2000" />
  </div>
</template>
```

#### `hydrate-when`

Hydrate component dựa trên một điều kiện boolean.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-when="isReady" />
  </div>
</template>
<script setup lang="ts">
const isReady = ref(false)
function myFunction() {
  // trigger custom hydration strategy...
  isReady.value = true
}
</script>
```

#### `hydrate-never`

Không bao giờ hydrate component.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-never />
  </div>
</template>
```

### Listening to Hydration Events

Tất cả các component hydration bị trì hoãn phát ra sự kiện `@hydrated` khi chúng được hydrate.

```vue [pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible @hydrated="onHydrate" />
  </div>
</template>

<script setup lang="ts">
function onHydrate() {
  console.log("Component has been hydrated!")
}
</script>
```

### Caveats and Best Practices

Hydration bị trì hoãn có thể mang lại lợi ích về hiệu suất, nhưng việc sử dụng đúng cách là rất quan trọng:

1. **Ưu tiên Nội dung Trong Viewport:** Tránh hydration bị trì hoãn cho nội dung quan trọng, above-the-fold. Nó phù hợp nhất cho nội dung không cần ngay lập tức.
2. **Render Có Điều kiện:** Khi sử dụng `v-if="false"` trên một component lazy, bạn có thể không cần hydration bị trì hoãn. Bạn chỉ cần sử dụng một component lazy bình thường.
3. **Trạng thái Chia sẻ:** Hãy chú ý đến trạng thái chia sẻ (`v-model`) trên nhiều component. Việc cập nhật model trong một component có thể kích hoạt hydration trong tất cả các component được bind với model đó.
4. **Sử dụng Trường hợp Dự định của Mỗi Chiến lược:** Mỗi chiến lược được tối ưu hóa cho một mục đích cụ thể.
   - `hydrate-when` tốt nhất cho các component có thể không luôn cần được hydrate.
   - `hydrate-after` dành cho các component có thể chờ một khoảng thời gian cụ thể.
   - `hydrate-on-idle` dành cho các component có thể được hydrate khi trình duyệt ở trạng thái idle.
5. **Tránh `hydrate-never` trên các component tương tác:** Nếu một component yêu cầu tương tác của người dùng, nó không nên được đặt thành never hydrate.

## Direct Imports

Bạn cũng có thể nhập rõ ràng các component từ `#components` nếu bạn muốn hoặc cần bỏ qua chức năng tự động nhập của Nuxt.

```vue [pages/index.vue]
<script setup lang="ts">
import { NuxtLink, LazyMountainsList } from '#components'

const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
    <NuxtLink to="/">Home</NuxtLink>
  </div>
</template>
```

## Custom Directories

Theo mặc định, chỉ thư mục `~/components` được quét. Nếu bạn muốn thêm các thư mục khác, hoặc thay đổi cách các component được quét trong một thư mục con của thư mục này, bạn có thể thêm các thư mục bổ sung vào cấu hình:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: [
    // ~/calendar-module/components/event/Update.vue => <EventUpdate />
    { path: '~/calendar-module/components' },

    // ~/user-module/components/account/UserDeleteDialog.vue => <UserDeleteDialog />
    { path: '~/user-module/components', pathPrefix: false },

    // ~/components/special-components/Btn.vue => <SpecialBtn />
    { path: '~/components/special-components', prefix: 'Special' },

    // It's important that this comes last if you have overrides you wish to apply
    // to sub-directories of `~/components`.
    //
    // ~/components/Btn.vue => <Btn />
    // ~/components/base/Btn.vue => <BaseBtn />
    '~/components'
  ]
})
```

::note
Bất kỳ thư mục lồng nhau nào cần được thêm trước vì chúng được quét theo thứ tự.
::

## npm Packages

Nếu bạn muốn tự động nhập các component từ một gói npm, bạn có thể sử dụng [`addComponent`](https://nuxt.com/docs/api/kit/components#addcomponent) trong một [module cục bộ](https://nuxt.com/docs/guide/directory-structure/modules) để đăng ký chúng.

::code-group
```ts [~/modules/register-component.ts] twoslash
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```

```vue [app.vue]
<template>
  <div>
    <!--  the component uses the name we specified and is auto-imported  -->
    <MyAutoImportedComponent />
  </div>
</template>
```
::

## Component Extensions

Theo mặc định, bất kỳ tệp nào có phần mở rộng được chỉ định trong [khóa extensions của `nuxt.config.ts`](https://nuxt.com/docs/api/nuxt-config#extensions) được coi là một component.
Nếu bạn cần hạn chế các phần mở rộng tệp nên được đăng ký làm component, bạn có thể sử dụng dạng mở rộng của khai báo thư mục component và khóa `extensions` của nó:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      extensions: ['.vue'], // [!code ++]
    }
  ]
})
```

## Client Components

Nếu một component được thiết kế để chỉ render ở phía client, bạn có thể thêm hậu tố `.client` vào component của mình.

```bash [Directory Structure]
| components/
--| Comments.client.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!-- this component will only be rendered on client side -->
    <Comments />
  </div>
</template>
```

::note
Tính năng này chỉ hoạt động với auto-imports của Nuxt và imports `#components`. Việc nhập rõ ràng các component này từ đường dẫn thực của chúng không chuyển đổi chúng thành các component chỉ client.
::

::important
Các component `.client` chỉ được render sau khi được mount. Để truy cập template đã render bằng `onMounted()`, hãy thêm `await nextTick()` trong callback của hook `onMounted()`.
::

::read-more{to="https://nuxt.com/docs/api/components/client-only"}
::

Bạn cũng có thể đạt được kết quả tương tự với component `<ClientOnly>`.
\::

## Server Components

Các component server cho phép server-rendering các component riêng lẻ trong ứng dụng client-side của bạn. Có thể sử dụng các component server trong Nuxt, ngay cả khi bạn đang tạo một trang web tĩnh. Điều đó làm cho việc xây dựng các trang web phức tạp kết hợp các component động, HTML được render server và thậm chí các chunk markup tĩnh trở nên khả thi.

::video-accordion
---
title: Xem video Learn Vue về Nuxt Server Components
video-id: u1yyXe86xJM
---
::

::tip
---
icon: i-lucide-newspaper
target: _blank
to: https://roe.dev/blog/nuxt-server-components
---
Đọc hướng dẫn của Daniel Roe về Nuxt Server Components.
::

### Standalone server components

Các component server độc lập sẽ luôn được render trên server, cũng được gọi là các component Islands.

Khi props của chúng cập nhật, điều này sẽ dẫn đến một yêu cầu mạng sẽ cập nhật HTML đã render ngay tại chỗ.

Các component server hiện tại đang thử nghiệm và để sử dụng chúng, bạn cần bật tính năng 'component islands' trong nuxt.config của mình:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    componentIslands: true
  }
})
```

Bây giờ bạn có thể đăng ký các component chỉ server với hậu tố `.server` và sử dụng chúng ở bất kỳ đâu trong ứng dụng của mình một cách tự động.

```bash [Directory Structure]
-| components/
---| HighlightedMarkdown.server.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!--
      this will automatically be rendered on the server, meaning your markdown parsing + highlighting
      libraries are not included in your client bundle.
     -->
    <HighlightedMarkdown markdown="# Headline" />
  </div>
</template>
```

Các component chỉ server sử dụng [`<NuxtIsland>`](https://nuxt.com/docs/api/components/nuxt-island) bên dưới, nghĩa là prop `lazy` và slot `#fallback` đều được truyền xuống nó.

::warning
Các component server (và islands) phải có một phần tử gốc duy nhất. (Các comment HTML cũng được coi là phần tử.)
::

::warning
Props được truyền đến các component server qua các tham số truy vấn URL, và do đó bị giới hạn bởi độ dài có thể của URL, vì vậy hãy cẩn thận không truyền lượng dữ liệu khổng lồ đến các component server qua props.
::

::warning
Hãy cẩn thận khi lồng các islands trong các islands khác vì mỗi island thêm một số overhead bổ sung.
::

::warning
Hầu hết các tính năng cho các component chỉ server và component island, chẳng hạn như slots và client components, chỉ có sẵn cho các component tệp đơn.
::

#### Client components within server components

::note
Tính năng này cần `experimental.componentIslands.selectiveClient` trong cấu hình của bạn được đặt thành true.
::

Bạn có thể hydrate một phần component bằng cách đặt thuộc tính `nuxt-client` trên component bạn muốn tải ở phía client.

```vue [components/ServerWithClient.vue]
<template>
  <div>
    <HighlightedMarkdown markdown="# Headline" />
    <!-- Counter will be loaded and hydrated client-side -->
    <Counter nuxt-client :count="5" />
  </div>
</template>
```

::note
Điều này chỉ hoạt động trong một component server. Các slot cho client components chỉ hoạt động với `experimental.componentIsland.selectiveClient` được đặt thành `'deep'` và vì chúng được render server-side, chúng không tương tác một khi ở phía client.
::

#### Server Component Context

Khi render một component chỉ server hoặc island, `<NuxtIsland>` thực hiện một yêu cầu fetch trả về một `NuxtIslandResponse`. (Đây là một yêu cầu nội bộ nếu được render trên server, hoặc một yêu cầu bạn có thể thấy trong tab network nếu đang render trên navigation phía client.)

Điều này có nghĩa là:

- Một ứng dụng Vue mới sẽ được tạo server-side để tạo `NuxtIslandResponse`.
- Một 'island context' mới sẽ được tạo trong khi render component.
- Bạn không thể truy cập 'island context' từ phần còn lại của ứng dụng và bạn không thể truy cập context của phần còn lại của ứng dụng từ component island. Nói cách khác, component server hoặc island được *cô lập* khỏi phần còn lại của ứng dụng.
- Các plugin của bạn sẽ chạy lại khi render island, trừ khi chúng có `env: { islands: false }` được đặt (mà bạn có thể làm trong một plugin cú pháp đối tượng).

Trong một component island, bạn có thể truy cập island context của nó qua `nuxtApp.ssrContext.islandContext`. Lưu ý rằng trong khi các component island vẫn được đánh dấu là thử nghiệm, định dạng của context này có thể thay đổi.

::note
Các slot có thể tương tác và được wrap trong một `<div>` với `display: contents;`
::

### Paired with a Client component

Trong trường hợp này, các component `.server` + `.client` là hai 'nửa' của một component và có thể được sử dụng trong các trường hợp sử dụng nâng cao cho việc triển khai riêng biệt của một component ở phía server và client.

```bash [Directory Structure]
-| components/
---| Comments.client.vue
---| Comments.server.vue
```

```vue [pages/example.vue]
<template>
  <div>
    <!-- this component will render Comments.server on the server then Comments.client once mounted in the browser -->
    <Comments />
  </div>
</template>
```

## Built-In Nuxt Components

Có một số component mà Nuxt cung cấp, bao gồm `<ClientOnly>` và `<DevOnly>`. Bạn có thể đọc thêm về chúng trong tài liệu API.

::read-more{to="https://nuxt.com/docs/api"}
::

## Library Authors

Việc tạo các thư viện component Vue với tree-shaking tự động và đăng ký component rất dễ dàng. ✨

Bạn có thể sử dụng phương thức [`addComponentsDir`](https://nuxt.com/docs/api/kit/components#addcomponentsdir) được cung cấp từ `@nuxt/kit` để đăng ký thư mục component của bạn trong module Nuxt.

Hãy tưởng tượng một cấu trúc thư mục như thế này:

```bash [Directory Structure]
-| node_modules/
---| awesome-ui/
-----| components/
-------| Alert.vue
-------| Button.vue
-----| nuxt.ts
-| pages/
---| index.vue
-| nuxt.config.ts
```

Sau đó trong `awesome-ui/nuxt.ts` bạn có thể sử dụng hook `addComponentsDir`:

```ts twoslash
import { createResolver, defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const resolver = createResolver(import.meta.url)

    // Add ./components dir to the list
    addComponentsDir({
      path: resolver.resolve('./components'),
      prefix: 'awesome',
    })
  },
})
```

Đó là nó! Bây giờ trong dự án của bạn, bạn có thể nhập thư viện UI của mình dưới dạng một module Nuxt trong tệp `nuxt.config` của mình:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  modules: ['awesome-ui/nuxt']
})
```

... và sử dụng trực tiếp các component module (có tiền tố `awesome-`) trong `pages/index.vue` của chúng ta:

```vue
<template>
  <div>
    My <AwesomeButton>UI button</AwesomeButton>!
    <awesome-alert>Here's an alert!</awesome-alert>
  </div>
</template>
```

Nó sẽ tự động nhập các component chỉ khi được sử dụng và cũng hỗ trợ HMR khi cập nhật các component của bạn trong `node_modules/awesome-ui/components/`.

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::


# composables

## Usage

**Phương pháp 1:** Sử dụng xuất có tên

```js [composables/useFoo.ts]
export const useFoo = () => {
  return useState('foo', () => 'bar')
}
```

**Phương pháp 2:** Sử dụng xuất mặc định

```js [composables/use-foo.ts or composables/useFoo.ts]
// Nó sẽ có sẵn dưới dạng useFoo() (camelCase của tên tệp không có phần mở rộng)
export default function () {
  return useState('foo', () => 'bar')
}
```

**Cách sử dụng:** Bây giờ bạn có thể sử dụng composable được tự động nhập trong các tệp `.js`, `.ts` và `.vue`

```vue [app.vue]
<script setup lang="ts">
const foo = useFoo()
</script>

<template>
  <div>
    {{ foo }}
  </div>
</template>
```

::note
Thư mục `composables/` trong Nuxt không cung cấp bất kỳ khả năng reactivity bổ sung nào cho mã của bạn. Thay vào đó, bất kỳ reactivity nào trong composables đều được đạt được bằng cách sử dụng các cơ chế Composition API của Vue, chẳng hạn như ref và reactive. Lưu ý rằng mã reactive cũng không bị giới hạn ở ranh giới của thư mục `composables/`. Bạn có thể sử dụng các tính năng reactivity bất cứ nơi nào chúng được cần trong ứng dụng của bạn.
::

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

## Types

Bên dưới, Nuxt tự động tạo tệp `.nuxt/imports.d.ts` để khai báo các kiểu.

Hãy lưu ý rằng bạn phải chạy [`nuxt prepare`](https://nuxt.com/docs/api/commands/prepare), [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) hoặc [`nuxt build`](https://nuxt.com/docs/api/commands/build) để cho phép Nuxt tạo các kiểu.

::note
Nếu bạn tạo một composable mà không có dev server đang chạy, TypeScript sẽ ném ra lỗi, chẳng hạn như `Cannot find name 'useBar'.`
::

## Examples

### Nested Composables

Bạn có thể sử dụng một composable trong một composable khác bằng cách sử dụng auto imports:

```js [composables/test.ts]
export const useFoo = () => {
  const nuxtApp = useNuxtApp()
  const bar = useBar()
}
```

### Access plugin injections

Bạn có thể truy cập [plugin injections](https://nuxt.com/docs/guide/directory-structure/plugins#providing-helpers) từ composables:

```js [composables/test.ts]
export const useHello = () => {
  const nuxtApp = useNuxtApp()
  return nuxtApp.$hello
}
```

## How Files Are Scanned

Nuxt chỉ quét các tệp ở cấp cao nhất của [thư mục `composables/`](https://nuxt.com/docs/guide/directory-structure/composables), ví dụ:

```bash [Directory Structure]
-| composables/
---| index.ts     // scanned
---| useFoo.ts    // scanned
---| nested/
-----| utils.ts   // not scanned
```

Chỉ `composables/index.ts` và `composables/useFoo.ts` mới được tìm kiếm để nhập.

Để làm cho auto imports hoạt động cho các module lồng nhau, bạn có thể re-export chúng (khuyến nghị) hoặc cấu hình scanner để bao gồm các thư mục lồng nhau:

**Ví dụ:** Re-export các composables bạn cần từ tệp `composables/index.ts`:

```ts [composables/index.ts]
// Cho phép auto import cho export này
export { utils } from './nested/utils.ts'
```

**Ví dụ:** Quét các thư mục lồng nhau bên trong thư mục `composables/`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  imports: {
    dirs: [
      // Quét composables cấp cao nhất
      '~/composables',
      // ... hoặc quét composables lồng nhau một cấp sâu với tên cụ thể và phần mở rộng tệp
      '~/composables/*/index.{ts,js,mjs,mts}',
      // ... hoặc quét tất cả composables trong thư mục đã cho
      '~/composables/**'
    ]
  }
})
```


# layouts

::tip{icon="i-lucide-rocket"}
Để có hiệu suất tốt nhất, các component được đặt trong thư mục này sẽ được tải tự động qua asynchronous import khi được sử dụng.
::

## Enable Layouts

Layouts được bật bằng cách thêm [`<NuxtLayout>`](https://nuxt.com/docs/api/components/nuxt-layout) vào [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) của bạn:

```vue [app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

Để sử dụng một layout:

- Đặt thuộc tính `layout` trong trang của bạn với [definePageMeta](https://nuxt.com/docs/api/utils/define-page-meta).
- Đặt prop `name` của `<NuxtLayout>`.

::note
Tên layout được chuẩn hóa thành kebab-case, vì vậy `someLayout` trở thành `some-layout`.
::

::note
Nếu không có layout nào được chỉ định, `layouts/default.vue` sẽ được sử dụng.
::

::important
Nếu bạn chỉ có một layout duy nhất trong ứng dụng của mình, chúng tôi khuyên bạn nên sử dụng [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) thay thế.
::

::important
Không giống như các component khác, các layout của bạn phải có một phần tử gốc duy nhất để cho phép Nuxt áp dụng các chuyển tiếp giữa các thay đổi layout - và phần tử gốc này không thể là `<slot />`.
::

## Default Layout

Thêm một `~/layouts/default.vue`:

```vue [layouts/default.vue]
<template>
  <div>
    <p>Some default layout content shared across all pages</p>
    <slot />
  </div>
</template>
```

Trong một tệp layout, nội dung của trang sẽ được hiển thị trong component `<slot />`.

## Named Layout

```bash [Directory Structure]
-| layouts/
---| default.vue
---| custom.vue
```

Sau đó bạn có thể sử dụng layout `custom` trong trang của mình:

```vue [pages/about.vue] twoslash
<script setup lang="ts">
definePageMeta({
  layout: 'custom'
})
</script>
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/pages#page-metadata
---
Tìm hiểu thêm về `definePageMeta`.
::

Bạn có thể ghi đè trực tiếp layout mặc định cho tất cả các trang bằng cách sử dụng thuộc tính `name` của [`<NuxtLayout>`](https://nuxt.com/docs/api/components/nuxt-layout):

```vue [app.vue]
<script setup lang="ts">
// You might choose this based on an API call or logged-in status
const layout = "custom";
</script>

<template>
  <NuxtLayout :name="layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

Nếu bạn có một layout trong các thư mục lồng nhau, tên của layout sẽ dựa trên đường dẫn thư mục và tên tệp của chính nó, với các đoạn trùng lặp được loại bỏ.

| File                              | Layout Name       |
| --------------------------------- | ----------------- |
| `~/layouts/desktop/default.vue`   | `desktop-default` |
| `~/layouts/desktop-base/base.vue` | `desktop-base`    |
| `~/layouts/desktop/index.vue`     | `desktop`         |

Để rõ ràng, chúng tôi khuyên rằng tên tệp của layout nên khớp với tên của nó:

| File                                     | Layout Name       |
| ---------------------------------------- | ----------------- |
| `~/layouts/desktop/DesktopDefault.vue`   | `desktop-default` |
| `~/layouts/desktop-base/DesktopBase.vue` | `desktop-base`    |
| `~/layouts/desktop/Desktop.vue`          | `desktop`         |

::link-example{to="https://nuxt.com/docs/examples/features/layouts"}
::

## Changing the Layout Dynamically

Bạn cũng có thể sử dụng helper [`setPageLayout`](https://nuxt.com/docs/api/utils/set-page-layout) để thay đổi layout một cách động:

```vue twoslash
<script setup lang="ts">
function enableCustomLayout () {
  setPageLayout('custom')
}
definePageMeta({
  layout: false,
});
</script>

<template>
  <div>
    <button @click="enableCustomLayout">Update layout</button>
  </div>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/features/layouts"}
::

## Overriding a Layout on a Per-page Basis

Nếu bạn đang sử dụng pages, bạn có thể kiểm soát hoàn toàn bằng cách đặt `layout: false` và sau đó sử dụng component `<NuxtLayout>` trong trang.

::code-group
```vue [pages/index.vue]
<script setup lang="ts">
definePageMeta({
  layout: false,
})
</script>

<template>
  <div>
    <NuxtLayout name="custom">
      <template #header> Some header template content. </template>

      The rest of the page
    </NuxtLayout>
  </div>
</template>
```

```vue [layouts/custom.vue]
<template>
  <div>
    <header>
      <slot name="header">
        Default header content
      </slot>
    </header>
    <main>
      <slot />
    </main>
  </div>
</template>
```
::

::important
Nếu bạn sử dụng `<NuxtLayout>` trong các trang của mình, hãy đảm bảo nó không phải là phần tử gốc (hoặc [tắt các chuyển tiếp layout/page](https://nuxt.com/docs/getting-started/transitions#disable-transitions)).
::


# middleware

Nuxt cung cấp một framework **route middleware** có thể tùy chỉnh mà bạn có thể sử dụng trong toàn bộ ứng dụng của mình, lý tưởng để trích xuất code mà bạn muốn chạy trước khi điều hướng đến một route cụ thể.

Có ba loại route middleware:

1. Anonymous (hoặc inline) route middleware được định nghĩa trực tiếp trong trang.
2. Named route middleware, được đặt trong `middleware/` và được tải tự động qua asynchronous import khi được sử dụng trên một trang.
3. Global route middleware, được đặt trong `middleware/` với hậu tố `.global` và được chạy trên mọi thay đổi route.

Hai loại route middleware đầu tiên có thể được định nghĩa trong [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta).

::note
Tên của middleware được chuẩn hóa thành kebab-case: `myMiddleware` trở thành `my-middleware`.
::

::note
Route middleware chạy trong phần Vue của ứng dụng Nuxt của bạn. Mặc dù có tên tương tự, chúng hoàn toàn khác với [server middleware](https://nuxt.com/docs/guide/directory-structure/server#server-middleware), được chạy trong phần Nitro server của ứng dụng của bạn.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on all 3 kinds of middleware
video-id: "761471577"
---
::

## Usage

Route middleware là navigation guards nhận route hiện tại và route tiếp theo làm đối số.

```ts [middleware/my-middleware.ts] twoslash
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.params.id === '1') {
    return abortNavigation()
  }
  // In a real app you would probably not redirect every route to `/`
  // however it is important to check `to.path` before redirecting or you
  // might get an infinite redirect loop
  if (to.path !== '/') {
    return navigateTo('/')
  }
})
```

Nuxt cung cấp hai helper có sẵn toàn cục có thể được trả về trực tiếp từ middleware.

1. [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) - Chuyển hướng đến route đã cho
2. [`abortNavigation`](https://nuxt.com/docs/api/utils/abort-navigation) - Hủy bỏ navigation, với thông báo lỗi tùy chọn.

Không giống như [navigation guards](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards){rel="nofollow"} từ `vue-router`, đối số thứ ba `next()` không được truyền, và **chuyển hướng hoặc hủy bỏ route được xử lý bằng cách trả về một giá trị từ middleware**.

Các giá trị trả về có thể là:

- không có gì (một `return` đơn giản hoặc không return) - không chặn navigation và sẽ chuyển đến hàm middleware tiếp theo, nếu có, hoặc hoàn thành navigation route
- `return navigateTo('/')` - chuyển hướng đến path đã cho và sẽ đặt mã chuyển hướng thành [`302` Found](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302){rel="nofollow"} nếu chuyển hướng xảy ra ở phía server
- `return navigateTo('/', { redirectCode: 301 })` - chuyển hướng đến path đã cho và sẽ đặt mã chuyển hướng thành [`301` Moved Permanently](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301){rel="nofollow"} nếu chuyển hướng xảy ra ở phía server
- `return abortNavigation()` - dừng navigation hiện tại
- `return abortNavigation(error)` - từ chối navigation hiện tại với lỗi

::read-more{to="https://nuxt.com/docs/api/utils/navigate-to"}
::

::read-more{to="https://nuxt.com/docs/api/utils/abort-navigation"}
::

::important
Chúng tôi khuyến nghị sử dụng các hàm helper ở trên để thực hiện chuyển hướng hoặc dừng navigation. Các giá trị trả về có thể khác được mô tả trong [vue-router docs](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards){rel="nofollow"} có thể hoạt động nhưng có thể có thay đổi breaking trong tương lai.
::

## Middleware Order

Middleware chạy theo thứ tự sau:

1. Global Middleware
2. Thứ tự middleware được định nghĩa trong trang (nếu có nhiều middleware được khai báo với cú pháp array)

Ví dụ, giả sử bạn có middleware và component sau:

```bash [middleware/ directory]
-| middleware/
---| analytics.global.ts
---| setup.global.ts
---| auth.ts
```

```vue [pages/profile.vue] twoslash
<script setup lang="ts">
definePageMeta({
  middleware: [
    function (to, from) {
      // Custom inline middleware
    },
    'auth',
  ],
});
</script>
```

Bạn có thể mong đợi middleware được chạy theo thứ tự sau:

1. `analytics.global.ts`
2. `setup.global.ts`
3. Custom inline middleware
4. `auth.ts`

### Ordering Global Middleware

Theo mặc định, global middleware được thực thi theo thứ tự alphabet dựa trên tên file.

Tuy nhiên, có thể có lúc bạn muốn định nghĩa thứ tự cụ thể. Ví dụ, trong kịch bản cuối cùng, `setup.global.ts` có thể cần chạy trước `analytics.global.ts`. Trong trường hợp đó, chúng tôi khuyến nghị thêm tiền tố global middleware với 'alphabetical' numbering.

```bash [Directory structure]
-| middleware/
---| 01.setup.global.ts
---| 02.analytics.global.ts
---| auth.ts
```

::note
Trong trường hợp bạn mới với 'alphabetical' numbering, hãy nhớ rằng tên file được sắp xếp như string, không phải như giá trị số. Ví dụ, `10.new.global.ts` sẽ đến trước `2.new.global.ts`. Đây là lý do ví dụ thêm `0` trước số có một chữ số.
::

## When Middleware Runs

Nếu site của bạn được server-rendered hoặc generated, middleware cho trang đầu tiên sẽ được thực thi cả khi trang được render và sau đó lại trên client. Điều này có thể cần thiết nếu middleware của bạn cần môi trường browser, chẳng hạn như nếu bạn có site generated, cache responses một cách tích cực, hoặc muốn đọc giá trị từ local storage.

Tuy nhiên, nếu bạn muốn tránh hành vi này bạn có thể làm như sau:

```ts [middleware/example.ts] twoslash
export default defineNuxtRouteMiddleware(to => {
  // skip middleware on server
  if (import.meta.server) return
  // skip middleware on client side entirely
  if (import.meta.client) return
  // or only skip middleware on initial client load
  const nuxtApp = useNuxtApp()
  if (import.meta.client && nuxtApp.isHydrating && nuxtApp.payload.serverRendered) return
})
```

Điều này đúng ngay cả khi bạn throw lỗi trong middleware của bạn trên server, và trang lỗi được render. Middleware vẫn sẽ chạy lại trong browser.

::note
Render trang lỗi là một page load hoàn toàn riêng biệt, nghĩa là bất kỳ middleware đã đăng ký nào sẽ chạy lại. Bạn có thể sử dụng [`useError`](https://nuxt.com/docs/getting-started/error-handling#useerror) trong middleware để kiểm tra xem lỗi có đang được xử lý hay không.
::

## Adding Middleware Dynamically

Có thể thêm global hoặc named route middleware theo cách thủ công bằng hàm helper [`addRouteMiddleware()`](https://nuxt.com/docs/api/utils/add-route-middleware), chẳng hạn như từ trong plugin.

```ts twoslash
export default defineNuxtPlugin(() => {
  addRouteMiddleware('global-test', () => {
    console.log('this global middleware was added in a plugin and will be run on every route change')
  }, { global: true })

  addRouteMiddleware('named-test', () => {
    console.log('this named middleware was added in a plugin and would override any existing middleware of the same name')
  })
})
```

## Example

```bash [Directory Structure]
-| middleware/
---| auth.ts
```

Trong file trang của bạn, bạn có thể tham chiếu route middleware này:

```vue twoslash
<script setup lang="ts">
definePageMeta({
  middleware: ["auth"]
  // or middleware: 'auth'
})
</script>
```

Bây giờ, trước khi navigation đến trang đó có thể hoàn thành, route middleware `auth` sẽ được chạy.

::link-example{to="https://nuxt.com/docs/examples/routing/middleware"}
::

## Setting Middleware at Build Time

Thay vì sử dụng `definePageMeta` trên mỗi trang, bạn có thể thêm named route middleware trong hook `pages:extend`.

```ts [nuxt.config.ts] twoslash
import type { NuxtPage } from 'nuxt/schema'

export default defineNuxtConfig({
  hooks: {
    'pages:extend' (pages) {
      function setMiddleware (pages: NuxtPage[]) {
        for (const page of pages) {
          if (/* some condition */ true) {
            page.meta ||= {}
            // Note that this will override any middleware set in `definePageMeta` in the page
            page.meta.middleware = ['named']
          }
          if (page.children) {
            setMiddleware(page.children)
          }
        }
      }
      setMiddleware(pages)
    }
  }
})
```


# pages

::note
Để giảm kích thước bundle của ứng dụng, thư mục này là **tùy chọn**, nghĩa là [`vue-router`](https://router.vuejs.org){rel="nofollow"} sẽ không được bao gồm nếu bạn chỉ sử dụng [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app). Để buộc hệ thống pages, hãy đặt `pages: true` trong `nuxt.config` hoặc có [`router.options.ts`](https://nuxt.com/docs/guide/recipes/custom-routing#using-approuteroptions).
::

## Usage

Pages là các Vue components và có thể có bất kỳ [extension hợp lệ](https://nuxt.com/docs/api/configuration/nuxt-config#extensions) nào mà Nuxt hỗ trợ (theo mặc định `.vue`, `.js`, `.jsx`, `.mjs`, `.ts` hoặc `.tsx`).

Nuxt sẽ tự động tạo một route cho mọi page trong thư mục `~/pages/` của bạn.

::code-group
```vue [pages/index.vue]
<template>
  <h1>Index page</h1>
</template>
```

```ts [pages/index.ts] twoslash
// https://vuejs.org/guide/extras/render-function.html
export default defineComponent({
  render () {
    return h('h1', 'Index page')
  }
})
```

```tsx [pages/index.tsx] twoslash
// https://nuxt.com/docs/examples/advanced/jsx
// https://vuejs.org/guide/extras/render-function.html#jsx-tsx
export default defineComponent({
  render () {
    return <h1>Index page</h1>
  }
})
```
::

File `pages/index.vue` sẽ được ánh xạ đến route `/` của ứng dụng.

Nếu bạn đang sử dụng [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app), hãy đảm bảo sử dụng component [`<NuxtPage/>`](https://nuxt.com/docs/api/components/nuxt-page) để hiển thị page hiện tại:

```vue [app.vue]
<template>
  <div>
    <!-- Markup shared across all pages, ex: NavBar -->
    <NuxtPage />
  </div>
</template>
```

Pages **phải có một single root element** để cho phép [route transitions](https://nuxt.com/docs/getting-started/transitions) giữa các pages. HTML comments cũng được coi là elements.

Điều này có nghĩa là khi route được server-rendered, hoặc statically generated, bạn sẽ có thể thấy nội dung của nó một cách chính xác, nhưng khi bạn điều hướng đến route đó trong client-side navigation thì transition giữa các routes sẽ thất bại và bạn sẽ thấy rằng route sẽ không được render.

Dưới đây là một số ví dụ để minh họa page có single root element trông như thế nào:

::code-group
```vue [pages/working.vue]
<template>
  <div>
    <!-- This page correctly has only one single root element -->
    Page content
  </div>
</template>
```

```vue [pages/bad-1.vue]
<template>
  <!-- This page will not render when route changes during client side navigation, because of this comment -->
  <div>Page content</div>
</template>
```

```vue [pages/bad-2.vue]
<template>
  <div>This page</div>
  <div>Has more than one root element</div>
  <div>And will not render when route changes during client side navigation</div>
</template>
```
::

## Dynamic Routes

Nếu bạn đặt bất cứ thứ gì trong dấu ngoặc vuông, nó sẽ được chuyển thành một [dynamic route](https://router.vuejs.org/guide/essentials/dynamic-matching.html){rel="nofollow"} parameter. Bạn có thể kết hợp nhiều parameters và thậm chí cả text không động trong một tên file hoặc thư mục.

Nếu bạn muốn một parameter là *optional*, bạn phải đặt nó trong double square brackets - ví dụ, `~/pages/[[slug]]/index.vue` hoặc `~/pages/[[slug]].vue` sẽ match cả `/` và `/test`.

```bash [Directory Structure]
-| pages/
---| index.vue
---| users-[group]/
-----| [id].vue
```

Với ví dụ ở trên, bạn có thể truy cập group/id trong component của mình qua object `$route`:

```vue [pages/users-[group\\]/[id\\].vue]
<template>
  <p>{{ $route.params.group }} - {{ $route.params.id }}</p>
</template>
```

Điều hướng đến `/users-admins/123` sẽ render:

```html
<p>admins - 123</p>
```

Nếu bạn muốn truy cập route bằng Composition API, có một global function [`useRoute`](https://nuxt.com/docs/api/composables/use-route) sẽ cho phép bạn truy cập route giống như `this.$route` trong Options API.

```vue twoslash
<script setup lang="ts">
const route = useRoute()

if (route.params.group === 'admins' && !route.params.id) {
  console.log('Warning! Make sure user is authenticated!')
}
</script>
```

::note
Named parent routes sẽ có ưu tiên cao hơn nested dynamic routes. Với route `/foo/hello`, `~/pages/foo.vue` sẽ có ưu tiên cao hơn `~/pages/foo/[slug].vue`. :br Sử dụng `~/pages/foo/index.vue` và `~/pages/foo/[slug].vue` để match `/foo` và `/foo/hello` với các pages khác nhau.
::

::video-accordion
---
platform: vimeo
title: Watch a video from Vue School on dynamic routes
video-id: "754465699"
---
::

## Catch-all Route

Nếu bạn cần một catch-all route, bạn tạo nó bằng cách sử dụng file có tên như `[...slug].vue`. Điều này sẽ match *tất cả* routes dưới path đó.

```vue [pages/[...slug\\].vue]
<template>
  <p>{{ $route.params.slug }}</p>
</template>
```

Điều hướng đến `/hello/world` sẽ render:

```html
<p>["hello", "world"]</p>
```

## Nested Routes

Có thể hiển thị [nested routes](https://next.router.vuejs.org/guide/essentials/nested-routes.html){rel="nofollow"} với `<NuxtPage>`.

Ví dụ:

```bash [Directory Structure]
-| pages/
---| parent/
-----| child.vue
---| parent.vue
```

Cây file này sẽ tạo ra các routes sau:

```js
[
  {
    path: '/parent',
    component: '~/pages/parent.vue',
    name: 'parent',
    children: [
      {
        path: 'child',
        component: '~/pages/parent/child.vue',
        name: 'parent-child'
      }
    ]
  }
]
```

Để hiển thị component `child.vue`, bạn phải chèn component `<NuxtPage>` bên trong `pages/parent.vue`:

```vue [pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :foobar="123" />
  </div>
</template>
```

```vue [pages/parent/child.vue]
<script setup lang="ts">
const props = defineProps(['foobar'])

console.log(props.foobar)
</script>
```

### Child Route Keys

Nếu bạn muốn kiểm soát nhiều hơn khi component `<NuxtPage>` được re-render (ví dụ, cho transitions), bạn có thể truyền một string hoặc function qua prop `pageKey`, hoặc bạn có thể định nghĩa một giá trị `key` qua `definePageMeta`:

```vue [pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :page-key="route => route.fullPath" />
  </div>
</template>
```

Hoặc thay thế:

```vue [pages/parent/child.vue] twoslash
<script setup lang="ts">
definePageMeta({
  key: route => route.fullPath
})
</script>
```

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::

## Route Groups

Trong một số trường hợp, bạn có thể muốn nhóm một tập hợp các routes lại với nhau theo cách không ảnh hưởng đến file-based routing. Với mục đích này, bạn có thể đặt files trong một folder được bao bọc bởi dấu ngoặc đơn - `(` và `)`.

Ví dụ:

```bash [Directory structure]
-| pages/
---| index.vue
---| (marketing)/
-----| about.vue
-----| contact.vue
```

Điều này sẽ tạo ra các pages `/`, `/about` và `/contact` trong ứng dụng của bạn. Nhóm `marketing` được bỏ qua cho mục đích cấu trúc URL của bạn.

## Page Metadata

Bạn có thể muốn định nghĩa metadata cho mỗi route trong ứng dụng của mình. Bạn có thể làm điều này bằng macro `definePageMeta`, macro này sẽ hoạt động cả trong `<script>` và trong `<script setup>`:

```vue twoslash
<script setup lang="ts">
definePageMeta({
  title: 'My home page'
})
</script>
```

Dữ liệu này sau đó có thể được truy cập trong toàn bộ ứng dụng của bạn từ object `route.meta`.

```vue twoslash
<script setup lang="ts">
const route = useRoute()

console.log(route.meta.title) // My home page
</script>
```

Nếu bạn đang sử dụng nested routes, page metadata từ tất cả các routes này sẽ được merge thành một single object. Để biết thêm về route meta, xem [vue-router docs](https://router.vuejs.org/guide/advanced/meta.html#route-meta-fields){rel="nofollow"}.

Giống như `defineEmits` hoặc `defineProps` (xem [Vue docs](https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits){rel="nofollow"}), `definePageMeta` là một **compiler macro**. Nó sẽ được compile away nên bạn không thể tham chiếu nó trong component của mình. Thay vào đó, metadata được truyền cho nó sẽ được hoisted ra khỏi component.
Do đó, page meta object không thể tham chiếu đến component. Tuy nhiên, nó có thể tham chiếu đến imported bindings, cũng như locally defined **pure functions**.

::warning
Hãy đảm bảo không tham chiếu đến bất kỳ reactive data hoặc functions nào gây ra side effects. Điều này có thể dẫn đến unexpected behavior.
::

```vue
<script setup lang="ts">
import { someData } from '~/utils/example'

function validateIdParam(route) {
  return route.params.id && !isNaN(Number(route.params.id))
}

const title = ref('')

definePageMeta({
  validate: validateIdParam,
  someData,
  title,    // do not do this, the ref will be hoisted out of the component
})
</script>
```

### Special Metadata

Tất nhiên, bạn được chào đón để định nghĩa metadata cho việc sử dụng riêng của mình trong toàn bộ ứng dụng. Nhưng một số metadata được định nghĩa với `definePageMeta` có một mục đích cụ thể:

#### `alias`

Bạn có thể định nghĩa page aliases. Chúng cho phép bạn truy cập cùng một page từ các paths khác nhau. Nó có thể là một string hoặc một array of strings như được định nghĩa [trong vue-router documentation](https://router.vuejs.org/guide/essentials/redirect-and-alias.html#Alias){rel="nofollow"}.

#### `keepalive`

Nuxt sẽ tự động wrap page của bạn trong [Vue `<KeepAlive>` component](https://vuejs.org/guide/built-ins/keep-alive.html#keepalive){rel="nofollow"} nếu bạn đặt `keepalive: true` trong `definePageMeta` của bạn. Điều này có thể hữu ích để làm, ví dụ, trong một parent route có dynamic child routes, nếu bạn muốn preserve page state across route changes.

Khi mục tiêu của bạn là preserve state cho parent routes hãy sử dụng syntax này: `<NuxtPage keepalive />`. Bạn cũng có thể đặt props để được truyền đến `<KeepAlive>` (xem [danh sách đầy đủ](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"}).

Bạn có thể đặt giá trị mặc định cho property này [trong `nuxt.config` của bạn](https://nuxt.com/docs/api/nuxt-config#keepalive).

#### `key`

[Xem ở trên](https://nuxt.com/#child-route-keys).

#### `layout`

Bạn có thể định nghĩa layout được sử dụng để render route. Điều này có thể là false (để disable bất kỳ layout nào), một string hoặc một ref/computed, nếu bạn muốn làm cho nó reactive theo một cách nào đó. [Thêm về layouts](https://nuxt.com/docs/guide/directory-structure/layouts).

#### `layoutTransition` and `pageTransition`

Bạn có thể định nghĩa transition properties cho component `<transition>` wrap pages và layouts của bạn, hoặc truyền `false` để disable `<transition>` wrapper cho route đó. Bạn có thể xem [danh sách options có thể được truyền](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"} hoặc đọc [thêm về cách transitions hoạt động](https://vuejs.org/guide/built-ins/transition.html#transition){rel="nofollow"}.

Bạn có thể đặt giá trị mặc định cho các properties này [trong `nuxt.config` của bạn](https://nuxt.com/docs/api/nuxt-config#layouttransition).

#### `middleware`

Bạn có thể định nghĩa middleware để áp dụng trước khi load page này. Nó sẽ được merge với tất cả middleware khác được sử dụng trong bất kỳ parent/child routes nào match. Nó có thể là một string, một function (một anonymous/inlined middleware function theo [global before guard pattern](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards){rel="nofollow"}), hoặc một array of strings/functions. [Thêm về named middleware](https://nuxt.com/docs/guide/directory-structure/middleware).

#### `name`

Bạn có thể định nghĩa một name cho route của page này.

#### `path`

Bạn có thể định nghĩa một path matcher, nếu bạn có một pattern phức tạp hơn có thể được biểu đạt với tên file. Xem [vue-router docs](https://router.vuejs.org/guide/essentials/route-matching-syntax.html#custom-regex-in-params){rel="nofollow"} để biết thêm thông tin.

#### `props`

Cho phép truy cập route `params` như props được truyền đến page component. Xem [vue-router docs](https://router.vuejs.org/guide/essentials/passing-props){rel="nofollow"} để biết thêm thông tin.

### Typing Custom Metadata

Nếu bạn thêm custom metadata cho pages của mình, bạn có thể muốn làm điều đó theo cách type-safe. Có thể augment type của object được chấp nhận bởi `definePageMeta`:

```ts [index.d.ts]
declare module '#app' {
  interface PageMeta {
    pageType?: string
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

## Navigation

Để điều hướng giữa các pages của ứng dụng, bạn nên sử dụng component [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link).

Component này được bao gồm với Nuxt và do đó bạn không cần import nó như với các components khác.

Một link đơn giản đến page `index.vue` trong folder `pages` của bạn:

```vue
<template>
  <NuxtLink to="/">Home page</NuxtLink>
</template>
```

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
Tìm hiểu thêm về cách sử dụng `<NuxtLink>`.
::

## Programmatic Navigation

Nuxt cho phép programmatic navigation thông qua utility method `navigateTo()`. Sử dụng utility method này, bạn sẽ có thể programmatically điều hướng user trong ứng dụng của mình. Điều này tuyệt vời để lấy input từ user và điều hướng họ một cách động trong toàn bộ ứng dụng. Trong ví dụ này, chúng ta có một method đơn giản gọi là `navigate()` được gọi khi user submit một search form.

::note
Hãy đảm bảo luôn `await` trên `navigateTo` hoặc chain kết quả của nó bằng cách return từ functions.
::

```vue twoslash
<script setup lang="ts">
const name = ref('');
const type = ref(1);

function navigate(){
  return navigateTo({
    path: '/search',
    query: {
      name: name.value,
      type: type.value
    }
  })
}
</script>
```

## Client-Only Pages

Bạn có thể định nghĩa một page là [client only](https://nuxt.com/docs/guide/directory-structure/components#client-components) bằng cách đặt suffix `.client.vue`. Không có nội dung nào của page này sẽ được render trên server.

## Server-Only Pages

Bạn có thể định nghĩa một page là [server only](https://nuxt.com/docs/guide/directory-structure/components#server-components) bằng cách đặt suffix `.server.vue`. Trong khi bạn sẽ có thể điều hướng đến page bằng client-side navigation, được điều khiển bởi `vue-router`, nó sẽ được render với một server component tự động, nghĩa là code cần thiết để render page sẽ không có trong client-side bundle của bạn.

::warning
Server-only pages phải có một single root element. (HTML comments cũng được coi là elements.)
::

## Custom Routing

Khi ứng dụng của bạn trở nên lớn hơn và phức tạp hơn, routing của bạn có thể yêu cầu nhiều flexibility hơn. Vì lý do này, Nuxt trực tiếp expose router, routes và router options để customization theo các cách khác nhau.

::read-more{to="https://nuxt.com/docs/guide/recipes/custom-routing"}
::

## Multiple Pages Directories

Theo mặc định, tất cả pages của bạn nên ở trong một thư mục `pages` tại root của project.

Tuy nhiên, bạn có thể sử dụng [Nuxt Layers](https://nuxt.com/docs/getting-started/layers) để tạo groupings của pages của ứng dụng:

```bash [Directory Structure]
-| some-app/
---| nuxt.config.ts
---| pages/
-----| app-page.vue
-| nuxt.config.ts
```

```ts [some-app/nuxt.config.ts] twoslash
// some-app/nuxt.config.ts
export default defineNuxtConfig({
})
```

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  extends: ['./some-app'],
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/layers"}
::


# plugins

Nuxt tự động đọc các files trong thư mục `plugins/` và load chúng khi tạo ứng dụng Vue.

::note
Tất cả plugins bên trong được tự động đăng ký, bạn không cần thêm chúng vào `nuxt.config` riêng biệt.
::

::note
Bạn có thể sử dụng suffix `.server` hoặc `.client` trong tên file để load plugin chỉ trên server hoặc client side.
::

## Registered Plugins

Chỉ có files ở top level của thư mục (hoặc index files trong bất kỳ subdirectories nào) sẽ được tự động đăng ký như plugins.

```bash [Directory structure]
-| plugins/
---| foo.ts      // scanned
---| bar/
-----| baz.ts    // not scanned
-----| foz.vue   // not scanned
-----| index.ts  // currently scanned but deprecated
```

Chỉ có `foo.ts` và `bar/index.ts` sẽ được đăng ký.

Để thêm plugins trong subdirectories, bạn có thể sử dụng option [`plugins`](https://nuxt.com/docs/api/nuxt-config#plugins-1) trong `nuxt.config.ts`:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  plugins: [
    '~/plugins/bar/baz',
    '~/plugins/bar/foz'
  ]
})
```

## Creating Plugins

Đối số duy nhất được truyền cho plugin là [`nuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app).

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin(nuxtApp => {
  // Doing something with nuxtApp
})
```

### Object Syntax Plugins

Cũng có thể định nghĩa plugin bằng object syntax, cho các use cases nâng cao hơn. Ví dụ:

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin({
  name: 'my-plugin',
  enforce: 'pre', // or 'post'
  async setup (nuxtApp) {
    // this is the equivalent of a normal functional plugin
  },
  hooks: {
    // You can directly register Nuxt app runtime hooks here
    'app:created'() {
      const nuxtApp = useNuxtApp()
      // do something in the hook
    }
  },
  env: {
    // Set this value to `false` if you don't want the plugin to run when rendering server-only or island components.
    islands: true
  }
})
```

::video-accordion
---
title: Watch a video from Alexander Lichter about the Object Syntax for Nuxt plugins
video-id: 2aXZyXB1QGQ
---
::

::note
Nếu bạn đang sử dụng object-syntax, các properties được statically analyzed để tạo ra build được tối ưu hóa hơn. Vì vậy bạn không nên định nghĩa chúng tại runtime. :br
Ví dụ, đặt `enforce: import.meta.server ? 'pre' : 'post'` sẽ làm mất bất kỳ tối ưu hóa nào mà Nuxt có thể làm cho plugins của bạn.
Nuxt does statically pre-load any hook listeners when using object-syntax, allowing you to define hooks without needing to worry about order of plugin registration.
::

## Registration Order

Bạn có thể kiểm soát thứ tự mà plugins được đăng ký bằng cách thêm tiền tố 'alphabetical' numbering vào tên files.

```bash [Directory structure]
plugins/
 | - 01.myPlugin.ts
 | - 02.myOtherPlugin.ts
```

Trong ví dụ này, `02.myOtherPlugin.ts` sẽ có thể truy cập bất cứ thứ gì được inject bởi `01.myPlugin.ts`.

Điều này hữu ích trong các tình huống mà bạn có plugin phụ thuộc vào plugin khác.

::note
Trong trường hợp bạn mới với 'alphabetical' numbering, hãy nhớ rằng tên files được sắp xếp như strings, không phải như giá trị số. Ví dụ, `10.myPlugin.ts` sẽ đến trước `2.myOtherPlugin.ts`. Đây là lý do ví dụ thêm `0` trước số có một chữ số.
::

## Loading Strategy

### Parallel Plugins

Theo mặc định, Nuxt load plugins sequentially. Bạn có thể định nghĩa plugin là `parallel` nên Nuxt sẽ không chờ đến cuối việc thực thi plugin trước khi load plugin tiếp theo.

```ts [plugins/my-plugin.ts] twoslash
export default defineNuxtPlugin({
  name: 'my-plugin',
  parallel: true,
  async setup (nuxtApp) {
    // the next plugin will be executed immediately
  }
})
```

### Plugins With Dependencies

Nếu plugin cần chờ plugin khác trước khi nó chạy, bạn có thể thêm tên plugin vào array `dependsOn`.

```ts [plugins/depending-on-my-plugin.ts] twoslash
export default defineNuxtPlugin({
  name: 'depends-on-my-plugin',
  dependsOn: ['my-plugin'],
  async setup (nuxtApp) {
    // this plugin will wait for the end of `my-plugin`'s execution before it runs
  }
})
```

## Using Composables

Bạn có thể sử dụng [composables](https://nuxt.com/docs/guide/directory-structure/composables) cũng như [utils](https://nuxt.com/docs/guide/directory-structure/utils) trong Nuxt plugins:

```ts [plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const foo = useFoo()
})
```

Tuy nhiên, hãy nhớ rằng có một số limitations và differences:

::important
**Nếu composable phụ thuộc vào plugin khác được đăng ký sau, nó có thể không hoạt động.** :br

Plugins được gọi theo thứ tự sequentially và trước mọi thứ khác. Bạn có thể sử dụng composable phụ thuộc vào plugin khác chưa được gọi.
::

::important
**Nếu composable phụ thuộc vào Vue.js lifecycle, nó sẽ không hoạt động.** :br

Normally, Vue.js composables are bound to the current component instance while plugins are only bound to [`nuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) instance.
::

## Providing Helpers

Nếu bạn muốn provide helper trên instance [`NuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app), return nó từ plugin dưới key `provide`.

::code-group
```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin(() => {
  return {
    provide: {
      hello: (msg: string) => `Hello ${msg}!`
    }
  }
})
```

```ts [plugins/hello-object-syntax.ts] twoslash
export default defineNuxtPlugin({
  name: 'hello',
  setup () {
    return {
      provide: {
        hello: (msg: string) => `Hello ${msg}!`
      }
    }
  }
})
```
::

Sau đó bạn có thể sử dụng helper trong components của mình:

```vue [components/Hello.vue]
<script setup lang="ts">
// alternatively, you can also use it here
const { $hello } = useNuxtApp()
</script>

<template>
  <div>
    {{ $hello('world') }}
  </div>
</template>
```

::important
Lưu ý rằng chúng tôi highly recommend sử dụng [`composables`](https://nuxt.com/docs/guide/directory-structure/composables) thay vì providing helpers để tránh polluting global namespace và giữ main bundle entry nhỏ.
::

::warning
**Nếu plugin của bạn provide `ref` hoặc `computed`, nó sẽ không được unwrapped trong component `<template>`.** :br
Điều này là do cách Vue hoạt động với refs không phải top-level của template. Bạn có thể đọc thêm về nó [trong Vue documentation](https://vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-when-unwrapping-in-templates){rel="nofollow"}.
::

## Typing Plugins

Nếu bạn return helpers từ plugin, chúng sẽ được typed tự động; bạn sẽ tìm thấy chúng được typed cho return của `useNuxtApp()` và trong templates của bạn.

::note
Nếu bạn cần sử dụng provided helper *trong* plugin khác, bạn có thể gọi [`useNuxtApp()`](https://nuxt.com/docs/api/composables/use-nuxt-app) để lấy version được typed. Nhưng nói chung, điều này nên được tránh trừ khi bạn chắc chắn về thứ tự của plugins.
::

Cho advanced use-cases, bạn có thể declare type của injected properties như này:

```ts [index.d.ts]
declare module '#app' {
  interface NuxtApp {
    $hello (msg: string): string
  }
}

declare module 'vue' {
  interface ComponentCustomProperties {
    $hello (msg: string): string
  }
}

export {}
```

::note
Nếu bạn đang sử dụng WebStorm, bạn có thể cần augment `@vue/runtime-core` cho đến khi [issue này](https://youtrack.jetbrains.com/issue/WEB-59818/VUE-TypeScript-WS-PS-does-not-correctly-display-type-of-globally-injected-properties){rel="nofollow"} được resolved.
::

## Vue Plugins

Nếu bạn muốn sử dụng Vue plugins, như [vue-gtag](https://github.com/MatteoGabriele/vue-gtag){rel="nofollow"} để thêm Google Analytics tags, bạn có thể sử dụng Nuxt plugin để làm điều đó.

Đầu tiên, install Vue plugin dependency:

::code-group{sync="pm"}
```bash [npm]
npm install --save-dev vue-gtag-next
```

```bash [yarn]
yarn add --dev vue-gtag-next
```

```bash [pnpm]
pnpm add -D vue-gtag-next
```

```bash [bun]
bun add -D vue-gtag-next
```
::

Sau đó tạo plugin file:

```ts [plugins/vue-gtag.client.ts]
import VueGtag, { trackRouter } from 'vue-gtag-next'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(VueGtag, {
    property: {
      id: 'GA_MEASUREMENT_ID'
    }
  })
  trackRouter(useRouter())
})
```

## Vue Directives

Tương tự, bạn có thể đăng ký custom Vue directive trong plugin.

```ts [plugins/my-directive.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.directive('focus', {
    mounted (el) {
      el.focus()
    },
    getSSRProps (binding, vnode) {
      // you can provide SSR-specific props here
      return {}
    }
  })
})
```

::warning
Nếu bạn đăng ký Vue directive, bạn *phải* đăng ký nó trên cả client và server side trừ khi bạn chỉ sử dụng nó khi rendering một side. Nếu directive chỉ có ý nghĩa từ client side, bạn luôn có thể move nó đến `~/plugins/my-directive.client.ts` và provide 'stub' directive cho server trong `~/plugins/my-directive.server.ts`.
::

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Custom Directives on Vue Docs
to: https://vuejs.org/guide/reusability/custom-directives.html
---
::


# utils

Mục đích chính của thư mục [`utils/` directory](https://nuxt.com/docs/guide/directory-structure/utils) là cho phép phân biệt ngữ nghĩa giữa Vue composables của bạn và các utility functions được auto-import khác.

## Usage

**Method 1:** Sử dụng named export

```ts [utils/index.ts] twoslash
export const { format: formatNumber } = Intl.NumberFormat('en-GB', {
  notation: 'compact',
  maximumFractionDigits: 1
})
```

**Method 2:** Sử dụng default export

```ts [utils/random-entry.ts or utils/randomEntry.ts] twoslash
// It will be available as randomEntry() (camelCase of file name without extension)
export default function (arr: Array<any>) {
  return arr[Math.floor(Math.random() * arr.length)]
}
```

Bây giờ bạn có thể sử dụng auto imported utility functions trong files `.js`, `.ts` và `.vue`

```vue [app.vue]
<template>
  <p>{{ formatNumber(1234) }}</p>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::

::link-example{to="https://nuxt.com/docs/examples/features/auto-imports"}
::

::tip
Cách `utils/` auto-imports hoạt động và được scan là giống hệt với thư mục [`composables/`](https://nuxt.com/docs/guide/directory-structure/composables).
::

::important
Các utils này chỉ có sẵn trong phần Vue của ứng dụng của bạn. :br
Chỉ `server/utils` được auto-import trong thư mục [`server/`](https://nuxt.com/docs/guide/directory-structure/server#server-utilities).
::


# app.vue

::tip
Nếu bạn có thư mục `pages/`, file `app.vue` là optional. Nuxt sẽ tự động include default `app.vue`, nhưng bạn vẫn có thể thêm của riêng mình để customize structure và content khi cần.
::

## Usage

### Minimal Usage

Với Nuxt, thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) là optional. Nếu nó không có mặt, Nuxt sẽ không include dependency [vue-router](https://router.vuejs.org){rel="nofollow"}. Điều này hữu ích khi xây dựng landing page hoặc ứng dụng không yêu cầu routing.

```vue [app.vue]
<template>
  <h1>Hello World!</h1>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/hello-world"}
::

### Usage with Pages

Khi bạn có thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages), bạn cần sử dụng component [`<NuxtPage>`](https://nuxt.com/docs/api/components/nuxt-page) để hiển thị current page:

```vue [app.vue]
<template>
  <NuxtPage />
</template>
```

Bạn cũng có thể định nghĩa common structure của ứng dụng trực tiếp trong `app.vue`. Điều này hữu ích khi bạn muốn include global elements như header hoặc footer:

```vue [app.vue]
<template>
  <header>
    Header content
  </header>
  <NuxtPage />
  <footer>
    Footer content
  </footer>
</template>
```

::note
Hãy nhớ rằng `app.vue` hoạt động như main component của Nuxt application. Bất cứ thứ gì bạn thêm vào nó (JS và CSS) sẽ là global và được include trong mọi page.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/pages"}
Tìm hiểu thêm về cách structure pages của bạn bằng thư mục `pages/`.
::

### Usage with Layouts

Khi ứng dụng của bạn yêu cầu different layouts cho different pages, bạn có thể sử dụng thư mục `layouts/` với component [`<NuxtLayout>`](https://nuxt.com/docs/api/components/nuxt-layout). Điều này cho phép bạn định nghĩa multiple layouts và áp dụng chúng per page.

```vue [app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/layouts"}
Tìm hiểu thêm về cách structure layouts của bạn bằng thư mục `layouts/`.
::


# app.config.ts

Nuxt cung cấp file config `app.config` để expose reactive configuration trong ứng dụng của bạn với khả năng cập nhật nó tại runtime trong lifecycle hoặc sử dụng nuxt plugin và chỉnh sửa nó với HMR (hot-module-replacement).

Bạn có thể dễ dàng cung cấp runtime app configuration bằng file `app.config.ts`. Nó có thể có extension `.ts`, `.js`, hoặc `.mjs`.

```ts [app.config.ts] twoslash
export default defineAppConfig({
  foo: 'bar'
})
```

::caution
Đừng đặt bất kỳ giá trị bí mật nào trong file `app.config`. Nó được expose cho user client bundle.
::

::note
Khi cấu hình custom [`srcDir`](https://nuxt.com/docs/api/nuxt-config#srcdir), hãy đảm bảo đặt file `app.config` tại root của path `srcDir` mới.
::

## Usage

Để expose config và environment variables cho phần còn lại của ứng dụng, bạn sẽ cần định nghĩa configuration trong file `app.config`.

```ts [app.config.ts] twoslash
export default defineAppConfig({
  theme: {
    primaryColor: '#ababab'
  }
})
```

Bây giờ chúng ta có thể universally access `theme` cả khi server-rendering page và trong browser bằng composable [`useAppConfig`](https://nuxt.com/docs/api/composables/use-app-config).

```vue [pages/index.vue]
<script setup lang="ts">
const appConfig = useAppConfig()

console.log(appConfig.theme)
</script>
```

Utility [`updateAppConfig`](https://nuxt.com/docs/api/utils/update-app-config) có thể được sử dụng để cập nhật `app.config` tại runtime.

```vue [pages/index.vue]
<script setup>
const appConfig = useAppConfig() // { foo: 'bar' }

const newAppConfig = { foo: 'baz' }

updateAppConfig(newAppConfig)

console.log(appConfig) // { foo: 'baz' }
</script>
```

::read-more{to="https://nuxt.com/docs/api/utils/update-app-config"}
Đọc thêm về utility `updateAppConfig`.
::

## Typing App Config

Nuxt cố gắng tự động generate TypeScript interface từ app config được cung cấp nên bạn sẽ không phải type nó manually.

Tuy nhiên, có một số trường hợp mà bạn có thể muốn type nó manually. Có hai điều có thể bạn muốn type.

### App Config Input

`AppConfigInput` có thể được sử dụng bởi module authors để declare những options *input* hợp lệ khi setting app config. Điều này sẽ không ảnh hưởng đến type của `useAppConfig()`.

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface AppConfigInput {
    /** Theme configuration */
    theme?: {
      /** Primary app color */
      primaryColor?: string
    }
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

### App Config Output

Nếu bạn muốn type kết quả của việc gọi [`useAppConfig()`](https://nuxt.com/docs/api/composables/use-app-config), thì bạn sẽ muốn extend `AppConfig`.

::warning
Hãy cẩn thận khi typing `AppConfig` vì bạn sẽ overwrite types mà Nuxt infer từ app config thực tế của bạn.
::

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface AppConfig {
    // This will entirely replace the existing inferred `theme` property
    theme: {
      // You might want to type this value to add more specific types than Nuxt can infer,
      // such as string literal types
      primaryColor?: 'red' | 'blue'
    }
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

## Merging Strategy

Nuxt sử dụng custom merging strategy cho `AppConfig` trong [the layers](https://nuxt.com/docs/getting-started/layers) của ứng dụng.

Strategy này được implement bằng [Function Merger](https://github.com/unjs/defu#function-merger){rel="nofollow"}, cho phép định nghĩa custom merging strategy cho mọi key trong `app.config` có array làm value.

::note
Function merger chỉ có thể được sử dụng trong extended layers và không phải main `app.config` trong project.
::

Đây là ví dụ về cách bạn có thể sử dụng:

::code-group
```ts [layer/app.config.ts] twoslash
export default defineAppConfig({
  // Default array value
  array: ['hello'],
})
```

```ts [app.config.ts] twoslash
export default defineAppConfig({
  // Overwrite default array value by using a merger function
  array: () => ['bonjour'],
})
```
::

## Known Limitations

Kể từ Nuxt v3.3, file `app.config.ts` được share với Nitro, dẫn đến những limitations sau:

1. Bạn không thể import Vue components trực tiếp trong `app.config.ts`.
2. Một số auto-imports không có sẵn trong Nitro context.

Những limitations này xảy ra vì Nitro process app config mà không có full Vue component support.

Trong khi có thể sử dụng Vite plugins trong Nitro config như workaround, approach này không được recommend:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    vite: {
      plugins: [vue()]
    }
  }
})
```

::warning
Sử dụng workaround này có thể dẫn đến unexpected behavior và bugs. Vue plugin là một trong nhiều plugins không có sẵn trong Nitro context.
::

Related issues:

- [Issue #19858](https://github.com/nuxt/nuxt/issues/19858){rel="nofollow"}
- [Issue #19854](https://github.com/nuxt/nuxt/issues/19854){rel="nofollow"}

::note
Nitro v3 sẽ resolve những limitations này bằng cách remove support cho app config.
Bạn có thể track progress trong [this pull request](https://github.com/nitrojs/nitro/pull/2521){rel="nofollow"}.
::


# error.vue

Trong suốt vòng đời của ứng dụng, một số lỗi có thể xuất hiện unexpectedly tại runtime. Trong trường hợp đó, chúng ta có thể sử dụng file `error.vue` để override default error files và hiển thị lỗi một cách đẹp.

```vue [error.vue]
<script setup lang="ts">
import type { NuxtError } from '#app'

const props = defineProps({
  error: Object as () => NuxtError
})
</script>

<template>
  <div>
    <h1>{{ error.statusCode }}</h1>
    <NuxtLink to="/">Go back home</NuxtLink>
  </div>
</template>
```

::note
Mặc dù nó được gọi là 'error page' nhưng nó không phải là route và không nên được đặt trong thư mục `~/pages` của bạn. Vì lý do tương tự, bạn không nên sử dụng `definePageMeta` trong page này. Điều đó nói rằng, bạn vẫn có thể sử dụng layouts trong error file, bằng cách sử dụng component [`NuxtLayout`](https://nuxt.com/docs/api/components/nuxt-layout) và chỉ định tên của layout.
::

Error page có một single prop - `error` chứa error để bạn handle.

Object `error` cung cấp các fields sau:

```ts
{
  statusCode: number
  fatal: boolean
  unhandled: boolean
  statusMessage?: string
  data?: unknown
  cause?: unknown
}
```

Nếu bạn có error với custom fields chúng sẽ bị mất; bạn nên assign chúng cho `data` thay thế:

```ts
throw createError({
  statusCode: 404,
  statusMessage: 'Page Not Found',
  data: {
    myCustomField: true
  }
})
```


# content

[Nuxt Content](https://content.nuxt.com){rel="nofollow"} đọc thư mục [`content/`](https://nuxt.com/docs/guide/directory-structure/content) trong dự án của bạn và phân tích các file `.md`, `.yml`, `.csv` và `.json` để tạo ra một CMS dựa trên file cho ứng dụng của bạn.

- Render nội dung của bạn với các component có sẵn.
- Truy vấn nội dung của bạn với API giống MongoDB.
- Sử dụng các Vue component của bạn trong file Markdown với cú pháp MDC.
- Tự động tạo navigation của bạn.

::read-more{target="_blank" to="https://content.nuxt.com"}
Tìm hiểu thêm trong tài liệu **Nuxt Content**.
::

## Enable Nuxt Content

Cài đặt module `@nuxt/content` trong dự án của bạn cũng như thêm nó vào `nuxt.config.ts` bằng một lệnh:

```bash [Terminal]
npx nuxt module add content
```

## Create Content

Đặt các file markdown của bạn bên trong thư mục `content/`:

```md [content/index.md]
# Hello Content
```

Module tự động tải và phân tích chúng.

## Render Content

Để render các trang nội dung, thêm một [catch-all route](https://nuxt.com/docs/guide/directory-structure/pages/#catch-all-route) sử dụng component [`<ContentRenderer>`](https://content.nuxt.com/docs/components/content-renderer){rel="nofollow"}:

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('content').path(route.path).first()
})
</script>

<template>
  <div>
    <header><!-- ... --></header>

    <ContentRenderer v-if="page" :value="page" />

    <footer><!-- ... --></footer>
  </div>
</template>
```

## Documentation

::tip{icon="i-lucide-book"}
Truy cập <https://content.nuxt.com>{rel="nofollow"} để tìm hiểu thêm về các tính năng của Content module, chẳng hạn như cách xây dựng truy vấn và sử dụng Vue component trong file Markdown với cú pháp MDC.
::


# modules

Đây là nơi tốt để đặt bất kỳ module local nào mà bạn phát triển khi xây dựng ứng dụng của mình.

Các mẫu file được tự động đăng ký là:

- `modules/*/index.ts`
- `modules/*.ts`

Bạn không cần thêm những module local này vào [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) một cách riêng biệt.

::code-group
```ts [modules/hello/index.ts] twoslash
// `nuxt/kit` là một helper subpath import bạn có thể sử dụng khi định nghĩa local module
// có nghĩa là bạn không cần thêm `@nuxt/kit` vào dependencies của dự án
import { createResolver, defineNuxtModule, addServerHandler } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'hello'
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    // Add an API route
    addServerHandler({
      route: '/api/hello',
      handler: resolver.resolve('./runtime/api-route')
    })
  }
})
```

```ts [modules/hello/runtime/api-route.ts] twoslash
export default defineEventHandler(() => {
  return { hello: 'world' }
})
```
::

Khi khởi động Nuxt, module `hello` sẽ được đăng ký và route `/api/hello` sẽ có sẵn.

Module được thực thi theo thứ tự sau:

- Đầu tiên, các module được định nghĩa trong [`nuxt.config.ts`](https://nuxt.com/docs/api/nuxt-config#modules-1) được tải.
- Sau đó, các module tìm thấy trong thư mục `modules/` được thực thi, và chúng tải theo thứ tự bảng chữ cái.

Bạn có thể thay đổi thứ tự của local module bằng cách thêm một số vào phía trước tên mỗi thư mục:

```bash [Directory structure]
modules/
  1.first-module/
    index.ts
  2.second-module.ts
```

::read-more{to="https://nuxt.com/docs/guide/going-further/modules"}
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/creating-your-first-module-from-scratch?friend=nuxt
---
Xem video Vue School về Nuxt private module.
::


# node_modules

Package manager ([`npm`](https://docs.npmjs.com/cli/commands/npm){rel="nofollow"} hoặc [`yarn`](https://yarnpkg.com){rel="nofollow"} hoặc [`pnpm`](https://pnpm.io/cli/install){rel="nofollow"} hoặc [`bun`](https://bun.sh/package-manager){rel="nofollow"}) tạo ra thư mục này để lưu trữ các dependency của dự án bạn.

::important
Thư mục này nên được thêm vào file [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) để tránh push các dependency lên repository của bạn.
::


# public

Các file chứa trong thư mục `public/` được phục vụ tại root và không được sửa đổi bởi quá trình build. Điều này phù hợp cho các file phải giữ nguyên tên (ví dụ: `robots.txt`) *hoặc* có khả năng không thay đổi (ví dụ: `favicon.ico`).

```bash [Directory structure]
-| public/
---| favicon.ico
---| og-image.png
---| robots.txt
```

```vue [app.vue]
<script setup lang="ts">
useSeoMeta({
  ogImage: '/og-image.png'
})
</script>
```

::tip{target="_blank" to="https://v2.nuxt.com/docs/directory-structure/static"}
Điều này được gọi là thư mục [`static/`] trong Nuxt 2.
::


# server

Nuxt tự động quét các file trong những thư mục này để đăng ký API và server handler với hỗ trợ Hot Module Replacement (HMR).

```bash [Directory structure]
-| server/
---| api/
-----| hello.ts      # /api/hello
---| routes/
-----| bonjour.ts    # /bonjour
---| middleware/
-----| log.ts        # log all requests
```

Mỗi file nên export một function mặc định được định nghĩa bằng `defineEventHandler()` hoặc `eventHandler()` (alias).

Handler có thể trực tiếp trả về dữ liệu JSON, một `Promise`, hoặc sử dụng `event.node.res.end()` để gửi response.

```ts [server/api/hello.ts] twoslash
export default defineEventHandler((event) => {
  return {
    hello: 'world'
  }
})
```

Giờ bạn có thể gọi API này universally trong pages và components:

```vue [pages/index.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/hello')
</script>

<template>
  <pre>{{ data }}</pre>
</template>
```

## Server Routes

Các file trong `~/server/api` được tự động thêm tiền tố `/api` vào route.

::video-accordion
---
platform: vimeo
title: Xem video từ Vue School về API routes
video-id: "761468863"
---
::

Để thêm server routes mà không có tiền tố `/api`, đặt chúng vào thư mục `~/server/routes`.

**Ví dụ:**

```ts [server/routes/hello.ts]
export default defineEventHandler(() => 'Hello World!')
```

Với ví dụ trên, route `/hello` sẽ có thể truy cập tại <http://localhost:3000/hello>{rel="nofollow"}.

::note
Lưu ý rằng hiện tại server routes không hỗ trợ đầy đủ chức năng của dynamic routes như [pages](https://nuxt.com/docs/guide/directory-structure/pages#dynamic-routes).
::

## Server Middleware

Nuxt sẽ tự động đọc bất kỳ file nào trong `~/server/middleware` để tạo server middleware cho dự án của bạn.

Middleware handlers sẽ chạy trên mỗi request trước bất kỳ server route nào khác để thêm hoặc kiểm tra headers, log requests, hoặc mở rộng request object của event.

::note
Middleware handlers không nên trả về bất cứ thứ gì (cũng như không đóng hoặc respond request) và chỉ nên kiểm tra hoặc mở rộng request context hoặc throw error.
::

**Ví dụ:**

```ts [server/middleware/log.ts]
export default defineEventHandler((event) => {
  console.log('New request: ' + getRequestURL(event))
})
```

```ts [server/middleware/auth.ts]
export default defineEventHandler((event) => {
  event.context.auth = { user: 123 }
})
```

## Server Plugins

Nuxt sẽ tự động đọc bất kỳ file nào trong thư mục `~/server/plugins` và đăng ký chúng như Nitro plugins. Điều này cho phép mở rộng runtime behavior của Nitro và hook vào lifecycle events.

**Ví dụ:**

```ts [server/plugins/nitroPlugin.ts]
export default defineNitroPlugin((nitroApp) => {
  console.log('Nitro plugin', nitroApp)
})
```

::read-more
---
target: _blank
title: Nitro Plugins
to: https://nitro.build/guide/plugins
---
::

## Server Utilities

Server routes được cung cấp bởi [h3js/h3](https://github.com/h3js/h3){rel="nofollow"} có kèm một bộ helpers hữu ích.

::read-more
---
target: _blank
title: Available H3 Request Helpers
to: https://www.jsdocs.io/package/h3#package-index-functions
---
::

Bạn có thể thêm nhiều helpers khác trong thư mục `~/server/utils`.

Ví dụ, bạn có thể định nghĩa một custom handler utility bao bọc original handler và thực hiện các thao tác bổ sung trước khi trả về final response.

**Ví dụ:**

```ts [server/utils/handler.ts]
import type { EventHandler, EventHandlerRequest } from 'h3'

export const defineWrappedResponseHandler = <T extends EventHandlerRequest, D> (
  handler: EventHandler<T, D>
): EventHandler<T, D> =>
  defineEventHandler<T>(async event => {
    try {
      // do something before the route handler
      const response = await handler(event)
      // do something after the route handler
      return { response }
    } catch (err) {
      // Error handling
      return { err }
    }
  })
```

## Server Types

::tip
Tính năng này có sẵn từ Nuxt >= 3.5
::

## Recipes

### Route Parameters

Server routes có thể sử dụng dynamic parameters trong dấu ngoặc vuông trong tên file như `/api/hello/[name].ts` và được truy cập qua `event.context.params`.

```ts [server/api/hello/[name\\].ts]
export default defineEventHandler((event) => {
  const name = getRouterParam(event, 'name')

  return `Hello, ${name}!`
})
```

::tip{to="https://h3.dev/examples/validate-data#validate-params"}
Thay vào đó, sử dụng `getValidatedRouterParams` với một schema validator như Zod cho runtime và type safety.
::

Giờ bạn có thể gọi API này universally trên `/api/hello/nuxt` và nhận `Hello, nuxt!`.

### Matching HTTP Method

Tên file handler có thể có hậu tố `.get`, `.post`, `.put`, `.delete`, ... để match với [HTTP Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods){rel="nofollow"} của request.

```ts [server/api/test.get.ts]
export default defineEventHandler(() => 'Test get handler')
```

```ts [server/api/test.post.ts]
export default defineEventHandler(() => 'Test post handler')
```

Với ví dụ trên, fetch `/test` với:

- **GET** method: Trả về `Test get handler`
- **POST** method: Trả về `Test post handler`
- Bất kỳ method nào khác: Trả về lỗi 405

Bạn cũng có thể sử dụng `index.[method].ts` trong một thư mục để cấu trúc code khác biệt, điều này hữu ích để tạo API namespaces.

::code-group
```ts [server/api/foo/index.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo` endpoint
})
```

```ts [server/api/foo/index.post.ts]
export default defineEventHandler((event) => {
  // handle POST requests for the `api/foo` endpoint
})
```

```ts [server/api/foo/bar.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo/bar` endpoint
})
```
::

### Catch-all Route

Catch-all routes hữu ích cho việc xử lý fallback route.

Ví dụ, tạo một file có tên `~/server/api/foo/[...].ts` sẽ đăng ký một catch-all route cho tất cả requests không match với bất kỳ route handler nào, chẳng hạn như `/api/foo/bar/baz`.

```ts [server/api/foo/[...\\].ts]
export default defineEventHandler((event) => {
  // event.context.path để lấy route path: '/api/foo/bar/baz'
  // event.context.params._ để lấy route segment: 'bar/baz'
  return `Default foo handler`
})
```

Bạn có thể đặt tên cho catch-all route bằng cách sử dụng `~/server/api/foo/[...slug].ts` và truy cập qua `event.context.params.slug`.

```ts [server/api/foo/[...slug\\].ts]
export default defineEventHandler((event) => {
  // event.context.params.slug để lấy route segment: 'bar/baz'
  return `Default foo handler`
})
```

### Body Handling

```ts [server/api/submit.post.ts]
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  return { body }
})
```

::tip
---
to: https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils
---
Thay vào đó, sử dụng `readValidatedBody` với một schema validator như Zod cho runtime và type safety.
::

Giờ bạn có thể gọi API này universally bằng cách sử dụng:

```vue [app.vue]
<script setup lang="ts">
async function submit() {
  const { body } = await $fetch('/api/submit', {
    method: 'post',
    body: { test: 123 }
  })
}
</script>
```

::note
Chúng tôi sử dụng `submit.post.ts` trong tên file chỉ để match requests với `POST` method có thể chấp nhận request body. Khi sử dụng `readBody` trong GET request, `readBody` sẽ throw một `405 Method Not Allowed` HTTP error.
::

### Query Parameters

Sample query `/api/query?foo=bar&baz=qux`

```ts [server/api/query.get.ts]
export default defineEventHandler((event) => {
  const query = getQuery(event)

  return { a: query.foo, b: query.baz }
})
```

::tip
---
to: https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils
---
Thay vào đó, sử dụng `getValidatedQuery` với một schema validator như Zod cho runtime và type safety.
::

### Error Handling

Nếu không có error nào được throw, status code `200 OK` sẽ được trả về.

Bất kỳ uncaught error nào sẽ trả về `500 Internal Server Error` HTTP Error.

Để trả về error codes khác, throw một exception với [`createError`](https://nuxt.com/docs/api/utils/create-error):

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  const id = parseInt(event.context.params.id) as number

  if (!Number.isInteger(id)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'ID should be an integer',
    })
  }
  return 'All good'
})
```

### Status Codes

Để trả về status codes khác, sử dụng utility [`setResponseStatus`](https://nuxt.com/docs/api/utils/set-response-status).

Ví dụ, để trả về `202 Accepted`

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  setResponseStatus(event, 202)
})
```

### Runtime Config

::code-group
```ts [server/api/foo.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  const repo = await $fetch('https://api.github.com/repos/nuxt/nuxt', {
    headers: {
      Authorization: `token ${config.githubToken}`
    }
  })

  return repo
})
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    githubToken: ''
  }
})
```

```ini [.env]
NUXT_GITHUB_TOKEN='<my-super-token>'
```
::

::note
Cung cấp `event` như argument cho `useRuntimeConfig` là tùy chọn, nhưng được khuyến nghị pass nó để lấy runtime config bị ghi đè bởi [environment variables](https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables) tại runtime cho server routes.
::

### Request Cookies

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```

### Forwarding Context & Headers

Theo mặc định, không có headers nào từ incoming request hoặc request context được forward khi thực hiện fetch requests trong server routes. Bạn có thể sử dụng `event.$fetch` để forward request context và headers khi thực hiện fetch requests trong server routes.

```ts [server/api/forward.ts]
export default defineEventHandler((event) => {
  return event.$fetch('/api/forwarded')
})
```

::note
Các headers **không được có ý định forward** sẽ **không được bao gồm** trong request. Những headers này bao gồm, ví dụ:
`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

### Awaiting Promises After Response

Khi xử lý server requests, bạn có thể cần thực hiện các async tasks không nên block response tới client (ví dụ, caching và logging). Bạn có thể sử dụng `event.waitUntil` để await một promise trong background mà không làm trễ response.

Method `event.waitUntil` chấp nhận một promise sẽ được awaited trước khi handler terminate, đảm bảo task được hoàn thành ngay cả khi server sẽ terminate handler ngay sau khi response được gửi. Điều này tích hợp với runtime providers để tận dụng native capabilities của chúng để xử lý asynchronous operations sau khi response được gửi.

```ts [server/api/background-task.ts]
const timeConsumingBackgroundTask = async () => {
  await new Promise((resolve) => setTimeout(resolve, 1000))
};

export default eventHandler((event) => {
  // schedule a background task without blocking the response
  event.waitUntil(timeConsumingBackgroundTask())

  // immediately send the response to the client
  return 'done'
});
```

## Advanced Usage

### Nitro Config

Bạn có thể sử dụng key `nitro` trong `nuxt.config` để trực tiếp set [Nitro configuration](https://nitro.build/config){rel="nofollow"}.

::warning
Đây là một tùy chọn nâng cao. Custom config có thể ảnh hưởng đến production deployments, vì configuration interface có thể thay đổi theo thời gian khi Nitro được upgrade trong semver-minor versions của Nuxt.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // https://nitro.build/config
  nitro: {}
})
```

::read-more{to="https://nuxt.com/docs/guide/concepts/server-engine"}
::

### Nested Router

```ts [server/api/hello/[...slug\\].ts]
import { createRouter, defineEventHandler, useBase } from 'h3'

const router = createRouter()

router.get('/test', defineEventHandler(() => 'Hello World'))

export default useBase('/api/hello', router.handler)
```

### Sending Streams

::tip
Đây là một experimental feature và có sẵn trong tất cả environments.
::

```ts [server/api/foo.get.ts]
import fs from 'node:fs'
import { sendStream } from 'h3'

export default defineEventHandler((event) => {
  return sendStream(event, fs.createReadStream('/path/to/file'))
})
```

### Sending Redirect

```ts [server/api/foo.get.ts]
export default defineEventHandler(async (event) => {
  await sendRedirect(event, '/path/redirect/to', 302)
})
```

### Legacy Handler or Middleware

```ts [server/api/legacy.ts]
export default fromNodeMiddleware((req, res) => {
  res.end('Legacy handler')
})
```

::important
Legacy support có thể sử dụng [h3js/h3](https://github.com/h3js/h3){rel="nofollow"}, nhưng được khuyên tránh legacy handlers càng nhiều càng tốt.
::

```ts [server/middleware/legacy.ts]
export default fromNodeMiddleware((req, res, next) => {
  console.log('Legacy middleware')
  next()
})
```

::warning
Không bao giờ kết hợp `next()` callback với legacy middleware là `async` hoặc trả về một `Promise`.
::

### Server Storage

Nitro cung cấp một cross-platform [storage layer](https://nitro.build/guide/storage){rel="nofollow"}. Để cấu hình các storage mount points bổ sung, bạn có thể sử dụng `nitro.storage`, hoặc [server plugins](https://nuxt.com/#server-plugins).

**Ví dụ thêm Redis storage:**

Sử dụng `nitro.storage`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    storage: {
      redis: {
        driver: 'redis',
        /* redis connector options */
        port: 6379, // Redis port
        host: "127.0.0.1", // Redis host
        username: "", // needs Redis >= 6
        password: "",
        db: 0, // Defaults to 0
        tls: {} // tls/ssl
      }
    }
  }
})
```

Sau đó trong API handler:

```ts [server/api/storage/test.ts]
export default defineEventHandler(async (event) => {
  // List all keys with
  const keys = await useStorage('redis').getKeys()

  // Set a key with
  await useStorage('redis').setItem('foo', 'bar')

  // Remove a key with
  await useStorage('redis').removeItem('foo')

  return {}
})
```

::read-more{target="_blank" to="https://nitro.build/guide/storage"}
Đọc thêm về Nitro Storage Layer.
::

Thay vào đó, bạn có thể tạo một storage mount point sử dụng server plugin và runtime config:

::code-group
```ts [server/plugins/storage.ts]
import redisDriver from 'unstorage/drivers/redis'

export default defineNitroPlugin(() => {
  const storage = useStorage()

  // Dynamically pass in credentials from runtime configuration, or other sources
  const driver = redisDriver({
      base: 'redis',
      host: useRuntimeConfig().redis.host,
      port: useRuntimeConfig().redis.port,
      /* other redis connector options */
    })

  // Mount driver
  storage.mount('redis', driver)
})
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    redis: { // Default values
      host: '',
      port: 0,
      /* other redis connector options */
    }
  }
})
```
::


# shared

Thư mục `shared/` cho phép bạn chia sẻ mã có thể được sử dụng trong cả ứng dụng Vue và máy chủ Nitro.

::note
Thư mục `shared/` có sẵn trong Nuxt v3.14+.
::

::important
Mã trong thư mục `shared/` không thể nhập bất kỳ mã Vue hoặc Nitro nào.
::

::video-accordion
---
title: Xem video từ Vue School về chia sẻ utils và types giữa app và server
video-id: nnAR-MO3q5M
---
::

## Usage

**Phương pháp 1:** Xuất có tên

```ts [shared/utils/capitalize.ts] twoslash
export const capitalize = (input: string) => {
  return input[0] ? input[0].toUpperCase() + input.slice(1) : ''
}
```

**Phương pháp 2:** Xuất mặc định

```ts [shared/utils/capitalize.ts] twoslash
export default function (input: string) {
  return input[0] ? input[0].toUpperCase() + input.slice(1) : ''
}
```

Bây giờ bạn có thể sử dụng các tiện ích [tự động nhập](https://nuxt.com/docs/guide/directory-structure/shared#auto-imports) trong ứng dụng Nuxt và thư mục `server/` của mình.

```vue [app.vue]
<script setup lang="ts">
const hello = capitalize('hello')
</script>

<template>
  <div>
    {{ hello }}
  </div>
</template>
```

```ts [server/api/hello.get.ts]
export default defineEventHandler((event) => {
  return {
    hello: capitalize('hello')
  }
})
```

## How Files Are Scanned

Chỉ các tệp trong thư mục `shared/utils/` và `shared/types/` mới được tự động nhập. Các tệp lồng nhau trong các thư mục con của các thư mục này sẽ không được tự động nhập trừ khi bạn thêm các thư mục này vào `imports.dirs` và `nitro.imports.dirs`.

::tip
Cách thức hoạt động và quét tự động nhập của `shared/utils` và `shared/types` giống hệt với các thư mục [`composables/`](https://nuxt.com/docs/guide/directory-structure/composables) và [`utils/`](https://nuxt.com/docs/guide/directory-structure/utils).
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/composables#how-files-are-scanned
---
::

```bash [Directory Structure]
-| shared/
---| capitalize.ts        # Not auto-imported
---| formatters
-----| lower.ts           # Not auto-imported
---| utils/
-----| lower.ts           # Auto-imported
-----| formatters
-------| upper.ts         # Not auto-imported
---| types/
-----| bar.d.ts           # Auto-imported
```

Bất kỳ tệp nào khác bạn tạo trong thư mục `shared/` phải được nhập thủ công bằng cách sử dụng bí danh `#shared` (được cấu hình tự động bởi Nuxt):

```ts
// For files directly in the shared directory
import capitalize from '#shared/capitalize'

// For files in nested directories
import lower from '#shared/formatters/lower'

// For files nested in a folder within utils
import upper from '#shared/utils/formatters/upper'
```

Bí danh này đảm bảo các lần nhập nhất quán trong toàn bộ ứng dụng của bạn, bất kể vị trí của tệp nhập.

::read-more{to="https://nuxt.com/docs/guide/concepts/auto-imports"}
::


# .env

::important
Tệp này nên được thêm vào tệp [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) của bạn để tránh đẩy bí mật lên kho lưu trữ của bạn.
::

## Dev, Build and Generate Time

Nuxt CLI có hỗ trợ tích hợp [dotenv](https://github.com/motdotla/dotenv){rel="nofollow"} trong chế độ phát triển và khi chạy [`nuxt build`](https://nuxt.com/docs/api/commands/build) và [`nuxt generate`](https://nuxt.com/docs/api/commands/generate).

Ngoài bất kỳ biến môi trường quy trình nào, nếu bạn có tệp `.env` trong thư mục gốc dự án của mình, nó sẽ được tải tự động **tại thời điểm dev, build và generate**. Bất kỳ biến môi trường nào được đặt ở đó sẽ có thể truy cập được trong tệp `nuxt.config` và các module của bạn.

```ini [.env]
MY_ENV_VARIABLE=hello
```

::note
Lưu ý rằng việc xóa một biến khỏi `.env` hoặc xóa hoàn toàn tệp `.env` sẽ không hủy đặt các giá trị đã được đặt.
::

## Custom File

Nếu bạn muốn sử dụng một tệp khác - ví dụ, để sử dụng `.env.local` hoặc `.env.production` - bạn có thể làm như vậy bằng cách truyền cờ `--dotenv` khi sử dụng Nuxt CLI.

```bash [Terminal]
npx nuxt dev --dotenv .env.local
```

Khi cập nhật `.env` trong chế độ phát triển, phiên bản Nuxt sẽ tự động khởi động lại để áp dụng các giá trị mới cho `process.env`.

::important
Trong mã ứng dụng của bạn, bạn nên sử dụng [Runtime Config](https://nuxt.com/docs/guide/going-further/runtime-config) thay vì các biến env thuần túy.
::

## Production

**Sau khi máy chủ của bạn được xây dựng**, bạn chịu trách nhiệm đặt các biến môi trường khi chạy máy chủ.

Các tệp `.env` của bạn sẽ không được đọc tại thời điểm này. Cách bạn làm điều này khác nhau cho mỗi môi trường.

Quyết định thiết kế này được đưa ra để đảm bảo khả năng tương thích trên các môi trường triển khai khác nhau, một số trong đó có thể không có hệ thống tệp truyền thống, chẳng hạn như nền tảng serverless hoặc mạng edge như Cloudflare Workers.

Vì các tệp `.env` không được sử dụng trong production, bạn phải đặt rõ ràng các biến môi trường bằng cách sử dụng các công cụ và phương pháp được cung cấp bởi môi trường hosting của bạn. Dưới đây là một số cách tiếp cận phổ biến:

- Bạn có thể truyền các biến môi trường dưới dạng đối số bằng cách sử dụng terminal: :br`$ DATABASE_HOST=mydatabaseconnectionstring node .output/server/index.mjs`
- Bạn có thể đặt các biến môi trường trong các tệp cấu hình shell như `.bashrc` hoặc `.profile`.
- Nhiều nhà cung cấp dịch vụ đám mây, chẳng hạn như Vercel, Netlify và AWS, cung cấp giao diện để đặt các biến môi trường thông qua bảng điều khiển, công cụ CLI hoặc tệp cấu hình của họ.

::important
`runtimeConfig` [sẽ không chọn các biến môi trường không bắt đầu bằng `NUXT_` trong production] (<https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables>{rel="nofollow"}).
::

## Production Preview

Để mục đích xem trước production cục bộ, chúng tôi khuyên bạn nên sử dụng [`nuxt preview`](https://nuxt.com/docs/api/commands/preview) vì khi sử dụng lệnh này, tệp `.env` sẽ được tải vào `process.env` để thuận tiện. Lưu ý rằng lệnh này yêu cầu các phụ thuộc được cài đặt trong thư mục gói.

Hoặc bạn có thể truyền các biến môi trường dưới dạng đối số bằng cách sử dụng terminal. Ví dụ, trên Linux hoặc macOS:

```bash [Terminal]
DATABASE_HOST=mydatabaseconnectionstring node .output/server/index.mjs
```

Lưu ý rằng đối với một trang web hoàn toàn tĩnh, không thể đặt cấu hình runtime config sau khi dự án của bạn được prerender.

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

::note
Nếu bạn muốn sử dụng các biến môi trường được đặt tại thời điểm build nhưng không quan tâm đến việc cập nhật chúng sau này (hoặc chỉ cần cập nhật chúng một cách phản ứng *trong* ứng dụng của bạn) thì `appConfig` có thể là lựa chọn tốt hơn. Bạn có thể định nghĩa `appConfig` cả trong `nuxt.config` của mình (sử dụng các biến môi trường) và cũng trong tệp `~/app.config.ts` trong dự án của bạn.

  :::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
  :::
::


# .gitignore

A `.gitignore` file specifies intentionally untracked files that git should ignore.

::read-more
---
icon: i-simple-icons-git
target: _blank
title: the git documentation
to: https://git-scm.com/docs/gitignore
---
::

We recommend having a `.gitignore` file that has **at least** the following entries present:

```bash [.gitignore]
# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store

# Local env files
.env
.env.*
!.env.example
```


# .nuxtignore

Tệp `.nuxtignore` yêu cầu Nuxt bỏ qua các tệp trong thư mục gốc dự án của bạn ([`rootDir`](https://nuxt.com/docs/api/nuxt-config#rootdir)) trong giai đoạn build.

Nó tuân theo cùng thông số kỹ thuật như các tệp [`.gitignore`](https://nuxt.com/docs/guide/directory-structure/gitignore) và `.eslintignore`, trong đó mỗi dòng là một mẫu glob chỉ ra các tệp nào nên được bỏ qua.

::tip
Bạn cũng có thể cấu hình [`ignoreOptions`](https://nuxt.com/docs/api/nuxt-config#ignoreoptions), [`ignorePrefix`](https://nuxt.com/docs/api/nuxt-config#ignoreprefix) và [`ignore`](https://nuxt.com/docs/api/nuxt-config#ignore) trong tệp `nuxt.config` của mình.
::

## Usage

```bash [.nuxtignore]
# ignore layout foo.vue
app/layouts/foo.vue
# ignore layout files whose name ends with -ignore.vue
app/layouts/*-ignore.vue

# ignore page bar.vue
app/pages/bar.vue
# ignore page inside ignore folder
app/pages/ignore/*.vue

# ignore route middleware files under foo folder except foo/bar.js
app/middleware/foo/*.js
!app/middleware/foo/bar.js
```

::read-more
---
icon: i-simple-icons-git
target: _blank
title: the git documentation
to: https://git-scm.com/docs/gitignore
---
Chi tiết hơn về thông số kỹ thuật có trong **tài liệu gitignore**.
::


# .nuxtrc

Tệp `.nuxtrc` có thể được sử dụng để cấu hình Nuxt với cú pháp phẳng. Nó dựa trên [`unjs/rc9`](https://github.com/unjs/rc9){rel="nofollow"}.

::tip
Đối với các cấu hình nâng cao hơn, hãy sử dụng [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config).
::

## Usage

```bash [.nuxtrc]
# Disable SSR
ssr=false

# Configuration for `@nuxt/devtools`
devtools.enabled=true

# Add Nuxt modules
modules[]=@nuxt/image
modules[]=nuxt-security
```

Nếu có, các thuộc tính trong tệp `nuxt.config` sẽ ghi đè các thuộc tính trong tệp `.nuxtrc`.

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config"}
Khám phá tất cả các tùy chọn có sẵn trong **tài liệu cấu hình Nuxt**.
::

## Global `.nuxtrc` File

Bạn cũng có thể tạo một tệp `.nuxtrc` toàn cục trong thư mục home của mình để áp dụng các cấu hình toàn cục.

- Trên macOS/Linux, tệp này nằm tại:
  ```md
  ~/.nuxtrc
  ```
- Trên Windows, nó nằm tại:
  ```md
  C:\Users\{username}\.nuxtrc
  ```

Tệp `.nuxtrc` toàn cục này cho phép bạn định nghĩa các cài đặt mặc định áp dụng cho tất cả các dự án Nuxt trên hệ thống của bạn. Tuy nhiên, các tệp `.nuxtrc` cấp dự án sẽ ghi đè các cài đặt toàn cục này, và `nuxt.config` sẽ ưu tiên hơn cả hai.


# nuxt.config.ts

The `nuxt.config` file extension can either be `.js`, `.ts` or `.mjs`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  // My Nuxt config
})
```

::tip
`defineNuxtConfig` helper is globally available without import.
::

You can explicitly import `defineNuxtConfig` from `nuxt/config` if you prefer:

```ts [nuxt.config.ts] twoslash
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  // My Nuxt config
})
```

::read-more{to="https://nuxt.com/docs/api/configuration/nuxt-config"}
Discover all the available options in the **Nuxt configuration** documentation.
::

To ensure your configuration is up to date, Nuxt will make a full restart when detecting changes in the main configuration file, the [`.env`](https://nuxt.com/docs/guide/directory-structure/env), [`.nuxtignore`](https://nuxt.com/docs/guide/directory-structure/nuxtignore) and [`.nuxtrc`](https://nuxt.com/docs/guide/directory-structure/nuxtrc) dotfiles.


# package.json

The minimal `package.json` of your Nuxt application should looks like:

```json [package.json]
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "nuxt": "latest",
    "vue": "latest",
    "vue-router": "latest"
  }
}
```

::read-more
---
icon: i-simple-icons-npm
target: _blank
to: https://docs.npmjs.com/cli/configuring-npm/package-json
---
Read more about the `package.json` file.
::


# tsconfig.json

Nuxt [automatically generates](https://nuxt.com/docs/guide/concepts/typescript) multiple TypeScript configuration files (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, `.nuxt/tsconfig.node.json` and `.nuxt/tsconfig.shared.json`) with the resolved aliases you are using in your Nuxt project, as well as with other sensible defaults.

You can benefit from this by creating a `tsconfig.json` in the root of your project with the following content:

```json [tsconfig.json]
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
```

::note
As you need to, you can customize the contents of this file. However, it is recommended that you don't overwrite `target`, `module` and `moduleResolution`.
::

::note
If you need to customize your `paths`, this will override the auto-generated path aliases. Instead, we recommend that you add any path aliases you need to the [`alias`](https://nuxt.com/docs/api/nuxt-config#alias) property within your `nuxt.config`, where they will get picked up and added to the auto-generated `tsconfig`.
::


# Events

Sử dụng sự kiện là một cách tuyệt vời để tách rời ứng dụng của bạn và cho phép giao tiếp linh hoạt và mô-đun hơn giữa các phần khác nhau của mã. Sự kiện có thể có nhiều trình nghe không phụ thuộc vào nhau. Ví dụ, bạn có thể muốn gửi email cho người dùng mỗi khi đơn hàng được giao. Thay vì ghép nối mã xử lý đơn hàng với mã email, bạn có thể phát ra một sự kiện mà trình nghe có thể nhận và sử dụng để gửi email.

Hệ thống sự kiện của Nuxt được hỗ trợ bởi [unjs/hookable](https://github.com/unjs/hookable){rel="nofollow"}, đây là thư viện tương tự hỗ trợ hệ thống hooks của Nuxt.

## Creating Events and Listeners

Bạn có thể tạo sự kiện tùy chỉnh của riêng mình bằng phương thức `hook`:

```ts
const nuxtApp = useNuxtApp()

nuxtApp.hook('app:user:registered', payload => {
  console.log('A new user has registered!', payload)
})
```

Để phát ra sự kiện và thông báo cho bất kỳ trình nghe nào, sử dụng `callHook`:

```ts
const nuxtApp = useNuxtApp()

await nuxtApp.callHook('app:user:registered', {
  id: 1,
  name: 'John Doe',
})
```

Bạn cũng có thể sử dụng đối tượng payload để cho phép giao tiếp hai chiều giữa emitter và listeners. Vì payload được truyền theo tham chiếu, một listener có thể sửa đổi nó để gửi dữ liệu trở lại emitter.

```ts
const nuxtApp = useNuxtApp()

nuxtApp.hook('app:user:registered', payload => {
  payload.message = 'Welcome to our app!'
})

const payload = {
  id: 1,
  name: 'John Doe',
}

await nuxtApp.callHook('app:user:registered', {
  id: 1,
  name: 'John Doe',
})

// payload.message will be 'Welcome to our app!'
```

::tip
Bạn có thể kiểm tra tất cả sự kiện bằng bảng điều khiển Hooks của **Nuxt DevTools**.
::

::read-more{to="https://nuxt.com/docs/guide/going-further/hooks"}
Tìm hiểu thêm về hooks tích hợp của Nuxt và cách mở rộng chúng
::


# Tính năng Thử nghiệm

Nuxt bao gồm các tính năng thử nghiệm mà bạn có thể bật trong tệp cấu hình của mình.

Về mặt nội bộ, Nuxt sử dụng `@nuxt/schema` để định nghĩa các tính năng thử nghiệm này. Bạn có thể tham khảo [API documentation](https://nuxt.com/docs/api/configuration/nuxt-config#experimental) hoặc [source code](https://github.com/nuxt/nuxt/blob/main/packages/schema/src/config/experimental.ts){rel="nofollow"} để biết thêm thông tin.

::note
Lưu ý rằng các tính năng này là thử nghiệm và có thể bị xóa hoặc sửa đổi trong tương lai.
::

## asyncContext

Bật ngữ cảnh async gốc để có thể truy cập được cho các composables lồng nhau trong Nuxt và Nitro. Điều này mở ra khả năng sử dụng composables bên trong các composables async và giảm khả năng gặp lỗi `Nuxt instance is unavailable`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    asyncContext: true
  }
})
```

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/20918
---
Xem giải thích đầy đủ trên pull-request GitHub.
::

## asyncEntry

Cho phép tạo điểm nhập async cho gói Vue, hỗ trợ module federation.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    asyncEntry: true
  }
})
```

## externalVue

Externalizes `vue`, `@vue/*` và `vue-router` khi xây dựng.

*Được bật theo mặc định.*

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    externalVue: true
  }
})
```

::warning
Tính năng này có thể sẽ bị xóa trong tương lai gần.
::

## emitRouteChunkError

Phát ra hook `app:chunkError` khi có lỗi tải các chunk vite/webpack. Hành vi mặc định là thực hiện tải lại tuyến đường mới khi điều hướng đến tuyến đường mới khi chunk không tải được.

Nếu bạn đặt thành `'automatic-immediate'`, Nuxt sẽ tải lại tuyến đường hiện tại ngay lập tức, thay vì chờ điều hướng. Điều này hữu ích cho các lỗi chunk không được kích hoạt bởi điều hướng, ví dụ như khi ứng dụng Nuxt của bạn không tải được [lazy component](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports). Một nhược điểm tiềm ẩn của hành vi này là các lần tải lại không mong muốn, ví dụ như khi ứng dụng của bạn không cần chunk gây ra lỗi.

Bạn có thể vô hiệu hóa xử lý tự động bằng cách đặt thành `false`, hoặc xử lý lỗi chunk theo cách thủ công bằng cách đặt thành `manual`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    emitRouteChunkError: 'automatic' // hoặc 'automatic-immediate', 'manual' hoặc false
  }
})
```

## restoreState

Cho phép trạng thái ứng dụng Nuxt được khôi phục từ `sessionStorage` khi tải lại trang sau lỗi chunk hoặc lệnh [`reloadNuxtApp()`](https://nuxt.com/docs/api/utils/reload-nuxt-app) thủ công.

Để tránh lỗi hydration, nó sẽ chỉ được áp dụng sau khi ứng dụng Vue đã được gắn kết, nghĩa là có thể có một hiệu ứng nhấp nháy khi tải ban đầu.

::important
Hãy cân nhắc cẩn thận trước khi bật tính năng này vì nó có thể gây ra hành vi không mong muốn,
và hãy cân nhắc cung cấp các khóa rõ ràng cho [`useState`](https://nuxt.com/docs/api/composables/use-state) vì các khóa tự động có thể không khớp qua các bản dựng.
::

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    restoreState: true
  }
})
```

## inlineRouteRules

Định nghĩa quy tắc tuyến đường ở cấp độ trang bằng cách sử dụng [`defineRouteRules`](https://nuxt.com/docs/api/utils/define-route-rules).

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    inlineRouteRules: true
  }
})
```

Các quy tắc tuyến đường phù hợp sẽ được tạo, dựa trên `path` của trang.

::read-more
---
icon: i-lucide-square-function
to: https://nuxt.com/docs/api/utils/define-route-rules
---
Đọc thêm trong tiện ích `defineRouteRules`.
::

::read-more
---
icon: i-lucide-medal
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
::

## renderJsonPayloads

Cho phép hiển thị các payload JSON với hỗ trợ phục hồi các loại phức tạp.

*Được bật theo mặc định.*

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    renderJsonPayloads: true
  }
})
```

## noVueServer

Vô hiệu hóa điểm cuối renderer Vue server trong Nitro.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    noVueServer: true
  }
})
```

## payloadExtraction

Cho phép trích xuất payload của các trang được tạo với `nuxt generate`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    payloadExtraction: true
  }
})
```

## clientFallback

Cho phép thành phần thử nghiệm [`<NuxtClientFallback>`](https://nuxt.com/docs/api/components/nuxt-client-fallback) để hiển thị nội dung trên client nếu có lỗi trong SSR.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    clientFallback: true
  }
})
```

## crossOriginPrefetch

Cho phép prefetch cross-origin bằng Speculation Rules API.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    crossOriginPrefetch: true
  }
})
```

::read-more
---
icon: i-simple-icons-w3c
target: _blank
to: https://wicg.github.io/nav-speculation/prefetch.html
---
Đọc thêm về **Speculation Rules API**.
::

## viewTransition

Cho phép tích hợp View Transition API với router phía client.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    viewTransition: true
  }
})
```

::link-example
---
target: _blank
to: https://stackblitz.com/edit/nuxt-view-transitions?file=app.vue
---
::

::read-more
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API
---
Đọc thêm về **View Transition API**.
::

## writeEarlyHints

Cho phép ghi early hints khi sử dụng server node.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    writeEarlyHints: true
  }
})
```

## componentIslands

Cho phép hỗ trợ component islands thử nghiệm với [`<NuxtIsland>`](https://nuxt.com/docs/api/components/nuxt-island) và các tệp `.island.vue`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    componentIslands: true // false hoặc 'local+remote'
  }
})
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/components#server-components
---
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/issues/19772
---
Bạn có thể theo dõi roadmap server components trên GitHub.
::

## localLayerAliases

Giải quyết các bí danh `~`, `~~`, `@` và `@@` nằm trong các layers với sự tôn trọng đến nguồn và thư mục gốc của layer.

*Được bật theo mặc định.*

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    localLayerAliases: true
  }
})
```

## typedPages

Bật router typed thử nghiệm mới bằng cách sử dụng [`unplugin-vue-router`](https://github.com/posva/unplugin-vue-router){rel="nofollow"}.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    typedPages: true
  }
})
```

Theo mặc định, điều này sẽ bật việc sử dụng typed cho [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to), [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link), [`router.push()`](https://nuxt.com/docs/api/composables/use-router) và nhiều hơn nữa.

Bạn thậm chí có thể nhận typed params trong một trang bằng cách sử dụng `const route = useRoute('route-name')`.

::important
Nếu bạn sử dụng `pnpm` mà không có `shamefully-hoist=true`, bạn sẽ cần cài đặt `unplugin-vue-router` làm devDependency để tính năng này hoạt động.
::

::video-accordion
---
title: Xem video từ Daniel Roe giải thích routing type-safe trong Nuxt
video-id: SXk-L19gTZk
---
::

## watcher

Đặt một watcher thay thế sẽ được sử dụng làm dịch vụ giám sát cho Nuxt.

Nuxt sử dụng `chokidar-granular` theo mặc định, sẽ bỏ qua các thư mục cấp cao
như `node_modules` và `.git` khỏi giám sát.

Bạn có thể đặt thành `parcel` để sử dụng `@parcel/watcher`, có thể cải thiện
hiệu suất trong các dự án lớn hoặc trên nền tảng Windows.

Bạn cũng có thể đặt thành `chokidar` để giám sát tất cả các tệp trong thư mục nguồn của bạn.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    watcher: 'chokidar-granular' // 'chokidar' hoặc 'parcel' cũng là tùy chọn
  }
})
```

## sharedPrerenderData

Nuxt tự động chia sẻ dữ liệu *payload* giữa các trang được prerender. Điều này có thể dẫn đến cải thiện hiệu suất đáng kể khi prerender các trang sử dụng `useAsyncData` hoặc `useFetch` và tìm nạp cùng dữ liệu trong các trang khác nhau.

Bạn có thể vô hiệu hóa tính năng này nếu cần.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

::video-accordion
---
title: Xem video từ Alexander Lichter về experimental sharedPrerenderData
video-id: 1jUupYHVvrU
---
::

Điều đặc biệt quan trọng khi bật tính năng này là đảm bảo rằng bất kỳ khóa duy nhất nào của dữ liệu
luôn có thể giải quyết được đến cùng một dữ liệu. Ví dụ, nếu bạn đang sử dụng `useAsyncData` để tìm nạp
dữ liệu liên quan đến một trang cụ thể, bạn nên cung cấp một khóa duy nhất khớp với dữ liệu đó. (`useFetch`
nên làm điều này tự động cho bạn.)

```ts
// Điều này sẽ không an toàn trong một trang động (ví dụ như `[slug].vue`) vì slug tuyến đường làm cho sự khác biệt
// đến dữ liệu được tìm nạp, nhưng Nuxt không thể biết điều đó vì nó không được phản ánh trong khóa.
// Thay vào đó, bạn nên sử dụng một khóa duy nhất xác định dữ liệu được tìm nạp.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Thay vào đó, bạn nên sử dụng một khóa duy nhất xác định dữ liệu được tìm nạp.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

## clientNodeCompat

Với tính năng này, Nuxt sẽ tự động polyfill các import Node.js trong bản dựng client bằng cách sử dụng [`unenv`](https://github.com/unjs/unenv){rel="nofollow"}.

::note
Để làm cho các globals như `Buffer` hoạt động trong trình duyệt, bạn cần tự động inject chúng.

```ts
import { Buffer } from 'node:buffer'

globalThis.Buffer = globalThis.Buffer || Buffer
```
::

## scanPageMeta

Nuxt hiển thị một số metadata tuyến đường được định nghĩa trong `definePageMeta` tại build-time cho các modules (cụ thể là `alias`, `name`, `path`, `redirect`, `props` và `middleware`).

Điều này chỉ hoạt động với static hoặc strings/arrays chứ không phải biến hoặc gán có điều kiện. Xem [issue gốc](https://github.com/nuxt/nuxt/issues/24770){rel="nofollow"} để biết thêm thông tin và ngữ cảnh.

Theo mặc định, metadata trang chỉ được quét sau khi tất cả các tuyến đường đã được đăng ký trong `pages:extend`. Sau đó, một hook khác, `pages:resolved` sẽ được gọi.

Bạn có thể vô hiệu hóa tính năng này nếu nó gây ra vấn đề trong dự án của bạn.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: false
  }
})
```

## cookieStore

Cho phép hỗ trợ CookieStore để lắng nghe các cập nhật cookie (nếu được hỗ trợ bởi trình duyệt) và làm mới giá trị ref của `useCookie`.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    cookieStore: true
  }
})
```

::read-more
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/CookieStore
---
Đọc thêm về **CookieStore**.
::

## buildCache

Lưu trữ các artifact xây dựng Nuxt dựa trên hash của cấu hình và tệp nguồn.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    buildCache: true
  }
})
```

Khi được bật, các thay đổi đối với các tệp sau sẽ kích hoạt việc xây dựng lại đầy đủ:

```bash [Cấu trúc thư mục]
.nuxtrc
.npmrc
package.json
package-lock.json
yarn.lock
pnpm-lock.yaml
tsconfig.json
bun.lock
bun.lockb
```

Ngoài ra, bất kỳ thay đổi nào đối với tệp trong `srcDir` sẽ kích hoạt việc xây dựng lại gói Vue client/server. Nitro sẽ luôn được xây dựng lại (mặc dù công việc đang được tiến hành để cho phép Nitro thông báo các artifact có thể lưu trữ và hash của chúng).

::note
Một tối đa 10 tarball cache được giữ lại.
::

## extraPageMetaExtractionKeys

Macro `definePageMeta()` là một cách hữu ích để thu thập meta build-time về các trang. Nuxt cung cấp một danh sách khóa được hỗ trợ để hỗ trợ một số tính năng nội bộ như chuyển hướng, bí danh trang và đường dẫn tùy chỉnh.

Tùy chọn này cho phép truyền các khóa bổ sung để trích xuất từ metadata trang khi sử dụng `scanPageMeta`.

```vue
<script lang="ts" setup>
definePageMeta({
  foo: 'bar'
})
</script>
```

```ts
export default defineNuxtConfig({
  experimental: {
    extraPageMetaExtractionKeys: ['foo'],
  },
  hooks: {
    'pages:resolved' (ctx) {
      // ✅ foo có sẵn
    },
  },
})
```

Điều này cho phép các modules truy cập metadata bổ sung từ metadata trang trong ngữ cảnh xây dựng. Nếu bạn đang sử dụng điều này trong một module, bạn nên [tăng cường các loại `NuxtPage` với các khóa của bạn](https://nuxt.com/docs/guide/directory-structure/pages#typing-custom-metadata).

## normalizeComponentNames

Nuxt cập nhật các tên component Vue được tạo tự động để khớp với tên component đầy đủ mà bạn sẽ sử dụng để auto-import component.

Nếu bạn gặp vấn đề, bạn có thể vô hiệu hóa tính năng này.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

Theo mặc định, nếu bạn chưa đặt thủ công, Vue sẽ gán một tên component khớp
với tên tệp của component.

```bash [Cấu trúc thư mục]
├─ components/
├─── SomeFolder/
├───── MyComponent.vue
```

Trong trường hợp này, tên component sẽ là `MyComponent`, theo quan điểm của Vue. Nếu bạn muốn sử dụng `<KeepAlive>` với nó, hoặc xác định nó trong Vue DevTools, bạn sẽ cần sử dụng component đó.

Nhưng để auto-import nó, bạn sẽ cần sử dụng `SomeFolderMyComponent`.

Bằng cách đặt `experimental.normalizeComponentNames`, hai giá trị này khớp nhau, và Vue sẽ tạo ra một tên component khớp với pattern đặt tên component của Nuxt.

## spaLoadingTemplateLocation

Khi hiển thị một trang chỉ client (với `ssr: false`), chúng tôi tùy chọn hiển thị màn hình tải (từ `~/spa-loading-template.html`).

Nó có thể được đặt thành `within`, sẽ hiển thị như thế này:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Ngoài ra, bạn có thể hiển thị template cùng với root ứng dụng Nuxt bằng cách đặt thành `body`:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

Điều này tránh hiệu ứng nhấp nháy trắng khi hydrate một trang chỉ client.

## browserDevtoolsTiming

Cho phép các marker hiệu suất cho các hook Nuxt trong devtools trình duyệt. Điều này thêm các marker hiệu suất mà bạn có thể theo dõi trong tab Performance của các trình duyệt dựa trên Chromium, điều này hữu ích cho việc gỡ lỗi và tối ưu hóa hiệu suất.

Điều này được bật theo mặc định trong chế độ phát triển. Nếu bạn cần vô hiệu hóa tính năng này, có thể làm như vậy:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    browserDevtoolsTiming: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/29922
---
Xem PR #29922 để biết chi tiết triển khai.
::

::read-more
---
color: gray
icon: i-simple-icons-googlechrome
target: _blank
to: https://developer.chrome.com/docs/devtools/performance/extension#tracks
---
Tìm hiểu thêm về Chrome DevTools Performance API.
::

## debugModuleMutation

Ghi lại các đột biến đến `nuxt.options` trong ngữ cảnh module, giúp gỡ lỗi các thay đổi cấu hình được thực hiện bởi các modules trong giai đoạn khởi tạo Nuxt.

Điều này được bật theo mặc định khi chế độ `debug` được bật. Nếu bạn cần vô hiệu hóa tính năng này, có thể làm như vậy:

Để bật rõ ràng:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    debugModuleMutation: true
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/30555
---
Xem PR #30555 để biết chi tiết triển khai.
::

## lazyHydration

Điều này cho phép các chiến lược hydration cho các component `<Lazy>`, cải thiện hiệu suất bằng cách trì hoãn hydration của các component cho đến khi chúng được cần.

Lazy hydration được bật theo mặc định, nhưng bạn có thể vô hiệu hóa tính năng này:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    lazyHydration: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
to: https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration
---
Đọc thêm về lazy hydration.
::

## templateImportResolution

Kiểm soát cách các import trong template Nuxt được giải quyết. Theo mặc định, Nuxt cố gắng giải quyết các import trong template tương đối với module đã thêm chúng.

Điều này được bật theo mặc định, vì vậy nếu bạn đang gặp vấn đề giải quyết trong một số môi trường nhất định, bạn có thể vô hiệu hóa hành vi này:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    templateImportResolution: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/31175
---
Xem PR #31175 để biết chi tiết triển khai.
::

## decorators

Tùy chọn này cho phép bật cú pháp decorator trên toàn bộ ứng dụng Nuxt/Nitro của bạn, được cung cấp bởi [esbuild](https://github.com/evanw/esbuild/releases/tag/v0.21.3){rel="nofollow"}.

Trong một thời gian dài, TypeScript đã có hỗ trợ cho decorators thông qua `compilerOptions.experimentalDecorators`. Việc triển khai này được dự định trước quá trình tiêu chuẩn hóa TC39. Bây giờ, decorators là một [Đề xuất Stage 3](https://github.com/tc39/proposal-decorators){rel="nofollow"}, và được hỗ trợ mà không cần cấu hình đặc biệt trong TS 5.0+ (xem <https://github.com/microsoft/TypeScript/pull/52582>{rel="nofollow"} và <https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#decorators>{rel="nofollow"}).

Bật `experimental.decorators` cho phép hỗ trợ cho đề xuất TC39, **KHÔNG** phải cho việc triển khai `compilerOptions.experimentalDecorators` trước đây của TypeScript.

::warning
Lưu ý rằng có thể có thay đổi trước khi điều này cuối cùng được đưa vào tiêu chuẩn JS.
::

### Cách sử dụng

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    decorators: true,
  },
})
```

```ts [app.vue]
function something (_method: () => unknown) {
  return () => 'decorated'
}

class SomeClass {
  @something
  public someMethod () {
    return 'initial'
  }
}

const value = new SomeClass().someMethod()
// điều này sẽ trả về 'decorated'
```

## purgeCachedData

Nuxt sẽ tự động xóa dữ liệu được lưu trữ từ `useAsyncData` và `nuxtApp.static.data`. Điều này giúp ngăn chặn rò rỉ bộ nhớ
và đảm bảo dữ liệu mới được tải khi cần, nhưng có thể vô hiệu hóa:

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    purgeCachedData: false
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/31379
---
Xem PR #31379 để biết chi tiết triển khai.
::

## granularCachedData

Có nên gọi và sử dụng kết quả từ `getCachedData` khi làm mới dữ liệu cho `useAsyncData` và `useFetch` (cho dù bởi `watch`, `refreshNuxtData()`, hoặc một lệnh `refresh()` thủ công.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    granularCachedData: true
  }
})
```

::read-more
---
color: gray
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/pull/31373
---
Xem PR #31373 để biết chi tiết triển khai.
::

## pendingWhenIdle

Nếu được đặt thành `false`, object `pending` được trả về từ `useAsyncData`, `useFetch`, `useLazyAsyncData` và `useLazyFetch` sẽ là một computed property chỉ `true` khi `status` cũng pending.

Điều đó có nghĩa là khi `immediate: false` được truyền, `pending` sẽ là `false` cho đến khi yêu cầu đầu tiên được thực hiện.

```ts [nuxt.config.ts] twoslash
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: false
  }
})
```


# Features

Một số tính năng của Nuxt có sẵn theo cơ chế opt-in, hoặc có thể bị tắt dựa trên nhu cầu của bạn.

## `features`

### inlineStyles

Inline styles khi render HTML. Hiện tại chỉ khả dụng khi sử dụng Vite.

Bạn cũng có thể truyền một hàm nhận đường dẫn của một Vue component và trả về một boolean chỉ ra liệu có inline styles cho component đó hay không.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    inlineStyles: false // or a function to determine inlining
  }
})
```

### noScripts

Tắt việc render Nuxt scripts và JS resource hints. Cũng có thể được cấu hình chi tiết trong `routeRules`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    noScripts: true
  }
})
```

## `future`

Cũng có namespace `future` để opt-in sớm vào các tính năng mới sẽ trở thành mặc định trong phiên bản tương lai (có thể là major) của framework.

### compatibilityVersion

Điều này được sử dụng để kích hoạt truy cập sớm vào các tính năng hoặc cờ của Nuxt.

Nó chưa thể cấu hình trong Nuxt 4, nhưng một khi chúng ta bắt đầu merge các thay đổi breaking cho v5, nó sẽ có thể kích hoạt.

### typescriptBundlerResolution

Điều này kích hoạt chế độ phân giải module 'Bundler' cho TypeScript, là cài đặt được khuyến nghị
cho các framework như Nuxt và [Vite](https://vite.dev/guide/performance.html#reduce-resolve-operations){rel="nofollow"}.

Nó cải thiện hỗ trợ type khi sử dụng các thư viện hiện đại với `exports`.

Xem [pull request gốc của TypeScript](https://github.com/microsoft/TypeScript/pull/51669){rel="nofollow"}.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    typescriptBundlerResolution: true
  }
})
```


# How Nuxt Works?

Hướng dẫn này giúp bạn hiểu rõ hơn về các phần nội bộ của Nuxt để phát triển các giải pháp mới và tích hợp module trên Nuxt.

## The Nuxt Interface

Khi bạn khởi động Nuxt ở chế độ phát triển với [`nuxt dev`](https://nuxt.com/docs/api/commands/dev) hoặc xây dựng ứng dụng sản xuất với [`nuxt build`](https://nuxt.com/docs/api/commands/build),
một ngữ cảnh chung sẽ được tạo, được gọi là `nuxt` nội bộ. Nó chứa các tùy chọn được chuẩn hóa được hợp nhất với tệp `nuxt.config`,
một số trạng thái nội bộ, và một hệ thống hooking mạnh mẽ [hooking system](https://nuxt.com/docs/api/advanced/hooks) được cung cấp bởi [unjs/hookable](https://github.com/unjs/hookable){rel="nofollow"}
cho phép các thành phần khác nhau giao tiếp với nhau. Bạn có thể nghĩ về nó như **Builder Core**.

Ngữ cảnh này có sẵn toàn cầu để sử dụng với các composables [Nuxt Kit](https://nuxt.com/docs/guide/going-further/kit).
Do đó, chỉ một instance của Nuxt được phép chạy mỗi process.

Để mở rộng giao diện Nuxt và hook vào các giai đoạn khác nhau của quá trình xây dựng, chúng ta có thể sử dụng [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules).

Để biết thêm chi tiết, hãy xem [mã nguồn](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/core/nuxt.ts){rel="nofollow"}.

## The NuxtApp Interface

Khi hiển thị một trang trong trình duyệt hoặc trên server, một ngữ cảnh chia sẻ sẽ được tạo, được gọi là `nuxtApp`.
Ngữ cảnh này giữ instance vue, các hook runtime, và các trạng thái nội bộ như ssrContext và payload cho hydration.
Bạn có thể nghĩ về nó như **Runtime Core**.

Ngữ cảnh này có thể được truy cập bằng cách sử dụng composable [`useNuxtApp()`](https://nuxt.com/docs/api/composables/use-nuxt-app) trong các plugin Nuxt và `<script setup>` và các composables vue.
Việc sử dụng toàn cầu có thể cho trình duyệt nhưng không phải cho server, để tránh chia sẻ ngữ cảnh giữa các người dùng.

Vì [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) ném ngoại lệ nếu ngữ cảnh hiện tại không khả dụng, nếu composable của bạn không luôn yêu cầu `nuxtApp`, bạn có thể sử dụng [`tryUseNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app#tryusenuxtapp) thay vào đó, sẽ trả về `null` thay vì ném ngoại lệ.

Để mở rộng giao diện `nuxtApp` và hook vào các giai đoạn khác nhau hoặc truy cập ngữ cảnh, chúng ta có thể sử dụng [Nuxt Plugins](https://nuxt.com/docs/guide/directory-structure/plugins).

Kiểm tra [Nuxt App](https://nuxt.com/docs/api/composables/use-nuxt-app) để biết thêm thông tin về giao diện này.

`nuxtApp` có các thuộc tính sau:

```js
const nuxtApp = {
  vueApp, // ứng dụng Vue toàn cầu: https://vuejs.org/api/application.html#application-api

  versions, // một object chứa các phiên bản Nuxt và Vue

  // Những cái này cho phép bạn gọi và thêm các hook NuxtApp runtime
  // https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts#L18
  hooks,
  hook,
  callHook,

  // Chỉ truy cập được ở phía server
  ssrContext: {
    url,
    req,
    res,
    runtimeConfig,
    noSSR,
  },

  // Điều này sẽ được stringified và truyền từ server đến client
  payload: {
    serverRendered: true,
    data: {},
    state: {}
  }

  provide: (name: string, value: any) => void
}
```

Để biết thêm chi tiết, hãy xem [mã nguồn](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts){rel="nofollow"}.

## Runtime Context vs. Build Context

Nuxt xây dựng và bundle dự án bằng Node.js nhưng cũng có phía runtime.

Mặc dù cả hai khu vực đều có thể được mở rộng, ngữ cảnh runtime được cô lập khỏi build-time. Do đó, chúng không được chia sẻ trạng thái, mã, hoặc ngữ cảnh ngoài cấu hình runtime!

`nuxt.config` và [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules) có thể được sử dụng để mở rộng ngữ cảnh build, và [Nuxt Plugins](https://nuxt.com/docs/guide/directory-structure/plugins) có thể được sử dụng để mở rộng runtime.

Khi xây dựng ứng dụng cho sản xuất, `nuxt build` sẽ tạo một bản dựng độc lập trong thư mục `.output`, độc lập với `nuxt.config` và [các module Nuxt](https://nuxt.com/docs/guide/going-further/modules).


# Runtime Config

## Exposing

Để expose config và environment variables cho phần còn lại của ứng dụng, bạn sẽ cần định nghĩa runtime configuration trong tệp [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) của bạn, sử dụng tùy chọn [`runtimeConfig`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig).

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // The private keys which are only available within server-side
    apiSecret: '123',
    // Keys within public, will be also exposed to the client-side
    public: {
      apiBase: '/api'
    }
  }
})
```

Khi thêm `apiBase` vào `runtimeConfig.public`, Nuxt thêm nó vào mỗi page payload. Chúng ta có thể universally access `apiBase` trong cả server và browser.

```ts
const runtimeConfig = useRuntimeConfig()

console.log(runtimeConfig.apiSecret)
console.log(runtimeConfig.public.apiBase)
```

::tip
Public runtime config có thể truy cập trong Vue templates với `$config.public`.
::

### Serialization

Runtime config của bạn sẽ được serialized trước khi được truyền đến Nitro. Điều này có nghĩa là bất kỳ thứ gì không thể serialized và deserialized (như functions, Sets, Maps, và tương tự), không nên được đặt trong `nuxt.config` của bạn.

Thay vì truyền non-serializable objects hoặc functions vào ứng dụng của bạn từ `nuxt.config`, bạn có thể đặt code này trong một Nuxt hoặc Nitro plugin hoặc middleware.

### Environment Variables

Cách phổ biến nhất để cung cấp configuration là sử dụng [Environment Variables](https://medium.com/chingu/an-introduction-to-environment-variables-and-how-to-use-them-f602f66d15fa){rel="nofollow"}.

::note
CLI Nuxt có built-in support để đọc tệp `.env` của bạn trong development, build và generate. Nhưng khi bạn chạy server built của mình, **tệp `.env` của bạn sẽ không được đọc**.

  :::read-more{to="https://nuxt.com/docs/guide/directory-structure/env"}
  :::
::

Runtime config values được **tự động thay thế bởi matching environment variables tại runtime**.

Có hai yêu cầu chính:

1. Các biến mong muốn của bạn phải được định nghĩa trong `nuxt.config` của bạn. Điều này đảm bảo rằng arbitrary environment variables không được expose cho code ứng dụng của bạn.
2. Chỉ một environment variable đặc biệt named mới có thể override một runtime config property. Đó là một uppercase environment variable bắt đầu với `NUXT_` sử dụng `_` để tách keys và case changes.

::warning
Đặt default của `runtimeConfig` values thành *differently named environment variables* (ví dụ đặt `myVar` thành `process.env.OTHER_VARIABLE`) sẽ chỉ hoạt động trong build-time và sẽ break trên runtime.
Bạn nên sử dụng environment variables khớp với cấu trúc của object `runtimeConfig` của bạn.
::

::tip{icon="i-lucide-video" target="_blank" to="https://youtu.be/_FYV5WfiWvs"}
Xem video từ Alexander Lichter showcasing top mistake developers make using runtimeConfig.
::

#### Example

```ini [.env]
NUXT_API_SECRET=api_secret_token
NUXT_PUBLIC_API_BASE=https://nuxtjs.org
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    apiSecret: '', // can be overridden by NUXT_API_SECRET environment variable
    public: {
      apiBase: '', // can be overridden by NUXT_PUBLIC_API_BASE environment variable
    }
  },
})
```

## Reading

### Vue App

Trong Vue part của Nuxt app của bạn, bạn sẽ cần gọi [`useRuntimeConfig()`](https://nuxt.com/docs/api/composables/use-runtime-config) để truy cập runtime config.

::important
Hành vi khác nhau giữa client-side và server-side:

- Trên client-side, chỉ keys trong `runtimeConfig.public` và `runtimeConfig.app` (được sử dụng bởi Nuxt internally) mới có sẵn, và object là cả writable và reactive.
- Trên server-side, toàn bộ runtime config có sẵn, nhưng nó là read-only để tránh sharing context.
::

```vue [pages/index.vue]
<script setup lang="ts">
const config = useRuntimeConfig()

console.log('Runtime config:', config)
if (import.meta.server) {
  console.log('API secret:', config.apiSecret)
}
</script>

<template>
  <div>
    <div>Check developer console!</div>
  </div>
</template>
```

::caution
**Lưu ý bảo mật:** Cẩn thận không expose runtime config keys cho client-side bằng cách render chúng hoặc pass chúng đến `useState`.
::

### Plugins

Nếu bạn muốn sử dụng runtime config trong bất kỳ (custom) plugin nào, bạn có thể sử dụng [`useRuntimeConfig()`](https://nuxt.com/docs/api/composables/use-runtime-config) bên trong hàm `defineNuxtPlugin` của bạn.

```ts [plugins/config.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const config = useRuntimeConfig()

  console.log('API base URL:', config.public.apiBase)
});
```

### Server Routes

Bạn có thể truy cập runtime config trong server routes cũng vậy bằng `useRuntimeConfig`.

```ts [server/api/test.ts]
export default defineEventHandler(async (event) => {
  const { apiSecret } = useRuntimeConfig(event)
  const result = await $fetch('https://my.api.com/test', {
    headers: {
      Authorization: `Bearer ${apiSecret}`
    }
  })
  return result
})
```

::note
Việc giving `event` như một argument cho `useRuntimeConfig` là optional, nhưng nó được khuyến khích để lấy runtime config được overwrite bởi [environment variables](https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables) cho server routes.
::

## Typing Runtime Config

Nuxt cố gắng tự động generate một typescript interface từ provided runtime config sử dụng [unjs/untyped](https://github.com/unjs/untyped){rel="nofollow"}.

Nhưng cũng có thể type runtime config của bạn manually:

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface RuntimeConfig {
    apiSecret: string
  }
  interface PublicRuntimeConfig {
    apiBase: string
  }
}
// It is always important to ensure you import/export something when augmenting a type
export {}
```

::note
`nuxt/schema` được cung cấp như một convenience cho end-users để truy cập version của schema được sử dụng bởi Nuxt trong project của họ. Module authors nên augment `@nuxt/schema` thay vào đó.
::


# Nightly Release Channel

Nuxt lands commits, improvements, và bug fixes mỗi ngày. Bạn có thể opt in để test chúng sớm hơn trước release tiếp theo.

Sau khi một commit được merge vào branch `main` của [nuxt/nuxt](https://github.com/nuxt/nuxt){rel="nofollow"} và **passes all tests**, chúng tôi trigger một automated npm release, sử dụng GitHub Actions.

Bạn có thể sử dụng các 'nightly' releases này để beta test các tính năng và thay đổi mới.

Phương pháp build và publishing và chất lượng của các 'nightly' releases này giống như stable ones. Sự khác biệt duy nhất là bạn nên thường xuyên check GitHub repository để cập nhật. Có một cơ hội nhỏ về regressions không được catch trong quá trình review và bởi automated tests. Do đó, chúng tôi internally sử dụng channel này để double-check mọi thứ trước mỗi release.

::note
Các tính năng chỉ có sẵn trên nightly release channel được mark với một alert trong documentation.
::

::warning
Kênh nightly release `latest` hiện tại đang tracking branch Nuxt v4, nghĩa là nó đặc biệt có khả năng có breaking changes ngay bây giờ — hãy cẩn thận! Bạn có thể opt in vào 3.x branch nightly releases với `"nuxt": "npm:nuxt-nightly@3x"`.
::

## Opting In

Cập nhật dependency `nuxt` bên trong `package.json`:

```diff [package.json]
{
  "devDependencies": {
--    "nuxt": "^4.0.0"
++    "nuxt": "npm:nuxt-nightly@latest"
  }
}
```

Xóa lockfile (`package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `bun.lock` hoặc `bun.lockb`) và reinstall dependencies.

## Opting Out

Cập nhật dependency `nuxt` bên trong `package.json`:

```diff [package.json]
{
  "devDependencies": {
--    "nuxt": "npm:nuxt-nightly@latest"
++    "nuxt": "^4.0.0"
  }
}
```

Xóa lockfile (`package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `bun.lock` hoặc `bun.lockb`) và reinstall dependencies.

## Using Nightly `@nuxt/cli`

Để thử phiên bản mới nhất của [nuxt/cli](https://github.com/nuxt/cli){rel="nofollow"}:

```bash [Terminal]
npx @nuxt/cli-nightly@latest [command]
```

::read-more{to="https://nuxt.com/docs/api/commands"}
Đọc thêm về các commands có sẵn.
::


# Lifecycle Hooks

::tip
Hệ thống hooking được cung cấp bởi [unjs/hookable](https://github.com/unjs/hookable){rel="nofollow"}.
::

## Nuxt Hooks (Build Time)

Các hooks này có sẵn cho [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules) và ngữ cảnh build.

### Within `nuxt.config.ts`

```js [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    close: () => { }
  }
})
```

### Within Nuxt Modules

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async () => { })
  }
})
```

::read-more{to="https://nuxt.com/docs/api/advanced/hooks#nuxt-hooks-build-time"}
Khám phá tất cả các hook Nuxt có sẵn.
::

## App Hooks (Runtime)

App hooks chủ yếu có thể được sử dụng bởi [Nuxt Plugins](https://nuxt.com/docs/guide/directory-structure/plugins) để hook vào vòng đời rendering nhưng cũng có thể được sử dụng trong Vue composables.

```js [plugins/test.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('page:start', () => {
    /* your code goes here */
  })
})
```

::read-more{to="https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime"}
Khám phá tất cả các App hooks có sẵn.
::

## Server Hooks (Runtime)

Các hooks này có sẵn cho [server plugins](https://nuxt.com/docs/guide/directory-structure/server#server-plugins) để hook vào hành vi runtime của Nitro.

```js [~/server/plugins/test.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:html', (html, { event }) => {
    console.log('render:html', html)
    html.bodyAppend.push('<hr>Appended by custom plugin')
  })

  nitroApp.hooks.hook('render:response', (response, { event }) => {
    console.log('render:response', response)
  })
})
```

::read-more
---
to: https://nuxt.com/docs/api/advanced/hooks#nitro-app-hooks-runtime-server-side
---
Tìm hiểu thêm về các hook vòng đời Nitro có sẵn.
::

## Adding Custom Hooks

Bạn có thể định nghĩa hỗ trợ hooks tùy chỉnh của riêng mình bằng cách mở rộng các giao diện hook của Nuxt.

```ts
import { HookResult } from "@nuxt/schema";

declare module '#app' {
  interface RuntimeNuxtHooks {
    'your-nuxt-runtime-hook': () => HookResult
  }
  interface NuxtHooks {
    'your-nuxt-hook': () => HookResult
  }
}

declare module 'nitropack/types' {
  interface NitroRuntimeHooks {
    'your-nitro-hook': () => void;
  }
}
```


# Module Author Guide

Nuxt's [configuration](https://nuxt.com/docs/api/nuxt-config) và [hooks](https://nuxt.com/docs/guide/going-further/hooks) systems làm cho việc tùy chỉnh mọi khía cạnh của Nuxt và thêm bất kỳ tích hợp nào bạn có thể cần (Vue plugins, CMS, server routes, components, logging, etc.) trở nên khả thi.

**Nuxt Modules** là các hàm chạy tuần tự khi khởi động Nuxt ở chế độ phát triển bằng `nuxt dev` hoặc xây dựng dự án cho sản xuất với `nuxt build`.
Với modules, bạn có thể đóng gói, kiểm tra đúng cách, và chia sẻ các giải pháp tùy chỉnh dưới dạng gói npm mà không thêm boilerplate không cần thiết vào dự án của bạn, hoặc yêu cầu thay đổi đối với Nuxt.

## Quick Start

Chúng tôi khuyên bạn nên bắt đầu với Nuxt Modules bằng cách sử dụng [starter template](https://github.com/nuxt/starter/tree/module){rel="nofollow"} của chúng tôi:

::code-group{sync="pm"}
```bash [npm]
npm create nuxt -- -t module my-module
```

```bash [yarn]
yarn create nuxt -t module my-module
```

```bash [pnpm]
pnpm create nuxt -t module my-module
```

```bash [bun]
bun create nuxt -t module my-module
```
::

Điều này sẽ tạo một dự án `my-module` với tất cả boilerplate cần thiết để phát triển và xuất bản module của bạn.

**Các bước tiếp theo:**

1. Mở `my-module` trong IDE yêu thích của bạn
2. Cài đặt dependencies bằng package manager yêu thích của bạn
3. Chuẩn bị các tệp cục bộ để phát triển bằng `npm run dev:prepare`
4. Làm theo tài liệu này để tìm hiểu thêm về Nuxt Modules

### Sử Dụng Starter

Tìm hiểu cách thực hiện các tác vụ cơ bản với module starter.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/navigating-the-official-starter-template?friend=nuxt
---
Xem video Vue School về template starter module chính thức.
::

#### How to Develop

Mặc dù mã nguồn module của bạn nằm trong thư mục `src`, trong hầu hết các trường hợp, để phát triển một module, bạn cần một ứng dụng Nuxt. Đó là lý do tại sao thư mục `playground` tồn tại. Đó là một ứng dụng Nuxt đã được cấu hình để chạy với module của bạn.

Bạn có thể tương tác với playground như với bất kỳ ứng dụng Nuxt nào.

- Khởi chạy server phát triển của nó với `npm run dev`, nó sẽ tự động tải lại khi bạn thực hiện thay đổi đối với module của mình trong thư mục `src`
- Xây dựng nó với `npm run dev:build`

::note
Tất cả các lệnh `nuxt` khác có thể được sử dụng đối với thư mục `playground` (ví dụ: `nuxt <COMMAND> playground`). Hãy tự do khai báo các script `dev:*` bổ sung trong `package.json` của bạn tham chiếu đến chúng để thuận tiện.
::

#### How to Test

Module starter đi kèm với một bộ test suite cơ bản:

- Một linter được cung cấp bởi [ESLint](https://eslint.org){rel="nofollow"}, chạy nó với `npm run lint`
- Một test runner được cung cấp bởi [Vitest](https://vitest.dev){rel="nofollow"}, chạy nó với `npm run test` hoặc `npm run test:watch`

::tip
Hãy tự do tăng cường chiến lược test mặc định này để phù hợp hơn với nhu cầu của bạn.
::

#### How to Build

Nuxt Modules đi kèm với một builder riêng được cung cấp bởi [`@nuxt/module-builder`](https://github.com/nuxt/module-builder#readme){rel="nofollow"}. Builder này không yêu cầu cấu hình nào trên phần bạn, hỗ trợ TypeScript, và đảm bảo tính tương thích của artifact xây dựng module của bạn với các ứng dụng Nuxt.

Bạn có thể xây dựng module của mình bằng cách chạy `npm run prepack`.

::tip
Mặc dù xây dựng module của bạn có thể hữu ích trong một số trường hợp, hầu hết thời gian bạn sẽ không cần xây dựng nó trên máy của mình: `playground` đảm nhận việc đó trong khi phát triển, và script release cũng có bạn bao phủ khi xuất bản.
::

#### How to Publish

::important
Trước khi xuất bản module của bạn lên npm, hãy đảm bảo bạn có tài khoản [npmjs.com](https://www.npmjs.com){rel="nofollow"} và được xác thực cục bộ với `npm login`.
::

Mặc dù bạn có thể xuất bản module của mình bằng cách tăng phiên bản và sử dụng lệnh `npm publish`, module starter đi kèm với một script release giúp bạn đảm bảo xuất bản một phiên bản hoạt động của module lên npm và hơn thế nữa.

Để sử dụng script release, trước tiên commit tất cả các thay đổi của bạn (chúng tôi khuyên bạn nên tuân theo [Conventional Commits](https://www.conventionalcommits.org){rel="nofollow"} để cũng tận dụng lợi thế của việc tăng phiên bản tự động và cập nhật changelog), sau đó chạy script release với `npm run release`.

Khi chạy script release, những điều sau sẽ xảy ra:

- Đầu tiên, nó sẽ chạy bộ test suite của bạn bằng cách:

  - Chạy linter (`npm run lint`)
  - Chạy unit, integration, và e2e tests (`npm run test`)
  - Xây dựng module (`npm run prepack`)
- Sau đó, nếu bộ test suite của bạn thành công, nó sẽ tiến hành xuất bản module của bạn bằng cách:

  - Tăng phiên bản module của bạn và tạo changelog theo Conventional Commits của bạn
  - Xuất bản module lên npm (đối với mục đích đó, module sẽ được xây dựng lại để đảm bảo phiên bản cập nhật của nó được tính đến trong artifact được xuất bản)
  - Đẩy một git tag đại diện cho phiên bản mới được xuất bản lên git remote origin của bạn

::tip
Như với các script khác, hãy tự do tinh chỉnh script `release` mặc định trong `package.json` của bạn để phù hợp hơn với nhu cầu của bạn.
::

## Developing Modules

Nuxt Modules đi kèm với nhiều API và pattern mạnh mẽ cho phép chúng thay đổi ứng dụng Nuxt theo bất kỳ cách nào có thể tưởng tượng. Phần này dạy bạn cách tận dụng những lợi thế đó.

### Module Anatomy

Chúng ta có thể coi hai loại Nuxt Modules:

- published modules được phân phối trên npm - bạn có thể thấy danh sách một số module cộng đồng trên [trang web Nuxt](https://nuxt.com/modules).
- "local" modules, chúng tồn tại trong ứng dụng Nuxt riêng lẻ, hoặc [inline trong Nuxt config](https://nuxt.com/docs/api/nuxt-config#modules) hoặc như một phần của [thư mục `modules`](https://nuxt.com/docs/guide/directory-structure/modules).

Trong cả hai trường hợp, anatomy của chúng tương tự.

#### Module Definition

::note
Khi sử dụng starter, định nghĩa module của bạn có sẵn tại `src/module.ts`.
::

Định nghĩa module là điểm nhập của module của bạn. Đó là những gì được tải bởi Nuxt khi module của bạn được tham chiếu trong cấu hình Nuxt.

Ở mức thấp, định nghĩa Nuxt Module là một hàm, có thể bất đồng bộ, chấp nhận tùy chọn inline và một object `nuxt` để tương tác với Nuxt.

```ts
export default function (inlineOptions, nuxt) {
  // Bạn có thể làm bất cứ điều gì ở đây..
  console.log(inlineOptions.token) // `123`
  console.log(nuxt.options.dev) // `true` hoặc `false`
  nuxt.hook('ready', async nuxt => {
    console.log('Nuxt đã sẵn sàng')
  })
}
```

Bạn có thể nhận hỗ trợ type-hint cho hàm này bằng cách sử dụng helper cấp cao hơn `defineNuxtModule` được cung cấp bởi [Nuxt Kit](https://nuxt.com/docs/guide/going-further/kit).

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule((options, nuxt) => {
  nuxt.hook('pages:extend', pages => {
    console.log(`Đã khám phá ${pages.length} trang`)
  })
})
```

Tuy nhiên, **chúng tôi không khuyến khích** sử dụng định nghĩa hàm cấp thấp này. Thay vào đó, để định nghĩa một module, **chúng tôi khuyến khích** sử dụng cú pháp object với thuộc tính `meta` để xác định module của bạn, đặc biệt khi xuất bản lên npm.

Helper này làm cho việc viết Nuxt modules trở nên đơn giản hơn bằng cách triển khai nhiều pattern phổ biến cần thiết cho modules, đảm bảo tương thích tương lai và cải thiện trải nghiệm cho cả tác giả module và người dùng.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    // Thường là tên gói npm của module của bạn
    name: '@nuxtjs/example',
    // Khóa trong `nuxt.config` giữ tùy chọn module của bạn
    configKey: 'sample',
    // Ràng buộc tương thích
    compatibility: {
      // Semver version của các phiên bản nuxt được hỗ trợ
      nuxt: '>=3.0.0'
    }
  },
  // Tùy chọn cấu hình mặc định cho module của bạn, cũng có thể là một hàm trả về những cái đó
  defaults: {},
  // Shorthand sugar để đăng ký Nuxt hooks
  hooks: {},
  // Hàm giữ logic module của bạn, nó có thể bất đồng bộ
  setup(moduleOptions, nuxt) {
    // ...
  }
})
```

Cuối cùng `defineNuxtModule` trả về một hàm wrapper với signature module cấp thấp `(inlineOptions, nuxt)`. Hàm wrapper này áp dụng defaults và các bước cần thiết khác trước khi gọi hàm `setup` của bạn:

- Hỗ trợ `defaults` và `meta.configKey` để tự động hợp nhất tùy chọn module
- Type hints và suy luận type tự động
- Shims cho tương thích Nuxt 2 cơ bản
- Thêm shims để đảm bảo module chỉ được cài đặt một lần bằng khóa duy nhất được tính từ `meta.name` hoặc `meta.configKey`
- Tự động đăng ký Nuxt hooks
- Tự động kiểm tra vấn đề tương thích dựa trên meta module
- Tích hợp với tooling builder module
- Đảm bảo tương thích ngược và tương thích tiến khi module đang sử dụng `defineNuxtModule` từ phiên bản mới nhất của `@nuxt/kit`
- Tích hợp với tooling builder module

#### Runtime Directory

::note
Khi sử dụng starter, thư mục runtime có sẵn tại `src/runtime`.
::

Modules, như mọi thứ trong cấu hình Nuxt, không được bao gồm trong runtime ứng dụng của bạn. Tuy nhiên, bạn có thể muốn module của mình cung cấp, hoặc inject runtime code vào ứng dụng mà nó được cài đặt. Đó là những gì thư mục runtime cho phép bạn làm.

Bên trong thư mục runtime, bạn có thể cung cấp bất kỳ loại assets nào liên quan đến Nuxt App:

- Vue components
- Composables
- [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins)

Đối với [server engine](https://nuxt.com/docs/guide/concepts/server-engine), Nitro:

- API routes
- Middlewares
- Nitro plugins

Hoặc bất kỳ loại asset nào bạn muốn inject vào ứng dụng Nuxt của người dùng:

- Stylesheets
- 3D models
- Images
- etc.

Bạn sẽ sau đó có thể inject tất cả những assets đó bên trong ứng dụng từ [định nghĩa module](https://nuxt.com/#module-definition) của bạn.

::tip
Tìm hiểu thêm về injection asset trong [phần recipes](https://nuxt.com/#recipes).
::

::warning
Published modules không thể tận dụng auto-imports cho assets trong thư mục runtime của chúng. Thay vào đó, chúng phải import chúng một cách rõ ràng từ `#imports` hoặc tương tự.

Thật vậy, auto-imports không được bật cho các tệp trong `node_modules` (vị trí mà một published module sẽ cuối cùng sống) vì lý do hiệu suất.
::

### Tooling

Modules đi kèm với một bộ công cụ first-party để giúp bạn với việc phát triển của chúng.

#### `@nuxt/module-builder`

[Nuxt Module Builder](https://github.com/nuxt/module-builder#readme){rel="nofollow"} là một công cụ xây dựng zero-configuration đảm nhận tất cả công việc nặng nhọc để xây dựng và ship module của bạn. Nó đảm bảo tính tương thích đúng cách của artifact xây dựng module của bạn với các ứng dụng Nuxt.

#### `@nuxt/kit`

[Nuxt Kit](https://nuxt.com/docs/guide/going-further/kit) cung cấp các composable tiện ích để giúp module của bạn tương tác với Nuxt applications. Bạn nên sử dụng các tiện ích Nuxt Kit thay vì các alternative thủ công bất cứ khi nào có thể để đảm bảo tương thích tốt hơn và khả năng đọc mã của module của bạn.

::read-more{to="https://nuxt.com/docs/guide/going-further/kit"}
::

#### `@nuxt/test-utils`

[Nuxt Test Utils](https://nuxt.com/docs/getting-started/testing) là một bộ sưu tập các tiện ích để giúp thiết lập và chạy Nuxt applications trong module tests của bạn.

### Recipes

Tìm ở đây các pattern phổ biến được sử dụng để tác giả modules.

#### Altering Nuxt Configuration

Cấu hình Nuxt có thể được đọc và thay đổi bởi modules. Đây là một ví dụ về module bật một tính năng thử nghiệm.

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // Chúng ta tạo object `experimental` nếu nó chưa tồn tại
    nuxt.options.experimental ||= {}
    nuxt.options.experimental.componentIslands = true
  }
})
```

Khi bạn cần xử lý các thay đổi cấu hình phức tạp hơn, bạn nên cân nhắc sử dụng [defu](https://github.com/unjs/defu){rel="nofollow"}.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/extending-and-altering-nuxt-configuration-and-options?friend=nuxt
---
Xem video Vue School về việc thay đổi cấu hình Nuxt.
::

#### Exposing Options to Runtime

Vì modules không phải là một phần của runtime ứng dụng, các tùy chọn của chúng cũng không phải. Tuy nhiên, trong nhiều trường hợp, bạn có thể cần truy cập một số tùy chọn module này trong runtime code của bạn. Chúng tôi khuyên bạn nên expose config cần thiết bằng cách sử dụng [`runtimeConfig`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig) của Nuxt.

```js
import { defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.options.runtimeConfig.public.myModule = defu(nuxt.options.runtimeConfig.public.myModule, {
      foo: options.foo
    })
  }
})
```

Lưu ý rằng chúng ta sử dụng [`defu`](https://github.com/unjs/defu){rel="nofollow"} để mở rộng public runtime configuration mà người dùng cung cấp thay vì ghi đè nó.

Bạn có thể sau đó truy cập tùy chọn module của mình trong một plugin, component, ứng dụng như bất kỳ runtime configuration nào khác:

```js
const options = useRuntimeConfig().public.myModule
```

::warning
Cẩn thận không expose các khóa runtime config cho client-side bằng cách render chúng hoặc pass chúng đến `useState`, vì chúng sẽ kết thúc trong bundle public.
::

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/passing-and-exposing-module-options?friend=nuxt
---
Xem video Vue School về việc truyền và expose tùy chọn module Nuxt.
::

#### Injecting Plugins With `addPlugin`

Plugins là một cách phổ biến cho một module để thêm logic runtime. Bạn có thể sử dụng tiện ích `addPlugin` để đăng ký chúng từ module của bạn.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // Tạo resolver để resolve các đường dẫn tương đối
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
  }
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/kit"}
::

#### Injecting Vue Components With `addComponent`

Nếu module của bạn nên cung cấp Vue components, bạn có thể sử dụng tiện ích `addComponent` để thêm chúng như auto-imports cho Nuxt resolve.

```js
import { defineNuxtModule, addComponent } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // Từ thư mục runtime
    addComponent({
      name: 'MySuperComponent', // tên của component để sử dụng trong vue templates
      export: 'MySuperComponent', // (tùy chọn) nếu component là một export có tên (không phải default) export
      filePath: resolver.resolve('runtime/components/MySuperComponent.vue')
    })

    // Từ một thư viện
    addComponent({
      name: 'MyAwesomeComponent', // tên của component để sử dụng trong vue templates
      export: 'MyAwesomeComponent', // (tùy chọn) nếu component là một export có tên (không phải default) export
      filePath: '@vue/awesome-components'
    })
  }
})
```

Ngoài ra, bạn có thể thêm toàn bộ thư mục bằng cách sử dụng `addComponentsDir`.

```ts
import { defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addComponentsDir({
      path: resolver.resolve('runtime/components')
    })
  }
})
```

#### Injecting Composables With `addImports` and `addImportsDir`

Nếu module của bạn nên cung cấp composables, bạn có thể sử dụng tiện ích `addImports` để thêm chúng như auto-imports cho Nuxt resolve.

```ts
import { defineNuxtModule, addImports, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports({
      name: 'useComposable', // tên của composable để sử dụng
      as: 'useComposable',
      from: resolver.resolve('runtime/composables/useComposable') // đường dẫn của composable
    })
  }
})
```

Ngoài ra, bạn có thể thêm toàn bộ thư mục bằng cách sử dụng `addImportsDir`.

```ts
import { defineNuxtModule, addImportsDir, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImportsDir(resolver.resolve('runtime/composables'))
  }
})
```

#### Injecting Server Routes With `addServerHandler`

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello',
      handler: resolver.resolve('./runtime/server/api/hello/index.get')
    })
  }
})
```

Bạn cũng có thể thêm một server route động:

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello/:name',
      handler: resolver.resolve('./runtime/server/api/hello/[name].get')
    })
  }
})
```

#### Injecting Other Assets

Nếu module của bạn nên cung cấp các loại assets khác, chúng cũng có thể được inject. Đây là một ví dụ module đơn giản inject một stylesheet thông qua array `css` của Nuxt.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.options.css.push(resolver.resolve('./runtime/style.css'))
  }
})
```

Và một cái nâng cao hơn, expose một thư mục assets thông qua tùy chọn `publicAssets` của [Nitro](https://nuxt.com/docs/guide/concepts/server-engine):

```js
import { defineNuxtModule, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('nitro:config', async (nitroConfig) => {
      nitroConfig.publicAssets ||= []
      nitroConfig.publicAssets.push({
        dir: resolver.resolve('./runtime/public'),
        maxAge: 60 * 60 * 24 * 365 // 1 năm
      })
    })
  }
})
```

#### Using Other Modules in Your Module

Nếu module của bạn phụ thuộc vào các module khác, bạn có thể thêm chúng bằng cách sử dụng tiện ích `installModule` của Nuxt Kit. Ví dụ, nếu bạn muốn sử dụng Nuxt Tailwind trong module của mình, bạn có thể thêm nó như dưới đây:

```ts
import { defineNuxtModule, createResolver, installModule } from '@nuxt/kit'

export default defineNuxtModule<ModuleOptions>({
  async setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // Chúng ta có thể inject tệp CSS của mình bao gồm các directives của Tailwind
    nuxt.options.css.push(resolver.resolve('./runtime/assets/styles.css'))

    await installModule('@nuxtjs/tailwindcss', {
      // cấu hình module
      exposeConfig: true,
      config: {
        darkMode: 'class',
        content: {
          files: [
            resolver.resolve('./runtime/components/**/*.{vue,mjs,ts}'),
            resolver.resolve('./runtime/*.{mjs,js,ts}')
          ]
        }
      }
    })
  }
})
```

#### Using Hooks

[Lifecycle hooks](https://nuxt.com/docs/guide/going-further/hooks) cho phép bạn mở rộng hầu hết mọi khía cạnh của Nuxt. Modules có thể hook đến chúng theo chương trình hoặc thông qua map `hooks` trong định nghĩa của chúng.

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  // Hook đến hook `app:error` thông qua map `hooks`
  hooks: {
    'app:error': (err) => {
      console.info(`Lỗi này đã xảy ra: ${err}`);
    }
  },
  setup (options, nuxt) {
    // Hook theo chương trình đến hook `pages:extend`
    nuxt.hook('pages:extend', (pages) => {
      console.info(`Đã khám phá ${pages.length} trang`);
    })
  }
})
```

::read-more{to="https://nuxt.com/docs/api/advanced/hooks"}
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/nuxt-lifecycle-hooks?friend=nuxt
---
Xem video Vue School về việc sử dụng lifecycle hooks Nuxt trong modules.
::

::note
**Module cleanup**

:br

:br

Nếu module của bạn mở, xử lý, hoặc bắt đầu một watcher, bạn nên đóng nó khi lifecycle Nuxt kết thúc. Hook `close` có sẵn cho điều này.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async nuxt => {
      // Mã tùy chỉnh của bạn ở đây
    })
  }
})
```
::

##### Custom Hooks

Modules cũng có thể định nghĩa và gọi hooks tùy chỉnh của riêng chúng, đó là một pattern mạnh mẽ để làm cho module của bạn có thể mở rộng.

Nếu bạn mong đợi các module khác có thể subscribe đến hooks của module của bạn, bạn nên gọi chúng trong hook `modules:done`. Điều này đảm bảo rằng tất cả các module khác đã có cơ hội được thiết lập và đăng ký listeners của chúng cho hook của bạn trong hàm `setup` riêng của chúng.

```ts
// my-module/module.ts
import { defineNuxtModule } from '@nuxt/kit'

export interface ModuleHooks {
  'my-module:custom-hook': (payload: { foo: string }) => void
}

export default defineNuxtModule({
  setup (options, nuxt) {
    // Gọi hook của bạn trong `modules:done`
    nuxt.hook('modules:done', async () => {
      const payload = { foo: 'bar' }
      await nuxt.callHook('my-module:custom-hook', payload)
    })
  }
})
```

#### Adding Templates/Virtual Files

Nếu bạn cần thêm một tệp ảo có thể được import vào ứng dụng của người dùng, bạn có thể sử dụng tiện ích `addTemplate`.

```ts
import { defineNuxtModule, addTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // Tệp được thêm vào virtual file system nội bộ của Nuxt và có thể được import từ '#build/my-module-feature.mjs'
    addTemplate({
      filename: 'my-module-feature.mjs',
      getContents: () => 'export const myModuleFeature = () => "hello world !"'
    })
  }
})
```

Đối với server, bạn nên sử dụng tiện ích `addServerTemplate` thay vào đó.

```ts
import { defineNuxtModule, addServerTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // Tệp được thêm vào virtual file system của Nitro và có thể được import trong server code từ 'my-server-module.mjs'
    addServerTemplate({
      filename: 'my-server-module.mjs',
      getContents: () => 'export const myServerModule = () => "hello world !"'
    })
  }
})
```

#### Adding Type Declarations

Bạn cũng có thể muốn thêm một type declaration vào dự án của người dùng (ví dụ, để augment một giao diện Nuxt
hoặc cung cấp một global type của riêng bạn). Đối với điều này, Nuxt cung cấp tiện ích `addTypeTemplate` để vừa
viết một template ra disk vừa thêm một reference đến nó trong tệp `nuxt.d.ts` được tạo.

Nếu module của bạn nên augment types được xử lý bởi Nuxt, bạn có thể sử dụng `addTypeTemplate` để thực hiện operation này:

```js
import { defineNuxtModule, addTemplate, addTypeTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    addTypeTemplate({
      filename: 'types/my-module.d.ts',
      getContents: () => `// Generated by my-module
        interface MyModuleNitroRules {
          myModule?: { foo: 'bar' }
        }
        declare module 'nitropack/types' {
          interface NitroRouteRules extends MyModuleNitroRules {}
          interface NitroRouteConfig extends MyModuleNitroRules {}
        }
        export {}`
    })
  }
})
```

Nếu bạn cần kiểm soát granular hơn, bạn có thể sử dụng hook `prepare:types` để đăng ký một callback sẽ inject types của bạn.

```ts
const template = addTemplate({ /* template options */ })
nuxt.hook('prepare:types', ({ references }) => {
  references.push({ path: template.dst })
})
```

##### Updating Templates

Nếu bạn cần cập nhật templates/virtual files của mình, bạn có thể tận dụng tiện ích `updateTemplates` như thế này :

```ts
nuxt.hook('builder:watch', async (event, path) => {
  if (path.includes('my-module-feature.config')) {
    // Điều này sẽ reload template mà bạn đã đăng ký
    updateTemplates({ filter: t => t.filename === 'my-module-feature.mjs' })
  }
})
```

### Testing

Testing giúp đảm bảo module của bạn hoạt động như mong đợi với nhiều setup. Tìm trong phần này cách thực hiện các loại test khác nhau đối với module của bạn.

#### Unit and Integration

::tip
Chúng tôi vẫn đang thảo luận và khám phá cách dễ dàng hóa unit và integration testing trên Nuxt Modules.
:br :br[Tham gia cuộc thảo luận trên GitHub RFC này](https://github.com/nuxt/nuxt/discussions/18399){rel="nofollow"}.
::

#### End to End

[Nuxt Test Utils](https://nuxt.com/docs/getting-started/testing) là công cụ go-to để giúp bạn test module của mình theo cách end-to-end. Đây là workflow để áp dụng:

1. Tạo một ứng dụng Nuxt để được sử dụng như một "fixture" bên trong `test/fixtures/*`
2. Thiết lập Nuxt với fixture đó bên trong tệp test của bạn
3. Tương tác với fixture bằng cách sử dụng utilities từ `@nuxt/test-utils` (ví dụ: fetching một trang)
4. Thực hiện checks liên quan đến fixture đó (ví dụ: "HTML chứa ...")
5. Lặp lại

Trong thực tế, fixture:

```js [test/fixtures/ssr/nuxt.config.ts]
// 1. Tạo một ứng dụng Nuxt để được sử dụng như một "fixture"
import MyModule from '../../../src/module'

export default defineNuxtConfig({
  ssr: true,
  modules: [
    MyModule
  ]
})
```

Và test của nó:

```js [test/rendering.ts]
import { describe, it, expect } from 'vitest'
import { fileURLToPath } from 'node:url'
import { setup, $fetch } from '@nuxt/test-utils/e2e'

describe('ssr', async () => {
  // 2. Thiết lập Nuxt với fixture đó bên trong tệp test của bạn
  await setup({
    rootDir: fileURLToPath(new URL('./fixtures/ssr', import.meta.url)),
  })

  it('renders the index page', async () => {
    // 3. Tương tác với fixture bằng cách sử dụng utilities từ `@nuxt/test-utils`
    const html = await $fetch('/')

    // 4. Thực hiện checks liên quan đến fixture đó
    expect(html).toContain('<div>ssr</div>')
  })
})

// 5. Lặp lại
describe('csr', async () => { /* ... */ })
```

::tip
Một ví dụ về workflow như vậy có sẵn trên [module starter](https://github.com/nuxt/starter/blob/module/test/basic.test.ts){rel="nofollow"}.
::

#### Manual QA With Playground and Externally

Có một ứng dụng Nuxt playground để test module của bạn khi phát triển nó là rất hữu ích. [Module starter tích hợp một cái cho mục đích đó](https://nuxt.com/#how-to-develop).

Bạn có thể test module của mình với các ứng dụng Nuxt khác (các ứng dụng không phải là một phần của repository module của bạn) cục bộ. Để làm điều đó, bạn có thể sử dụng lệnh [`npm pack`](https://docs.npmjs.com/cli/commands/npm-pack){rel="nofollow"} , hoặc equivalent của package manager của bạn, để tạo một tarball từ module của bạn. Sau đó trong dự án test của bạn, bạn có thể thêm module của mình vào `package.json` packages như: `"my-module": "file:/path/to/tarball.tgz"`.

Sau đó, bạn nên có thể tham chiếu `my-module` như trong bất kỳ dự án thông thường nào.

### Best Practices

Với sức mạnh lớn đi kèm trách nhiệm lớn. Mặc dù modules rất mạnh mẽ, đây là một số best practices để ghi nhớ trong khi tác giả modules để giữ cho các ứng dụng performant và trải nghiệm developer tuyệt vời.

#### Async Modules

Như chúng ta đã thấy, Nuxt Modules có thể bất đồng bộ. Ví dụ, bạn có thể muốn phát triển một module cần fetching một số API hoặc gọi một hàm async.

Tuy nhiên, hãy cẩn thận với behaviors bất đồng bộ vì Nuxt sẽ chờ module của bạn setup trước khi đi đến module tiếp theo và khởi động development server, build process, etc. Ưu tiên deferring logic tốn thời gian đến Nuxt hooks.

::warning
Nếu module của bạn mất hơn **1 giây** để setup, Nuxt sẽ emit một warning về nó.
::

#### Always Prefix Exposed Interfaces

Nuxt Modules nên cung cấp một prefix rõ ràng cho bất kỳ cấu hình, plugin, API, composable, hoặc component nào được expose để tránh conflict với các module khác và internals.

Lý tưởng nhất, bạn nên prefix chúng với tên module của bạn (ví dụ: nếu module của bạn được gọi là `nuxt-foo`, expose `<FooButton>` và `useFooBar()` và **không phải** `<Button>` và `useBar()`).

#### Be TypeScript Friendly

Nuxt có tích hợp TypeScript first-class cho trải nghiệm developer tốt nhất.

Exposing types và sử dụng TypeScript để phát triển modules mang lợi ích cho người dùng ngay cả khi không sử dụng TypeScript trực tiếp.

#### Avoid CommonJS Syntax

Nuxt dựa trên native ESM. Hãy đọc [Native ES Modules](https://nuxt.com/docs/guide/concepts/esm) để biết thêm thông tin.

#### Document Module Usage

Cân nhắc documenting việc sử dụng module trong tệp readme:

- Tại sao sử dụng module này?
- Làm thế nào để sử dụng module này?
- Module này làm gì?

Liên kết đến trang web tích hợp và documentation luôn là một ý tưởng tốt.

#### Provide a StackBlitz Demo or Boilerplate

Đây là một practice tốt để làm một minimal reproduction với module của bạn và [StackBlitz](https://nuxt.new/s/v4){rel="nofollow"} mà bạn thêm vào readme module của mình.

Điều này không chỉ cung cấp cho các potential users của module của bạn một cách nhanh chóng và dễ dàng để experiment với module mà còn một cách dễ dàng cho họ để build minimal reproductions họ có thể gửi cho bạn khi họ gặp issues.

#### Do Not Advertise With a Specific Nuxt Version

Nuxt, Nuxt Kit, và các tooling mới khác được làm để có tương thích forward và backward trong tâm trí.

Hãy sử dụng "X for Nuxt" thay vì "X for Nuxt 3" để tránh fragmentation trong ecosystem và ưu tiên sử dụng `meta.compatibility` để đặt ràng buộc phiên bản Nuxt.

#### Stick With Starter Defaults

Module starter đi kèm với một bộ defaults của tools và configurations (ví dụ: cấu hình ESLint). Nếu bạn định open-source module của mình, sticking với những defaults đó đảm bảo module của bạn chia sẻ một coding style nhất quán với các [community modules](https://nuxt.com/modules) khác ở đó, làm cho nó dễ dàng hơn cho người khác để contribute.

## Ecosystem

[Ecosystem Nuxt Module](https://nuxt.com/modules) đại diện cho hơn 15 triệu downloads NPM hàng tháng và cung cấp chức năng mở rộng và tích hợp với tất cả các loại tools. Bạn có thể là một phần của ecosystem này!

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/exploring-nuxt-modules-ecosystem-and-module-types?friend=nuxt
---
Xem video Vue School về Nuxt module types.
::

### Module Types

**Official modules** là modules được prefix (scoped) với `@nuxt/` (ví dụ: [`@nuxt/content`](https://content.nuxtjs.org){rel="nofollow"}). Chúng được làm và maintain tích cực bởi team Nuxt. Như với framework, contributions từ community cũng rất được chào đón để giúp làm chúng tốt hơn!

**Community modules** là modules được prefix (scoped) với `@nuxtjs/` (ví dụ: [`@nuxtjs/tailwindcss`](https://tailwindcss.nuxtjs.org){rel="nofollow"}). Chúng là modules đã được chứng minh được làm và maintain bởi community members. Một lần nữa, contributions được chào đón từ bất kỳ ai.

**Third-party and other community modules** là modules (thường) được prefix với `nuxt-`. Bất kỳ ai cũng có thể làm chúng, sử dụng prefix này cho phép các modules này có thể discoverable trên npm. Đây là điểm khởi đầu tốt nhất để draft và thử một ý tưởng!

**Private or personal modules** là modules được làm cho use case hoặc công ty của riêng bạn. Chúng không cần tuân theo bất kỳ quy tắc đặt tên nào để hoạt động với Nuxt và thường được scoped dưới một tổ chức npm (ví dụ: `@my-company/nuxt-auth`)

### Listing Your Community Module

Bất kỳ community modules nào cũng được chào đón để được list trên [module list](https://nuxt.com/modules). Để được list, [mở một issue trong nuxt/modules](https://github.com/nuxt/modules/issues/new?template=module_request.yml){rel="nofollow"} repository. Team Nuxt có thể giúp bạn áp dụng best practices trước khi list.

### Joining `nuxt-modules` and `@nuxtjs/`

Bằng cách di chuyển modules của bạn đến [nuxt-modules](https://github.com/nuxt-modules){rel="nofollow"}, luôn có ai đó khác để giúp đỡ, và bằng cách này, chúng ta có thể join forces để làm một giải pháp hoàn hảo.

Nếu bạn có một module đã published và đang hoạt động, và muốn transfer nó đến `nuxt-modules`, [mở một issue trong nuxt/modules](https://github.com/nuxt/modules/issues/new){rel="nofollow"}.

Bằng cách joining `nuxt-modules` chúng ta có thể rename community module của bạn dưới scope `@nuxtjs/` và cung cấp một subdomain (ví dụ: `my-module.nuxtjs.org`) cho documentation của nó.


# Nuxt Kit

Nuxt Kit cung cấp các composable utilities để làm cho việc tương tác với [Nuxt Hooks](https://nuxt.com/docs/api/advanced/hooks), [Nuxt Interface](https://nuxt.com/docs/guide/going-further/internals#the-nuxt-interface) và phát triển [Nuxt Modules](https://nuxt.com/docs/guide/going-further/modules) trở nên siêu dễ dàng.

::read-more{to="https://nuxt.com/docs/api/kit"}
Khám phá tất cả các utilities Nuxt Kit.
::

## Usage

### Install Dependency

Bạn có thể cài đặt Nuxt Kit mới nhất bằng cách thêm nó vào phần `dependencies` của `package.json` của bạn. Tuy nhiên, hãy cân nhắc luôn cài đặt rõ ràng gói `@nuxt/kit` ngay cả khi nó đã được cài đặt bởi Nuxt.

::note
`@nuxt/kit` và `@nuxt/schema` là các dependencies chính cho Nuxt. Nếu bạn đang cài đặt nó riêng biệt, hãy đảm bảo rằng các phiên bản của `@nuxt/kit` và `@nuxt/schema` bằng hoặc lớn hơn phiên bản `nuxt` của bạn để tránh bất kỳ hành vi không mong muốn nào.
::

```json [package.json]
{
  "dependencies": {
    "@nuxt/kit": "npm:@nuxt/kit-nightly@latest"
  }
}
```

### Import Kit Utilities

```js [test.mjs]
import { useNuxt } from '@nuxt/kit'
```

::read-more{to="https://nuxt.com/docs/api/kit"}
::

::note
Các utilities Nuxt Kit chỉ có sẵn cho modules và không được dùng để import trong runtime (components, Vue composables, pages, plugins, hoặc server routes).
::

Nuxt Kit là một [esm-only package](https://nuxt.com/docs/guide/concepts/esm) nghĩa là bạn **không thể** `require('@nuxt/kit')`. Như một workaround, sử dụng dynamic import trong ngữ cảnh CommonJS:

```js [test.cjs]
// Điều này KHÔNG hoạt động!
// const kit = require('@nuxt/kit')
async function main() {
  const kit = await import('@nuxt/kit')
}
main()
```


# NuxtApp

Trong Nuxt, bạn có thể truy cập ngữ cảnh ứng dụng runtime trong composables, components và plugins.

::read-more
---
target: _blank
to: https://v2.nuxt.com/docs/internals-glossary/context#the-context
---
Trong Nuxt 2, điều này được gọi là **Nuxt context**.
::

## Nuxt App Interface

::read-more
---
to: https://nuxt.com/docs/guide/going-further/internals#the-nuxtapp-interface
---
Nhảy qua tài liệu giao diện `NuxtApp`.
::

## The Nuxt Context

Nhiều composables và utilities, cả built-in và user-made, có thể yêu cầu truy cập đến instance Nuxt. Điều này không tồn tại ở mọi nơi trên ứng dụng của bạn, vì một instance mới được tạo trên mỗi request.

Hiện tại, ngữ cảnh Nuxt chỉ truy cập được trong [plugins](https://nuxt.com/docs/guide/directory-structure/plugins), [Nuxt hooks](https://nuxt.com/docs/guide/going-further/hooks), [Nuxt middleware](https://nuxt.com/docs/guide/directory-structure/middleware) (nếu được wrap trong `defineNuxtRouteMiddleware`), và [setup functions](https://vuejs.org/api/composition-api-setup.html){rel="nofollow"} (trong pages và components).

Nếu một composable được gọi mà không có truy cập đến ngữ cảnh, bạn có thể nhận được một lỗi nói rằng 'A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function.' Trong trường hợp đó, bạn cũng có thể gọi rõ ràng các hàm trong ngữ cảnh này bằng cách sử dụng [`nuxtApp.runWithContext`](https://nuxt.com/docs/api/composables/use-nuxt-app#runwithcontext).

## Accessing NuxtApp

Trong composables, plugins và components bạn có thể truy cập `nuxtApp` với [`useNuxtApp()`](https://nuxt.com/docs/api/composables/use-nuxt-app):

```ts [composables/useMyComposable.ts]
export function useMyComposable () {
  const nuxtApp = useNuxtApp()
  // access runtime nuxt app instance
}
```

Nếu composable của bạn không luôn cần `nuxtApp` hoặc bạn chỉ muốn kiểm tra xem nó có hiện diện hay không, vì [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) ném ngoại lệ, bạn có thể sử dụng [`tryUseNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app#tryusenuxtapp) thay vào đó.

Plugins cũng nhận `nuxtApp` như đối số đầu tiên để thuận tiện.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

## Providing Helpers

Bạn có thể cung cấp helpers để có thể sử dụng trên tất cả composables và ứng dụng. Điều này thường xảy ra trong một Nuxt plugin.

```ts
const nuxtApp = useNuxtApp()
nuxtApp.provide('hello', (name) => `Hello ${name}!`)

console.log(nuxtApp.$hello('name')) // Prints "Hello name!"
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/plugins#providing-helpers
---
Có thể inject helpers bằng cách trả về một object với khóa `provide` trong plugins.
::

::read-more
---
target: _blank
to: https://v2.nuxt.com/docs/directory-structure/plugins#inject-in-root--context
---
Trong Nuxt 2 plugins, điều này được gọi là **inject function**.
::


# Authoring Nuxt Layers

Nuxt layers là một tính năng mạnh mẽ mà bạn có thể sử dụng để chia sẻ và tái sử dụng các ứng dụng Nuxt một phần trong một monorepo, hoặc từ một git repository hoặc npm package. Cấu trúc layers gần như giống hệt với một ứng dụng Nuxt tiêu chuẩn, điều này làm cho chúng dễ dàng tác giả và maintain.

::read-more{to="https://nuxt.com/docs/getting-started/layers"}
::

Một thư mục layer Nuxt tối giản nên chứa một tệp [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) để chỉ ra rằng nó là một layer.

```ts [base/nuxt.config.ts]
export default defineNuxtConfig({})
```

Ngoài ra, một số tệp khác trong thư mục layer sẽ được auto-scanned và sử dụng bởi Nuxt cho dự án mở rộng layer này.

- [`app/components/*`](https://nuxt.com/docs/guide/directory-structure/components) - Mở rộng các components mặc định
- [`app/composables/*`](https://nuxt.com/docs/guide/directory-structure/composables) - Mở rộng các composables mặc định
- [`app/layouts/*`](https://nuxt.com/docs/guide/directory-structure/layouts) - Mở rộng các layouts mặc định
- [`app/middleware/*`](https://nuxt.com/docs/guide/directory-structure/middleware) - Mở rộng các middleware mặc định
- [`app/pages/*`](https://nuxt.com/docs/guide/directory-structure/pages) - Mở rộng các pages mặc định
- [`app/plugins/*`](https://nuxt.com/docs/guide/directory-structure/plugins) - Mở rộng các plugins mặc định
- [`app/utils/*`](https://nuxt.com/docs/guide/directory-structure/utils) - Mở rộng các utils mặc định
- [`app/app.config.ts`](https://nuxt.com/docs/guide/directory-structure/app-config) - Mở rộng app config mặc định
- [`server/*`](https://nuxt.com/docs/guide/directory-structure/server) - Mở rộng các server endpoints & middleware mặc định
- [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config)- Mở rộng nuxt config mặc định

## Basic Example

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    './base'
  ]
})
```

```vue [app.vue]
  <template>
    <BaseComponent/>
  </template>
```

```ts [base/nuxt.config.ts]
  export default defineNuxtConfig({
    // Mở rộng từ base nuxt.config.ts!
    app: {
      head: {
        title: 'Mở rộng Configs thật Vui!',
        meta: [
          { name: 'description', content: 'Tôi đang sử dụng tính năng extends trong Nuxt!' }
        ],
      }
    }
  })
```

```vue [base/app/components/BaseComponent.vue]
  <template>
    <h1>Mở rộng Components thật Vui!</h1>
  </template>
```
::

## Starter Template

Để bắt đầu bạn có thể khởi tạo một layer với [nuxt/starter/layer template](https://github.com/nuxt/starter/tree/layer){rel="nofollow"}. Điều này sẽ tạo một cấu trúc cơ bản mà bạn có thể xây dựng lên. Thực thi lệnh này trong terminal để bắt đầu:

```bash [Terminal]
npm create nuxt -- --template layer nuxt-layer
```

Làm theo hướng dẫn README cho các bước tiếp theo.

## Publishing Layers

Bạn có thể xuất bản và chia sẻ layers bằng cách sử dụng một remote source hoặc một npm package.

### Git Repository

Bạn có thể sử dụng một git repository để chia sẻ layer Nuxt của bạn. Một số ví dụ:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    'github:username/repoName',        // GitHub Remote Source
    'github:username/repoName/base',   // GitHub Remote Source within /base directory
    'github:username/repoName#dev',    // GitHub Remote Source from dev branch
    'github:username/repoName#v1.0.0', // GitHub Remote Source from v1.0.0 tag
    'gitlab:username/repoName',        // GitLab Remote Source example
    'bitbucket:username/repoName',     // Bitbucket Remote Source example
  ]
})
```

::tip
Nếu bạn muốn mở rộng một remote source private, bạn cần thêm biến môi trường `GIGET_AUTH=<token>` để cung cấp token.
::

::tip
Nếu bạn muốn mở rộng một remote source từ một instance GitHub hoặc GitLab tự host, bạn cần cung cấp URL của nó với biến môi trường `GIGET_GITHUB_URL=<url>` hoặc `GIGET_GITLAB_URL=<url>` - hoặc cấu hình trực tiếp với [tùy chọn `auth`](https://github.com/unjs/c12#extending-config-layer-from-remote-sources){rel="nofollow"} trong `nuxt.config` của bạn.
::

::warning
Hãy nhớ rằng nếu bạn đang mở rộng một remote source như một layer, bạn sẽ không thể truy cập dependencies của nó bên ngoài Nuxt. Ví dụ, nếu remote layer phụ thuộc vào một eslint plugin, điều này sẽ không sử dụng được trong eslint config của bạn. Đó là vì các dependencies này sẽ được đặt ở một vị trí đặc biệt (`node_modules/.c12/layer_name/node_modules/`) mà không truy cập được bởi package manager của bạn.
::

::note
Khi sử dụng git remote sources, nếu một layer có npm dependencies và bạn muốn cài đặt chúng, bạn có thể làm như vậy bằng cách chỉ định `install: true` trong tùy chọn layer của bạn.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    ['github:username/repoName', { install: true }]
  ]
})
```
::

### npm Package

Bạn có thể xuất bản Nuxt layers như một npm package chứa các tệp và dependencies bạn muốn mở rộng. Điều này cho phép bạn chia sẻ config của mình với người khác, sử dụng nó trong nhiều dự án hoặc sử dụng riêng tư.

Để mở rộng từ một npm package, bạn cần đảm bảo rằng module được xuất bản lên npm và cài đặt trong dự án của người dùng như một devDependency. Sau đó bạn có thể sử dụng tên module để mở rộng nuxt config hiện tại:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // Node Module with scope
    '@scope/moduleName',
    // or just the module name
    'moduleName'
  ]
})
```

Để xuất bản một thư mục layer như một npm package, bạn muốn đảm bảo rằng `package.json` có các thuộc tính đúng được điền. Điều này sẽ đảm bảo rằng các tệp được bao gồm khi package được xuất bản.

```json [package.json]
{
  "name": "my-theme",
  "version": "1.0.0",
  "type": "module",
  "main": "./nuxt.config.ts",
  "dependencies": {},
  "devDependencies": {
    "nuxt": "^3.0.0"
  }
}
```

::important
Đảm bảo bất kỳ dependency nào được import trong layer được **thêm rõ ràng** vào `dependencies`. Dependency `nuxt`, và bất kỳ thứ gì chỉ được sử dụng để test layer trước khi xuất bản, nên ở trong trường `devDependencies`.
::

Bây giờ bạn có thể tiến hành xuất bản module lên npm, hoặc công khai hoặc riêng tư.

::important
Khi xuất bản layer như một npm package riêng tư, bạn cần đảm bảo bạn đăng nhập, để xác thực với npm để tải node module.
::

## Tips

### Named Layer Aliases

Auto-scanned layers (từ thư mục `~~/layers` của bạn) tự động tạo aliases. Ví dụ, bạn có thể truy cập layer `~~/layers/test` của mình qua `#layers/test`.

Nếu bạn muốn tạo named layer aliases cho các layers khác, bạn có thể chỉ định một tên trong cấu hình của layer.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  $meta: {
    name: 'example',
  },
})
```

Điều này sẽ tạo ra một alias của `#layers/example` trỏ đến layer của bạn.

### Relative Paths and Aliases

Khi import sử dụng global aliases (như `~/` và `@/`) trong components và composables của layer, lưu ý rằng các aliases này được giải quyết tương đối đến đường dẫn dự án của người dùng. Như một workaround, bạn có thể **sử dụng relative paths** để import chúng, hoặc sử dụng named layer aliases.

Cũng khi sử dụng relative paths trong tệp `nuxt.config` của layer, (với ngoại lệ của nested `extends`) chúng được giải quyết tương đối đến dự án của người dùng thay vì layer. Như một workaround, sử dụng full resolved paths trong `nuxt.config`:

```js [nuxt.config.ts]
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  css: [
    join(currentDir, './app/assets/main.css')
  ]
})
```

## Multi-Layer Support for Nuxt Modules

Bạn có thể sử dụng internal array `nuxt.options._layers` để hỗ trợ custom multi-layer handling cho modules của bạn.

```ts [modules/my-module.ts]
export default defineNuxtModule({
  setup(_options, nuxt) {
    for (const layer of nuxt.options._layers) {
      // You can check for a custom directory existence to extend for each layer
      console.log('Custom extension for', layer.cwd, layer.config)
    }
  }
})
```

**Notes:**

- Các items sớm hơn trong array `_layers` có ưu tiên cao hơn và override các cái sau
- Dự án của người dùng là item đầu tiên trong array `_layers`

## Going Deeper

Configuration loading và extends support được xử lý bởi [unjs/c12](https://github.com/unjs/c12){rel="nofollow"}, merged sử dụng [unjs/defu](https://github.com/unjs/defu){rel="nofollow"} và remote git sources được hỗ trợ sử dụng [unjs/giget](https://github.com/unjs/giget){rel="nofollow"}. Kiểm tra docs và source code để tìm hiểu thêm.

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/issues/13367
---
Checkout development đang diễn ra của chúng tôi để mang lại nhiều cải thiện hơn cho layers support trên GitHub.
::


# Debugging

## Sourcemaps

Sourcemaps được bật cho server build của bạn theo mặc định, và cho client build trong dev mode, nhưng bạn có thể bật chúng cụ thể hơn trong cấu hình của bạn.

```ts
export default defineNuxtConfig({
  // or sourcemap: true
  sourcemap: {
    server: true,
    client: true
  }
})
```

## Debugging with Node Inspector

Bạn có thể sử dụng [Node inspector](https://nodejs.org/en/learn/getting-started/debugging){rel="nofollow"} để debug phía server của Nuxt.

```bash
nuxt dev --inspect
```

Điều này sẽ khởi động Nuxt ở chế độ `dev` với debugger active. Nếu mọi thứ hoạt động đúng, một icon Node.js sẽ xuất hiện trên Chrome DevTools của bạn và bạn có thể attach vào debugger.

::important
Lưu ý rằng các process Node.js và Chrome cần chạy trên cùng một platform. Điều này không hoạt động bên trong Docker.
::

## Debugging in Your IDE

Có thể debug ứng dụng Nuxt của bạn trong IDE của bạn trong khi bạn đang phát triển nó.

### Example VS Code Debug Configuration

Bạn có thể cần cập nhật config dưới đây với một đường dẫn đến web browser của bạn. Để biết thêm thông tin, hãy truy cập [tài liệu VS Code về debug configuration](https://go.microsoft.com/fwlink/?linkid=830387){rel="nofollow"}.

```json5
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  "version": "0.2.0",
  "configurations": [
    {
      "type": "chrome",
      "request": "launch",
      "name": "client: chrome",
      "url": "http://localhost:3000",
      // this should point to your Nuxt `srcDir`, which is `app` by default
      "webRoot": "${workspaceFolder}/app"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "server: nuxt",
      "outputCapture": "std",
      "program": "${workspaceFolder}/node_modules/nuxt/bin/nuxt.mjs",
      "args": [
        "dev"
      ],
    }
  ],
  "compounds": [
    {
      "name": "fullstack: nuxt",
      "configurations": [
        "server: nuxt",
        "client: chrome"
      ]
    }
  ]
}
```

Nếu bạn thích các browser extensions thông thường của mình, thêm điều này vào cấu hình *chrome* ở trên:

```json5
"userDataDir": false,
```

### Example JetBrains IDEs Debug Configuration

Bạn cũng có thể debug ứng dụng Nuxt của mình trong JetBrains IDEs như IntelliJ IDEA, WebStorm, hoặc PhpStorm.

1. Tạo một tệp mới trong thư mục root dự án của bạn và đặt tên là `nuxt.run.xml`.
2. Mở tệp `nuxt.run.xml` và paste cấu hình debug sau:

```html
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="client: chrome" type="JavascriptDebugType" uri="http://localhost:3000" useFirstLineBreakpoints="true">
    <method v="2" />
  </configuration>

  <configuration default="false" name="server: nuxt" type="NodeJSConfigurationType" application-parameters="dev" path-to-js-file="$PROJECT_DIR$/node_modules/nuxt/bin/nuxt.mjs" working-dir="$PROJECT_DIR$">
    <method v="2" />
  </configuration>

  <configuration default="false" name="fullstack: nuxt" type="CompoundRunConfigurationType">
    <toRun name="client: chrome" type="JavascriptDebugType" />
    <toRun name="server: nuxt" type="NodeJSConfigurationType" />
    <method v="2" />
  </configuration>
</component>
```

### Other IDEs

Nếu bạn có một IDE khác và muốn contribute sample configuration, hãy tự do [mở một PR](https://github.com/nuxt/nuxt/edit/main/docs/2.guide/3.going-further/9.debugging.md){rel="nofollow"}!




# Custom Routing

## Adding custom routes

Trong Nuxt, định tuyến của bạn được định nghĩa bởi cấu trúc của các file bên trong [pages directory](https://nuxt.com/docs/guide/directory-structure/pages). Tuy nhiên, vì nó sử dụng [vue-router](https://router.vuejs.org){rel="nofollow"} ở dưới, Nuxt cung cấp cho bạn một số cách để thêm các tuyến tùy chỉnh trong dự án của bạn.

### Router Config

Sử dụng [router options](https://nuxt.com/docs/guide/recipes/custom-routing#router-options), bạn có thể tùy chọn ghi đè hoặc mở rộng các tuyến của mình bằng cách sử dụng một hàm chấp nhận các tuyến đã quét và trả về các tuyến tùy chỉnh.

Nếu nó trả về `null` hoặc `undefined`, Nuxt sẽ quay lại các tuyến mặc định (hữu ích để sửa đổi mảng đầu vào).

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'

export default {
  // https://router.vuejs.org/api/interfaces/routeroptions.html#routes
  routes: (_routes) => [
    {
      name: 'home',
      path: '/',
      component: () => import('~/pages/home.vue')
    }
  ],
} satisfies RouterConfig
```

::note
Nuxt sẽ không tăng cường bất kỳ tuyến mới nào bạn trả về từ hàm `routes` với metadata được định nghĩa trong `definePageMeta` của component bạn cung cấp. Nếu bạn muốn điều đó xảy ra, bạn nên sử dụng hook `pages:extend` được [gọi tại thời điểm build](https://nuxt.com/docs/api/advanced/hooks#nuxt-hooks-build-time).
::

### Pages Hook

Bạn có thể thêm, thay đổi hoặc xóa các trang từ các tuyến đã quét với hook `pages:extend` của Nuxt.

Ví dụ, để ngăn tạo các tuyến cho bất kỳ file `.ts` nào:

```ts [nuxt.config.ts]
import type { NuxtPage } from '@nuxt/schema'

export default defineNuxtConfig({
  hooks: {
    'pages:extend' (pages) {
      // thêm một tuyến
      pages.push({
        name: 'profile',
        path: '/profile',
        file: '~/extra-pages/profile.vue'
      })

      // xóa các tuyến
      function removePagesMatching (pattern: RegExp, pages: NuxtPage[] = []) {
        const pagesToRemove: NuxtPage[] = []
        for (const page of pages) {
          if (page.file && pattern.test(page.file)) {
            pagesToRemove.push(page)
          } else {
            removePagesMatching(pattern, page.children)
          }
        }
        for (const page of pagesToRemove) {
          pages.splice(pages.indexOf(page), 1)
        }
      }
      removePagesMatching(/\.ts$/, pages)
    }
  }
})
```

### Nuxt Module

Nếu bạn dự định thêm một bộ trang hoàn chỉnh liên quan đến một chức năng cụ thể, bạn có thể muốn sử dụng một [Nuxt module](https://nuxt.com/modules).

[Nuxt kit](https://nuxt.com/docs/guide/going-further/kit) cung cấp một số cách [để thêm các tuyến](https://nuxt.com/docs/api/kit/pages):

- [`extendPages`](https://nuxt.com/docs/api/kit/pages#extendpages) (callback: pages => void)
- [`extendRouteRules`](https://nuxt.com/docs/api/kit/pages#extendrouterules) (route: string, rule: NitroRouteConfig, options: ExtendRouteRulesOptions)

## Router Options

Ngoài việc tùy chỉnh các tùy chọn cho [`vue-router`](https://router.vuejs.org/api/interfaces/routeroptions.html){rel="nofollow"}, Nuxt cung cấp [các tùy chọn bổ sung](https://nuxt.com/docs/api/nuxt-config#router) để tùy chỉnh router.

### Using `router.options`

Đây là cách được khuyến nghị để chỉ định [router options](https://nuxt.com/docs/api/nuxt-config#router).

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'

export default {
} satisfies RouterConfig
```

Có thể thêm nhiều file tùy chọn router hơn bằng cách thêm các file trong hook `pages:routerOptions`. Các mục sau trong mảng ghi đè các mục trước.

::callout
Việc thêm một file tùy chọn router trong hook này sẽ bật định tuyến dựa trên trang, trừ khi `optional` được đặt, trong trường hợp đó nó chỉ áp dụng khi định tuyến dựa trên trang đã được bật.
::

```ts [nuxt.config.ts]
import { createResolver } from '@nuxt/kit'

export default defineNuxtConfig({
  hooks: {
    'pages:routerOptions' ({ files }) {
      const resolver = createResolver(import.meta.url)
      // thêm một tuyến
      files.push({
        path: resolver.resolve('./runtime/router-options'),
        optional: true
      })
    }
  }
})
```

### Using `nuxt.config`

**Lưu ý:** Chỉ các [tùy chọn](https://nuxt.com/docs/api/nuxt-config#router) có thể tuần tự hóa JSON mới có thể cấu hình:

- `linkActiveClass`
- `linkExactActiveClass`
- `end`
- `sensitive`
- `strict`
- `hashMode`
- `scrollBehaviorType`

```js [nuxt.config]
export default defineNuxtConfig({
  router: {
    options: {}
  }
})
```

### Hash Mode (SPA)

Bạn có thể bật lịch sử hash trong chế độ SPA bằng cách sử dụng [config](https://nuxt.com/docs/api/nuxt-config#router) `hashMode`. Trong chế độ này, router sử dụng ký tự hash (#) trước URL thực tế được truyền bên trong. Khi được bật, **URL không bao giờ được gửi đến server** và **SSR không được hỗ trợ**.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
  router: {
    options: {
      hashMode: true
    }
  }
})
```

### Scroll Behavior for hash links

Bạn có thể tùy chỉnh hành vi cuộn cho các liên kết hash. Khi bạn đặt [config](https://nuxt.com/docs/api/nuxt-config#router) thành `smooth` và bạn tải một trang với liên kết hash (ví dụ: `https://example.com/blog/my-article#comments`), bạn sẽ thấy trình duyệt cuộn mượt mà đến anchor đó.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  router: {
    options: {
      scrollBehaviorType: 'smooth'
    }
  }
})
```

#### Custom History (advanced)

Bạn có thể ghi đè chế độ lịch sử bằng cách sử dụng một hàm chấp nhận URL cơ sở và trả về chế độ lịch sử. Nếu nó trả về `null` hoặc `undefined`, Nuxt sẽ quay lại lịch sử mặc định.

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'
import { createMemoryHistory } from 'vue-router'

export default {
  // https://router.vuejs.org/api/interfaces/routeroptions.html
  history: base => import.meta.client ? createMemoryHistory(base) : null /* default */
} satisfies RouterConfig
```


# Using Vite Plugins in Nuxt

Trong khi các module Nuxt cung cấp chức năng rộng lớn, đôi khi một plugin Vite cụ thể có thể đáp ứng nhu cầu của bạn trực tiếp hơn.

Đầu tiên, chúng ta cần cài đặt plugin Vite, cho ví dụ của chúng ta, chúng ta sẽ sử dụng `@rollup/plugin-yaml`:

::code-group{sync="pm"}
```bash [npm]
npm install @rollup/plugin-yaml
```

```bash [yarn]
yarn add @rollup/plugin-yaml
```

```bash [pnpm]
pnpm add @rollup/plugin-yaml
```

```bash [bun]
bun add @rollup/plugin-yaml
```
::

Tiếp theo, chúng ta cần import và thêm nó vào file [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) của chúng ta:

```ts [nuxt.config.ts]
import yaml from '@rollup/plugin-yaml'

export default defineNuxtConfig({
  vite: {
    plugins: [
      yaml()
    ]
  }
})
```

Bây giờ chúng ta đã cài đặt và cấu hình plugin Vite của mình, chúng ta có thể bắt đầu sử dụng các file YAML trực tiếp trong dự án của mình.

Ví dụ, chúng ta có thể có một `config.yaml` lưu trữ dữ liệu cấu hình và import dữ liệu này trong các component Nuxt của chúng ta:

::code-group
```yaml [data/hello.yaml]
greeting: "Hello, Nuxt with Vite!"
```

```vue [components/Hello.vue]
<script setup>
import config from '~/data/hello.yaml'
</script>

<template>
  <h1>{{ config.greeting }}</h1>
</template>
```
::


# Custom useFetch in Nuxt

Khi làm việc với Nuxt, bạn có thể đang tạo frontend và fetch một API bên ngoài, và bạn có thể muốn đặt một số tùy chọn mặc định để fetch từ API của bạn.

Hàm tiện ích [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) (được sử dụng bởi composable [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch)) được thiết kế không thể cấu hình toàn cục. Điều này quan trọng để hành vi fetch trong toàn bộ ứng dụng của bạn vẫn nhất quán, và các tích hợp khác (như modules) có thể dựa vào hành vi của các tiện ích cốt lõi như `$fetch`.

Tuy nhiên, Nuxt cung cấp một cách để tạo một fetcher tùy chỉnh cho API của bạn (hoặc nhiều fetcher nếu bạn có nhiều API để gọi).

## Custom `$fetch`

Hãy tạo một instance `$fetch` tùy chỉnh với một [Nuxt plugin](https://nuxt.com/docs/guide/directory-structure/plugins).

::note
`$fetch` là một instance được cấu hình của [ofetch](https://github.com/unjs/ofetch){rel="nofollow"} hỗ trợ thêm base URL của server Nuxt của bạn cũng như các lệnh gọi hàm trực tiếp trong SSR (tránh các vòng lặp HTTP).
::

Hãy giả định ở đây rằng:

- The main API is <https://api.nuxt.com>{rel="nofollow"}
- We are storing the JWT token in a session with [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils){rel="nofollow"}
- If the API responds with a `401` status code, we redirect the user to the `/login` page

```ts [plugins/api.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const { session } = useUserSession()

  const api = $fetch.create({
    baseURL: 'https://api.nuxt.com',
    onRequest({ request, options, error }) {
      if (session.value?.token) {
        // lưu ý rằng điều này dựa trên ofetch >= 1.4.0 - bạn có thể cần làm mới lockfile của mình
        options.headers.set('Authorization', `Bearer ${session.value?.token}`)
      }
    },
    async onResponseError({ response }) {
      if (response.status === 401) {
        await nuxtApp.runWithContext(() => navigateTo('/login'))
      }
    }
  })

  // Expose cho useNuxtApp().$api
  return {
    provide: {
      api
    }
  }
})
```

Với plugin Nuxt này, `$api` được expose từ `useNuxtApp()` để thực hiện các lệnh gọi API trực tiếp từ các component Vue:

```vue [app.vue]
<script setup>
const { $api } = useNuxtApp()
const { data: modules } = await useAsyncData('modules', () => $api('/modules'))
</script>
```

::callout
Wrap với [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) **tránh fetch dữ liệu kép khi thực hiện server-side rendering** (server & client on hydration).
::

## Custom `useFetch`/`useAsyncData`

Bây giờ `$api` đã có logic chúng ta muốn, hãy tạo một composable `useAPI` để thay thế việc sử dụng `useAsyncData` + `$api`:

```ts [composables/useAPI.ts]
import type { UseFetchOptions } from 'nuxt/app'

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch(url, {
    ...options,
    $fetch: useNuxtApp().$api as typeof $fetch
  })
}
```

Hãy sử dụng composable mới và có một component đẹp và sạch sẽ:

```vue [app.vue]
<script setup>
const { data: modules } = await useAPI('/modules')
</script>
```

Nếu bạn muốn tùy chỉnh loại lỗi được trả về, bạn cũng có thể làm như vậy:

```ts
import type { FetchError } from 'ofetch'
import type { UseFetchOptions } from 'nuxt/app'

interface CustomError {
  message: string
  statusCode: number
}

export function useAPI<T>(
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch<T, FetchError<CustomError>>(url, {
    ...options,
    $fetch: useNuxtApp().$api
  })
}
```

::note
Ví dụ này minh họa cách sử dụng một `useFetch` tùy chỉnh, nhưng cấu trúc tương tự giống hệt cho một `useAsyncData` tùy chỉnh.
::

::link-example
---
to: https://nuxt.com/docs/examples/advanced/use-custom-fetch-composable
---
::

::video-accordion
---
title: Watch a video about custom $fetch and Repository Pattern in Nuxt
video-id: jXH8Tr-exhI
---
::

::note
Chúng tôi hiện đang thảo luận để tìm một cách sạch hơn để cho phép bạn tạo một fetcher tùy chỉnh, xem <https://github.com/nuxt/nuxt/issues/14736>{rel="nofollow"}.
::


# Sessions and Authentication

## Introduction

Trong công thức này, chúng ta sẽ thiết lập xác thực trong một ứng dụng Nuxt full-stack bằng cách sử dụng [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils){rel="nofollow"} cung cấp các tiện ích thuận tiện để quản lý dữ liệu phiên client-side và server-side.

Module sử dụng cookies được bảo mật & niêm phong để lưu trữ dữ liệu phiên, vì vậy bạn không cần thiết lập cơ sở dữ liệu để lưu trữ dữ liệu phiên.

## Install nuxt-auth-utils

Cài đặt module `nuxt-auth-utils` bằng cách sử dụng `nuxt` CLI.

```bash [Terminal]
npx nuxt module add auth-utils
```

::callout
Lệnh này sẽ cài đặt `nuxt-auth-utils` như một dependency và đẩy nó vào phần `modules` của `nuxt.config.ts` của chúng ta
::

## Cookie Encryption Key

Vì `nuxt-auth-utils` sử dụng cookies niêm phong để lưu trữ dữ liệu phiên, cookies phiên được mã hóa bằng một khóa bí mật từ biến môi trường `NUXT_SESSION_PASSWORD`.

::note
Nếu không được đặt, biến môi trường này sẽ được thêm vào `.env` của bạn tự động khi chạy ở chế độ phát triển.
::

```ini [.env]
NUXT_SESSION_PASSWORD=a-random-password-with-at-least-32-characters
```

::important
Bạn sẽ cần thêm biến môi trường này vào môi trường sản xuất của mình trước khi triển khai.
::

## Login API Route

Cho công thức này, chúng ta sẽ tạo một tuyến API đơn giản để đăng nhập người dùng dựa trên dữ liệu tĩnh.

Hãy tạo một tuyến API `/api/login` sẽ chấp nhận một yêu cầu POST với email và mật khẩu trong body yêu cầu.

```ts [server/api/login.post.ts]
import { z } from 'zod'

const bodySchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
})

export default defineEventHandler(async (event) => {
  const { email, password } = await readValidatedBody(event, bodySchema.parse)

  if (email === 'admin@admin.com' && password === 'iamtheadmin') {
    // đặt phiên người dùng trong cookie
    // util server này được auto-import bởi module auth-utils
    await setUserSession(event, {
      user: {
        name: 'John Doe'
      }
    })
    return {}
  }
  throw createError({
    statusCode: 401,
    message: 'Bad credentials'
  })
})
```

::callout
Đảm bảo cài đặt dependency `zod` trong dự án của bạn (`npm i zod`).
::

::tip{to="https://github.com/atinux/nuxt-auth-utils#server-utils"}
Read more about the `setUserSession` server helper exposed by `nuxt-auth-utils`.
::

## Login Page

Module expose một Vue composable để biết nếu người dùng được xác thực trong ứng dụng của chúng ta:

```vue
<script setup>
const { loggedIn, session, user, clear, fetch } = useUserSession()
</script>
```

Hãy tạo một trang đăng nhập với một form để gửi dữ liệu đăng nhập đến tuyến `/api/login` của chúng ta.

```vue [pages/login.vue]
<script setup lang="ts">
const { loggedIn, user, fetch: refreshSession } = useUserSession()
const credentials = reactive({
  email: '',
  password: '',
})
async function login() {
  $fetch('/api/login', {
    method: 'POST',
    body: credentials
  })
  .then(async () => {
    // Làm mới phiên ở client-side và chuyển hướng đến trang chủ
    await refreshSession()
    await navigateTo('/')
  })
  .catch(() => alert('Bad credentials'))
}
</script>

<template>
  <form @submit.prevent="login">
    <input v-model="credentials.email" type="email" placeholder="Email" />
    <input v-model="credentials.password" type="password" placeholder="Password" />
    <button type="submit">Login</button>
  </form>
</template>
```

## Protect API Routes

Bảo vệ các tuyến server là chìa khóa để đảm bảo dữ liệu của bạn an toàn. Middleware client-side hữu ích cho người dùng, nhưng mà không có bảo vệ server-side dữ liệu của bạn vẫn có thể bị truy cập. Điều quan trọng là bảo vệ bất kỳ tuyến nào có dữ liệu nhạy cảm, chúng ta nên trả về lỗi 401 nếu người dùng không đăng nhập trên những tuyến đó.

Module `auth-utils` cung cấp hàm tiện ích `requireUserSession` để giúp đảm bảo rằng người dùng đã đăng nhập và có một phiên hoạt động.

Hãy tạo một ví dụ về tuyến `/api/user/stats` mà chỉ người dùng đã xác thực mới có thể truy cập.

```ts [server/api/user/stats.get.ts]
export default defineEventHandler(async (event) => {
  // đảm bảo người dùng đã đăng nhập
  // Điều này sẽ ném lỗi 401 nếu yêu cầu không đến từ một phiên người dùng hợp lệ
  const { user } = await requireUserSession(event)

  // TODO: Fetch một số thống kê dựa trên người dùng

  return {}
});
```

## Protect App Routes

Dữ liệu của chúng ta an toàn với tuyến server-side đã được đặt, nhưng mà không làm gì khác, người dùng chưa xác thực có lẽ sẽ nhận được một số dữ liệu kỳ lạ khi cố gắng truy cập trang `/users`. Chúng ta nên tạo một [middleware client-side](https://nuxt.com/docs/guide/directory-structure/middleware){rel="nofollow"} để bảo vệ tuyến ở phía client và chuyển hướng người dùng đến trang đăng nhập.

`nuxt-auth-utils` cung cấp một composable `useUserSession` thuận tiện mà chúng ta sẽ sử dụng để kiểm tra nếu người dùng đã đăng nhập, và chuyển hướng họ nếu họ không.

Chúng ta sẽ tạo một middleware trong thư mục `/middleware`. Không giống như trên server, middleware client-side không được áp dụng tự động cho tất cả endpoints, và chúng ta sẽ cần chỉ định nơi chúng ta muốn nó được áp dụng.

```typescript [middleware/authenticated.ts]
export default defineNuxtRouteMiddleware(() => {
  const { loggedIn } = useUserSession()

  // chuyển hướng người dùng đến màn hình đăng nhập nếu họ không được xác thực
  if (!loggedIn.value) {
    return navigateTo('/login')
  }
})
```

## Home Page

Bây giờ chúng ta có middleware ứng dụng để bảo vệ các tuyến của mình, chúng ta có thể sử dụng nó trên trang chủ hiển thị thông tin người dùng đã xác thực của chúng ta. Nếu người dùng không được xác thực, họ sẽ được chuyển hướng đến trang đăng nhập.

Chúng ta sẽ sử dụng [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) để áp dụng middleware cho tuyến mà chúng ta muốn bảo vệ.

```vue [pages/index.vue]
<script setup lang="ts">
definePageMeta({
  middleware: ['authenticated'],
})
  
const { user, clear: clearSession } = useUserSession()

async function logout() {
  await clearSession()
  await navigateTo('/login')
}
</script>

<template>
  <div>
    <h1>Welcome {{ user.name }}</h1>
    <button @click="logout">Logout</button>
  </div>
</template>
```

Chúng ta cũng đã thêm một nút đăng xuất để xóa phiên và chuyển hướng người dùng đến trang đăng nhập.

## Conclusion

Chúng ta đã thành công thiết lập một xác thực người dùng và quản lý phiên rất cơ bản trong ứng dụng Nuxt của mình. Chúng ta cũng đã bảo vệ các tuyến nhạy cảm ở phía server và client để đảm bảo rằng chỉ người dùng đã xác thực mới có thể truy cập chúng.

Làm bước tiếp theo, bạn có thể:

- Add authentication using the [20+ supported OAuth providers](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#supported-oauth-providers){rel="nofollow"}
- Add a database to store users, see [Nitro SQL Database](https://nitro.build/guide/database){rel="nofollow"} or [NuxtHub SQL Database](https://hub.nuxt.com/docs/features/database){rel="nofollow"}
- Let user signup with email & password using [password hashing](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#password-hashing){rel="nofollow"}
- Add support for [WebAuthn / Passkeys](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#webauthn-passkey){rel="nofollow"}

Kiểm tra repository mã nguồn mở [atidone](https://github.com/atinux/atidone){rel="nofollow"} để có một ví dụ đầy đủ về ứng dụng Nuxt với xác thực OAuth, cơ sở dữ liệu và các thao tác CRUD.


# Nuxt and hydration

Khi phát triển, bạn có thể gặp phải các vấn đề hydration. Đừng bỏ qua những cảnh báo đó.

# Why is it important to fix them?

Các lỗi hydration không chỉ là cảnh báo - chúng là dấu hiệu của các vấn đề nghiêm trọng có thể phá vỡ ứng dụng của bạn:

## Performance Impact

- **Thời gian tương tác tăng lên**: Lỗi hydration buộc Vue phải render lại toàn bộ cây component, điều này sẽ tăng thời gian để ứng dụng Nuxt của bạn trở nên tương tác
- **Trải nghiệm người dùng kém**: Người dùng có thể thấy nội dung nhấp nháy hoặc dịch chuyển bố cục bất ngờ

## Functionality Issues

- **Tương tác bị hỏng**: Các event listener có thể không gắn kết đúng cách, khiến các nút và form không hoạt động
- **Không nhất quán trạng thái**: Trạng thái ứng dụng có thể không đồng bộ giữa những gì người dùng thấy và những gì ứng dụng nghĩ là đã render
- **Vấn đề SEO**: Công cụ tìm kiếm có thể index nội dung khác với những gì người dùng thực sự thấy

# How to detect them

## Development Console Warnings

Vue sẽ ghi lại các cảnh báo lỗi hydration trong console trình duyệt trong quá trình phát triển:

![Screenshot of Vue hydration mismatch warning in the browser console](https://nuxt.com/assets/docs/best-practices/vue-console-hydration.png)

# Common reasons

## Browser-only APIs in Server Context

**Vấn đề**: Sử dụng các API dành riêng cho trình duyệt trong quá trình render phía server.

```html
<template>
  <div>User preference: {{ userTheme }}</div>
</template>

<script setup>
// This will cause hydration mismatch!
// localStorage doesn't exist on the server!
const userTheme = localStorage.getItem('theme') || 'light'
</script>
```

**Giải pháp**: Bạn có thể sử dụng [`useCookie`](https://nuxt.com/docs/api/composables/use-cookie):

```html
<template>
  <div>User preference: {{ userTheme }}</div>
</template>

<script setup>
// This works on both server and client
const userTheme = useCookie('theme', { default: () => 'light' })
</script>
```

## Inconsistent Data

**Vấn đề**: Dữ liệu khác nhau giữa server và client.

```html
<template>
  <div>{{ Math.random() }}</div>
</template>
```

**Giải pháp**: Sử dụng trạng thái thân thiện với SSR:

```html
<template>
  <div>{{ state }}</div>
</template>

<script setup>
const state = useState('random', () => Math.random())
</script>
```

## Conditional Rendering Based on Client State

**Vấn đề**: Sử dụng điều kiện chỉ dành cho client trong SSR.

```html
<template>
  <div v-if="window?.innerWidth > 768">
    Desktop content
  </div>
</template>
```

**Giải pháp**: Sử dụng media queries hoặc xử lý phía client:

```html
<template>
  <div class="responsive-content">
    <div class="hidden md:block">Desktop content</div>
    <div class="md:hidden">Mobile content</div>
  </div>
</template>
```

## Third-party Libraries with Side Effects

**Vấn đề**: Các thư viện sửa đổi DOM hoặc có phụ thuộc trình duyệt (điều này xảy ra RẤT NHIỀU với tag managers).

```html
<script setup>
if (import.meta.client) {
    const { default: SomeBrowserLibrary } = await import('browser-only-lib')
    SomeBrowserLibrary.init()
}
</script>
```

**Giải pháp**: Khởi tạo thư viện sau khi hydration hoàn thành:

```html
<script setup>
onMounted(async () => {
  const { default: SomeBrowserLibrary } = await import('browser-only-lib')
  SomeBrowserLibrary.init()
})
</script>
```

## Dynamic Content Based on Time

**Vấn đề**: Nội dung thay đổi dựa trên thời gian hiện tại.

```html
<template>
  <div>{{ greeting }}</div>
</template>

<script setup>
const hour = new Date().getHours()
const greeting = hour < 12 ? 'Good morning' : 'Good afternoon'
</script>
```

**Giải pháp**: Sử dụng component [`NuxtTime`](https://nuxt.com/docs/api/components/nuxt-time) hoặc xử lý phía client:

```html
<template>
  <div>
    <NuxtTime :date="new Date()" format="HH:mm" />
  </div>
</template>
```

```html
<template>
  <div>
    <ClientOnly>
      {{ greeting }}
      <template #fallback>
        Hello!
      </template>
    </ClientOnly>
  </div>
</template>

<script setup>
const greeting = ref('Hello!')

onMounted(() => {
  const hour = new Date().getHours()
  greeting.value = hour < 12 ? 'Good morning' : 'Good afternoon'
})
</script>
```

## In summary

1. **Sử dụng composables thân thiện với SSR**: [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch), [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data), [`useState`](https://nuxt.com/docs/api/composables/use-state)
2. **Bao bọc code chỉ dành cho client**: Sử dụng component [`ClientOnly`](https://nuxt.com/docs/api/components/client-only) cho nội dung dành riêng cho trình duyệt
3. **Nguồn dữ liệu nhất quán**: Đảm bảo server và client sử dụng cùng dữ liệu
4. **Tránh side effects trong setup**: Di chuyển code phụ thuộc trình duyệt vào `onMounted`

::tip
Bạn có thể đọc [tài liệu Vue về lỗi hydration SSR](https://vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch){rel="nofollow"} để hiểu rõ hơn về hydration.
::


# Nuxt performance

Nuxt đi kèm với các tính năng tích hợp được thiết kế để cải thiện hiệu suất ứng dụng của bạn và góp phần vào [Core Web Vitals](https://web.dev/articles/vitals){rel="nofollow"} tốt hơn. Ngoài ra còn có nhiều module cốt lõi Nuxt giúp cải thiện hiệu suất trong các lĩnh vực cụ thể. Hướng dẫn này nêu ra các thực tiễn tốt nhất để tối ưu hóa hiệu suất ứng dụng Nuxt của bạn.

## Built-in Features

Nuxt cung cấp một số tính năng tích hợp giúp bạn tối ưu hóa hiệu suất của trang web. Hiểu cách các tính năng này hoạt động là rất quan trọng để đạt được hiệu suất nhanh như chớp.

### Links

[`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link) là một thay thế drop-in cho component Vue Router's `<RouterLink>` và thẻ HTML `<a>`. Nó thông minh xác định xem link là internal hay external và render tương ứng với các tối ưu hóa có sẵn (prefetching, thuộc tính mặc định, v.v.)

```html
<template>
  <NuxtLink to="/about">About page</NuxtLink>
</template>

<!-- Which will render to with Vue Router & Smart Prefetching -->
<a href="/about">About page</a>
```

Nuxt tự động bao gồm smart prefetching. Điều đó có nghĩa là nó phát hiện khi một link hiển thị (theo mặc định), trong viewport hoặc khi cuộn và prefetch JavaScript cho những trang đó để chúng sẵn sàng khi người dùng nhấp vào link.

Bạn cũng có thể chọn prefetching khi tương tác thay thế:

```ts
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        prefetchOn: 'interaction',
      },
    }
  }
})
```

::read-more
---
title: NuxtLink
to: https://nuxt.com/docs/api/components/nuxt-link
---
::

### Hybrid Rendering

Trong các ứng dụng phức tạp hơn, chúng ta có thể cần kiểm soát đầy đủ cách ứng dụng của chúng ta được render để hỗ trợ các trường hợp mà một số trang có thể được tạo tại build time, trong khi những trang khác nên được client-side rendered

Hybrid rendering cho phép các quy tắc caching khác nhau cho mỗi route bằng Route Rules và quyết định cách server phản hồi yêu cầu mới trên một URL nhất định:

```ts
export default defineNuxtConfig({
  routeRules: {
    '/': {
      prerender: true
    },
    '/products/**': {
      swr: 3600
    },
    '/blog': {
      isr: 3600
    },
    '/admin/**': {
      ssr: false
    },
  }
})
```

Server Nuxt sẽ tự động đăng ký middleware tương ứng và wrap routes với cache handlers sử dụng Nitro caching layer.

::read-more
---
title: Hybrid rendering
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
::

### Lazy Loading Components

Để import động một component (cũng được gọi là lazy-loading một component) tất cả những gì bạn cần làm là thêm tiền tố Lazy vào tên component. Điều này hữu ích nếu component không luôn cần thiết.

```html
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
  </div>
</template>
```

Bằng cách sử dụng tiền tố Lazy bạn có thể trì hoãn tải code component cho đến thời điểm phù hợp, điều này có thể giúp tối ưu hóa kích thước bundle JavaScript của bạn.

::read-more
---
title: Lazy loading components
to: https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports
---
::

### Lazy Hydration

Không phải lúc nào cũng cần hydrate (hoặc làm cho tương tác) tất cả các component của trang web của bạn khi load ban đầu. Sử dụng lazy hydration, bạn có thể kiểm soát khi code component có thể được tải, điều này có thể cải thiện metric time-to-interactive cho ứng dụng của bạn. Nuxt cho phép bạn kiểm soát khi các component trở nên tương tác với lazy hydration (được thêm vào Nuxt v3.16).

```html
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

Để tối ưu hóa ứng dụng của bạn, bạn có thể trì hoãn hydration của một số component cho đến khi chúng hiển thị, hoặc cho đến khi trình duyệt hoàn thành các tác vụ quan trọng hơn.

::read-more
---
title: Lazy hydration
to: https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration
---
::

### Fetching data

Để tránh fetch cùng dữ liệu hai lần (một lần trên server và một lần trên client) Nuxt cung cấp [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) và [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data). Chúng đảm bảo rằng nếu một API call được thực hiện trên server, dữ liệu được chuyển tiếp đến client trong payload thay vì fetch lại.

::read-more
---
title: Data fetching
to: https://nuxt.com/docs/getting-started/data-fetching
---
::

## Core Nuxt Modules

Ngoài các tính năng tích hợp của Nuxt, còn có các module cốt lõi được duy trì bởi team Nuxt giúp cải thiện hiệu suất hơn nữa. Các module này giúp xử lý assets như hình ảnh, font tùy chỉnh, hoặc third party scripts.

### Images

Hình ảnh chưa được tối ưu hóa có thể có tác động tiêu cực đáng kể đến hiệu suất trang web, đặc biệt là điểm số [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp){rel="nofollow"}.

Trong Nuxt chúng ta có thể sử dụng module [Nuxt Image](https://image.nuxt.com/){rel="nofollow"} là một plug-and-play image optimization cho các ứng dụng Nuxt. Nó cho phép resize và transform hình ảnh của bạn bằng built-in optimizer hoặc CDN hình ảnh yêu thích của bạn.

::video-accordion
---
title: Watch the video by LearnVue about Nuxt Image
video-id: _UBff2eqGY0
---
::

[`<NuxtImg>`](https://nuxt.com/docs/api/components/nuxt-img) là một thay thế drop-in cho thẻ `<img>` native đi kèm với các enhancements sau:

- Sử dụng provider tích hợp để tối ưu hóa hình ảnh local và remote
- Chuyển `src` thành provider optimized URLs với các định dạng hiện đại như WebP hoặc Avif
- Tự động resize hình ảnh dựa trên `width` và `height`
- Tạo responsive `sizes` khi cung cấp tùy chọn sizes
- Hỗ trợ `lazy loading` native cũng như các thuộc tính `<img>` khác

Hình ảnh trong trang web của bạn thường có thể được phân tách theo tầm quan trọng; những hình ảnh cần được deliver trước tại load ban đầu (tức là `Largest Contentful Paint`), và những hình ảnh có thể được tải sau hoặc khi cần cụ thể. Vì vậy, chúng ta có thể sử dụng các tối ưu hóa sau:

```html
<template>
  <!-- 🚨 Cần được tải ASAP -->
  <NuxtImg
    src="/hero-banner.jpg"
    format="webp"
    preload
    loading="eager"
    fetch-priority="high"
    width="200"
    height="100"
  />

  <!-- 🐌 Có thể tải sau -->
  <NuxtImg
    src="/facebook-logo.jpg"
    format="webp"
    loading="lazy"
    fetch-priority="low"
    width="200"
    height="100"
  />
</template>
```

::read-more{title="Nuxt Image" to="https://image.nuxt.com/usage/nuxt-img"}
::

### Fonts

[Nuxt Fonts](https://fonts.nuxt.com/){rel="nofollow"} sẽ tự động tối ưu hóa fonts của bạn (bao gồm custom fonts) và loại bỏ external network requests để cải thiện privacy và hiệu suất.

Nó bao gồm built-in automatic self-hosting cho bất kỳ file font nào, nghĩa là bạn có thể load web fonts một cách tối ưu với reduced layout shift, nhờ underlying package [fontaine](https://github.com/unjs/fontaine){rel="nofollow"}.

::video-accordion
---
title: Watch the talk by Daniel Roe about the idea behind Nuxt Fonts
video-id: D3F683UViBY
---
::

Nuxt Fonts xử lý tất cả CSS của bạn và thực hiện các việc sau khi nó gặp một font-family declaration.

1. **Resolve fonts** – Tìm kiếm file font trong public/, sau đó kiểm tra web providers như Google, Bunny, và Fontshare.
2. **Tạo @font-face rules** – Inject CSS rules để load fonts từ các nguồn chính xác.
3. **Proxy & cache fonts** – Rewrite URLs thành `/_fonts`, download và cache fonts locally.
4. **Tạo fallback metrics** – Điều chỉnh local system fonts để match web fonts, giảm layout shift ([CLS](https://web.dev/articles/cls){rel="nofollow"}).
5. **Bao gồm fonts trong build** – Bundle fonts với project của bạn, hash file names và set long-lived cache headers.

Nó hỗ trợ nhiều providers được thiết kế để pluggable và extensible, vì vậy bất kể setup của bạn là gì bạn nên có thể sử dụng một provider hiện có hoặc viết provider riêng của mình.

### Scripts

Third-party resources như analytics tools, video embeds, maps, và social media integrations nâng cao chức năng trang web nhưng có thể làm giảm đáng kể trải nghiệm người dùng và tác động tiêu cực đến [Interaction to Next Paint (INP)](https://web.dev/articles/inp){rel="nofollow"} và Largest Contentful Paint (LCP) scores.

[Nuxt Scripts](https://scripts.nuxt.com/){rel="nofollow"} cho phép bạn load third-party scripts với hiệu suất, privacy, security và DX tốt hơn.

::video-accordion
---
title: Watch the video by Alex Lichter about Nuxt Scripts
video-id: sjMqUUvH9AE
---
::

Nuxt Scripts cung cấp một abstraction layer trên top của third-party scripts, cung cấp SSR support và type-safety đồng thời vẫn cho bạn kiểm soát low-level đầy đủ về cách một script được load.

```ts
const { onLoaded, proxy } = useScriptGoogleAnalytics(
  { 
    id: 'G-1234567',
    scriptOptions: {
      trigger: 'manual',
    },
  },
)
// queue events to be sent when ga loads
proxy.gtag('config', 'UA-123456789-1')
// or wait until ga is loaded
onLoaded((gtag) => {
  // script loaded
})
```

::read-more{title="Nuxt Scripts" to="https://scripts.nuxt.com/scripts"}
::

## Profiling Tools

Để cải thiện hiệu suất, chúng ta cần biết cách đo lường nó trước, bắt đầu với đo lường hiệu suất trong quá trình phát triển - trên local environment, sau đó chuyển sang audit ứng dụng được deploy trên production.

### Nuxi Analyze

Lệnh `nuxi` này cho phép analyze production bundle hoặc ứng dụng Nuxt của bạn. Nó tận dụng `vite-bundle-visualizer` (tương tự như `webpack-bundle-analyzer`) để tạo một biểu diễn visual của bundle ứng dụng của bạn, giúp dễ dàng xác định component nào chiếm nhiều không gian nhất.

Khi bạn thấy một block lớn trong visualization, nó thường báo hiệu một cơ hội tối ưu hóa—cho dù bằng cách chia nó thành các phần nhỏ hơn, implement lazy loading, hoặc thay thế bằng một thứ hiệu quả hơn, đặc biệt là cho third-party libraries.

Large blocks chứa nhiều element có thể được giảm bằng cách import chỉ các component cần thiết thay vì toàn bộ modules trong khi large standalone blocks có thể phù hợp hơn cho lazy loading thay vì được include trong main bundle.

### Nuxt DevTools

[Nuxt DevTools](https://devtools.nuxt.com/){rel="nofollow"} cung cấp cho bạn insights và transparency về Nuxt App của bạn để xác định performance gaps và seamlessly manage cấu hình ứng dụng của bạn.

![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)

Nó đi kèm với một số tính năng chúng ta có thể sử dụng để đo lường hiệu suất của Nuxt apps:

1. **Timeline** – Theo dõi thời gian dành cho rendering, updating, và initializing components để xác định performance bottlenecks.
2. **Assets** – Hiển thị file sizes (ví dụ: hình ảnh) mà không có transformations.
3. **Render Tree** – Hiển thị connections giữa Vue components, scripts, và styles để tối ưu hóa dynamic loading.
4. **Inspect** – Liệt kê tất cả files được sử dụng trong Vue app với size và evaluation time.

### Chrome DevTools

Chrome DevTools đi kèm với hai tab hữu ích để đo lường hiệu suất; `Performance` và `Lighthouse`.

Khi bạn mở panel [Performance](https://developer.chrome.com/docs/devtools/performance/overview){rel="nofollow"}, nó ngay lập tức hiển thị local &#x2A;*Largest Contentful Paint (LCP)** và &#x2A;*Cumulative Layout Shift (CLS)** scores của bạn (tốt, cần cải thiện, hoặc xấu).

Nếu bạn tương tác với trang, nó cũng capture &#x2A;*Interaction to Next Paint (INP)**, cho bạn view đầy đủ của Core Web Vitals dựa trên thiết bị và network của bạn.

![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)

[Lighthouse](https://developer.chrome.com/docs/lighthouse){rel="nofollow"} audits hiệu suất, accessibility, SEO, progressive web apps, và best practices. Nó chạy tests trên trang của bạn và tạo một report. Sử dụng failing audits như một guide để cải thiện site của bạn.

![Lighthouse](https://developer.chrome.com/static/docs/devtools/lighthouse/images/lighthouse-overview_720.png)

Mỗi audit có một reference document giải thích tại sao audit quan trọng, cũng như cách fix nó.

### PageSpeed Insights

[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about){rel="nofollow"} báo cáo về trải nghiệm người dùng của một trang trên cả mobile và desktop devices, và cung cấp gợi ý về cách trang đó có thể được cải thiện.

Nó cung cấp cả lab và field data về một trang. Lab data hữu ích cho debugging issues, vì nó được thu thập trong môi trường kiểm soát trong khi field data hữu ích cho capturing true, real-world user experience.

### Web Page Test

[WebPageTest](https://www.webpagetest.org/){rel="nofollow"} là một web performance tool cung cấp diagnostic information sâu về cách một trang perform dưới nhiều điều kiện khác nhau.

Mỗi test có thể được chạy từ các location khác nhau trên thế giới, trên real browsers, qua bất kỳ số lượng customizable network conditions nào.

## Common problems

Khi xây dựng ứng dụng Nuxt phức tạp hơn, bạn sẽ có thể gặp một số vấn đề được liệt kê dưới đây. Hiểu các vấn đề này và fix chúng sẽ giúp bạn cải thiện hiệu suất của trang web.

### Overusing plugins

**Vấn đề**: Một số lượng lớn plugins có thể gây ra performance issues, đặc biệt nếu chúng yêu cầu expensive computations hoặc mất quá nhiều thời gian để initialize. Vì plugins chạy trong hydration phase, inefficient setups có thể block rendering và degrade trải nghiệm người dùng.

**Giải pháp**: Kiểm tra plugins của bạn và xem liệu một số có thể được implement thay thế như một composable hoặc utility function không.

### Unused code / dependencies

**Vấn đề**: Với development của project, có thể có trường hợp có một số unused code hoặc dependency. Chức năng bổ sung này có thể không được sử dụng hoặc cần thiết trong khi nó sẽ tăng bundle size của project của chúng ta.

**Giải pháp**: Kiểm tra `package.json` của bạn cho unused dependencies và analyze code của bạn cho unused utils/composables/functions.

### Not using Vue Performance tips

**Vấn đề**: [Vue documentation](https://vuejs.org/guide/best-practices/performance){rel="nofollow"} liệt kê một số Performance improvements chúng ta có thể sử dụng trong Nuxt projects của chúng ta cũng nhưng vì chúng là một phần của Vue documentation, developers có xu hướng quên về nó và tập trung vào Nuxt specific improvements only - trong khi Nuxt application vẫn là một Vue project.

**Giải pháp**: Sử dụng concepts như `shallowRef`, `v-memo`, `v-once`, v.v để cải thiện hiệu suất.

### Not following patterns

**Vấn đề**: Càng nhiều người đang làm việc trên project, càng khó để maintain stable codebase. Developers có xu hướng giới thiệu new concepts họ thấy trong một project khác có thể gây conflicts và problems với performance.

**Giải pháp**: Thiết lập rules và patterns trong project như [Good practices and Design Patterns for Vue Composables](https://dev.to/jacobandrewsky/good-practices-and-design-patterns-for-vue-composables-24lk){rel="nofollow"}

### Trying to load everything at the same time

**Vấn đề**: Khi một trang được load và nó không được hướng dẫn đúng cách về thứ tự loading elements nó sẽ dẫn đến fetching everything cùng lúc - điều này có thể chậm và dẫn đến bad User Experience.

**Giải pháp**: Sử dụng concepts như Progressive Enhancement nơi core webpage content được set first, sau đó more nuanced và technically rigorous layers of presentation và features được thêm on top khi browser/internet connection cho phép.

## Useful Resources

Để tìm hiểu thêm về các techniques khác nhau để cải thiện hiệu suất, hãy xem các resources sau:

1. [Apply instant loading with the PRPL pattern](https://web.dev/articles/apply-instant-loading-with-prpl){rel="nofollow"}
2. [Perceived performance](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/Perceived_performance){rel="nofollow"}
3. [Understanding Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Critical_rendering_path){rel="nofollow"}


# Nuxt Plugins

Plugins trong Nuxt cho phép bạn mở rộng ứng dụng của bạn với chức năng bổ sung. Tuy nhiên, việc sử dụng không đúng cách có thể dẫn đến tắc nghẽn hiệu suất. Hướng dẫn này nêu ra các thực tiễn tốt nhất để tối ưu hóa plugins Nuxt của bạn.

## Avoid costly plugin setup

Một số lượng lớn plugins có thể gây ra vấn đề hiệu suất, đặc biệt nếu chúng yêu cầu expensive computations hoặc mất quá nhiều thời gian để initialize. Vì plugins chạy trong hydration phase, inefficient setups có thể block rendering và degrade trải nghiệm người dùng.

## Use Composition whenever possible

Bất cứ khi nào có thể, ưu tiên composition over plugins. Giống như trong Vue, nhiều utilities và composables có thể được sử dụng trực tiếp mà không cần plugin. Điều này giữ cho project của bạn lightweight và cải thiện maintainability.

## If `async`, enable `parallel`

Theo mặc định, tất cả plugins load synchronously.
Khi định nghĩa asynchronous plugins, setting `parallel: true` cho phép multiple plugins load concurrently, cải thiện hiệu suất bằng cách ngăn chặn blocking operations.


# <ClientOnly>

Thành phần `<ClientOnly>` được sử dụng để cố ý hiển thị một thành phần chỉ ở phía client.

::note
Nội dung của slot mặc định sẽ được loại bỏ khỏi bản build server. (Điều này có nghĩa là bất kỳ CSS nào được sử dụng bởi các thành phần bên trong có thể không được nhúng khi hiển thị HTML ban đầu.)
::

## Props

- `placeholderTag` | `fallbackTag`: chỉ định một thẻ để được hiển thị ở phía server.
- `placeholder` | `fallback`: chỉ định nội dung để được hiển thị ở phía server.

```vue
<template>
  <div>
    <Sidebar />
    <!-- The <Comment> component will only be rendered on client-side -->
    <ClientOnly fallback-tag="span" fallback="Loading comments...">
      <Comment />
    </ClientOnly>
  </div>
</template>
```

## Slots

- `#fallback`: chỉ định nội dung để được hiển thị trên server và hiển thị cho đến khi `<ClientOnly>` được gắn vào trình duyệt.

```vue [pages/example.vue]
<template>
  <div>
    <Sidebar />
    <!-- This renders the "span" element on the server side -->
    <ClientOnly fallbackTag="span">
      <!-- this component will only be rendered on client side -->
      <Comments />
      <template #fallback>
        <!-- this will be rendered on server side -->
        <p>Loading comments...</p>
      </template>
    </ClientOnly>
  </div>
</template>
```

## Examples

### Accessing HTML Elements

Các thành phần bên trong `<ClientOnly>` chỉ được hiển thị sau khi được gắn. Để truy cập các phần tử đã hiển thị trong DOM, bạn có thể theo dõi một template ref:

```vue [pages/example.vue]
<script setup lang="ts">
const nuxtWelcomeRef = useTemplateRef('nuxtWelcomeRef')

// The watch will be triggered when the component is available
watch(nuxtWelcomeRef, () => {
  console.log('<NuxtWelcome /> mounted')
}, { once: true })
</script>

<template>
  <ClientOnly>
    <NuxtWelcome ref="nuxtWelcomeRef" />
  </ClientOnly>
</template>
```


# <DevOnly>

Nuxt cung cấp thành phần `<DevOnly>` để hiển thị một thành phần chỉ trong quá trình phát triển.

Nội dung sẽ không được bao gồm trong các bản build production.

```vue [pages/example.vue]
<template>
  <div>
    <Sidebar />
    <DevOnly>
      <!-- this component will only be rendered during development -->
      <LazyDebugBar />

      <!-- if you ever require to have a replacement during production -->
      <!-- be sure to test these using `nuxt preview` -->
      <template #fallback>
        <div><!-- empty div for flex.justify-between --></div>
      </template>
    </DevOnly>
  </div>
</template>
```

## Slots

- `#fallback`: nếu bạn từng cần có một thay thế trong production.

```vue
<template>
  <div>
    <Sidebar />
    <DevOnly>
      <!-- this component will only be rendered during development -->
      <LazyDebugBar />
      <!-- be sure to test these using `nuxt preview` -->
      <template #fallback>
        <div><!-- empty div for flex.justify-between --></div>
      </template>
    </DevOnly>
  </div>
</template>
```


# <NuxtClientFallback>

Nuxt cung cấp thành phần `<NuxtClientFallback>` để hiển thị nội dung của nó trên client nếu bất kỳ thành phần con nào gây ra lỗi trong SSR.

::note
---
to: https://nuxt.com/docs/guide/going-further/experimental-features#clientfallback
---
Thành phần này là thử nghiệm và để sử dụng nó bạn phải bật tùy chọn `experimental.clientFallback` trong `nuxt.config` của bạn.
::

```vue [pages/example.vue]
<template>
  <div>
    <Sidebar />
    <!-- this component will be rendered on client-side -->
    <NuxtClientFallback fallback-tag="span">
      <Comments />
      <BrokeInSSR />
    </NuxtClientFallback>
  </div>
</template>
```

## Events

- `@ssr-error`: Sự kiện được phát ra khi một thành phần con gây ra lỗi trong SSR. Lưu ý rằng điều này sẽ chỉ được kích hoạt trên server.
  ```vue
  <template>
    <NuxtClientFallback @ssr-error="logSomeError">
      <!-- ... -->
    </NuxtClientFallback>
  </template>
  ```

## Props

- `placeholderTag` | `fallbackTag`: Chỉ định thẻ dự phòng để được hiển thị nếu slot không thể hiển thị trên server.

  - **type**: `string`
  - **default**: `div`
- `placeholder` | `fallback`: Chỉ định nội dung dự phòng để được hiển thị nếu slot không thể hiển thị.

  - **type**: `string`
- `keepFallback`: Giữ nội dung dự phòng nếu nó không thể hiển thị ở phía server.

  - **type**: `boolean`
  - **default**: `false`

```vue
  <template>
    <!-- render <span>Hello world</span> server-side if the default slot fails to render -->
    <NuxtClientFallback fallback-tag="span" fallback="Hello world">
      <BrokeInSsr />
    </NuxtClientFallback>
  </template>
```

## Slots

- `#fallback`: chỉ định nội dung để được hiển thị ở phía server nếu slot không thể hiển thị.

```vue
<template>
  <NuxtClientFallback>
    <!-- ... -->
    <template #fallback>
      <!-- this will be rendered on server side if the default slot fails to render in ssr -->
      <p>Hello world</p>
    </template>
  </NuxtClientFallback>
</template>
```


# <NuxtPicture>

`<NuxtPicture>` là một thay thế drop-in cho thẻ `<picture>` native.

Usage của `<NuxtPicture>` gần như giống hệt [`<NuxtImg>`](https://nuxt.com/docs/api/components/nuxt-img) nhưng nó cũng cho phép serving modern formats như `webp` khi possible.

Tìm hiểu thêm về [`<picture>` tag on MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture){rel="nofollow"}.

## Setup

Để sử dụng `<NuxtPicture>` bạn nên install và enable Nuxt Image module:

```bash [Terminal]
npx nuxt module add image
```

::read-more{target="_blank" to="https://image.nuxt.com/usage/nuxt-picture"}
Read more about the `<NuxtPicture>` component.
::


# <Teleport>

::warning
Target `to` của [`<Teleport>`](https://vuejs.org/guide/built-ins/teleport.html){rel="nofollow"} expect một chuỗi CSS selector hoặc một DOM node thực tế. Nuxt hiện có SSR support cho teleports đến `#teleports` only, với client-side support cho other targets sử dụng một `<ClientOnly>` wrapper.
::

## Body Teleport

```vue
<template>
  <button @click="open = true">
    Open Modal
  </button>
  <Teleport to="#teleports">
    <div v-if="open" class="modal">
      <p>Hello from the modal!</p>
      <button @click="open = false">
        Close
      </button>
    </div>
  </Teleport>
</template>
```

## Client-side Teleport

```vue
<template>
  <ClientOnly>
    <Teleport to="#some-selector">
      <!-- content -->
    </Teleport>
  </ClientOnly>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/advanced/teleport"}
::


# <NuxtRouteAnnouncer>

::important
Thành phần này có sẵn trong Nuxt v3.12+.
::

## Usage

Thêm `<NuxtRouteAnnouncer/>` trong [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) hoặc [`layouts/`](https://nuxt.com/docs/guide/directory-structure/layouts) của bạn để enhance accessibility bằng cách inform assistive technologies về page title changes. Điều này đảm bảo rằng navigational changes được announced đến users dựa vào screen readers.

```vue [app.vue]
<template>
  <NuxtRouteAnnouncer />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

## Slots

Bạn có thể truyền HTML tùy chỉnh hoặc components qua default slot của route announcer.

```vue
  <template>
    <NuxtRouteAnnouncer>
      <template #default="{ message }">
        <p>{{ message }} was loaded.</p>
      </template>
    </NuxtRouteAnnouncer>
  </template>
```

## Props

- `atomic`: Kiểm soát liệu screen readers chỉ announce changes hay toàn bộ content. Đặt thành true cho full content readouts on updates, false cho changes only. (mặc định `false`)
- `politeness`: Đặt urgency cho screen reader announcements: `off` (disable the announcement), `polite` (waits for silence), hoặc `assertive` (interrupts immediately). (mặc định `polite`)

::callout
Thành phần này là tùy chọn. :br
Để đạt được full customization, bạn có thể implement một cái của riêng bạn dựa trên [source code của nó](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-route-announcer.ts){rel="nofollow"}.
::

::callout
Bạn có thể hook vào underlying announcer instance sử dụng [the `useRouteAnnouncer` composable](https://nuxt.com/docs/api/composables/use-route-announcer), điều này cho phép bạn set một custom announcement message.
::


# <NuxtTime>

::important
Thành phần này có sẵn trong Nuxt v3.17+.
::

Thành phần `<NuxtTime>` cho phép bạn hiển thị dates và times trong format locale-friendly với proper `<time>` HTML semantics. Nó đảm bảo consistent rendering giữa server và client without hydration mismatches.

## Usage

Bạn có thể sử dụng thành phần `<NuxtTime>` anywhere trong app của bạn:

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
</template>
```

## Props

### `datetime`

- Type: `Date | number | string`
- Required: `true`

Giá trị date và time để hiển thị. Bạn có thể cung cấp:

- Một `Date` object
- Một timestamp (number)
- Một ISO-formatted date string

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
  <NuxtTime :datetime="new Date()" />
  <NuxtTime datetime="2023-06-15T09:30:00.000Z" />
</template>
```

### `locale`

- Type: `string`
- Required: `false`
- Default: Sử dụng browser hoặc server's default locale

[BCP 47 language tag](https://datatracker.ietf.org/doc/html/rfc5646){rel="nofollow"} cho formatting (ví dụ, 'en-US', 'fr-FR', 'ja-JP'):

```vue
<template>
  <NuxtTime :datetime="Date.now()" locale="fr-FR" />
</template>
```

### Formatting Props

Thành phần chấp nhận bất kỳ property nào từ [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat){rel="nofollow"} options:

```vue
<template>
  <NuxtTime 
    :datetime="Date.now()" 
    year="numeric"
    month="long"
    day="numeric"
    hour="2-digit"
    minute="2-digit"
  />
</template>
```

Điều này sẽ output something like: "April 22, 2025, 08:30 AM"

### `relative`

- Type: `boolean`
- Required: `false`
- Default: `false`

Bật relative time formatting sử dụng Intl.RelativeTimeFormat API:

```vue
<template>
  <!-- Shows something like "5 minutes ago" -->
  <NuxtTime :datetime="Date.now() - 5 * 60 * 1000" relative />
</template>
```

### Relative Time Formatting Props

Khi `relative` được đặt thành `true`, thành phần cũng chấp nhận properties từ [Intl.RelativeTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat){rel="nofollow"}:

```vue
<template>
  <NuxtTime 
    :datetime="Date.now() - 3 * 24 * 60 * 60 * 1000" 
    relative 
    numeric="auto"
    style="long"
  />
</template>
```

Điều này sẽ output something like: "3 days ago" hoặc "last Friday" tùy thuộc vào setting `numeric`.

## Examples

### Basic Usage

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
</template>
```

### Custom Formatting

```vue
<template>
  <NuxtTime 
    :datetime="Date.now()" 
    weekday="long"
    year="numeric"
    month="short"
    day="numeric"
    hour="numeric"
    minute="numeric"
    second="numeric"
    timeZoneName="short"
  />
</template>
```

### Relative Time

```vue
<template>
  <div>
    <p>
      <NuxtTime :datetime="Date.now() - 30 * 1000" relative />
      <!-- 30 seconds ago -->
    </p>
    <p>  
      <NuxtTime :datetime="Date.now() - 45 * 60 * 1000" relative />
      <!-- 45 minutes ago -->
    </p>
    <p>
      <NuxtTime :datetime="Date.now() + 2 * 24 * 60 * 60 * 1000" relative />
      <!-- in 2 days -->
    </p>
  </div>
</template>
```

### With Custom Locale

```vue
<template>
  <div>
    <NuxtTime :datetime="Date.now()" locale="en-US" weekday="long" />
    <NuxtTime :datetime="Date.now()" locale="fr-FR" weekday="long" />
    <NuxtTime :datetime="Date.now()" locale="ja-JP" weekday="long" />
  </div>
</template>
```


# <NuxtPage>

`<NuxtPage>` là một thành phần tích hợp đi kèm với Nuxt. Nó cho phép bạn hiển thị các trang cấp cao nhất hoặc lồng nhau nằm trong thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages).

::note
`<NuxtPage>` là một wrapper xung quanh [`<RouterView>`](https://router.vuejs.org/api/interfaces/RouterViewProps.html#interface-routerviewprops){rel="nofollow"} từ Vue Router. Nó nên được sử dụng thay vì `<RouterView>` vì cái trước đó đảm nhận thêm các trạng thái nội bộ. Nếu không, `useRoute()` có thể trả về các đường dẫn không chính xác.
::

`<NuxtPage>` bao gồm các thành phần sau:

```vue
<template>
  <RouterView #default="{ Component }">
    <!-- Optional, when using transitions -->
    <Transition>
      <!-- Optional, when using keep-alive -->
      <KeepAlive>
        <Suspense>
          <component :is="Component" />
        </Suspense>
      </KeepAlive>
    </Transition>
  </RouterView>
</template>
```

Theo mặc định, Nuxt không bật `<Transition>` và `<KeepAlive>`. Bạn có thể bật chúng trong file nuxt.config hoặc bằng cách đặt các thuộc tính `transition` và `keepalive` trên `<NuxtPage>`. Nếu bạn muốn định nghĩa một trang cụ thể, bạn có thể đặt nó trong `definePageMeta` trong thành phần trang.

::warning
Nếu bạn bật `<Transition>` trong thành phần trang của mình, hãy đảm bảo rằng trang có một phần tử gốc duy nhất.
::

Vì `<NuxtPage>` sử dụng `<Suspense>` dưới hood, hành vi vòng đời thành phần trong quá trình thay đổi trang khác với ứng dụng Vue điển hình.

Trong một ứng dụng Vue điển hình, một thành phần trang mới được gắn **chỉ sau** khi cái trước đó đã được gỡ bỏ hoàn toàn. Tuy nhiên, trong Nuxt, do cách Vue `<Suspense>` được triển khai, thành phần trang mới được gắn **trước** khi cái trước đó được gỡ bỏ.

## Props

- `name`: yêu cầu `<RouterView>` hiển thị thành phần với tên tương ứng trong tùy chọn components của bản ghi route khớp.

  - type: `string`
- `route`: route location that has all of its components resolved.

  - type: `RouteLocationNormalized`
- `pageKey`: kiểm soát khi thành phần `NuxtPage` được re-render.

  - type: `string` hoặc `function`
- `transition`: định nghĩa các chuyển tiếp toàn cục cho tất cả các trang được hiển thị với thành phần `NuxtPage`.

  - type: `boolean` hoặc [`TransitionProps`](https://vuejs.org/api/built-in-components#transition){rel="nofollow"}
- `keepalive`: kiểm soát bảo tồn trạng thái của các trang được hiển thị với thành phần `NuxtPage`.

  - type: `boolean` hoặc [`KeepAliveProps`](https://vuejs.org/api/built-in-components#keepalive){rel="nofollow"}

::tip
Nuxt tự động giải quyết `name` và `route` bằng cách quét và hiển thị tất cả các file thành phần Vue được tìm thấy trong thư mục `/pages`.
::

## Example

Ví dụ, nếu bạn truyền một key không bao giờ thay đổi, thành phần `<NuxtPage>` sẽ được hiển thị chỉ một lần - khi nó được gắn lần đầu.

```vue [app.vue]
<template>
  <NuxtPage page-key="static" />
</template>
```

Bạn cũng có thể sử dụng một key động dựa trên route hiện tại:

```html
<NuxtPage :page-key="route => route.fullPath" />
```

::warning
Đừng sử dụng đối tượng `$route` ở đây vì nó có thể gây ra vấn đề với cách `<NuxtPage>` hiển thị các trang với `<Suspense>`.
::

Ngoài ra, `pageKey` có thể được truyền dưới dạng giá trị `key` qua [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) từ phần `<script>` của thành phần Vue của bạn trong thư mục `/pages`.

```vue [pages/my-page.vue]
<script setup lang="ts">
definePageMeta({
  key: route => route.fullPath
})
</script>
```

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::

## Page's Ref

Để lấy `ref` của một thành phần trang, truy cập nó qua `ref.value.pageRef`

```vue [app.vue]
<script setup lang="ts">
const page = ref()

function logFoo () {
  page.value.pageRef.foo()
}
</script>

<template>
  <NuxtPage ref="page" />
</template>
```

```vue [my-page.vue]
<script setup lang="ts">
const foo = () => {
  console.log('foo method called')
}

defineExpose({
  foo,
})
</script>
```

## Custom Props

`<NuxtPage>` cũng chấp nhận các props tùy chỉnh mà bạn có thể cần truyền xuống cấp bậc thấp hơn.

Ví dụ, trong ví dụ dưới đây, giá trị của `foobar` sẽ được truyền đến thành phần `NuxtPage` và sau đó đến các thành phần trang.

```vue [app.vue]
<template>
  <NuxtPage :foobar="123" />
</template>
```

Chúng ta có thể truy cập prop `foobar` trong thành phần trang:

```vue [pages/page.vue]
<script setup lang="ts">
const props = defineProps<{ foobar: number }>()
console.log(props.foobar) // Outputs: 123
</script>
```

Nếu bạn chưa định nghĩa prop với `defineProps`, bất kỳ props nào được truyền xuống `NuxtPage` vẫn có thể được truy cập trực tiếp từ `attrs` của trang:

```vue [pages/page.vue]
<script setup lang="ts">
const attrs = useAttrs()
console.log(attrs.foobar) // Outputs: 123
</script>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/pages"}
::


# <NuxtLayout>

Bạn có thể sử dụng thành phần `<NuxtLayout />` để kích hoạt layout `default` trên `app.vue` hoặc `error.vue`.

```vue [app.vue]
<template>
  <NuxtLayout>
    some page content
  </NuxtLayout>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/layouts"}
::

## Props

- `name`: Chỉ định tên layout để được hiển thị, có thể là một chuỗi, tham chiếu reactive hoặc thuộc tính computed. Nó **phải** khớp với tên của file layout tương ứng trong thư mục [`layouts/`](https://nuxt.com/docs/guide/directory-structure/layouts).

  - **type**: `string`
  - **default**: `default`

```vue [pages/index.vue]
<script setup lang="ts">
// layouts/custom.vue
const layout = 'custom'
</script>

<template>
  <NuxtLayout :name="layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

::note
Lưu ý rằng tên layout được chuẩn hóa thành kebab-case, vì vậy nếu file layout của bạn được đặt tên `errorLayout.vue`, nó sẽ trở thành `error-layout` khi được truyền dưới dạng thuộc tính `name` cho `<NuxtLayout />`.
::

```vue [error.vue]
<template>
  <NuxtLayout name="error-layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/layouts"}
::

Đọc thêm về dynamic layouts.

- `fallback`: Nếu một layout không hợp lệ được truyền đến prop `name`, không có layout nào sẽ được hiển thị. Chỉ định một layout `fallback` để được hiển thị trong trường hợp này. Nó **phải** khớp với tên của file layout tương ứng trong thư mục [`layouts/`](https://nuxt.com/docs/guide/directory-structure/layouts).

  - **type**: `string`
  - **default**: `null`

## Additional Props

`NuxtLayout` cũng chấp nhận bất kỳ props bổ sung nào mà bạn có thể cần truyền đến layout. Các props tùy chỉnh này sau đó được làm cho có thể truy cập dưới dạng attributes.

```vue [pages/some-page.vue]
<template>
  <div>
    <NuxtLayout name="custom" title="I am a custom layout">
      <-- ... -->
    </NuxtLayout>
  </div>
</template>
```

Trong ví dụ trên, giá trị của `title` sẽ có sẵn bằng cách sử dụng `$attrs.title` trong template hoặc `useAttrs().title` trong `<script setup>` tại custom.vue.

```vue [layouts/custom.vue]
<script setup lang="ts">
const layoutCustomProps = useAttrs()

console.log(layoutCustomProps.title) // I am a custom layout
</script>
```

## Transitions

`<NuxtLayout />` hiển thị nội dung đến qua `<slot />`, sau đó được bọc xung quanh thành phần `<Transition />` của Vue để kích hoạt chuyển tiếp layout. Để điều này hoạt động như mong đợi, khuyến nghị rằng `<NuxtLayout />` **không phải** là phần tử gốc của thành phần trang.

::code-group
```vue [pages/index.vue]
<template>
  <div>
    <NuxtLayout name="custom">
      <template #header> Some header template content. </template>
    </NuxtLayout>
  </div>
</template>
```

```vue [layouts/custom.vue]
<template>
  <div>
    <!-- named slot -->
    <slot name="header" />
    <slot />
  </div>
</template>
```
::

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

## Layout's Ref

Để lấy ref của một thành phần layout, truy cập nó qua `ref.value.layoutRef`.

::code-group
```vue [app.vue]
<script setup lang="ts">
const layout = ref()

function logFoo () {
  layout.value.layoutRef.foo()
}
</script>

<template>
  <NuxtLayout ref="layout">
    default layout
  </NuxtLayout>
</template>
```

```vue [layouts/default.vue]
<script setup lang="ts">
const foo = () => console.log('foo')
defineExpose({
  foo
})
</script>

<template>
  <div>
    default layout
    <slot />
  </div>
</template>
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/layouts"}
::


# <NuxtLink>

::note
`<NuxtLink>` là một thay thế drop-in cho cả thành phần `<RouterLink>` của Vue Router và thẻ `<a>` của HTML. Nó thông minh xác định xem link là *internal* hay *external* và hiển thị nó tương ứng với các tối ưu hóa có sẵn (prefetching, default attributes, etc.)
::

## Internal Routing

Trong ví dụ này, chúng ta sử dụng thành phần `<NuxtLink>` để link đến một trang khác của ứng dụng.

::code-group
```vue [pages/index.vue]
<template>
  <NuxtLink to="/about">About page</NuxtLink>
</template>
```

```html [(Renders as) index.html]
<!-- (Vue Router & Smart Prefetching) -->
<a href="/about">About page</a>
```
::

### Passing Params to Dynamic Routes

Trong ví dụ này, chúng ta truyền param `id` để link đến route `~/pages/posts/[id].vue`.

::code-group
```vue [pages/index.vue]
<template>
  <NuxtLink :to="{ name: 'posts-id', params: { id: 123 } }">
    Post 123
  </NuxtLink>
</template>
```

```html [(Renders as) index.html]
<a href="/posts/123">Post 123</a>
```
::

::tip
Kiểm tra panel Pages trong Nuxt DevTools để xem tên route và các params nó có thể nhận.
::

::tip
Khi bạn truyền một object vào prop `to`, `<NuxtLink>` sẽ kế thừa xử lý query parameters của Vue Router. Keys và values sẽ được tự động encode, vì vậy bạn không cần gọi `encodeURI` hoặc `encodeURIComponent` thủ công.
::

### Handling Static File and Cross-App Links

Theo mặc định, `<NuxtLink>` sử dụng navigation phía client của Vue Router cho relative route. Khi link đến static files trong thư mục `/public` hoặc đến một ứng dụng khác được host trên cùng domain, nó có thể dẫn đến lỗi 404 không mong muốn vì chúng không phải là phần của client routes. Trong những trường hợp như vậy, bạn có thể sử dụng prop `external` với `<NuxtLink>` để bypass cơ chế routing nội bộ của Vue Router.

Prop `external` rõ ràng chỉ ra rằng link là external. `<NuxtLink>` sẽ render link dưới dạng thẻ `<a>` HTML chuẩn. Điều này đảm bảo link hoạt động chính xác, bypass logic của Vue Router và trực tiếp trỏ đến resource.

#### Linking to Static Files

Đối với static files trong thư mục `/public`, chẳng hạn như PDFs hoặc images, sử dụng prop `external` để đảm bảo link resolve chính xác.

```vue [pages/index.vue]
<template>
  <NuxtLink to="/example-report.pdf" external>
    Download Report
  </NuxtLink>
</template>
```

#### Linking to a Cross-App URL

Khi trỏ đến một ứng dụng khác trên cùng domain, sử dụng prop `external` đảm bảo hành vi chính xác.

```vue [pages/index.vue]
<template>
  <NuxtLink to="/another-app" external>
    Go to Another App
  </NuxtLink>
</template>
```

Sử dụng prop `external` hoặc dựa vào xử lý tự động đảm bảo navigation đúng, tránh các vấn đề routing không mong muốn, và cải thiện tương thích với static resources hoặc cross-application scenarios.

## External Routing

Trong ví dụ này, chúng ta sử dụng thành phần `<NuxtLink>` để link đến một website.

```vue [app.vue]
<template>
  <NuxtLink to="https://nuxtjs.org">
    Nuxt website
  </NuxtLink>
  <!-- <a href="https://nuxtjs.org" rel="noopener noreferrer">...</a> -->
</template>
```

## `rel` and `noRel` Attributes

Một attribute `rel` của `noopener noreferrer` được áp dụng theo mặc định cho links với attribute `target` hoặc cho absolute links (ví dụ, links bắt đầu với `http://`, `https://`, hoặc `//`).

- `noopener` giải quyết một [lỗi bảo mật](https://mathiasbynens.github.io/rel-noopener/){rel="nofollow"} trong các trình duyệt cũ.
- `noreferrer` cải thiện privacy cho người dùng của bạn bằng cách không gửi header `Referer` đến site được link.

Những mặc định này không có tác động tiêu cực đến SEO và được coi là [best practice](https://developer.chrome.com/docs/lighthouse/best-practices/external-anchors-use-rel-noopener){rel="nofollow"}.

Khi bạn cần overwrite hành vi này bạn có thể sử dụng props `rel` hoặc `noRel`.

```vue [app.vue]
<template>
  <NuxtLink to="https://twitter.com/nuxt_js">
    Nuxt Twitter
  </NuxtLink>
  <!-- <a href="https://twitter.com/nuxt_js" rel="noopener noreferrer">...</a> -->

  <NuxtLink to="https://discord.nuxtjs.org" rel="noopener">
    Nuxt Discord
  </NuxtLink>
  <!-- <a href="https://discord.nuxtjs.org" rel="noopener">...</a> -->

  <NuxtLink to="/about" target="_blank">About page</NuxtLink>
  <!-- <a href="/about" target="_blank" rel="noopener noreferrer">...</a> -->
</template>
```

Prop `noRel` có thể được sử dụng để ngăn attribute `rel` mặc định được thêm vào absolute links.

```vue [app.vue]
<template>
  <NuxtLink to="https://github.com/nuxt" no-rel>
    Nuxt GitHub
  </NuxtLink>
  <!-- <a href="https://github.com/nuxt">...</a> -->
</template>
```

::note
`noRel` và `rel` không thể được sử dụng cùng nhau. `rel` sẽ bị bỏ qua.
::

## Prefetch Links

Nuxt tự động bao gồm smart prefetching. Điều đó có nghĩa là nó phát hiện khi một link hiển thị (theo mặc định), hoặc trong viewport hoặc khi scroll và prefetch JavaScript cho những trang đó để chúng sẵn sàng khi người dùng click link. Nuxt chỉ load resources khi trình duyệt không bận và bỏ qua prefetching nếu connection của bạn offline hoặc chỉ có 2g.

```vue [pages/index.vue]
<NuxtLink to="/about" no-prefetch>About page not pre-fetched</NuxtLink>
<NuxtLink to="/about" :prefetch="false">About page not pre-fetched</NuxtLink>
```

### Custom Prefetch Triggers

Chúng ta hiện hỗ trợ custom prefetch triggers cho `<NuxtLink>` sau `v3.13.0`. Bạn có thể sử dụng prop `prefetchOn` để kiểm soát khi nào prefetch links.

```vue
<template>
  <NuxtLink prefetch-on="visibility">
    This will prefetch when it becomes visible (default)
  </NuxtLink>

  <NuxtLink prefetch-on="interaction">
    This will prefetch when hovered or when it gains focus
  </NuxtLink>
</template>
```

- `visibility`: Prefetch khi link trở nên hiển thị trong viewport. Giám sát giao thoa của element với viewport sử dụng [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API){rel="nofollow"}. Prefetching được kích hoạt khi element được scroll vào view.
- `interaction`: Prefetch khi link được hover hoặc focus. Cách tiếp cận này lắng nghe events `pointerenter` và `focus`, chủ động prefetch resources khi người dùng chỉ ra ý định tương tác.

Bạn cũng có thể sử dụng một object để cấu hình `prefetchOn`:

```vue
<template>
  <NuxtLink :prefetch-on="{ interaction: true }">
    This will prefetch when hovered or when it gains focus
  </NuxtLink>
</template>
```

Bạn có lẽ không muốn cả hai được bật!

```vue
<template>
  <NuxtLink :prefetch-on="{ visibility: true, interaction: true }">
    This will prefetch when hovered/focus - or when it becomes visible
  </NuxtLink>
</template>
```

Cấu hình này sẽ quan sát khi element enters viewport và cũng lắng nghe events `pointerenter` và `focus`. Điều này có thể dẫn đến việc sử dụng resource không cần thiết hoặc prefetching redundant, vì cả hai triggers có thể prefetch cùng một resource dưới các điều kiện khác nhau.

### Enable Cross-origin Prefetch

Để bật cross-origin prefetching, bạn có thể đặt tùy chọn `crossOriginPrefetch` trong `nuxt.config` của bạn. Điều này sẽ bật cross-origin prefetching sử dụng [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API){rel="nofollow"}.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    crossOriginPrefetch: true,
  },
})
```

### Disable prefetch globally

Cũng có thể bật/tắt prefetching tất cả links globally cho app của bạn.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        prefetch: false,
      },
    },
  },
})
```

## Props

### RouterLink

Khi không sử dụng `external`, `<NuxtLink>` hỗ trợ tất cả [`RouterLink` props](https://router.vuejs.org/api/interfaces/RouterLinkProps.html){rel="nofollow"} của Vue Router

- `to`: Bất kỳ URL nào hoặc một [route location object](https://router.vuejs.org/api/type-aliases/RouteLocation.html){rel="nofollow"} từ Vue Router
- `custom`: Liệu `<NuxtLink>` có nên wrap nội dung của nó trong một element `<a>`. Nó cho phép lấy full control của cách một link được render và cách navigation hoạt động khi nó được click. Hoạt động giống như [Vue Router's `custom` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-custom){rel="nofollow"}
- `exactActiveClass`: Một class để áp dụng trên exact active links. Hoạt động giống như [Vue Router's `exactActiveClass` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-exactActiveClass){rel="nofollow"} trên internal links. Mặc định là mặc định của Vue Router (`"router-link-exact-active"`)
- `activeClass`: Một class để áp dụng trên active links. Hoạt động giống như [Vue Router's `activeClass` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-activeClass){rel="nofollow"} trên internal links. Mặc định là mặc định của Vue Router (`"router-link-active"`)
- `replace`: Hoạt động giống như [Vue Router's `replace` prop](https://router.vuejs.org/api/interfaces/RouteLocationOptions.html#Properties-replace){rel="nofollow"} trên internal links
- `ariaCurrentValue`: Một `aria-current` attribute value để áp dụng trên exact active links. Hoạt động giống như [Vue Router's `ariaCurrentValue` prop](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-ariaCurrentValue){rel="nofollow"} trên internal links

### NuxtLink

- `href`: Một alias cho `to`. Nếu được sử dụng với `to`, `href` sẽ bị bỏ qua
- `noRel`: Nếu đặt thành `true`, không có attribute `rel` nào sẽ được thêm vào external link
- `external`: Buộc link được render dưới dạng thẻ `<a>` thay vì Vue Router `RouterLink`.
- `prefetch`: Khi được bật sẽ prefetch middleware, layouts và payloads (khi sử dụng [payloadExtraction](https://nuxt.com/docs/api/nuxt-config#crossoriginprefetch)) của links trong viewport. Được sử dụng bởi experimental [crossOriginPrefetch](https://nuxt.com/docs/api/nuxt-config#crossoriginprefetch) config.
- `prefetchOn`: Cho phép kiểm soát tùy chỉnh khi nào prefetch links. Các tùy chọn có thể là `interaction` và `visibility` (mặc định). Bạn cũng có thể truyền một object cho full control, ví dụ: `{ interaction: true, visibility: true }`. Prop này chỉ được sử dụng khi `prefetch` được bật (mặc định) và `noPrefetch` không được đặt.
- `noPrefetch`: Tắt prefetching.
- `prefetchedClass`: Một class để áp dụng cho links đã được prefetched.

### Anchor

- `target`: Một giá trị attribute `target` để áp dụng trên link
- `rel`: Một giá trị attribute `rel` để áp dụng trên link. Mặc định là `"noopener noreferrer"` cho external links.

::tip
Mặc định có thể được overwritten, xem [overwriting defaults](https://nuxt.com/#overwriting-defaults) nếu bạn muốn thay đổi chúng.
::

## Overwriting Defaults

### In Nuxt Config

Bạn có thể overwrite một số mặc định của `<NuxtLink>` trong [`nuxt.config`](https://nuxt.com/docs/api/nuxt-config#defaults) của bạn

::important
Những tùy chọn này có khả năng sẽ được di chuyển đến nơi khác trong tương lai, chẳng hạn như vào `app.config` hoặc vào thư mục `app/`.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        // default values
        componentName: 'NuxtLink',
        externalRelAttribute: 'noopener noreferrer',
        activeClass: 'router-link-active',
        exactActiveClass: 'router-link-exact-active',
        prefetchedClass: undefined, // can be any valid string class name
        trailingSlash: undefined // can be 'append' or 'remove'
        prefetch: true,
        prefetchOn: { visibility: true } 
      }
    }
  }
})
```

### Custom Link Component

Bạn có thể overwrite mặc định của `<NuxtLink>` bằng cách tạo thành phần link của riêng bạn sử dụng `defineNuxtLink`.

```js [components/MyNuxtLink.ts]
export default defineNuxtLink({
  componentName: 'MyNuxtLink',
  /* see signature below for more */
})
```

Sau đó bạn có thể sử dụng thành phần `<MyNuxtLink />` như bình thường với mặc định mới của bạn.

### `defineNuxtLink` Signature

```ts
interface NuxtLinkOptions {
  componentName?: string;
  externalRelAttribute?: string;
  activeClass?: string;
  exactActiveClass?: string;
  trailingSlash?: 'append' | 'remove'
  prefetch?: boolean
  prefetchedClass?: string
  prefetchOn?: Partial<{
    visibility: boolean
    interaction: boolean
  }>
}
function defineNuxtLink(options: NuxtLinkOptions): Component {}
```

- `componentName`: Một tên cho thành phần. Mặc định là `NuxtLink`.
- `externalRelAttribute`: Một giá trị attribute `rel` mặc định áp dụng trên external links. Mặc định là `"noopener noreferrer"`. Đặt nó thành `""` để tắt
- `activeClass`: Một class mặc định để áp dụng trên active links. Hoạt động giống như [Vue Router's `linkActiveClass` option](https://router.vuejs.org/api/interfaces/RouterOptions.html#Properties-linkActiveClass){rel="nofollow"}. Mặc định là mặc định của Vue Router (`"router-link-active"`)
- `exactActiveClass`: Một class mặc định để áp dụng trên exact active links. Hoạt động giống như [Vue Router's `linkExactActiveClass` option](https://router.vuejs.org/api/interfaces/RouterOptions.html#Properties-linkExactActiveClass){rel="nofollow"}. Mặc định là mặc định của Vue Router (`"router-link-exact-active"`)
- `trailingSlash`: Một tùy chọn để thêm hoặc xóa trailing slashes trong `href`. Nếu unset hoặc không matching các giá trị hợp lệ `append` hoặc `remove`, nó sẽ bị bỏ qua.
- `prefetch`: Liệu có prefetch links theo mặc định hay không.
- `prefetchOn`: Kiểm soát granular của strategies prefetch nào để áp dụng theo mặc định.
- `prefetchedClass`: Một class mặc định để áp dụng cho links đã được prefetched.

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::


# <NuxtLoadingIndicator>

## Usage

Thêm `<NuxtLoadingIndicator/>` trong [`app.vue`](https://nuxt.com/docs/guide/directory-structure/app) hoặc [`layouts/`](https://nuxt.com/docs/guide/directory-structure/layouts) của bạn.

```vue [app.vue]
<template>
  <NuxtLoadingIndicator />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

::link-example{to="https://nuxt.com/docs/examples/routing/pages"}
::

## Slots

Bạn có thể truyền HTML tùy chỉnh hoặc components qua default slot của loading indicator.

## Props

- `color`: Màu của loading bar. Nó có thể được đặt thành `false` để tắt explicit color styling.
- `errorColor`: Màu của loading bar khi `error` được đặt thành `true`.
- `height`: Chiều cao của loading bar, tính bằng pixels (mặc định `3`).
- `duration`: Thời lượng của loading bar, tính bằng milliseconds (mặc định `2000`).
- `throttle`: Throttle việc xuất hiện và ẩn, tính bằng milliseconds (mặc định `200`).
- `estimatedProgress`: Theo mặc định Nuxt sẽ back off khi nó approaches 100%. Bạn có thể cung cấp một function tùy chỉnh để customize estimation tiến trình, là một function nhận duration của loading bar (ở trên) và elapsed time. Nó nên trả về một giá trị giữa 0 và 100.

::note
Thành phần này là tùy chọn. :br
Để đạt được full customization, bạn có thể implement một cái của riêng bạn dựa trên [source code của nó](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-loading-indicator.ts){rel="nofollow"}.
::

::note
Bạn có thể hook vào underlying indicator instance sử dụng [the `useLoadingIndicator` composable](https://nuxt.com/docs/api/composables/use-loading-indicator), điều này sẽ cho phép bạn trigger start/finish events của riêng bạn.
::

::tip
Tốc độ của loading indicator dần giảm sau khi đạt đến một điểm cụ thể được kiểm soát bởi `estimatedProgress`. Điều chỉnh này cung cấp một reflection chính xác hơn của thời gian load trang dài hơn và ngăn indicator hiển thị 100% completion sớm.
::


# <NuxtErrorBoundary>

::tip
`<NuxtErrorBoundary>` sử dụng hook [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"} của Vue dưới hood.
::

## Events

- `@error`: Sự kiện được phát ra khi default slot của thành phần throw một error.
  ```vue
  <template>
    <NuxtErrorBoundary @error="logSomeError">
      <!-- ... -->
    </NuxtErrorBoundary>
  </template>
  ```

## Slots

- `#error`: Chỉ định nội dung dự phòng để hiển thị trong trường hợp error.
  ```vue
    <template>
      <NuxtErrorBoundary>
        <!-- ... -->
        <template #error="{ error, clearError }">
          <p>An error occurred: {{ error }}</p>

          <button @click="clearError">Clear error</button>
        </template>
      </NuxtErrorBoundary>
    </template>
  ```

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::

## Examples

### Accessing `error` and `clearError` in script

Bạn có thể truy cập properties `error` và `clearError` trong script của thành phần như dưới đây:

```vue
<template>
  <NuxtErrorBoundary ref="errorBoundary">
    <!-- ... -->
  </NuxtErrorBoundary>
</template>

<script setup lang="ts">
const errorBoundary = useTemplateRef('errorBoundary')

// errorBoundary.value?.error
// errorBoundary.value?.clearError()
</script>
```


# <NuxtWelcome>

Nó bao gồm links đến tài liệu Nuxt, source code, và tài khoản social media.

```vue [app.vue]
<template>
  <NuxtWelcome />
</template>
```

::read-more
---
target: _blank
to: https://templates.ui.nuxtjs.org/templates/welcome
---
Preview the `<NuxtWelcome />` component.
::

::tip
Thành phần này là phần của [nuxt/assets](https://github.com/nuxt/assets){rel="nofollow"}.
::


# <NuxtIsland>

Khi render một thành phần island, nội dung của thành phần island là static, do đó không có JS nào được download phía client.

Thay đổi props của thành phần island kích hoạt refetch của thành phần island để re-render nó lại.

::note
Global styles của ứng dụng của bạn được gửi với response.
::

::tip
Server only components sử dụng `<NuxtIsland>` dưới hood
::

## Props

- `name` : Tên của thành phần để render.

  - **type**: `string`
  - **required**
- `lazy`: Làm cho thành phần non-blocking.

  - **type**: `boolean`
  - **default**: `false`
- `props`: Props để gửi đến thành phần để render.

  - **type**: `Record<string, any>`
- `source`: Remote source để call island để render.

  - **type**: `string`
- **dangerouslyLoadClientComponents**: Required để load components từ remote source.

  - **type**: `boolean`
  - **default**: `false`

::note
Remote islands cần `experimental.componentIslands` là `'local+remote'` trong `nuxt.config` của bạn.
Nó được khuyến cáo mạnh mẽ không bật `dangerouslyLoadClientComponents` vì bạn không thể tin tưởng javascript của remote server.
::

::note
Theo mặc định, component islands được scan từ thư mục `~/components/islands/`. Vì vậy thành phần `~/components/islands/MyIsland.vue` có thể được render với `<NuxtIsland name="MyIsland" />`.
::

## Slots

Slots có thể được truyền đến một thành phần island nếu được khai báo.

Mọi slot là interactive vì parent component là cái cung cấp nó.

Một số slots được reserved cho `NuxtIsland` cho special cases.

- `#fallback`: Chỉ định nội dung để được render trước khi island load (nếu thành phần là lazy) hoặc nếu `NuxtIsland` fail to fetch thành phần.

## Ref

- `refresh()`
  - **type**: `() => Promise<void>`
  - **description**: force refetch server component by refetching it.

## Events

- `error`
  - **parameters**:

    - **error**:

      - **type**: `unknown`
  - **description**: emitted when `NuxtIsland` fails to fetch the new island.


# <NuxtImg>

`<NuxtImg>` là một thay thế drop-in cho thẻ `<img>` native.

- Sử dụng built-in provider để optimize local và remote images
- Chuyển `src` thành provider-optimized URLs
- Tự động resize images dựa trên `width` và `height`
- Tạo responsive sizes khi cung cấp tùy chọn `sizes`
- Hỗ trợ native lazy loading cũng như các attributes `<img>` khác

## Setup

Để sử dụng `<NuxtImg>` bạn nên install và enable Nuxt Image module:

```bash [Terminal]
npx nuxt module add image
```

## Usage

`<NuxtImg>` output một thẻ `img` native trực tiếp (không có wrapper xung quanh nó). Sử dụng nó như bạn sử dụng thẻ `<img>`:

```html
<NuxtImg src="/nuxt-icon.png" />
```

Sẽ result in:

```html
<img src="/nuxt-icon.png" />
```

::read-more{target="_blank" to="https://image.nuxt.com/usage/nuxt-img"}
Read more about the `<NuxtImg>` component.
::


# onPrehydrate

::important
Composable này có sẵn trong Nuxt v3.12+.
::

`onPrehydrate` là một composable lifecycle hook cho phép bạn chạy một callback trên client ngay lập tức trước khi Nuxt hydrate trang.

::note
Đây là một tiện ích nâng cao và nên được sử dụng cẩn thận. Ví dụ, [`nuxt-time`](https://github.com/danielroe/nuxt-time/pull/251){rel="nofollow"} và [`@nuxtjs/color-mode`](https://github.com/nuxt-modules/color-mode/blob/main/src/script.js){rel="nofollow"} thao tác DOM để tránh các lỗi hydration không khớp.
::

## Usage

Gọi `onPrehydrate` trong hàm setup của một Vue component (ví dụ, trong `<script setup>`) hoặc trong một plugin. Nó chỉ có hiệu lực khi được gọi trên server và sẽ không được bao gồm trong build client của bạn.

## Type

```ts [Signature]
export function onPrehydrate(callback: (el: HTMLElement) => void): void
export function onPrehydrate(callback: string | ((el: HTMLElement) => void), key?: string): undefined | string
```

## Parameters

| Parameter  | Type                                   | Required | Description                                                                                                                                                                                                                                                                                               |
| ---------- | -------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `callback` | `((el: HTMLElement) => void) | string` | Yes      | Một hàm (hoặc hàm được stringified) để chạy trước khi Nuxt hydrates. Nó sẽ được stringified và inline trong HTML. Không nên có các dependencies bên ngoài hoặc tham chiếu đến các biến bên ngoài callback. Chạy trước khi Nuxt runtime khởi tạo, vì vậy nó không nên phụ thuộc vào Nuxt hoặc Vue context. |
| `key`      | `string`                               | No       | (Nâng cao) Một key duy nhất để xác định prehydrate script, hữu ích cho các kịch bản nâng cao như nhiều root nodes.                                                                                                                                                                                        |

## Return Values

- Trả về `undefined` khi được gọi chỉ với một callback function.
- Trả về một string (prehydrate id) khi được gọi với một callback và một key, có thể được sử dụng để set hoặc access thuộc tính `data-prehydrate-id` cho các use case nâng cao.

## Example

```vue [app.vue] twoslash
<script setup lang="ts">
declare const window: Window
// ---cut---
// Chạy code trước khi Nuxt hydrates
onPrehydrate(() => {
  console.log(window)
})

// Truy cập root element
onPrehydrate((el) => {
  console.log(el.outerHTML)
  // <div data-v-inspector="app.vue:15:3" data-prehydrate-id=":b3qlvSiBeH:"> Hi there </div>
})

// Nâng cao: truy cập/set `data-prehydrate-id` của chính bạn
const prehydrateId = onPrehydrate((el) => {})
</script>

<template>
  <div>
    Hi there
  </div>
</template>
```


# useAppConfig

## Usage

```ts
const appConfig = useAppConfig()

console.log(appConfig)
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
::


# useAsyncData

Trong các pages, components và plugins của bạn, bạn có thể sử dụng useAsyncData để có quyền truy cập vào dữ liệu được giải quyết bất đồng bộ.

::note
[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) là một composable được thiết kế để được gọi trực tiếp trong [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context). Nó trả về các composables reactive và xử lý việc thêm responses vào Nuxt payload để chúng có thể được truyền từ server sang client **mà không cần fetch lại dữ liệu trên client side** khi trang hydrate.
::

## Usage

```vue [pages/index.vue]
<script setup lang="ts">
const { data, status, error, refresh, clear } = await useAsyncData(
  'mountains',
  () => $fetch('https://api.nuxtjs.dev/mountains')
)
</script>
```

::warning
Nếu bạn đang sử dụng một useAsyncData wrapper tùy chỉnh, không await nó trong composable, vì điều đó có thể gây ra hành vi không mong muốn. Vui lòng làm theo [recipe này](https://nuxt.com/docs/guide/recipes/custom-usefetch#custom-usefetch) để biết thêm thông tin về cách tạo một custom async data fetcher.
::

::note
`data`, `status` và `error` là Vue refs và chúng nên được truy cập với `.value` khi được sử dụng trong `<script setup>`, trong khi `refresh`/`execute` và `clear` là các hàm plain.
::

### Watch Params

Option `watch` tích hợp cho phép tự động rerun hàm fetcher khi phát hiện bất kỳ thay đổi nào.

```vue [pages/index.vue]
<script setup lang="ts">
const page = ref(1)
const { data: posts } = await useAsyncData(
  'posts',
  () => $fetch('https://fakeApi.com/posts', {
    params: {
      page: page.value
    }
  }), {
    watch: [page]
  }
)
</script>
```

### Reactive Keys

Bạn có thể sử dụng một computed ref, plain ref hoặc một getter function làm key, cho phép fetching dữ liệu động tự động cập nhật khi key thay đổi:

```vue [pages/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const userId = computed(() => `user-${route.params.id}`)

// Khi route thay đổi và userId cập nhật, dữ liệu sẽ được tự động refetch
const { data: user } = useAsyncData(
  userId,
  () => fetchUserById(route.params.id)
)
</script>
```

::warning
[`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) là một function name được reserved được transformed bởi compiler, vì vậy bạn không nên đặt tên cho function của riêng bạn là [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data).
::

::read-more
---
to: https://nuxt.com/docs/getting-started/data-fetching#useasyncdata
---
::

## Params

- `key`: một key duy nhất để đảm bảo rằng việc fetching dữ liệu có thể được de-duplicated đúng cách trên các requests. Nếu bạn không cung cấp key, thì một key sẽ được tạo cho bạn duy nhất cho file name và line number của instance của `useAsyncData`.
- `handler`: một hàm asynchronous phải trả về một giá trị truthy (ví dụ, nó không nên là `undefined` hoặc `null`) hoặc request có thể bị duplicated trên client side.
  :warning[Hàm `handler` nên là **side-effect free** để đảm bảo hành vi predictable trong SSR và CSR hydration. Nếu bạn cần trigger side effects, hãy sử dụng utility [`callOnce`](https://nuxt.com/docs/api/utils/call-once) để làm điều đó.]
- `options`:

  - `server`: có fetch dữ liệu trên server hay không (mặc định là `true`)
  - `lazy`: có resolve hàm async sau khi loading route hay không, thay vì blocking client-side navigation (mặc định là `false`)
  - `immediate`: khi được set thành `false`, sẽ ngăn request firing ngay lập tức. (mặc định là `true`)
  - `default`: một factory function để set giá trị mặc định của `data`, trước khi hàm async resolves - hữu ích với option `lazy: true` hoặc `immediate: false`
  - `transform`: một hàm có thể được sử dụng để alter `handler` function result sau khi resolving
  - `getCachedData`: Cung cấp một hàm trả về cached data. Một return value `null` hoặc `undefined` sẽ trigger một fetch. Theo mặc định, điều này là:

    ```ts
    const getDefaultCachedData = (key, nuxtApp, ctx) => nuxtApp.isHydrating 
      ? nuxtApp.payload.data[key] 
      : nuxtApp.static.data[key]
    ```
    Chỉ cache data khi `experimental.payloadExtraction` của `nuxt.config` được enabled.
  - `pick`: chỉ pick specified keys trong array này từ `handler` function result
  - `watch`: watch reactive sources để auto-refresh
  - `deep`: return data trong một deep ref object. Nó là `false` theo mặc định để return data trong một shallow ref object, có thể cải thiện performance nếu data của bạn không cần reactive deeply.
  - `dedupe`: tránh fetching cùng key nhiều hơn một lần tại một thời điểm (mặc định là `cancel`). Các options có thể:

    - `cancel` - cancels existing requests khi một request mới được thực hiện
    - `defer` - không thực hiện new requests nếu có một pending request

::note
Dưới hood, `lazy: false` sử dụng `<Suspense>` để block loading của route trước khi data đã được fetched. Cân nhắc sử dụng `lazy: true` và implement một loading state thay thế để có user experience mượt mà hơn.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-lazy-async-data"}
::

Bạn có thể sử dụng `useLazyAsyncData` để có cùng behavior như `lazy: true` với `useAsyncData`.
\::

::video-accordion
---
title: Xem video từ Alexander Lichter về client-side caching với getCachedData
video-id: aQPR0xn-MMk
---
::

### Shared State và Option Consistency

Khi sử dụng cùng key cho multiple `useAsyncData` calls, chúng sẽ share cùng `data`, `error` và `status` refs. Điều này đảm bảo consistency trên components nhưng yêu cầu option consistency.

Các options sau **phải consistent** trên tất cả calls với cùng key:

- `handler` function
- `deep` option
- `transform` function
- `pick` array
- `getCachedData` function
- `default` value

Các options sau **có thể khác** mà không trigger warnings:

- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ❌ Điều này sẽ trigger development warning
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })

// ✅ Điều này được cho phép
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: true })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: false })
```

::tip
Keyed state được tạo bằng `useAsyncData` có thể được retrieved trên Nuxt application của bạn bằng [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data).
::

## Return Values

- `data`: kết quả của hàm asynchronous được truyền vào.
- `refresh`/`execute`: một hàm có thể được sử dụng để refresh data được trả về bởi hàm `handler`.
- `error`: một error object nếu việc fetching data thất bại.
- `status`: một string chỉ ra status của data request:

  - `idle`: khi request chưa bắt đầu, chẳng hạn như:

    - khi `execute` chưa được gọi và `{ immediate: false }` được set
    - khi rendering HTML trên server và `{ server: false }` được set
  - `pending`: request đang trong tiến trình
  - `success`: request đã hoàn thành thành công
  - `error`: request đã thất bại
- `clear`: một hàm có thể được sử dụng để set `data` thành `undefined` (hoặc giá trị của `options.default()` nếu được cung cấp), set `error` thành `undefined`, set `status` thành `idle`, và mark bất kỳ pending requests hiện tại nào là cancelled.

Theo mặc định, Nuxt chờ cho đến khi một `refresh` hoàn thành trước khi nó có thể được execute lại.

::note
Nếu bạn chưa fetch data trên server (ví dụ, với `server: false`), thì data *sẽ không* được fetch cho đến khi hydration hoàn thành. Điều này có nghĩa là ngay cả khi bạn await [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) trên client side, `data` sẽ vẫn là `undefined` trong `<script setup>`.
::

## Type

```ts [Signature]
function useAsyncData<DataT, DataE>(
  handler: (nuxtApp?: NuxtApp) => Promise<DataT>,
  options?: AsyncDataOptions<DataT>
): AsyncData<DataT, DataE>
function useAsyncData<DataT, DataE>(
  key: MaybeRefOrGetter<string>,
  handler: (nuxtApp?: NuxtApp) => Promise<DataT>,
  options?: AsyncDataOptions<DataT>
): Promise<AsyncData<DataT, DataE>>

type AsyncDataOptions<DataT> = {
  server?: boolean
  lazy?: boolean
  immediate?: boolean
  deep?: boolean
  dedupe?: 'cancel' | 'defer'
  default?: () => DataT | Ref<DataT> | null
  transform?: (input: DataT) => DataT | Promise<DataT>
  pick?: string[]
  watch?: MultiWatchSources | false
  getCachedData?: (key: string, nuxtApp: NuxtApp, ctx: AsyncDataRequestContext) => DataT | undefined
}

type AsyncDataRequestContext = {
  /** Lý do cho data request này */
  cause: 'initial' | 'refresh:manual' | 'refresh:hook' | 'watch'
}

type AsyncData<DataT, ErrorT> = {
  data: Ref<DataT | undefined>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
  clear: () => void
  error: Ref<ErrorT | undefined>
  status: Ref<AsyncDataRequestStatus>
};

interface AsyncDataExecuteOptions {
  dedupe?: 'cancel' | 'defer'
}

type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'
```

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# useCookie

## Usage

Trong các pages, components và plugins của bạn, bạn có thể sử dụng `useCookie` để đọc và ghi cookies trong một cách thân thiện với SSR.

```ts
const cookie = useCookie(name, options)
```

::note
`useCookie` chỉ hoạt động trong [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

::tip
Ref được trả về sẽ tự động serialize và deserialize cookie values thành JSON.
::

## Type

```ts [Signature]
import type { Ref } from 'vue'
import type { CookieParseOptions, CookieSerializeOptions } from 'cookie-es'

export interface CookieOptions<T = any> extends Omit<CookieSerializeOptions & CookieParseOptions, 'decode' | 'encode'> {
  decode?(value: string): T
  encode?(value: T): string
  default?: () => T | Ref<T>
  watch?: boolean | 'shallow'
  readonly?: boolean
}

export interface CookieRef<T> extends Ref<T> {}

export function useCookie<T = string | null | undefined>(
  name: string,
  options?: CookieOptions<T>
): CookieRef<T>
```

## Parameters

`name`: Tên của cookie.

`options`: Options để control cookie behavior. Object có thể có các properties sau:

Hầu hết options sẽ được pass trực tiếp đến package [cookie](https://github.com/jshttp/cookie){rel="nofollow"}.

| Property      | Type                   | Default                                                                        | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------------- | ---------------------- | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `decode`      | `(value: string) => T` | `decodeURIComponent` + [destr](https://github.com/unjs/destr){rel="nofollow"}. | Custom function để decode cookie value. Vì giá trị của cookie có limited character set (và phải là simple string), function này có thể được sử dụng để decode một previously encoded cookie value thành JavaScript string hoặc object khác. :br &#x2A;*Lưu ý:** Nếu error được throw từ function này, original, non-decoded cookie value sẽ được trả về như cookie's value.                                                                                                                                                                                                                                                                  |
| `encode`      | `(value: T) => string` | `JSON.stringify` + `encodeURIComponent`                                        | Custom function để encode cookie value. Vì giá trị của cookie có limited character set (và phải là simple string), function này có thể được sử dụng để encode một value thành string suited cho cookie's value.                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `default`     | `() => T | Ref<T>`     | `undefined`                                                                    | Function returning giá trị mặc định nếu cookie không tồn tại. Function cũng có thể return một `Ref`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `watch`       | `boolean | 'shallow'`  | `true`                                                                         | Có watch cho changes và update cookie hay không. `true` cho deep watch, `'shallow'` cho shallow watch, tức là data changes chỉ cho top level properties, `false` để disable. :br &#x2A;*Lưu ý:** Refresh `useCookie` values manually khi một cookie đã changed với [`refreshCookie`](https://nuxt.com/docs/api/utils/refresh-cookie).                                                                                                                                                                                                                                                                                                        |
| `readonly`    | `boolean`              | `false`                                                                        | Nếu `true`, disables writing to cookie.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `maxAge`      | `number`               | `undefined`                                                                    | Max age in seconds cho cookie, tức là giá trị cho [`Max-Age` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.2){rel="nofollow"}. Số given sẽ được converted to integer bằng rounding down. Theo mặc định, no maximum age được set.                                                                                                                                                                                                                                                                                                                                                                                   |
| `expires`     | `Date`                 | `undefined`                                                                    | Expiration date cho cookie. Theo mặc định, no expiration được set. Hầu hết clients sẽ consider this a "non-persistent cookie" và sẽ delete nó on a condition như exiting a web browser application. :br &#x2A;*Lưu ý:** [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3){rel="nofollow"} states rằng nếu cả `expires` và `maxAge` được set, thì `maxAge` takes precedence, nhưng không phải tất cả clients obey this, vì vậy nếu cả hai được set, chúng nên point to cùng date và time! :br Nếu không `expires` và `maxAge` được set, cookie sẽ session-only và removed khi user closes browser của họ. |
| `httpOnly`    | `boolean`              | `false`                                                                        | Sets HttpOnly attribute. :br &#x2A;*Lưu ý:** Cẩn thận khi setting this thành `true`, vì compliant clients sẽ không allow client-side JavaScript để see cookie in `document.cookie`.                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `secure`      | `boolean`              | `false`                                                                        | Sets [`Secure` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.5){rel="nofollow"}. :br&#x2A;*Lưu ý:** Cẩn thận khi setting this thành `true`, vì compliant clients sẽ không send cookie back to server trong future nếu browser không có HTTPS connection. Điều này có thể lead to hydration errors.                                                                                                                                                                                                                                                                                                                 |
| `partitioned` | `boolean`              | `false`                                                                        | Sets [`Partitioned` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/draft-cutler-httpbis-partitioned-cookies#section-2.1){rel="nofollow"}. :br&#x2A;*Lưu ý:** Đây là một attribute chưa được fully standardized, và có thể change trong future. :br Điều này cũng có nghĩa là nhiều clients có thể ignore attribute này cho đến khi họ understand nó. :br Thông tin thêm có thể được tìm thấy trong [proposal](https://github.com/privacycg/CHIPS){rel="nofollow"}.                                                                                                                                                            |
| `domain`      | `string`               | `undefined`                                                                    | Sets [`Domain` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.3){rel="nofollow"}. Theo mặc định, no domain được set, và hầu hết clients sẽ consider applying cookie chỉ to current domain.                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `path`        | `string`               | `'/'`                                                                          | Sets [`Path` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.4){rel="nofollow"}. Theo mặc định, path được considered ["default path"](https://tools.ietf.org/html/rfc6265#section-5.1.4){rel="nofollow"}.                                                                                                                                                                                                                                                                                                                                                                                                            |
| `sameSite`    | `boolean | string`     | `undefined`                                                                    | Sets [`SameSite` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7){rel="nofollow"}. :br - `true` sẽ set `SameSite` attribute thành `Strict` cho strict same-site enforcement. :br - `false` sẽ không set `SameSite` attribute. :br - `'lax'` sẽ set `SameSite` attribute thành `Lax` cho lax same-site enforcement. :br - `'none'` sẽ set `SameSite` attribute thành `None` cho một explicit cross-site cookie. :br - `'strict'` sẽ set `SameSite` attribute thành `Strict` cho strict same-site enforcement.                                                                            |

## Return Values

Trả về một Vue `Ref<T>` representing cookie value. Updating ref sẽ update cookie (trừ khi `readonly` được set). Ref là SSR-friendly và sẽ work on cả client và server.

## Examples

### Basic Usage

Ví dụ dưới đây tạo một cookie gọi là `counter`. Nếu cookie không tồn tại, nó được initially set thành một random value. Bất cứ khi nào chúng ta update biến `counter`, cookie sẽ được update accordingly.

```vue [app.vue]
<script setup lang="ts">
const counter = useCookie('counter')

counter.value = counter.value || Math.round(Math.random() * 1000)
</script>

<template>
  <div>
    <h1>Counter: {{ counter || '-' }}</h1>
    <button @click="counter = null">reset</button>
    <button @click="counter--">-</button>
    <button @click="counter++">+</button>
  </div>
</template>
```

### Readonly Cookies

```vue
<script setup lang="ts">
const user = useCookie(
  'userInfo',
  {
    default: () => ({ score: -1 }),
    watch: false
  }
)

if (user.value) {
  // cookie `userInfo` thực tế sẽ không được updated
  user.value.score++
}
</script>

<template>
  <div>User score: {{ user?.score }}</div>
</template>
```

### Writable Cookies

```vue
<script setup lang="ts">
const list = useCookie(
  'list',
  {
    default: () => [],
    watch: 'shallow'
  }
)

function add() {
  list.value?.push(Math.round(Math.random() * 1000))
  // cookie list sẽ không được updated với change này
}

function save() {
  if (list.value) {
    // cookie `list` thực tế sẽ được updated
    list.value = [...list.value]
  }
}
</script>

<template>
  <div>
    <h1>List</h1>
    <pre>{{ list }}</pre>
    <button @click="add">Add</button>
    <button @click="save">Save</button>
  </div>
</template>
```

### Cookies in API Routes

Bạn có thể sử dụng `getCookie` và `setCookie` từ package [`h3`](https://github.com/h3js/h3){rel="nofollow"} để set cookies trong server API routes.

```ts [server/api/counter.ts]
export default defineEventHandler(event => {
  // Read counter cookie
  let counter = getCookie(event, 'counter') || 0

  // Increase counter cookie by 1
  setCookie(event, 'counter', ++counter)

  // Send JSON response
  return { counter }
})
```

::link-example{to="https://nuxt.com/docs/examples/advanced/use-cookie"}
::


# useError

## Usage

Composable `useError` trả về lỗi Nuxt toàn cục đang được xử lý và có sẵn trên cả client và server. Nó cung cấp một error state reactive, thân thiện với SSR trên app của bạn.

```ts
const error = useError()
```

Bạn có thể sử dụng composable này trong components, pages hoặc plugins của bạn để access hoặc react với Nuxt error hiện tại.

## Type

```ts
interface NuxtError<DataT = unknown> {
  statusCode: number
  statusMessage: string
  message: string
  data?: DataT
  error?: true
}

export const useError: () => Ref<NuxtError | undefined>
```

## Parameters

Composable này không nhận bất kỳ parameters nào.

## Return Values

Trả về một `Ref` chứa Nuxt error hiện tại (hoặc `undefined` nếu không có error). Error object là reactive và sẽ update tự động khi error state changes.

## Example

```ts
<script setup lang="ts">
const error = useError()

if (error.value) {
  console.error('Nuxt error:', error.value)
}
</script>
```

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# useFetch

Composable này cung cấp một wrapper tiện lợi xung quanh [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch).

Nó tự động generate một key dựa trên URL và fetch options, cung cấp type hints cho request url dựa trên server routes, và infers API response type.

::note
`useFetch` là một composable được thiết kế để được gọi trực tiếp trong một setup function, plugin, hoặc route middleware. Nó trả về các composables reactive và xử lý việc thêm responses vào Nuxt payload để chúng có thể được truyền từ server sang client mà không re-fetch dữ liệu trên client side khi trang hydrate.
::

## Usage

```vue [pages/modules.vue]
<script setup lang="ts">
const { data, status, error, refresh, clear } = await useFetch('/api/modules', {
  pick: ['title']
})
</script>
```

::warning
Nếu bạn đang sử dụng một useFetch wrapper tùy chỉnh, không await nó trong composable, vì điều đó có thể gây ra hành vi không mong muốn. Vui lòng làm theo [recipe này](https://nuxt.com/docs/guide/recipes/custom-usefetch#custom-usefetch) để biết thêm thông tin về cách tạo một custom async data fetcher.
::

::note
`data`, `status`, và `error` là Vue refs, và chúng nên được truy cập với `.value` khi được sử dụng trong `<script setup>`, trong khi `refresh`/`execute` và `clear` là các hàm plain.
::

Sử dụng option `query`, bạn có thể thêm search parameters vào query của bạn. Option này được extended từ [unjs/ofetch](https://github.com/unjs/ofetch){rel="nofollow"} và sử dụng [unjs/ufo](https://github.com/unjs/ufo){rel="nofollow"} để tạo URL. Objects được tự động stringified.

```ts
const param1 = ref('value1')
const { data, status, error, refresh } = await useFetch('/api/modules', {
  query: { param1, param2: 'value2' }
})
```

Ví dụ trên results in `https://api.nuxt.com/modules?param1=value1&param2=value2`.

Bạn cũng có thể sử dụng [interceptors](https://github.com/unjs/ofetch#%EF%B8%8F-interceptors){rel="nofollow"}:

```ts
const { data, status, error, refresh, clear } = await useFetch('/api/auth/login', {
  onRequest({ request, options }) {
    // Set the request headers
    // note that this relies on ofetch >= 1.4.0 - you may need to refresh your lockfile
    options.headers.set('Authorization', '...')
  },
  onRequestError({ request, options, error }) {
    // Handle the request errors
  },
  onResponse({ request, response, options }) {
    // Process the response data
    localStorage.setItem('token', response._data.token)
  },
  onResponseError({ request, response, options }) {
    // Handle the response errors
  }
})
```

### Reactive Keys và Shared State

Bạn có thể sử dụng một computed ref hoặc một plain ref làm URL, cho phép fetching dữ liệu động tự động cập nhật khi URL thay đổi:

```vue [pages/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => route.params.id)

// Khi route thay đổi và id cập nhật, dữ liệu sẽ được tự động refetched
const { data: post } = await useFetch(() => `/api/posts/${id.value}`)
</script>
```

Khi sử dụng `useFetch` với cùng URL và options trong multiple components, chúng sẽ share cùng `data`, `error` và `status` refs. Điều này đảm bảo consistency trên components.

::tip
Keyed state được tạo bằng `useFetch` có thể được retrieved trên Nuxt application của bạn bằng [`useNuxtData`](https://nuxt.com/docs/api/composables/use-nuxt-data).
::

::warning
`useFetch` là một function name được reserved được transformed bởi compiler, vì vậy bạn không nên đặt tên cho function của riêng bạn là `useFetch`.
::

::warning
Nếu bạn encounter variable `data` destructured từ một `useFetch` returns một string và không phải là JSON parsed object thì đảm bảo component của bạn không include một import statement như `import { useFetch } from '@vueuse/core`.
::

::video-accordion
---
title: Xem video từ Alexander Lichter để tránh sử dụng useFetch theo cách sai
video-id: njsGVmcWviY
---
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::

## Type

```ts [Signature]
function useFetch<DataT, ErrorT>(
  url: string | Request | Ref<string | Request> | (() => string | Request),
  options?: UseFetchOptions<DataT>
): Promise<AsyncData<DataT, ErrorT>>

type UseFetchOptions<DataT> = {
  key?: MaybeRefOrGetter<string>
  method?: string
  query?: SearchParams
  params?: SearchParams
  body?: RequestInit['body'] | Record<string, any>
  headers?: Record<string, string> | [key: string, value: string][] | Headers
  baseURL?: string
  server?: boolean
  lazy?: boolean
  immediate?: boolean
  getCachedData?: (key: string, nuxtApp: NuxtApp, ctx: AsyncDataRequestContext) => DataT | undefined
  deep?: boolean
  dedupe?: 'cancel' | 'defer'
  default?: () => DataT
  transform?: (input: DataT) => DataT | Promise<DataT>
  pick?: string[]
  $fetch?: typeof globalThis.$fetch
  watch?: MultiWatchSources | false
}

type AsyncDataRequestContext = {
  /** Lý do cho data request này */
  cause: 'initial' | 'refresh:manual' | 'refresh:hook' | 'watch'
}

type AsyncData<DataT, ErrorT> = {
  data: Ref<DataT | undefined>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
  clear: () => void
  error: Ref<ErrorT | undefined>
  status: Ref<AsyncDataRequestStatus>
}

interface AsyncDataExecuteOptions {
  dedupe?: 'cancel' | 'defer'
}

type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'
```

## Parameters

- `URL` (`string | Request | Ref<string | Request> | () => string | Request`): URL hoặc request để fetch. Có thể là string, Request object, Vue ref, hoặc function returning string/Request. Supports reactivity cho dynamic endpoints.
- `options` (object): Configuration cho fetch request. Extends [unjs/ofetch](https://github.com/unjs/ofetch){rel="nofollow"} options và [`AsyncDataOptions`](https://nuxt.com/docs/api/composables/use-async-data#params). Tất cả options có thể là static value, `ref`, hoặc computed value.

| Option          | Type                                                | Default    | Description                                                                                   |
| --------------- | --------------------------------------------------- | ---------- | --------------------------------------------------------------------------------------------- |
| `key`           | `MaybeRefOrGetter<string>`                          | auto-gen   | Unique key cho de-duplication. Nếu không provided, generated từ URL và options.               |
| `method`        | `string`                                            | `'GET'`    | HTTP request method.                                                                          |
| `query`         | `object`                                            | -          | Query/search params để append vào URL. Alias: `params`. Supports refs/computed.               |
| `params`        | `object`                                            | -          | Alias cho `query`.                                                                            |
| `body`          | `RequestInit['body'] | Record<string, any>`         | -          | Request body. Objects được tự động stringified. Supports refs/computed.                       |
| `headers`       | `Record<string, string> | [key, value][] | Headers` | -          | Request headers.                                                                              |
| `baseURL`       | `string`                                            | -          | Base URL cho request.                                                                         |
| `timeout`       | `number`                                            | -          | Timeout in milliseconds để abort request.                                                     |
| `cache`         | `boolean | string`                                  | -          | Cache control. Boolean disables cache, hoặc use Fetch API values: `default`, `no-store`, etc. |
| `server`        | `boolean`                                           | `true`     | Có fetch trên server hay không.                                                               |
| `lazy`          | `boolean`                                           | `false`    | Nếu true, resolves sau khi loading route (không block navigation).                            |
| `immediate`     | `boolean`                                           | `true`     | Nếu false, prevents request firing ngay lập tức.                                              |
| `default`       | `() => DataT`                                       | -          | Factory cho default value của `data` trước khi async resolves.                                |
| `transform`     | `(input: DataT) => DataT | Promise<DataT>`          | -          | Function để transform result sau khi resolving.                                               |
| `getCachedData` | `(key, nuxtApp, ctx) => DataT | undefined`          | -          | Function để return cached data. Xem dưới cho default.                                         |
| `pick`          | `string[]`                                          | -          | Chỉ pick specified keys từ result.                                                            |
| `watch`         | `MultiWatchSources | false`                         | -          | Array của reactive sources để watch và auto-refresh. `false` disables watching.               |
| `deep`          | `boolean`                                           | `false`    | Return data trong deep ref object.                                                            |
| `dedupe`        | `'cancel' | 'defer'`                                | `'cancel'` | Tránh fetching cùng key nhiều hơn một lần tại một thời điểm.                                  |
| `$fetch`        | `typeof globalThis.$fetch`                          | -          | Custom $fetch implementation.                                                                 |

::note
Tất cả fetch options có thể được given một `computed` hoặc `ref` value. Những cái này sẽ được watched và new requests made tự động với bất kỳ new values nào nếu chúng được updated.
::

**getCachedData default:**

```ts
const getDefaultCachedData = (key, nuxtApp, ctx) => nuxtApp.isHydrating 
  ? nuxtApp.payload.data[key] 
  : nuxtApp.static.data[key]
```

Chỉ cache data khi `experimental.payloadExtraction` trong `nuxt.config` được enabled.

## Return Values

| Name      | Type                                                | Description                                                                                                                                                                                 |
| --------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `Ref<DataT | undefined>`                            | Kết quả của asynchronous fetch.                                                                                                                                                             |
| `refresh` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Function để manually refresh data. Theo mặc định, Nuxt waits cho đến khi một `refresh` hoàn thành trước khi nó có thể được execute lại.                                                     |
| `execute` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Alias cho `refresh`.                                                                                                                                                                        |
| `error`   | `Ref<ErrorT | undefined>`                           | Error object nếu data fetching thất bại.                                                                                                                                                    |
| `status`  | `Ref<'idle' | 'pending' | 'success' | 'error'>`     | Status của data request. Xem dưới cho possible values.                                                                                                                                      |
| `clear`   | `() => void`                                        | Resets `data` thành `undefined` (hoặc giá trị của `options.default()` nếu provided), `error` thành `undefined`, set `status` thành `idle`, và cancels bất kỳ pending requests hiện tại nào. |

### Status values

- `idle`: Request chưa bắt đầu (e.g. `{ immediate: false }` hoặc `{ server: false }` trên server render)
- `pending`: Request đang trong tiến trình
- `success`: Request hoàn thành thành công
- `error`: Request thất bại

::note
Nếu bạn chưa fetch data trên server (ví dụ, với `server: false`), thì data *sẽ không* được fetch cho đến khi hydration hoàn thành. Điều này có nghĩa là ngay cả khi bạn await `useFetch` trên client-side, `data` sẽ vẫn là null trong `<script setup>`.
::

### Examples

::link-example
---
to: https://nuxt.com/docs/examples/advanced/use-custom-fetch-composable
---
::

::link-example{to="https://nuxt.com/docs/examples/features/data-fetching"}
::


# useHead

Hàm composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) cho phép bạn quản lý các thẻ head của mình theo cách lập trình và phản ứng, được hỗ trợ bởi [Unhead](https://unhead.unjs.io){rel="nofollow"}. Nếu dữ liệu đến từ người dùng hoặc nguồn không đáng tin cậy, chúng tôi khuyên bạn nên kiểm tra [`useHeadSafe`](https://nuxt.com/docs/api/composables/use-head-safe).

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Type

```ts
useHead(meta: MaybeComputedRef<MetaObject>): void
```

Dưới đây là các loại không phản ứng cho [`useHead`](https://nuxt.com/docs/api/composables/use-head).

```ts
interface MetaObject {
  title?: string
  titleTemplate?: string | ((title?: string) => string)
  base?: Base
  link?: Link[]
  meta?: Meta[]
  style?: Style[]
  script?: Script[]
  noscript?: Noscript[]
  htmlAttrs?: HtmlAttributes
  bodyAttrs?: BodyAttributes
}
```

Xem [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/schema.ts){rel="nofollow"} để biết các loại chi tiết hơn.

::note
Các thuộc tính của `useHead` có thể động, chấp nhận các thuộc tính `ref`, `computed` và `reactive`. Tham số `meta` cũng có thể chấp nhận một hàm trả về một đối tượng để làm cho toàn bộ đối tượng phản ứng.
::

## Params

### `meta`

**Type**: `MetaObject`

Một đối tượng chấp nhận siêu dữ liệu head sau:

- `meta`: Mỗi phần tử trong mảng được ánh xạ tới một thẻ `<meta>` mới được tạo, nơi các thuộc tính đối tượng được ánh xạ tới các thuộc tính tương ứng.

  - **Type**: `Array<Record<string, any>>`
- `link`: Mỗi phần tử trong mảng được ánh xạ tới một thẻ `<link>` mới được tạo, nơi các thuộc tính đối tượng được ánh xạ tới các thuộc tính tương ứng.

  - **Type**: `Array<Record<string, any>>`
- `style`: Mỗi phần tử trong mảng được ánh xạ tới một thẻ `<style>` mới được tạo, nơi các thuộc tính đối tượng được ánh xạ tới các thuộc tính tương ứng.

  - **Type**: `Array<Record<string, any>>`
- `script`: Mỗi phần tử trong mảng được ánh xạ tới một thẻ `<script>` mới được tạo, nơi các thuộc tính đối tượng được ánh xạ tới các thuộc tính tương ứng.

  - **Type**: `Array<Record<string, any>>`
- `noscript`: Mỗi phần tử trong mảng được ánh xạ tới một thẻ `<noscript>` mới được tạo, nơi các thuộc tính đối tượng được ánh xạ tới các thuộc tính tương ứng.

  - **Type**: `Array<Record<string, any>>`
- `titleTemplate`: Cấu hình mẫu động để tùy chỉnh tiêu đề trang trên một trang riêng lẻ.

  - **Type**: `string` | `((title: string) => string)`
- `title`: Đặt tiêu đề trang tĩnh trên một trang riêng lẻ.

  - **Type**: `string`
- `bodyAttrs`: Đặt các thuộc tính của thẻ `<body>`. Mỗi thuộc tính đối tượng được ánh xạ tới thuộc tính tương ứng.

  - **Type**: `Record<string, any>`
- `htmlAttrs`: Đặt các thuộc tính của thẻ `<html>`. Mỗi thuộc tính đối tượng được ánh xạ tới thuộc tính tương ứng.

  - **Type**: `Record<string, any>`


# useHeadSafe

Composable `useHeadSafe` là một wrapper xung quanh composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) nhằm hạn chế đầu vào chỉ cho phép các giá trị an toàn.

## Usage

Bạn có thể truyền tất cả các giá trị giống như [`useHead`](https://nuxt.com/docs/api/composables/use-head)

```ts
useHeadSafe({
  script: [
    { id: 'xss-script', innerHTML: 'alert("xss")' }
  ],
  meta: [
    { 'http-equiv': 'refresh', content: '0;javascript:alert(1)' }
  ]
})
// Sẽ tạo ra một cách an toàn
// <script id="xss-script"></script>
// <meta content="0;javascript:alert(1)">
```

::read-more
---
target: _blank
to: https://unhead.unjs.io/docs/typescript/head/api/composables/use-head-safe
---
Đọc thêm về tài liệu `Unhead`.
::

## Type

```ts
useHeadSafe(input: MaybeComputedRef<HeadSafe>): void
```

Danh sách các giá trị được phép là:

```ts
const WhitelistAttributes = {
  htmlAttrs: ['class', 'style', 'lang', 'dir'],
  bodyAttrs: ['class', 'style'],
  meta: ['name', 'property', 'charset', 'content', 'media'],
  noscript: ['textContent'],
  style: ['media', 'textContent', 'nonce', 'title', 'blocking'],
  script: ['type', 'textContent', 'nonce', 'blocking'],
  link: ['color', 'crossorigin', 'fetchpriority', 'href', 'hreflang', 'imagesrcset', 'imagesizes', 'integrity', 'media', 'referrerpolicy', 'rel', 'sizes', 'type'],
}
```

Xem [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/safeSchema.ts){rel="nofollow"} để biết các loại chi tiết hơn.


# useHydration

::note
Đây là một composable nâng cao, chủ yếu được thiết kế để sử dụng trong các plugin, chủ yếu được sử dụng bởi các module Nuxt.
::

::note
`useHydration` được thiết kế để **đảm bảo đồng bộ hóa và khôi phục trạng thái trong quá trình SSR**. Nếu bạn cần tạo một trạng thái phản ứng toàn cục thân thiện với SSR trong Nuxt, [`useState`](https://nuxt.com/docs/api/composables/use-state) là lựa chọn được khuyến nghị.
::

`useHydration` là một composable tích hợp cung cấp cách để đặt dữ liệu ở phía máy chủ mỗi khi có yêu cầu HTTP mới và nhận dữ liệu đó ở phía client. Bằng cách này `useHydration` cho phép bạn kiểm soát đầy đủ chu kỳ hydration.

Dữ liệu trả về từ hàm `get` trên máy chủ được lưu trữ trong `nuxtApp.payload` dưới khóa duy nhất được cung cấp làm tham số đầu tiên cho `useHydration`. Trong quá trình hydration, dữ liệu này sau đó được truy xuất trên client, ngăn chặn các tính toán hoặc gọi API dư thừa.

## Usage

::code-group
```ts [Without useHydration]
export default defineNuxtPlugin((nuxtApp) => {
  const myStore = new MyStore()

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      nuxtApp.payload.myStoreState = myStore.getState()
    })
  }

  if (import.meta.client) {
    nuxt.hooks.hook('app:created', () => {
      myStore.setState(nuxtApp.payload.myStoreState)
    })
  }
})
```

```ts [With useHydration]
export default defineNuxtPlugin((nuxtApp) => {
  const myStore = new MyStore()

  useHydration(
    'myStoreState',
    () => myStore.getState(),
    (data) => myStore.setState(data)
  )
})
```
::

## Type

```ts [signature]
useHydration <T> (key: string, get: () => T, set: (value: T) => void) => void
```

## Parameters

- `key`: Một khóa duy nhất xác định dữ liệu trong ứng dụng Nuxt của bạn.
- `get`: Một hàm được thực thi **chỉ trên máy chủ** (được gọi khi kết xuất SSR hoàn tất) để đặt giá trị ban đầu.
- `set`: Một hàm được thực thi **chỉ trên client** (được gọi khi instance vue ban đầu được tạo) để nhận dữ liệu.


# useLazyAsyncData

## Description

Theo mặc định, [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) chặn điều hướng cho đến khi trình xử lý async của nó được giải quyết. `useLazyAsyncData` cung cấp một wrapper xung quanh [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) kích hoạt điều hướng trước khi trình xử lý được giải quyết bằng cách đặt tùy chọn `lazy` thành `true`.

::note
`useLazyAsyncData` has the same signature as [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data).
::

::read-more{to="https://nuxt.com/docs/api/composables/use-async-data"}
::

## Example

```vue [pages/index.vue]
<script setup lang="ts">
/* Điều hướng sẽ xảy ra trước khi fetching hoàn tất.
  Xử lý trạng thái 'pending' và 'error' trực tiếp trong template của component
*/
const { status, data: count } = await useLazyAsyncData('count', () => $fetch('/api/count'))

watch(count, (newCount) => {
  // Vì count có thể bắt đầu là null, bạn sẽ không có quyền truy cập
  // vào nội dung của nó ngay lập tức, nhưng bạn có thể watch nó.
})
</script>

<template>
  <div>
    {{ status === 'pending' ? 'Đang tải' : count }}
  </div>
</template>
```

::warning
`useLazyAsyncData` là một tên hàm được bảo lưu được biến đổi bởi compiler, vì vậy bạn không nên đặt tên hàm của mình là `useLazyAsyncData`.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# useLazyFetch

## Description

Theo mặc định, [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) chặn điều hướng cho đến khi trình xử lý async của nó được giải quyết. `useLazyFetch` cung cấp một wrapper xung quanh [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) kích hoạt điều hướng trước khi trình xử lý được giải quyết bằng cách đặt tùy chọn `lazy` thành `true`.

::note
`useLazyFetch` has the same signature as [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch).
::

::note
Việc awaiting `useLazyFetch` ở chế độ này chỉ đảm bảo cuộc gọi được khởi tạo. Trên điều hướng phía client, dữ liệu có thể không khả dụng ngay lập tức, và bạn nên đảm bảo xử lý trạng thái pending trong ứng dụng của mình.
::

::read-more{to="https://nuxt.com/docs/api/composables/use-fetch"}
::

## Example

```vue [pages/index.vue]
<script setup lang="ts">
/* Điều hướng sẽ xảy ra trước khi fetching hoàn tất.
 * Xử lý trạng thái 'pending' và 'error' trực tiếp trong template của component
 */
const { status, data: posts } = await useLazyFetch('/api/posts')
watch(posts, (newPosts) => {
  // Vì posts có thể bắt đầu là null, bạn sẽ không có quyền truy cập
  // vào nội dung của nó ngay lập tức, nhưng bạn có thể watch nó.
})
</script>

<template>
  <div v-if="status === 'pending'">
    Đang tải ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

::note
`useLazyFetch` là một tên hàm được bảo lưu được biến đổi bởi compiler, vì vậy bạn không nên đặt tên hàm của mình là `useLazyFetch`.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# useLoadingIndicator

## Description

Một composable trả về trạng thái loading của trang. Được sử dụng bởi [`<NuxtLoadingIndicator>`](https://nuxt.com/docs/api/components/nuxt-loading-indicator) và có thể kiểm soát.
Nó hook vào [`page:loading:start`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) và [`page:loading:end`](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) để thay đổi trạng thái của nó.

## Parameters

- `duration`: Thời lượng của thanh loading, tính bằng mili giây (mặc định `2000`).
- `throttle`: Throttle việc xuất hiện và ẩn, tính bằng mili giây (mặc định `200`).
- `estimatedProgress`: Theo mặc định Nuxt sẽ back off khi nó tiếp cận 100%. Bạn có thể cung cấp một hàm tùy chỉnh để tùy chỉnh ước tính tiến độ, hàm này nhận thời lượng của thanh loading (ở trên) và thời gian đã trôi qua. Nó nên trả về một giá trị từ 0 đến 100.

## Properties

### `isLoading`

- **type**: `Ref<boolean>`
- **description**: Trạng thái loading

### `error`

- **type**: `Ref<boolean>`
- **description**: Trạng thái lỗi

### `progress`

- **type**: `Ref<number>`
- **description**: Trạng thái tiến độ. Từ `0` đến `100`.

## Methods

### `start()`

Đặt `isLoading` thành true và bắt đầu tăng giá trị `progress`. `start` chấp nhận tùy chọn `{ force: true }` để bỏ qua khoảng thời gian và hiển thị trạng thái loading ngay lập tức.

### `set()`

Đặt giá trị `progress` thành một giá trị cụ thể. `set` chấp nhận tùy chọn `{ force: true }` để bỏ qua khoảng thời gian và hiển thị trạng thái loading ngay lập tức.

### `finish()`

Đặt giá trị `progress` thành `100`, dừng tất cả timer và interval sau đó reset trạng thái loading sau `500` ms. `finish` chấp nhận `{ force: true }` để bỏ qua khoảng thời gian trước khi trạng thái được reset, và `{ error: true }` để thay đổi màu thanh loading và đặt thuộc tính error thành true.

### `clear()`

Được sử dụng bởi `finish()`. Xóa tất cả timer và interval được sử dụng bởi composable.

## Example

```vue
<script setup lang="ts">
  const { progress, isLoading, start, finish, clear } = useLoadingIndicator({
    duration: 2000,
    throttle: 200,
    // Đây là cách tiến độ được tính toán theo mặc định
    estimatedProgress: (duration, elapsed) => (2 / Math.PI * 100) * Math.atan(elapsed / duration * 100 / 50)
  })
</script>
```

```vue
<script setup lang="ts">
  const { start, set } = useLoadingIndicator()
  // giống như set(0, { force: true })
  // đặt tiến độ thành 0, và hiển thị loading ngay lập tức
  start({ force: true })
</script>
```


# useNuxtApp

`useNuxtApp` là một composable tích hợp cung cấp cách truy cập ngữ cảnh thời gian chạy chia sẻ của Nuxt, còn được gọi là [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context), có sẵn trên cả client và server side (nhưng không trong Nitro routes). Nó giúp bạn truy cập Vue app instance, runtime hooks, runtime config variables và internal states, chẳng hạn như `ssrContext` và `payload`.

```vue [app.vue]
<script setup lang="ts">
const nuxtApp = useNuxtApp()
</script>
```

Nếu ngữ cảnh thời gian chạy không khả dụng trong phạm vi của bạn, `useNuxtApp` sẽ ném ra một ngoại lệ khi được gọi. Bạn có thể sử dụng [`tryUseNuxtApp`](https://nuxt.com/#tryusenuxtapp) thay thế cho các composables không yêu cầu `nuxtApp`, hoặc để đơn giản kiểm tra xem ngữ cảnh có khả dụng hay không mà không có ngoại lệ.

## Methods

### `provide (name, value)`

`nuxtApp` là một ngữ cảnh thời gian chạy mà bạn có thể mở rộng bằng cách sử dụng [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins). Sử dụng hàm `provide` để tạo Nuxt plugins để làm cho các giá trị và phương thức trợ giúp khả dụng trong ứng dụng Nuxt của bạn trên tất cả các composables và components.

Hàm `provide` chấp nhận các tham số `name` và `value`.

```js
const nuxtApp = useNuxtApp()
nuxtApp.provide('hello', (name) => `Hello ${name}!`)

// Prints "Hello name!"
console.log(nuxtApp.$hello('name'))
```

Như bạn có thể thấy trong ví dụ trên, `$hello` đã trở thành phần mới và tùy chỉnh của ngữ cảnh `nuxtApp` và nó khả dụng ở tất cả các nơi mà `nuxtApp` có thể truy cập.

### `hook(name, cb)`

Các hooks khả dụng trong `nuxtApp` cho phép bạn tùy chỉnh các khía cạnh thời gian chạy của ứng dụng Nuxt của bạn. Bạn có thể sử dụng runtime hooks trong Vue.js composables và [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins) để hook vào vòng đời rendering.

Hàm `hook` hữu ích để thêm logic tùy chỉnh bằng cách hook vào vòng đời rendering tại một điểm cụ thể. Hàm `hook` chủ yếu được sử dụng khi tạo Nuxt plugins.

See [Runtime Hooks](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime) for available runtime hooks called by Nuxt.

```ts [plugins/test.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('page:start', () => {
    /* your code goes here */
  })
  nuxtApp.hook('vue:error', (..._args) => {
    console.log('vue:error')
    // if (import.meta.client) {
    //   console.log(..._args)
    // }
  })
})
```

### `callHook(name, ...args)`

`callHook` trả về một promise khi được gọi với bất kỳ hooks hiện có nào.

```ts
await nuxtApp.callHook('my-plugin:init')
```

## Properties

`useNuxtApp()` hiển thị các thuộc tính sau mà bạn có thể sử dụng để mở rộng và tùy chỉnh ứng dụng của bạn và chia sẻ state, data và variables.

### `vueApp`

`vueApp` là [application instance](https://vuejs.org/api/application.html#application-api){rel="nofollow"} Vue.js toàn cục mà bạn có thể truy cập thông qua `nuxtApp`.

Một số phương thức hữu ích:

- [`component()`](https://vuejs.org/api/application.html#app-component){rel="nofollow"} - Đăng ký một component toàn cục nếu truyền cả tên string và định nghĩa component, hoặc truy xuất một component đã đăng ký nếu chỉ truyền tên.
- [`directive()`](https://vuejs.org/api/application.html#app-directive){rel="nofollow"} - Đăng ký một directive tùy chỉnh toàn cục nếu truyền cả tên string và định nghĩa directive, hoặc truy xuất một directive đã đăng ký nếu chỉ truyền tên[(example)](https://nuxt.com/docs/guide/directory-structure/plugins#vue-directives).
- [`use()`](https://vuejs.org/api/application.html#app-use){rel="nofollow"&#x7D; - Cài đặt một &#x2A;*[Vue.js Plugin](https://vuejs.org/guide/reusability/plugins.html){rel="nofollow"}** [(example)](https://nuxt.com/docs/guide/directory-structure/plugins#vue-plugins).

::read-more
---
icon: i-simple-icons-vuedotjs
to: https://vuejs.org/api/application.html#application-api
---
::

### `ssrContext`

`ssrContext` được tạo ra trong quá trình server-side rendering và nó chỉ khả dụng trên server side.

Nuxt hiển thị các thuộc tính sau thông qua `ssrContext`:

- `url` (string) - URL yêu cầu hiện tại.
- `event` ([h3js/h3](https://github.com/h3js/h3){rel="nofollow"} request event) - Truy cập request & response của route hiện tại.
- `payload` (object) - Đối tượng payload NuxtApp.

### `payload`

`payload` hiển thị data và state variables từ server side sang client side. Các keys sau sẽ khả dụng trên client sau khi chúng đã được truyền từ server side:

- `serverRendered` (boolean) - Cho biết nếu response là server-side-rendered.
- `data` (object) - Khi bạn fetch data từ một API endpoint bằng cách sử dụng [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) hoặc [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data), payload kết quả có thể được truy cập từ `payload.data`. Data này được cache và giúp bạn ngăn chặn việc fetch cùng một data trong trường hợp một yêu cầu giống hệt được thực hiện nhiều hơn một lần. :code-group[```vue \[app.vue\]
  <script setup lang="ts">
  const { data } = await useAsyncData('count', () => $fetch('/api/count'))
  </script>
  ``````ts \[server/api/count.ts\]
  export default defineEventHandler(event => {
    return { count: 1 }
  })
  ```]:br Sau khi fetch giá trị của `count` bằng cách sử dụng [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) trong ví dụ trên, nếu bạn truy cập `payload.data`, bạn sẽ thấy `{ count: 1 }` được ghi lại ở đó. :br Khi truy cập cùng một `payload.data` từ [`ssrcontext`](https://nuxt.com/#ssrcontext), bạn có thể truy cập cùng một giá trị trên server side cũng vậy.
- `state` (object) - Khi bạn sử dụng composable [`useState`](https://nuxt.com/docs/api/composables/use-state) trong Nuxt để thiết lập shared state, data state này được truy cập thông qua `payload.state.[name-of-your-state]`.
  ```ts [plugins/my-plugin.ts]
  export const useColor = () => useState<string>('color', () => 'pink')

  export default defineNuxtPlugin((nuxtApp) => {
    if (import.meta.server) {
      const color = useColor()
    }
  })
  ```
  :brCũng có thể sử dụng các loại nâng cao hơn, chẳng hạn như `ref`, `reactive`, `shallowRef`, `shallowReactive` và `NuxtError`. :br Kể từ [Nuxt v3.4](https://nuxt.com/blog/v3-4#payload-enhancements){rel="nofollow"}, có thể định nghĩa reducer/reviver riêng của bạn cho các loại không được hỗ trợ bởi Nuxt. :video-accordion{title="Watch a video from Alexander Lichter about serializing payloads, especially with regards to classes" video-id="8w6ffRBs8a4"}:br Trong ví dụ dưới đây, chúng ta định nghĩa một reducer (hoặc serializer) và một reviver (hoặc deserializer) cho lớp DateTime [Luxon](https://moment.github.io/luxon/#/){rel="nofollow"}, sử dụng một payload plugin.
  ```ts [plugins/date-time-payload.ts]
  /**
   * This kind of plugin runs very early in the Nuxt lifecycle, before we revive the payload.
   * You will not have access to the router or other Nuxt-injected properties.
   *
   * Note that the "DateTime" string is the type identifier and must
   * be the same on both the reducer and the reviver.
   */
  export default definePayloadPlugin((nuxtApp) => {
    definePayloadReducer('DateTime', (value) => {
      return value instanceof DateTime && value.toJSON()
    })
    definePayloadReviver('DateTime', (value) => {
      return DateTime.fromISO(value)
    })
  })
  ```

### `isHydrating`

Sử dụng `nuxtApp.isHydrating` (boolean) để kiểm tra xem Nuxt app có đang hydrating trên client side hay không.

```ts [components/nuxt-error-boundary.ts]
export default defineComponent({
  setup (_props, { slots, emit }) {
    const nuxtApp = useNuxtApp()
    onErrorCaptured((err) => {
      if (import.meta.client && !nuxtApp.isHydrating) {
        // ...
      }
    })
  }
})
```

### `runWithContext`

::note
Bạn có thể ở đây vì bạn nhận được thông báo "Nuxt instance unavailable". Vui lòng sử dụng phương thức này một cách tiết kiệm, và báo cáo các ví dụ gây ra vấn đề, để cuối cùng nó có thể được giải quyết ở cấp độ framework.
::

Phương thức `runWithContext` được thiết kế để gọi một hàm và cung cấp cho nó một ngữ cảnh Nuxt rõ ràng. Thông thường, ngữ cảnh Nuxt được truyền xung quanh một cách ngầm định và bạn không cần lo lắng về điều này. Tuy nhiên, khi làm việc với các kịch bản `async`/`await` phức tạp trong middleware/plugins, bạn có thể gặp phải các trường hợp mà instance hiện tại đã bị unset sau một async call.

```ts [middleware/auth.ts]
export default defineNuxtRouteMiddleware(async (to, from) => {
  const nuxtApp = useNuxtApp()
  let user
  try {
    user = await fetchUser()
    // the Vue/Nuxt compiler loses context here because of the try/catch block.
  } catch (e) {
    user = null
  }
  if (!user) {
    // apply the correct Nuxt context to our `navigateTo` call.
    return nuxtApp.runWithContext(() => navigateTo('/auth'))
  }
})
```

#### Usage

```js
const result = nuxtApp.runWithContext(() => functionWithContext())
```

- `functionWithContext`: Bất kỳ hàm nào yêu cầu ngữ cảnh của ứng dụng Nuxt hiện tại. Ngữ cảnh này sẽ được áp dụng chính xác một cách tự động.

`runWithContext` sẽ trả về bất cứ gì được trả về bởi `functionWithContext`.

#### A Deeper Explanation of Context

Vue.js Composition API (và Nuxt composables tương tự) hoạt động bằng cách phụ thuộc vào một ngữ cảnh ngầm định. Trong vòng đời, Vue thiết lập instance tạm thời của component hiện tại (và instance tạm thời của nuxtApp trong Nuxt) vào một biến toàn cục và unset nó trong cùng một tick. Khi rendering trên server side, có nhiều yêu cầu từ các user khác nhau và nuxtApp chạy trong cùng một ngữ cảnh toàn cục. Vì vậy, Nuxt và Vue ngay lập tức unset instance toàn cục này để tránh rò rỉ tham chiếu chia sẻ giữa hai user hoặc components.

Điều này có nghĩa là gì? Composition API và Nuxt Composables chỉ khả dụng trong vòng đời và trong cùng một tick trước bất kỳ async operation nào:

```js
// --- Vue internal ---
const _vueInstance = null
const getCurrentInstance = () => _vueInstance
// ---

// Vue / Nuxt sets a global variable referencing to current component in _vueInstance when calling setup()
async function setup() {
  getCurrentInstance() // Works
  await someAsyncOperation() // Vue unsets the context in same tick before async operation!
  getCurrentInstance() // null
}
```

Giải pháp cổ điển cho điều này là cache instance hiện tại trên lần gọi đầu tiên vào một biến local như `const instance = getCurrentInstance()` và sử dụng nó trong lần gọi composable tiếp theo nhưng vấn đề là bất kỳ nested composable calls nào bây giờ cần chấp nhận instance một cách rõ ràng làm đối số và không phụ thuộc vào ngữ cảnh ngầm định của composition-api. Đây là giới hạn thiết kế với composables và không phải là vấn đề per-se.

Để vượt qua giới hạn này, Vue thực hiện một số công việc behind the scenes khi compile code ứng dụng của chúng ta và khôi phục ngữ cảnh sau mỗi lần gọi cho `<script setup>`:

```js
const __instance = getCurrentInstance() // Generated by Vue compiler
getCurrentInstance() // Works!
await someAsyncOperation() // Vue unsets the context
__restoreInstance(__instance) // Generated by Vue compiler
getCurrentInstance() // Still works!
```

Để có mô tả tốt hơn về những gì Vue thực sự làm, xem [unjs/unctx#2 (comment)](https://github.com/unjs/unctx/issues/2#issuecomment-942193723){rel="nofollow"}.

#### Solution

Đây là nơi `runWithContext` có thể được sử dụng để khôi phục ngữ cảnh, tương tự như cách `<script setup>` hoạt động.

Nuxt nội bộ sử dụng [unjs/unctx](https://github.com/unjs/unctx){rel="nofollow"} để hỗ trợ composables tương tự như Vue cho plugins và middleware. Điều này cho phép các composables như `navigateTo()` hoạt động mà không cần truyền trực tiếp `nuxtApp` cho chúng - mang lại lợi ích DX và performance của Composition API cho toàn bộ framework Nuxt.

Kiểm tra [unjs/unctx#2](https://github.com/unjs/unctx/issues/2){rel="nofollow"} (proposal), [unjs/unctx#4](https://github.com/unjs/unctx/pull/4){rel="nofollow"} (transform implementation), và [nuxt/framework#3884](https://github.com/nuxt/framework/pull/3884){rel="nofollow"} (Integration to Nuxt).

Vue hiện tại chỉ hỗ trợ async context restoration cho `<script setup>` cho việc sử dụng async/await. Trong Nuxt, hỗ trợ transform cho `defineNuxtPlugin()` và `defineNuxtRouteMiddleware()` đã được thêm vào, có nghĩa là khi bạn sử dụng chúng Nuxt tự động transform chúng với context restoration.

#### Remaining Issues

Transformation `unjs/unctx` để tự động khôi phục ngữ cảnh dường như có bug với các câu lệnh `try/catch` chứa `await` mà cuối cùng cần được giải quyết để loại bỏ yêu cầu của workaround được đề xuất ở trên.

#### Native Async Context

Sử dụng một tính năng thử nghiệm mới, có thể kích hoạt hỗ trợ native async context bằng cách sử dụng [Node.js `AsyncLocalStorage`](https://nodejs.org/api/async_context.html#class-asynclocalstorage){rel="nofollow"} và hỗ trợ unctx mới để làm cho async context khả dụng **một cách native** cho **bất kỳ nested async composable nào** mà không cần transform hoặc truyền/gọi thủ công với context.

::tip
Hỗ trợ native async context hiện tại hoạt động trong Bun và Node.
::

::read-more
---
to: https://nuxt.com/docs/guide/going-further/experimental-features#asynccontext
---
::

## tryUseNuxtApp

Hàm này hoạt động chính xác giống như `useNuxtApp`, nhưng trả về `null` nếu ngữ cảnh không khả dụng thay vì ném ra ngoại lệ.

Bạn có thể sử dụng nó cho các composables không yêu cầu `nuxtApp`, hoặc để đơn giản kiểm tra xem ngữ cảnh có khả dụng hay không mà không có ngoại lệ.

Ví dụ sử dụng:

```ts [composable.ts]
export function useStandType() {
  // Always works on the client
  if (tryUseNuxtApp()) {
    return useRuntimeConfig().public.STAND_TYPE
  } else {
    return process.env.STAND_TYPE
  }
}
```


# useNuxtData

::note
`useNuxtData` cho bạn truy cập giá trị cache hiện tại của [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) , [`useLazyAsyncData`](https://nuxt.com/docs/api/composables/use-lazy-async-data), [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) và [`useLazyFetch`](https://nuxt.com/docs/api/composables/use-lazy-fetch) với key được cung cấp rõ ràng.
::

## Usage

Composable `useNuxtData` được sử dụng để truy cập giá trị cache hiện tại của các composables fetch data như `useAsyncData`, `useLazyAsyncData`, `useFetch`, và `useLazyFetch`. Bằng cách cung cấp key được sử dụng trong quá trình fetch data, bạn có thể truy xuất data cache và sử dụng nó khi cần.

Điều này đặc biệt hữu ích để tối ưu hóa performance bằng cách tái sử dụng data đã fetch hoặc triển khai các tính năng như Optimistic Updates hoặc cascading data updates.

Để sử dụng `useNuxtData`, đảm bảo rằng composable fetch data (`useFetch`, `useAsyncData`, etc.) đã được gọi với key được cung cấp rõ ràng.

::video-accordion
---
title: Watch a video from LearnVue about useNuxtData
video-id: e-_u6swXRWk
---
::

## Params

- `key`: Key duy nhất xác định data cache. Key này nên khớp với key được sử dụng trong quá trình fetch data ban đầu.

## Return Values

- `data`: Một reactive reference đến data cache liên quan đến key được cung cấp. Nếu không có data cache tồn tại, giá trị sẽ là `null`. `Ref` này tự động cập nhật nếu data cache thay đổi, cho phép reactivity liền mạch trong các components của bạn.

## Example

Ví dụ dưới đây cho thấy cách bạn có thể sử dụng data cache làm placeholder trong khi data mới nhất đang được fetch từ server.

```vue [pages/posts.vue]
<script setup lang="ts">
// We can access same data later using 'posts' key
const { data } = await useFetch('/api/posts', { key: 'posts' })
</script>
```

```vue [pages/posts/[id\\].vue]
<script setup lang="ts">
// Access to the cached value of useFetch in posts.vue (parent route)
const { data: posts } = useNuxtData('posts')

const route = useRoute()

const { data } = useLazyFetch(`/api/posts/${route.params.id}`, {
  key: `post-${route.params.id}`,
  default() {
    // Find the individual post from the cache and set it as the default value.
    return posts.value.find(post => post.id === route.params.id)
  }
})
</script>
```

## Optimistic Updates

Ví dụ dưới đây cho thấy cách triển khai Optimistic Updates có thể được thực hiện bằng cách sử dụng useNuxtData.

Optimistic Updates là một kỹ thuật mà giao diện người dùng được cập nhật ngay lập tức, giả định rằng một operation server sẽ thành công. Nếu operation cuối cùng thất bại, UI sẽ được rollback về trạng thái trước đó.

```vue [pages/todos.vue]
<script setup lang="ts">
// We can access same data later using 'todos' key
const { data } = await useAsyncData('todos', () => $fetch('/api/todos'))
</script>
```

```vue [components/NewTodo.vue]
<script setup lang="ts">
const newTodo = ref('')
let previousTodos = []

// Access to the cached value of useAsyncData in todos.vue
const { data: todos } = useNuxtData('todos')

async function addTodo () {
  return $fetch('/api/addTodo', {
    method: 'post',
    body: {
      todo: newTodo.value
    },
    onRequest () {
      // Store the previously cached value to restore if fetch fails.
      previousTodos = todos.value

      // Optimistically update the todos.
      todos.value = [...todos.value, newTodo.value]
    },
    onResponseError () {
      // Rollback the data if the request failed.
      todos.value = previousTodos
    },
    async onResponse () {
      // Invalidate todos in the background if the request succeeded.
      await refreshNuxtData('todos')
    }
  })
}
</script>
```

## Type

```ts
useNuxtData<DataT = any> (key: string): { data: Ref<DataT | undefined> }
```


# `usePreviewMode`

Chế độ preview cho phép bạn xem cách các thay đổi của bạn sẽ được hiển thị trên một site trực tiếp mà không tiết lộ chúng cho người dùng.

Bạn có thể sử dụng composable tích hợp `usePreviewMode` để truy cập và kiểm soát trạng thái preview trong Nuxt. Nếu composable phát hiện chế độ preview, nó sẽ tự động buộc bất kỳ cập nhật nào cần thiết cho [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) để rerender nội dung preview.

```js
const { enabled, state } = usePreviewMode()
```

## Options

### Custom `enable` check

Bạn có thể chỉ định cách tùy chỉnh để kích hoạt chế độ preview. Theo mặc định, composable `usePreviewMode` sẽ kích hoạt chế độ preview nếu có param `preview` trong url bằng `true` (ví dụ, `http://localhost:3000?preview=true`). Bạn có thể wrap `usePreviewMode` vào composable tùy chỉnh, để giữ options nhất quán trên các usages và ngăn chặn bất kỳ lỗi nào.

```js
export function useMyPreviewMode () {
  return usePreviewMode({
    shouldEnable: () => {
      return !!route.query.customPreview
    }
  });
}
```

### Modify default state

`usePreviewMode` sẽ cố gắng lưu giá trị của param `token` từ url trong state. Bạn có thể sửa đổi state này và nó sẽ khả dụng cho tất cả các calls [`usePreviewMode`](https://nuxt.com/docs/api/composables/use-preview-mode).

```js
const data1 = ref('data1')

const { enabled, state } = usePreviewMode({
  getState: (currentState) => {
    return { data1, data2: 'data2' }
  }
})
```

::note
Hàm `getState` sẽ append các giá trị trả về vào state hiện tại, vì vậy hãy cẩn thận không vô tình ghi đè state quan trọng.
::

### Customize the `onEnable` and `onDisable` callbacks

Theo mặc định, khi `usePreviewMode` được kích hoạt, nó sẽ gọi `refreshNuxtData()` để re-fetch tất cả data từ server.

Khi chế độ preview bị vô hiệu hóa, composable sẽ attach một callback để gọi `refreshNuxtData()` để chạy sau một router navigation tiếp theo.

Bạn có thể chỉ định callbacks tùy chỉnh để được trigger bằng cách cung cấp các hàm riêng của bạn cho options `onEnable` và `onDisable`.

```js
const { enabled, state } = usePreviewMode({
  onEnable: () => {
    console.log('preview mode has been enabled')
  },
  onDisable: () => {
    console.log('preview mode has been disabled')
  }
})
```

## Example

Ví dụ dưới đây tạo một page nơi một phần nội dung chỉ được render trong chế độ preview.

```vue [pages/some-page.vue]
<script setup>
const { enabled, state } = usePreviewMode()

const { data } = await useFetch('/api/preview', {
  query: {
    apiKey: state.token
  }
})
</script>

<template>
  <div>
    Some base content
    <p v-if="enabled">
      Only preview content: {{ state.token }}
      <br>
      <button @click="enabled = false">
        disable preview mode
      </button>
    </p>
  </div>
</template>
```

Bây giờ bạn có thể generate site của bạn và serve nó:

```bash [Terminal]
npx nuxt generate
npx nuxt preview
```

Sau đó bạn có thể xem page preview của bạn bằng cách thêm query param `preview` vào cuối page bạn muốn xem một lần:

```js
?preview=true
```

::note
`usePreviewMode` nên được test locally với `nuxt generate` và sau đó `nuxt preview` thay vì `nuxt dev`. (Lệnh [preview](https://nuxt.com/docs/api/commands/preview) không liên quan đến chế độ preview.)
::


# useRequestEvent

Trong [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context) bạn có thể sử dụng `useRequestEvent` để truy cập request đến.

```ts
// Get underlying request event
const event = useRequestEvent()

// Get the URL
const url = event?.path
```

::tip
Trong browser, `useRequestEvent` sẽ trả về `undefined`.
::


# useRequestFetch

Bạn có thể sử dụng `useRequestFetch` để chuyển tiếp ngữ cảnh request và headers khi thực hiện các yêu cầu fetch server-side.

Khi thực hiện yêu cầu fetch client-side, browser tự động gửi các headers cần thiết.

Tuy nhiên, khi thực hiện yêu cầu trong quá trình server-side rendering, do các cân nhắc bảo mật, chúng ta cần chuyển tiếp headers thủ công.

::note
Headers mà **không được thiết kế để chuyển tiếp** sẽ **không được bao gồm** trong yêu cầu. Các headers này bao gồm, ví dụ:

`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

::tip
Composable [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) sử dụng `useRequestFetch` under the hood để tự động chuyển tiếp ngữ cảnh request và headers.
::

::code-group
```vue [pages/index.vue]
<script setup lang="ts">
// This will forward the user's headers to the `/api/cookies` event handler
// Result: { cookies: { foo: 'bar' } }
const requestFetch = useRequestFetch()
const { data: forwarded } = await useAsyncData(() => requestFetch('/api/cookies'))

// This will NOT forward anything
// Result: { cookies: {} }
const { data: notForwarded } = await useAsyncData(() => $fetch('/api/cookies')) 
</script>
```

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```
::

::tip
Trong browser trong quá trình navigation client-side, `useRequestFetch` sẽ hoạt động giống như [`$fetch`](https://nuxt.com/docs/api/utils/dollarfetch) thông thường.
::


# useRequestHeader

Bạn có thể sử dụng composable tích hợp [`useRequestHeader`](https://nuxt.com/docs/api/composables/use-request-header) để truy cập bất kỳ header request đến nào trong pages, components và plugins của bạn.

```ts
// Get the authorization request header
const authorization = useRequestHeader('authorization')
```

::tip
Trong browser, `useRequestHeader` sẽ trả về `undefined`.
::

## Example

Chúng ta có thể sử dụng `useRequestHeader` để dễ dàng xác định xem một user có được ủy quyền hay không.

Ví dụ dưới đây đọc header request `authorization` để tìm hiểu xem một người có thể truy cập tài nguyên bị hạn chế hay không.

```ts [middleware/authorized-only.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  if (!useRequestHeader('authorization')) {
    return navigateTo('/not-authorized')
  }
})
```


# useRequestHeaders

Bạn có thể sử dụng composable tích hợp [`useRequestHeaders`](https://nuxt.com/docs/api/composables/use-request-headers) để truy cập các headers request đến trong pages, components và plugins của bạn.

```js
// Get all request headers
const headers = useRequestHeaders()

// Get only cookie request header
const headers = useRequestHeaders(['cookie'])
```

::tip
Trong browser, `useRequestHeaders` sẽ trả về một object rỗng.
::

## Example

Chúng ta có thể sử dụng `useRequestHeaders` để truy cập và proxy header `authorization` của request ban đầu cho bất kỳ yêu cầu internal nào trong tương lai trong quá trình SSR.

Ví dụ dưới đây thêm header request `authorization` vào một call `$fetch` isomorphic.

```vue [pages/some-page.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/confidential', {
  headers: useRequestHeaders(['authorization'])
})
</script>
```


# useRequestURL

`useRequestURL` là một hàm trợ giúp trả về một [URL object](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL){rel="nofollow"} hoạt động trên cả server-side và client-side.

::important
Khi sử dụng [Hybrid Rendering](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering) với các chiến lược cache, tất cả headers request đến sẽ bị drop khi xử lý các responses cache qua [Nitro caching layer](https://nitro.build/guide/cache){rel="nofollow"} (có nghĩa là `useRequestURL` sẽ trả về `localhost` cho `host`).

Bạn có thể định nghĩa option [`cache.varies`](https://nitro.build/guide/cache#options){rel="nofollow"} để chỉ định headers sẽ được xem xét khi cache và serve responses, chẳng hạn như `host` và `x-forwarded-host` cho các môi trường multi-tenant.
::

::code-group
```vue [pages/about.vue]
<script setup lang="ts">
const url = useRequestURL()
</script>

<template>
  <p>URL is: {{ url }}</p>
  <p>Path is: {{ url.pathname }}</p>
</template>
```

```html [Result in development]
<p>URL is: http://localhost:3000/about</p>
<p>Path is: /about</p>
```
::

::tip
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/URL#instance_properties
---
Đọc về các thuộc tính instance URL trên tài liệu MDN.
::


# useResponseHeader

::important
Composable này khả dụng trong Nuxt v3.14+.
::

Bạn có thể sử dụng composable tích hợp [`useResponseHeader`](https://nuxt.com/docs/api/composables/use-response-header) để thiết lập bất kỳ header response server nào trong pages, components và plugins của bạn.

```ts
// Set a custom response header
const header = useResponseHeader('X-My-Header');
header.value = 'my-value';
```

## Example

Chúng ta có thể sử dụng `useResponseHeader` để dễ dàng thiết lập một header response trên cơ sở per-page.

```vue [pages/test.vue]
<script setup>
// pages/test.vue
const header = useResponseHeader('X-My-Header');
header.value = 'my-value';
</script>

<template>
  <h1>Test page with custom header</h1>
  <p>The response from the server for this "/test" page will have a custom "X-My-Header" header.</p>
</template>
```

Chúng ta có thể sử dụng `useResponseHeader` ví dụ trong Nuxt [middleware](https://nuxt.com/docs/guide/directory-structure/middleware) để thiết lập một header response cho tất cả pages.

```ts [middleware/my-header-middleware.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const header = useResponseHeader('X-My-Always-Header');
  header.value = `I'm Always here!`;
});

```


# useRoute

::note
Trong template của một Vue component, bạn có thể truy cập route bằng `$route`.
::

## Example

Trong ví dụ sau, chúng ta gọi một API qua [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) sử dụng một tham số trang động - `slug` - làm một phần của URL.

```html [~/pages/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data: mountain } = await useFetch(`/api/mountains/${route.params.slug}`)
</script>

<template>
  <div>
    <h1>{{ mountain.title }}</h1>
    <p>{{ mountain.description }}</p>
  </div>
</template>
```

Nếu bạn cần truy cập các tham số query của route (ví dụ `example` trong path `/test?example=true`), thì bạn có thể sử dụng `useRoute().query` thay vì `useRoute().params`.

## API

Ngoài các tham số động và tham số query, `useRoute()` cũng cung cấp các computed references sau liên quan đến route hiện tại:

- `fullPath`: URL được encode liên quan đến route hiện tại chứa path, query và hash
- `hash`: phần hash được decode của URL bắt đầu với #
- `query`: truy cập tham số query của route
- `matched`: mảng các route đã match được normalized với vị trí route hiện tại
- `meta`: dữ liệu tùy chỉnh được gắn vào record
- `name`: tên duy nhất cho route record
- `path`: phần pathname được encode của URL
- `redirectedFrom`: vị trí route đã cố gắng truy cập trước khi kết thúc ở vị trí route hiện tại

::note
Browsers không gửi [URL fragments](https://url.spec.whatwg.org/#concept-url-fragment){rel="nofollow"} (ví dụ `#foo`) khi thực hiện requests. Vì vậy, sử dụng `route.fullPath` trong template của bạn có thể trigger các vấn đề hydration vì điều này sẽ bao gồm fragment trên client nhưng không phải trên server.
::

::read-more
---
icon: i-simple-icons-vuedotjs
to: https://router.vuejs.org/api/type-aliases/RouteLocationNormalizedLoaded.html
---
::


# useRouteAnnouncer

::important
Composable này khả dụng trong Nuxt v3.12+.
::

## Description

Một composable quan sát các thay đổi tiêu đề trang và cập nhật thông báo announcer tương ứng. Được sử dụng bởi [`<NuxtRouteAnnouncer>`](https://nuxt.com/docs/api/components/nuxt-route-announcer) và có thể kiểm soát.

Nó hook vào [`dom:rendered`](https://unhead.unjs.io/docs/typescript/head/api/hooks/dom-rendered){rel="nofollow"} của Unhead để đọc tiêu đề trang và thiết lập nó làm thông báo announcer.

## Parameters

- `politeness`: Thiết lập mức độ khẩn cấp cho các thông báo screen reader: `off` (tắt thông báo), `polite` (chờ im lặng), hoặc `assertive` (ngắt ngay lập tức). (mặc định `polite`).

## Properties

### `message`

- **type**: `Ref<string>`
- **description**: Thông báo để announce

### `politeness`

- **type**: `Ref<string>`
- **description**: Mức độ khẩn cấp thông báo screen reader `off`, `polite`, hoặc `assertive`

## Methods

### `set(message, politeness = "polite")`

Thiết lập thông báo để announce với mức độ khẩn cấp của nó.

### `polite(message)`

Thiết lập thông báo với `politeness = "polite"`

### `assertive(message)`

Thiết lập thông báo với `politeness = "assertive"`

## Example

```vue [pages/index.vue]
<script setup lang="ts">
  const { message, politeness, set, polite, assertive } = useRouteAnnouncer({
    politeness: 'assertive'
  })
</script>
```


# useRouter

```vue [pages/index.vue]
<script setup lang="ts">
const router = useRouter()
</script>
```

Nếu bạn chỉ cần instance router trong template của bạn, sử dụng `$router`:

```vue [pages/index.vue]
<template>
  <button @click="$router.back()">Back</button>
</template>
```

Nếu bạn có thư mục `pages/`, `useRouter` có hành vi giống hệt với cái được cung cấp bởi `vue-router`.

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
to: https://router.vuejs.org/api/interfaces/Router.html#Properties-currentRoute
---
Đọc `vue-router` documentation về `Router` interface.
::

## Basic Manipulation

- [`addRoute()`](https://router.vuejs.org/api/interfaces/Router.html#addRoute){rel="nofollow"}: Thêm một route mới vào instance router. `parentName` có thể được cung cấp để thêm route mới làm con của một route hiện có.
- [`removeRoute()`](https://router.vuejs.org/api/interfaces/Router.html#removeRoute){rel="nofollow"}: Xóa một route hiện có theo tên của nó.
- [`getRoutes()`](https://router.vuejs.org/api/interfaces/Router.html#getRoutes){rel="nofollow"}: Lấy danh sách đầy đủ của tất cả các route records.
- [`hasRoute()`](https://router.vuejs.org/api/interfaces/Router.html#hasRoute){rel="nofollow"}: Kiểm tra xem một route với tên đã cho có tồn tại hay không.
- [`resolve()`](https://router.vuejs.org/api/interfaces/Router.html#resolve){rel="nofollow"}: Trả về phiên bản normalized của vị trí route. Cũng bao gồm thuộc tính `href` bao gồm bất kỳ base nào hiện có.

```ts [Example]
const router = useRouter()

router.addRoute({ name: 'home', path: '/home', component: Home })
router.removeRoute('home')
router.getRoutes()
router.hasRoute('home')
router.resolve({ name: 'home' })
```

::note
`router.addRoute()` thêm chi tiết route vào một mảng các routes và nó hữu ích khi xây dựng [Nuxt plugins](https://nuxt.com/docs/guide/directory-structure/plugins) trong khi `router.push()` mặt khác, trigger một navigation mới ngay lập tức và nó hữu ích trong pages, Vue components và composable.
::

## Based on History API

- [`back()`](https://router.vuejs.org/api/interfaces/Router.html#back){rel="nofollow"}: Quay lại trong history nếu có thể, giống như `router.go(-1)`.
- [`forward()`](https://router.vuejs.org/api/interfaces/Router.html#forward){rel="nofollow"}: Tiến về phía trước trong history nếu có thể, giống như `router.go(1)`.
- [`go()`](https://router.vuejs.org/api/interfaces/Router.html#go){rel="nofollow"}: Di chuyển về phía trước hoặc phía sau qua history mà không có các hạn chế hierarchical được thực thi trong `router.back()` và `router.forward()`.
- [`push()`](https://router.vuejs.org/api/interfaces/Router.html#push){rel="nofollow"}: Programmatically navigate đến một URL mới bằng cách push một entry trong history stack. &#x2A;*Khuyến nghị sử dụng [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) thay thế.**
- [`replace()`](https://router.vuejs.org/api/interfaces/Router.html#replace){rel="nofollow"}: Programmatically navigate đến một URL mới bằng cách thay thế entry hiện tại trong routes history stack. &#x2A;*Khuyến nghị sử dụng [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) thay thế.**

```ts [Example]
const router = useRouter()

router.back()
router.forward()
router.go(3)
router.push({ path: "/home" })
router.replace({ hash: "#bio" })
```

::read-more
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/API/History
---
Đọc thêm về browser's History API.
::

## Navigation Guards

Composable `useRouter` cung cấp các phương thức trợ giúp `afterEach`, `beforeEach` và `beforeResolve` hoạt động như navigation guards.

Tuy nhiên, Nuxt có khái niệm **route middleware** giúp đơn giản hóa việc triển khai navigation guards và cung cấp trải nghiệm developer tốt hơn.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/middleware"}
::

## Promise and Error Handling

- [`isReady()`](https://router.vuejs.org/api/interfaces/Router.html#isReady){rel="nofollow"}: Trả về một Promise resolve khi router đã hoàn thành navigation ban đầu.
- [`onError`](https://router.vuejs.org/api/interfaces/Router.html#onError){rel="nofollow"}: Thêm một error handler được gọi mỗi lần một lỗi không được catch xảy ra trong quá trình navigation.

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Vue Router Docs
to: https://router.vuejs.org/api/interfaces/Router.html#Methods
---
::

## Universal Router Instance

Nếu bạn không có thư mục `pages/`, thì [`useRouter`](https://nuxt.com/docs/api/composables/use-router) sẽ trả về một universal router instance với các phương thức trợ giúp tương tự, nhưng lưu ý rằng không phải tất cả các tính năng có thể được hỗ trợ hoặc hoạt động chính xác giống như với `vue-router`.


# useRuntimeConfig

## Usage

```vue [app.vue]
<script setup lang="ts">
const config = useRuntimeConfig()
</script>
```

```ts [server/api/foo.ts]
export default defineEventHandler((event) => {
  const config = useRuntimeConfig(event)
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## Define Runtime Config

Ví dụ dưới đây cho thấy cách thiết lập một public API base URL và một secret API token chỉ có thể truy cập trên server.

Chúng ta nên luôn định nghĩa các biến `runtimeConfig` bên trong `nuxt.config`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // Private keys are only available on the server
    apiSecret: '123',

    // Public keys that are exposed to the client
    public: {
      apiBase: process.env.NUXT_PUBLIC_API_BASE || '/api'
    }
  }
})
```

::note
Các biến cần truy cập trên server được thêm trực tiếp bên trong `runtimeConfig`. Các biến cần truy cập trên cả client và server được định nghĩa trong `runtimeConfig.public`.
::

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## Access Runtime Config

Để truy cập runtime config, chúng ta có thể sử dụng composable `useRuntimeConfig()`:

```ts [server/api/test.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  // Access public variables
  const result = await $fetch(`/test`, {
    baseURL: config.public.apiBase,
    headers: {
      // Access a private variable (only available on the server)
      Authorization: `Bearer ${config.apiSecret}`
    }
  })
  return result
}
```

Trong ví dụ này, vì `apiBase` được định nghĩa trong namespace `public`, nó có thể truy cập universally trên cả server và client-side, trong khi `apiSecret` **chỉ có thể truy cập trên server-side**.

## Environment Variables

Có thể cập nhật các giá trị runtime config bằng cách sử dụng tên biến môi trường khớp với prefix `NUXT_`.

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

### Using the `.env` File

Chúng ta có thể thiết lập các biến môi trường bên trong file `.env` để làm cho chúng có thể truy cập trong quá trình **development** và **build/generate**.

```ini [.env]
NUXT_PUBLIC_API_BASE = "https://api.localhost:5555"
NUXT_API_SECRET = "123"
```

::note
Bất kỳ biến môi trường nào được thiết lập trong file `.env` được truy cập bằng `process.env` trong Nuxt app trong quá trình **development** và **build/generate**.
::

::warning
Trong **production runtime**, bạn nên sử dụng platform environment variables và `.env` không được sử dụng.
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/env"}
::

## `app` namespace

Nuxt sử dụng namespace `app` trong runtime-config với các keys bao gồm `baseURL` và `cdnURL`. Bạn có thể tùy chỉnh các giá trị của chúng tại runtime bằng cách thiết lập environment variables.

::note
Đây là một namespace reserved. Bạn không nên giới thiệu các keys bổ sung bên trong `app`.
::

### `app.baseURL`

Theo mặc định, `baseURL` được thiết lập thành `'/'`.

Tuy nhiên, `baseURL` có thể được cập nhật tại runtime bằng cách thiết lập `NUXT_APP_BASE_URL` làm environment variable.

Sau đó, bạn có thể truy cập base URL mới này bằng `config.app.baseURL`:

```ts [/plugins/my-plugin.ts]
export default defineNuxtPlugin((NuxtApp) => {
  const config = useRuntimeConfig()

  // Access baseURL universally
  const baseURL = config.app.baseURL
})
```

### `app.cdnURL`

Ví dụ này cho thấy cách thiết lập một custom CDN url và truy cập chúng bằng `useRuntimeConfig()`.

Bạn có thể sử dụng một custom CDN để serve static assets bên trong `.output/public` bằng environment variable `NUXT_APP_CDN_URL`.

Và sau đó truy cập CDN url mới bằng `config.app.cdnURL`.

```ts [server/api/foo.ts]
export default defineEventHandler((event) => {
  const config = useRuntimeConfig(event)

  // Access cdnURL universally
  const cdnURL = config.app.cdnURL
})
```

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::


# useRuntimeHook

::important
Composable này khả dụng trong Nuxt v3.14+.
::

```ts [signature]
function useRuntimeHook<THookName extends keyof RuntimeNuxtHooks>(
  name: THookName,
  fn: RuntimeNuxtHooks[THookName] extends HookCallback ? RuntimeNuxtHooks[THookName] : never
): void
```

## Usage

### Parameters

- `name`: Tên của runtime hook để đăng ký. Bạn có thể xem danh sách đầy đủ của [runtime Nuxt hooks here](https://nuxt.com/docs/api/advanced/hooks#app-hooks-runtime).
- `fn`: Hàm callback để thực thi khi hook được trigger. Chữ ký hàm thay đổi dựa trên tên hook.

### Returns

Composable không trả về giá trị, nhưng nó tự động unregister hook khi scope của component bị destroy.

## Example

```vue [pages/index.vue] twoslash
<script setup lang="ts">
// Register a hook that runs every time a link is prefetched, but which will be
// automatically cleaned up (and not called again) when the component is unmounted
useRuntimeHook('link:prefetch', (link) => {
  console.log('Prefetching', link)
})
</script>
```


# useSeoMeta

Điều này giúp bạn tránh các lỗi phổ biến, chẳng hạn như sử dụng `name` thay vì `property`, cũng như lỗi đánh máy - với hơn 100+ meta tags được typed đầy đủ.

::important
Đây là cách được khuyến nghị để thêm meta tags vào site của bạn vì nó an toàn XSS và có hỗ trợ TypeScript đầy đủ.
::

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Usage

```vue [app.vue]
<script setup lang="ts">
useSeoMeta({
  title: 'My Amazing Site',
  ogTitle: 'My Amazing Site',
  description: 'This is my amazing site, let me tell you all about it.',
  ogDescription: 'This is my amazing site, let me tell you all about it.',
  ogImage: 'https://example.com/image.png',
  twitterCard: 'summary_large_image',
})
</script>
```

Khi chèn các tags là reactive, bạn nên sử dụng syntax computed getter (`() => value`):

```vue [app.vue]
<script setup lang="ts">
const title = ref('My title')

useSeoMeta({
  title,
  description: () => `This is a description for the ${title.value} page`
})
</script>
```

## Parameters

Có hơn 100 parameters. Xem [danh sách đầy đủ các parameters trong source code](https://github.com/harlan-zw/zhead/blob/main/packages/zhead/src/metaFlat.ts#L1035){rel="nofollow"}.

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Performance

Trong hầu hết các trường hợp, SEO meta tags không cần reactive vì search engine robots chủ yếu scan initial page load.

Để có performance tốt hơn, bạn có thể wrap các calls `useSeoMeta` của bạn trong một điều kiện server-only khi các meta tags không cần reactive:

```vue [app.vue]
<script setup lang="ts">
if (import.meta.server) {
  // These meta tags will only be added during server-side rendering
  useSeoMeta({
    robots: 'index, follow',
    description: 'Static description that does not need reactivity',
    ogImage: 'https://example.com/image.png',
    // other static meta tags...
  })
}

const dynamicTitle = ref('My title')
// Only use reactive meta tags outside the condition when necessary
useSeoMeta({
  title: () => dynamicTitle.value,
  ogTitle: () => dynamicTitle.value,
})
</script>
```

Trước đây sử dụng composable [`useServerSeoMeta`](https://nuxt.com/docs/api/composables/use-server-seo-meta), nhưng nó đã bị deprecated để ủng hộ approach này.


# useServerSeoMeta

Giống như [`useSeoMeta`](https://nuxt.com/docs/api/composables/use-seo-meta), composable `useServerSeoMeta` cho phép bạn định nghĩa các meta tags SEO của site dưới dạng một object phẳng với hỗ trợ TypeScript đầy đủ.

::read-more{to="https://nuxt.com/docs/api/composables/use-seo-meta"}
::

Trong hầu hết các trường hợp, meta không cần reactive vì robots sẽ chỉ scan initial load. Vì vậy chúng tôi khuyến nghị sử dụng [`useServerSeoMeta`](https://nuxt.com/docs/api/composables/use-server-seo-meta) làm utility tập trung vào performance sẽ không làm gì (hoặc trả về một object `head`) trên client.

```vue [app.vue]
<script setup lang="ts">
useServerSeoMeta({
  robots: 'index, follow'
})
</script>
```

Parameters chính xác giống như với [`useSeoMeta`](https://nuxt.com/docs/api/composables/use-seo-meta)

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::


# useState

## Usage

```ts
// Create a reactive state and set default value
const count = useState('counter', () => Math.round(Math.random() * 100))
```

::read-more{to="https://nuxt.com/docs/getting-started/state-management"}
::

::important
Vì data bên trong `useState` sẽ được serialize thành JSON, điều quan trọng là nó không chứa bất kỳ thứ gì không thể serialize, chẳng hạn như classes, functions hoặc symbols.
::

::warning
`useState` là một tên hàm reserved được transform bởi compiler, vì vậy bạn không nên đặt tên hàm riêng của bạn là `useState`.
::

::video-accordion
---
title: Watch a video from Alexander Lichter about why and when to use useState
video-id: mv0WcBABcIk
---
::

## Using `shallowRef`

Nếu bạn không cần state của bạn reactive deeply, bạn có thể kết hợp `useState` với [`shallowRef`](https://vuejs.org/api/reactivity-advanced.html#shallowref){rel="nofollow"}. Điều này có thể cải thiện performance khi state của bạn chứa large objects và arrays.

```ts
const state = useState('my-shallow-state', () => shallowRef({ deep: 'not reactive' }))
// isShallow(state) === true
```

## Type

```ts
useState<T>(init?: () => T | Ref<T>): Ref<T>
useState<T>(key: string, init?: () => T | Ref<T>): Ref<T>
```

- `key`: Một key duy nhất đảm bảo rằng data fetching được de-duplicate đúng cách trên các requests. Nếu bạn không cung cấp key, thì một key duy nhất với file và line number của instance [`useState`](https://nuxt.com/docs/api/composables/use-state) sẽ được generate cho bạn.
- `init`: Một hàm cung cấp giá trị ban đầu cho state khi không được initiated. Hàm này cũng có thể trả về một `Ref`.
- `T`: (chỉ typescript) Chỉ định type của state


# $fetch

Nuxt sử dụng [ofetch](https://github.com/unjs/ofetch){rel="nofollow"} để hiển thị toàn cầu trình trợ giúp `$fetch` để thực hiện các yêu cầu HTTP trong ứng dụng Vue hoặc các tuyến API của bạn.

::tip{icon="i-lucide-rocket"}
Trong quá trình kết xuất phía máy chủ, việc gọi `$fetch` để lấy dữ liệu từ các [tuyến API](https://nuxt.com/docs/guide/directory-structure/server) nội bộ của bạn sẽ trực tiếp gọi hàm liên quan (mô phỏng yêu cầu), **tiết kiệm một cuộc gọi API bổ sung**.
::

::note{color="blue" icon="i-lucide-info"}
Sử dụng `$fetch` trong các thành phần mà không bao bọc nó bằng [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) khiến việc lấy dữ liệu hai lần: ban đầu trên máy chủ, sau đó lại trên phía máy khách trong quá trình hydrat hóa, vì `$fetch` không chuyển trạng thái từ máy chủ sang máy khách. Do đó, việc lấy dữ liệu sẽ được thực hiện ở cả hai phía vì máy khách phải lấy dữ liệu lại.
::

## Usage

Chúng tôi khuyên dùng [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) hoặc [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) + `$fetch` để ngăn chặn việc lấy dữ liệu hai lần khi lấy dữ liệu thành phần.

```vue [app.vue]
<script setup lang="ts">
// During SSR data is fetched twice, once on the server and once on the client.
const dataTwice = await $fetch('/api/item')

// During SSR data is fetched only on the server side and transferred to the client.
const { data } = await useAsyncData('item', () => $fetch('/api/item'))

// You can also useFetch as shortcut of useAsyncData + $fetch
const { data } = await useFetch('/api/item')
</script>
```

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::

Bạn có thể sử dụng `$fetch` trong bất kỳ phương thức nào chỉ được thực hiện ở phía máy khách.

```vue [pages/contact.vue]
<script setup lang="ts">
async function contactForm() {
  await $fetch('/api/contact', {
    method: 'POST',
    body: { hello: 'world '}
  })
}
</script>

<template>
  <button @click="contactForm">Contact</button>
</template>
```

::tip
`$fetch` là cách ưu tiên để thực hiện các cuộc gọi HTTP trong Nuxt thay vì [@nuxt/http](https://github.com/nuxt/http){rel="nofollow"} và [@nuxtjs/axios](https://github.com/nuxt-community/axios-module){rel="nofollow"} được tạo cho Nuxt 2.
::

::note
Nếu bạn sử dụng `$fetch` để gọi một URL HTTPS (bên ngoài) với chứng chỉ tự ký trong quá trình phát triển, bạn sẽ cần đặt `NODE_TLS_REJECT_UNAUTHORIZED=0` trong môi trường của mình.
::

### Passing Headers and Cookies

Khi chúng ta gọi `$fetch` trong trình duyệt, các tiêu đề người dùng như `cookie` sẽ được gửi trực tiếp đến API.

Tuy nhiên, trong quá trình Kết xuất Phía Máy chủ, do các rủi ro bảo mật như &#x2A;*Server-Side Request Forgery (SSRF)** hoặc **Lạm dụng Xác thực**, `$fetch` sẽ không bao gồm cookie của trình duyệt người dùng, cũng không chuyển tiếp cookie từ phản hồi lấy dữ liệu.

::code-group
```vue [pages/index.vue]
<script setup lang="ts">
// This will NOT forward headers or cookies during SSR
const { data } = await useAsyncData(() => $fetch('/api/cookies'))
</script>
```

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const foo = getCookie(event, 'foo')
  // ... Do something with the cookie
})
```
::

Nếu bạn cần chuyển tiếp tiêu đề và cookie trên máy chủ, bạn phải truyền chúng theo cách thủ công:

```vue [pages/index.vue]
<script setup lang="ts">
// This will forward the user's headers and cookies to `/api/cookies`
const requestFetch = useRequestFetch()
const { data } = await useAsyncData(() => requestFetch('/api/cookies'))
</script>
```

Tuy nhiên, khi gọi `useFetch` với một URL tương đối trên máy chủ, Nuxt sẽ sử dụng [`useRequestFetch`](https://nuxt.com/docs/api/composables/use-request-fetch) để proxy tiêu đề và cookie (với ngoại lệ các tiêu đề không được chuyển tiếp, như `host`).


# abortNavigation

::warning
`abortNavigation` chỉ có thể sử dụng bên trong một [trình xử lý middleware tuyến](https://nuxt.com/docs/guide/directory-structure/middleware).
::

## Type

```ts
abortNavigation(err?: Error | string): false
```

## Parameters

### `err`

- **Type**: [`Error`](https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Error){rel="nofollow"} | `string`:br Lỗi tùy chọn được ném ra bởi `abortNavigation`.

## Examples

Ví dụ dưới đây cho thấy cách bạn có thể sử dụng `abortNavigation` trong middleware tuyến để ngăn chặn truy cập tuyến không được ủy quyền:

```ts [middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('user')

  if (!user.value.isAuthorized) {
    return abortNavigation()
  }

  if (to.path !== '/edit-post') {
    return navigateTo('/edit-post')
  }
})
```

### `err` as a String

Bạn có thể truyền lỗi dưới dạng chuỗi:

```ts [middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('user')

  if (!user.value.isAuthorized) {
    return abortNavigation('Insufficient permissions.')
  }
})
```

### `err` as an Error Object

Bạn có thể truyền lỗi dưới dạng đối tượng [`Error`](https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Error){rel="nofollow"}, ví dụ như được bắt bởi khối `catch`:

```ts [middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  try {
    /* code that might throw an error */
  } catch (err) {
    return abortNavigation(err)
  }
})
```


# addRouteMiddleware

::note
Middleware tuyến là các bảo vệ điều hướng được lưu trữ trong thư mục [`middleware/`](https://nuxt.com/docs/guide/directory-structure/middleware) của ứng dụng Nuxt của bạn (trừ khi [đặt khác](https://nuxt.com/docs/api/nuxt-config#middleware)).
::

## Type

```ts
function addRouteMiddleware (name: string, middleware: RouteMiddleware, options?: AddRouteMiddlewareOptions): void
function addRouteMiddleware (middleware: RouteMiddleware): void

interface AddRouteMiddlewareOptions {
  global?: boolean
}
```

## Parameters

### `name`

- **Type:** `string` | `RouteMiddleware`

Có thể là một chuỗi hoặc một hàm của loại `RouteMiddleware`. Hàm nhận tuyến tiếp theo `to` làm đối số đầu tiên và tuyến hiện tại `from` làm đối số thứ hai, cả hai đều là các đối tượng tuyến Vue.

Learn more about available properties of [route objects](https://nuxt.com/docs/api/composables/use-route).

### `middleware`

- **Type:** `RouteMiddleware`

Đối số thứ hai là một hàm của loại `RouteMiddleware`. Giống như trên, nó cung cấp các đối tượng tuyến `to` và `from`. Nó trở nên tùy chọn nếu đối số đầu tiên trong `addRouteMiddleware()` đã được truyền dưới dạng hàm.

### `options`

- **Type:** `AddRouteMiddlewareOptions`

Một đối số `options` tùy chọn cho phép bạn đặt giá trị của `global` thành `true` để chỉ ra xem middleware bộ định tuyến có phải là toàn cầu hay không (đặt thành `false` theo mặc định).

## Examples

### Named Route Middleware

Middleware tuyến được đặt tên được định nghĩa bằng cách cung cấp một chuỗi làm đối số đầu tiên và một hàm làm đối số thứ hai:

```ts [plugins/my-plugin.ts]
export default defineNuxtPlugin(() => {
  addRouteMiddleware('named-middleware', () => {
    console.log('named middleware added in Nuxt plugin')
  })
})
```

Khi được định nghĩa trong một plugin, nó ghi đè bất kỳ middleware nào có cùng tên nằm trong thư mục `middleware/`.

### Global Route Middleware

Middleware tuyến toàn cầu có thể được định nghĩa theo hai cách:

- Truyền một hàm trực tiếp làm đối số đầu tiên mà không có tên. Nó sẽ tự động được coi là middleware toàn cầu và áp dụng trên mọi thay đổi tuyến.
  ```ts [plugins/my-plugin.ts]
  export default defineNuxtPlugin(() => {
    addRouteMiddleware((to, from) => {
      console.log('anonymous global middleware that runs on every route change')
    })
  })
  ```
- Đặt đối số thứ ba tùy chọn `{ global: true }` để chỉ ra xem middleware tuyến có phải là toàn cầu hay không.
  ```ts [plugins/my-plugin.ts]
  export default defineNuxtPlugin(() => {
    addRouteMiddleware('global-middleware', (to, from) => {
        console.log('global middleware that runs on every route change')
      },
      { global: true }
    )
  })
  ```


# callOnce

::important
Tiện ích này có sẵn kể từ [Nuxt v3.9](https://nuxt.com/blog/v3-9).
::

## Purpose

Hàm `callOnce` được thiết kế để thực thi một hàm hoặc khối mã đã cho chỉ một lần trong quá trình:

- kết xuất phía máy chủ nhưng không phải hydrat hóa
- điều hướng phía máy khách

Điều này hữu ích cho mã chỉ nên được thực thi một lần, chẳng hạn như ghi nhật ký sự kiện hoặc thiết lập trạng thái toàn cầu.

## Usage

Chế độ mặc định của `callOnce` là chạy mã chỉ một lần. Ví dụ, nếu mã chạy trên máy chủ, nó sẽ không chạy lại trên máy khách. Nó cũng sẽ không chạy lại nếu bạn `callOnce` nhiều hơn một lần trên máy khách, ví dụ bằng cách điều hướng trở lại trang này.

```vue [app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  console.log('This will only be logged once')
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

Cũng có thể chạy trên mọi điều hướng trong khi vẫn tránh tải kép ban đầu máy chủ/máy khách. Để làm điều này, có thể sử dụng chế độ `navigation`:

```vue [app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  console.log('This will only be logged once and then on every client side navigation')
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
}, { mode: 'navigation' })
</script>
```

::important
Chế độ `navigation` có sẵn kể từ [Nuxt v3.15](https://nuxt.com/blog/v3-15).
::

::tip
---
to: https://nuxt.com/docs/getting-started/state-management#usage-with-pinia
---
`callOnce` hữu ích khi kết hợp với [mô-đun Pinia](https://nuxt.com/modules/pinia) để gọi các hành động store.
::

::read-more{to="https://nuxt.com/docs/getting-started/state-management"}
::

::warning
Lưu ý rằng `callOnce` không trả về gì. Bạn nên sử dụng [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) hoặc [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) nếu bạn muốn thực hiện việc lấy dữ liệu trong quá trình SSR.
::

::note
`callOnce` là một composable được thiết kế để được gọi trực tiếp trong hàm setup, plugin hoặc middleware tuyến, vì nó cần thêm dữ liệu vào payload Nuxt để tránh gọi lại hàm trên máy khách khi trang hydrat hóa.
::

## Type

```ts
callOnce (key?: string, fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>
callOnce(fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>

type CallOnceOptions = {
  /**
   * Execution mode for the callOnce function
   * @default 'render'
   */
  mode?: 'navigation' | 'render'
}
```

## Parameters

- `key`: Một khóa duy nhất đảm bảo rằng mã được chạy một lần. Nếu bạn không cung cấp khóa, thì một khóa duy nhất với tệp và số dòng của phiên bản `callOnce` sẽ được tạo cho bạn.
- `fn`: Hàm để chạy một lần. Nó có thể không đồng bộ.
- `options`: Thiết lập chế độ, hoặc để thực thi lại trên điều hướng (`navigation`) hoặc chỉ một lần trong suốt thời gian tồn tại của ứng dụng (`render`). Mặc định là `render`.

  - `render`: Thực thi một lần trong quá trình kết xuất ban đầu (hoặc SSR hoặc CSR) - Chế độ mặc định
  - `navigation`: Thực thi một lần trong quá trình kết xuất ban đầu và một lần cho mỗi điều hướng phía máy khách tiếp theo


# clearError

Trong các trang, thành phần và plugin của bạn, bạn có thể sử dụng `clearError` để xóa tất cả lỗi và chuyển hướng người dùng.

**Parameters:**

- `options?: { redirect?: string }`

Bạn có thể cung cấp một đường dẫn tùy chọn để chuyển hướng đến (ví dụ, nếu bạn muốn điều hướng đến một trang 'an toàn').

```js
// Without redirect
clearError()

// With redirect
clearError({ redirect: '/homepage' })
```

Lỗi được đặt trong trạng thái bằng cách sử dụng [`useError()`](https://nuxt.com/docs/api/composables/use-error). Composable `clearError` sẽ đặt lại trạng thái này và gọi hook `app:error:cleared` với các tùy chọn được cung cấp.

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# clearNuxtData

::note
Phương thức này hữu ích nếu bạn muốn làm mất hiệu lực việc lấy dữ liệu cho một trang khác.
::

## Type

```ts
clearNuxtData (keys?: string | string[] | ((key: string) => boolean)): void
```

## Parameters

- `keys`: Một hoặc một mảng các khóa được sử dụng trong [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) để xóa dữ liệu được lưu trong bộ nhớ cache của chúng. Nếu không có khóa nào được cung cấp, **tất cả dữ liệu** sẽ bị làm mất hiệu lực.


# clearNuxtState

::note
Phương thức này hữu ích nếu bạn muốn làm mất hiệu lực trạng thái của `useState`.
::

## Type

```ts
clearNuxtState (keys?: string | string[] | ((key: string) => boolean)): void
```

## Parameters

- `keys`: Một hoặc một mảng các khóa được sử dụng trong [`useState`](https://nuxt.com/docs/api/composables/use-state) để xóa trạng thái được lưu trong bộ nhớ cache của chúng. Nếu không có khóa nào được cung cấp, **tất cả trạng thái** sẽ bị làm mất hiệu lực.


# createError

Bạn có thể sử dụng hàm này để tạo một đối tượng lỗi với siêu dữ liệu bổ sung. Nó có thể sử dụng được trong cả phần Vue và Nitro của ứng dụng của bạn, và được thiết kế để được ném ra.

## Parameters

- `err`: `string | { cause, data, message, name, stack, statusCode, statusMessage, fatal }`

Bạn có thể truyền một chuỗi hoặc một đối tượng cho hàm `createError`. Nếu bạn truyền một chuỗi, nó sẽ được sử dụng làm `message` lỗi, và `statusCode` sẽ mặc định là `500`. Nếu bạn truyền một đối tượng, bạn có thể đặt nhiều thuộc tính của lỗi, chẳng hạn như `statusCode`, `message`, và các thuộc tính lỗi khác.

## In Vue App

Nếu bạn ném một lỗi được tạo với `createError`:

- ở phía máy chủ, nó sẽ kích hoạt một trang lỗi toàn màn hình mà bạn có thể xóa với `clearError`.
- ở phía máy khách, nó sẽ ném một lỗi không nghiêm trọng để bạn xử lý. Nếu bạn cần kích hoạt một trang lỗi toàn màn hình, thì bạn có thể làm điều này bằng cách đặt `fatal: true`.

### Example

```vue [pages/movies/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data } = await useFetch(`/api/movies/${route.params.slug}`)
if (!data.value) {
  throw createError({ statusCode: 404, statusMessage: 'Page Not Found' })
}
</script>
```

## In API Routes

Sử dụng `createError` để kích hoạt xử lý lỗi trong các tuyến API máy chủ.

### Example

```ts [server/api/error.ts]
export default eventHandler(() => {
  throw createError({
    statusCode: 404,
    statusMessage: 'Page Not Found'
  })
})
```

Trong các tuyến API, việc sử dụng `createError` bằng cách truyền một đối tượng với `statusMessage` ngắn được khuyến nghị vì nó có thể được truy cập ở phía máy khách. Nếu không, một `message` được truyền cho `createError` trên một tuyến API sẽ không được truyền đến máy khách. Ngoài ra, bạn có thể sử dụng thuộc tính `data` để truyền dữ liệu trở lại máy khách. Trong mọi trường hợp, luôn cân nhắc tránh đặt đầu vào người dùng động vào message để tránh các vấn đề bảo mật tiềm ẩn.

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# defineLazyHydrationComponent

`defineLazyHydrationComponent` là một macro trình biên dịch giúp bạn tạo một thành phần với chiến lược hydrat hóa lười cụ thể. Hydrat hóa lười trì hoãn hydrat hóa cho đến khi các thành phần trở nên hiển thị hoặc cho đến khi trình duyệt đã hoàn thành các tác vụ quan trọng hơn. Điều này có thể giảm đáng kể chi phí hiệu suất ban đầu, đặc biệt là đối với các thành phần không thiết yếu.

## Usage

### Visibility Strategy

Hydrat hóa thành phần khi nó trở nên hiển thị trong viewport.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'visible',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- 
      Hydration will be triggered when
      the element(s) is 100px away from entering the viewport.
    -->
    <LazyHydrationMyComponent :hydrate-on-visible="{ rootMargin: '100px' }" />
  </div>
</template>
```

Prop `hydrateOnVisible` là tùy chọn. Bạn có thể truyền một đối tượng để tùy chỉnh hành vi của `IntersectionObserver` bên dưới.

::read-more
---
title: IntersectionObserver options
to: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver
---
Đọc thêm về các tùy chọn cho `hydrate-on-visible`.
::

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnVisible`](https://vuejs.org/guide/components/async.html#hydrate-on-visible){rel="nofollow"} tích hợp sẵn của Vue.
::

### Idle Strategy

Hydrat hóa thành phần khi trình duyệt đang rảnh. Điều này phù hợp nếu bạn cần thành phần tải càng sớm càng tốt, nhưng không chặn đường dẫn kết xuất quan trọng.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'idle',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- Hydration will be triggered when the browser is idle or after 2000ms. -->
    <LazyHydrationMyComponent :hydrate-on-idle="2000" />
  </div>
</template>
```

Prop `hydrateOnIdle` là tùy chọn. Bạn có thể truyền một số dương để chỉ định thời gian chờ tối đa.

Chiến lược rảnh là dành cho các thành phần có thể được hydrat hóa khi trình duyệt đang rảnh.

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnIdle`](https://vuejs.org/guide/components/async.html#hydrate-on-idle){rel="nofollow"} tích hợp sẵn của Vue.
::

### Interaction Strategy

Hydrat hóa thành phần sau một tương tác được chỉ định (ví dụ: click, mouseover).

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'interaction',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!--
      Hydration will be triggered when
      the element(s) is hovered over by the pointer.
    -->
    <LazyHydrationMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

Prop `hydrateOnInteraction` là tùy chọn. Nếu bạn không truyền một sự kiện hoặc danh sách các sự kiện, nó mặc định hydrat hóa trên `pointerenter`, `click`, và `focus`.

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnInteraction`](https://vuejs.org/guide/components/async.html#hydrate-on-interaction){rel="nofollow"} tích hợp sẵn của Vue.
::

### Media Query Strategy

Hydrat hóa thành phần khi cửa sổ khớp với một truy vấn phương tiện.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'mediaQuery',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!--
      Hydration will be triggered when
      the window width is greater than or equal to 768px.
    -->
    <LazyHydrationMyComponent hydrate-on-media-query="(min-width: 768px)" />
  </div>
</template>
```

::note
Bên dưới, điều này sử dụng chiến lược [`hydrateOnMediaQuery`](https://vuejs.org/guide/components/async.html#hydrate-on-media-query){rel="nofollow"} tích hợp sẵn của Vue.
::

### Time Strategy

Hydrat hóa thành phần sau một độ trễ được chỉ định (tính bằng mili giây).

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'time', 
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- Hydration is triggered after 1000ms. -->
    <LazyHydrationMyComponent :hydrate-after="1000" />
  </div>
</template>
```

Chiến lược thời gian là dành cho các thành phần có thể chờ một khoảng thời gian cụ thể.

### If Strategy

Hydrat hóa thành phần dựa trên một điều kiện boolean.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'if',
  () => import('./components/MyComponent.vue')
)

const isReady = ref(false)

function myFunction() {
  // Trigger custom hydration strategy...
  isReady.value = true
}
</script>

<template>
  <div>
    <!-- Hydration is triggered when isReady becomes true. -->
    <LazyHydrationMyComponent :hydrate-when="isReady" />
  </div>
</template>
```

Chiến lược if là tốt nhất cho các thành phần có thể không luôn cần được hydrat hóa.

### Never Hydrate

Không bao giờ hydrat hóa thành phần.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'never',
  () => import('./components/MyComponent.vue')
)
</script>

<template>
  <div>
    <!-- This component will never be hydrated by Vue. -->
    <LazyHydrationMyComponent />
  </div>
</template>
```

### Listening to Hydration Events

Tất cả các thành phần hydrat hóa bị trì hoãn phát ra sự kiện `@hydrated` khi chúng được hydrat hóa.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'visible',
  () => import('./components/MyComponent.vue')
)

function onHydrate() {
  console.log("Component has been hydrated!")
}
</script>

<template>
  <div>
    <LazyHydrationMyComponent
      :hydrate-on-visible="{ rootMargin: '100px' }"
      @hydrated="onHydrated"
    />
  </div>
</template>
```

## Parameters

::warning
Để đảm bảo trình biên dịch nhận dạng đúng macro này, tránh sử dụng các biến bên ngoài. Cách tiếp cận sau sẽ ngăn macro được nhận dạng đúng cách:

```vue
<script setup lang="ts">
const strategy = 'visible'
const source = () => import('./components/MyComponent.vue')
const LazyHydrationMyComponent = defineLazyHydrationComponent(strategy, source)
</script>
```
::

### `strategy`

- **Type**: `'visible' | 'idle' | 'interaction' | 'mediaQuery' | 'if' | 'time' | 'never'`
- **Required**: `true`

| Strategy      | Description                                                               |
| ------------- | ------------------------------------------------------------------------- |
| `visible`     | Hydrat hóa khi thành phần trở nên hiển thị trong viewport.                |
| `idle`        | Hydrat hóa khi trình duyệt đang rảnh hoặc sau một độ trễ.                 |
| `interaction` | Hydrat hóa khi có tương tác của người dùng (ví dụ: click, hover).         |
| `mediaQuery`  | Hydrat hóa khi điều kiện truy vấn phương tiện được chỉ định được đáp ứng. |
| `if`          | Hydrat hóa khi điều kiện boolean được chỉ định được đáp ứng.              |
| `time`        | Hydrat hóa sau độ trễ thời gian được chỉ định.                            |
| `never`       | Ngăn Vue hydrat hóa thành phần.                                           |

### `source`

- **Type**: `() => Promise<Component>`
- **Required**: `true`


# defineNuxtComponent

::note
`defineNuxtComponent()` là một hàm trợ giúp để định nghĩa các thành phần Vue an toàn kiểu bằng cách sử dụng options API tương tự như [`defineComponent()`](https://vuejs.org/api/general.html#definecomponent){rel="nofollow"}. Wrapper `defineNuxtComponent()` cũng thêm hỗ trợ cho các tùy chọn thành phần `asyncData` và `head`.
::

::note
Sử dụng `<script setup lang="ts">` là cách được khuyến nghị để khai báo các thành phần Vue trong Nuxt.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::

## `asyncData()`

Nếu bạn chọn không sử dụng `setup()` trong ứng dụng của mình, bạn có thể sử dụng phương thức `asyncData()` trong định nghĩa thành phần của mình:

```vue [pages/index.vue]
<script lang="ts">
export default defineNuxtComponent({
  async asyncData() {
    return {
      data: {
        greetings: 'hello world!'
      }
    }
  },
})
</script>
```

## `head()`

Nếu bạn chọn không sử dụng `setup()` trong ứng dụng của mình, bạn có thể sử dụng phương thức `head()` trong định nghĩa thành phần của mình:

```vue [pages/index.vue]
<script lang="ts">
export default defineNuxtComponent({
  head(nuxtApp) {
    return {
      title: 'My site'
    }
  },
})
</script>
```


# defineNuxtPlugin

`defineNuxtPlugin` là một hàm trợ giúp để tạo các plugin Nuxt với chức năng nâng cao và an toàn kiểu. Tiện ích này chuẩn hóa các định dạng plugin khác nhau thành một cấu trúc nhất quán hoạt động liền mạch trong hệ thống plugin của Nuxt.

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  // Doing something with nuxtApp
})
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/plugins#creating-plugins
---
::

## Type

```ts
defineNuxtPlugin<T extends Record<string, unknown>>(plugin: Plugin<T> | ObjectPlugin<T>): Plugin<T> & ObjectPlugin<T>

type Plugin<T> = (nuxt: [NuxtApp](/docs/guide/going-further/internals#the-nuxtapp-interface)) => Promise<void> | Promise<{ provide?: T }> | void | { provide?: T }

interface ObjectPlugin<T> {
  name?: string
  enforce?: 'pre' | 'default' | 'post'
  dependsOn?: string[]
  order?: number
  parallel?: boolean
  setup?: Plugin<T>
  hooks?: Partial<[RuntimeNuxtHooks](/docs/api/advanced/hooks#app-hooks-runtime)>
  env?: {
    islands?: boolean
  }
}
```

## Parameters

**plugin**: Một plugin có thể được định nghĩa theo hai cách:

1. **Function Plugin**: Một hàm nhận instance [`NuxtApp`](https://nuxt.com/docs/guide/going-further/internals#the-nuxtapp-interface) và có thể trả về một promise với một đối tượng tiềm năng có thuộc tính [`provide`](https://nuxt.com/docs/guide/directory-structure/plugins#providing-helpers) nếu bạn muốn cung cấp một trợ giúp trên instance [`NuxtApp`](https://nuxt.com/docs/guide/going-further/internals#the-nuxtapp-interface).
2. **Object Plugin**: Một đối tượng có thể bao gồm các thuộc tính khác nhau để cấu hình hành vi của plugin, chẳng hạn như `name`, `enforce`, `dependsOn`, `order`, `parallel`, `setup`, `hooks`, và `env`.

| Property    | Type                                                                                                                                          | Required | Description                                                                                                                                                                            |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`      | `string`                                                                                                                                      | `false`  | Tên tùy chọn cho plugin, hữu ích cho việc gỡ lỗi và quản lý phụ thuộc.                                                                                                                 |
| `enforce`   | `'pre'` \| `'default'` \| `'post'`                                                                                                            | `false`  | Kiểm soát khi plugin chạy tương đối với các plugin khác.                                                                                                                               |
| `dependsOn` | `string[]`                                                                                                                                    | `false`  | Mảng tên plugin mà plugin này phụ thuộc vào. Đảm bảo thứ tự thực thi đúng.                                                                                                             |
| `order`     | `number`                                                                                                                                      | `false`  | Điều này cho phép kiểm soát chi tiết hơn về thứ tự plugin và chỉ nên được sử dụng bởi người dùng nâng cao. &#x2A;*Nó ghi đè giá trị của `enforce` và được sử dụng để sắp xếp plugin.** |
| `parallel`  | `boolean`                                                                                                                                     | `false`  | Có thực thi plugin song song với các plugin song song khác hay không.                                                                                                                  |
| `setup`     | `Plugin<T>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                 | `false`  | Hàm plugin chính, tương đương với một function plugin.                                                                                                                                 |
| `hooks`     | `Partial<RuntimeNuxtHooks>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Các hook runtime ứng dụng Nuxt để đăng ký trực tiếp.                                                                                                                                   |
| `env`       | `{ islands?: boolean }`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}     | `false`  | Đặt giá trị này thành `false` nếu bạn không muốn plugin chạy khi kết xuất chỉ máy chủ hoặc các thành phần island.                                                                      |

::video-accordion
---
title: Watch a video from Alexander Lichter about the Object Syntax for Nuxt plugins
video-id: 2aXZyXB1QGQ
---
::

## Examples

### Basic Usage

Ví dụ dưới đây minh họa một plugin đơn giản thêm chức năng toàn cầu:

```ts [plugins/hello.ts] twoslash
export default defineNuxtPlugin((nuxtApp) => {
  // Add a global method
  return {
    provide: {
      hello: (name: string) => `Hello ${name}!`
    }
  }
})
```

### Object Syntax Plugin

Ví dụ dưới đây cho thấy cú pháp đối tượng với cấu hình nâng cao:

```ts [plugins/advanced.ts] twoslash
export default defineNuxtPlugin({
  name: 'my-plugin',
  enforce: 'pre',
  async setup (nuxtApp) {
    // Plugin setup logic
    const data = await $fetch('/api/config')
    
    return {
      provide: {
        config: data
      }
    }
  },
  hooks: {
    'app:created'() {
      console.log('App created!')
    }
  },
})
```


# defineNuxtRouteMiddleware

Middleware tuyến được lưu trữ trong [`middleware/`](https://nuxt.com/docs/guide/directory-structure/middleware) của ứng dụng Nuxt của bạn (trừ khi [đặt khác](https://nuxt.com/docs/api/nuxt-config#middleware)).

## Type

```ts
defineNuxtRouteMiddleware(middleware: RouteMiddleware) => RouteMiddleware

interface RouteMiddleware {
  (to: RouteLocationNormalized, from: RouteLocationNormalized): ReturnType<NavigationGuard>
}
```

## Parameters

### `middleware`

- **Type**: `RouteMiddleware`

Một hàm nhận hai đối tượng vị trí tuyến của Vue Router làm tham số: tuyến tiếp theo `to` làm đầu tiên, và tuyến hiện tại `from` làm thứ hai.

Learn more about available properties of `RouteLocationNormalized&#x60; in the &#x2A;*[Vue Router docs](https://router.vuejs.org/api/interfaces/RouteLocationNormalized.html){rel="nofollow"}**.

## Examples

### Showing Error Page

Bạn có thể sử dụng middleware tuyến để ném lỗi và hiển thị thông báo lỗi hữu ích:

```ts [middleware/error.ts]
export default defineNuxtRouteMiddleware((to) => {
  if (to.params.id === '1') {
    throw createError({ statusCode: 404, statusMessage: 'Page Not Found' })
  }
})
```

Middleware tuyến ở trên sẽ chuyển hướng người dùng đến trang lỗi tùy chỉnh được định nghĩa trong tệp `~/error.vue`, và hiển thị thông báo lỗi và mã được truyền từ middleware.

### Redirection

Sử dụng [`useState`](https://nuxt.com/docs/api/composables/use-state) kết hợp với hàm trợ giúp `navigateTo` bên trong middleware tuyến để chuyển hướng người dùng đến các tuyến khác nhau dựa trên trạng thái xác thực của họ:

```ts [middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const auth = useState('auth')

  if (!auth.value.isAuthenticated) {
    return navigateTo('/login')
  }

  if (to.path !== '/dashboard') {
    return navigateTo('/dashboard')
  }
})
```

Cả [navigateTo](https://nuxt.com/docs/api/utils/navigate-to) và [abortNavigation](https://nuxt.com/docs/api/utils/abort-navigation) đều là các hàm trợ giúp có sẵn toàn cầu mà bạn có thể sử dụng bên trong `defineNuxtRouteMiddleware`.


# definePageMeta

`definePageMeta` là một macro trình biên dịch mà bạn có thể sử dụng để đặt siêu dữ liệu cho các thành phần **trang** của mình nằm trong thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) (trừ khi [đặt khác](https://nuxt.com/docs/api/nuxt-config#pages)). Bằng cách này, bạn có thể đặt siêu dữ liệu tùy chỉnh cho mỗi tuyến tĩnh hoặc động của ứng dụng Nuxt của mình.

```vue [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'default'
})
</script>
```

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/pages#page-metadata
---
::

## Type

```ts
definePageMeta(meta: PageMeta) => void

interface PageMeta {
  validate?: (route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>
  redirect?: RouteRecordRedirectOption
  name?: string
  path?: string
  props?: RouteRecordRaw['props']
  alias?: string | string[]
  pageTransition?: boolean | TransitionProps
  layoutTransition?: boolean | TransitionProps
  viewTransition?: boolean | 'always'
  key?: false | string | ((route: RouteLocationNormalizedLoaded) => string)
  keepalive?: boolean | KeepAliveProps
  layout?: false | LayoutKey | Ref<LayoutKey> | ComputedRef<LayoutKey>
  middleware?: MiddlewareKey | NavigationGuard | Array<MiddlewareKey | NavigationGuard>
  scrollToTop?: boolean | ((to: RouteLocationNormalizedLoaded, from: RouteLocationNormalizedLoaded) => boolean)
  [key: string]: unknown
}
```

## Parameters

### `meta`

- **Type**: `PageMeta`:br Một đối tượng chấp nhận siêu dữ liệu trang sau:&#x20;:b&#x72;&#x2A;*`name`**
  - **Type**: `string`:br Bạn có thể định nghĩa một tên cho tuyến của trang này. Theo mặc định, tên được tạo dựa trên đường dẫn bên trong thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages).
  :b&#x72;&#x2A;*`path`**
  - **Type**: `string`:br Bạn có thể định nghĩa một [biểu thức chính quy tùy chỉnh](https://nuxt.com/#using-a-custom-regular-expression) nếu bạn có một mẫu phức tạp hơn có thể được biểu đạt bằng tên tệp.
  :b&#x72;&#x2A;*`props`**
  - **Type**: [`RouteRecordRaw['props']`](https://router.vuejs.org/guide/essentials/passing-props){rel="nofollow"}:br Cho phép truy cập `params` tuyến dưới dạng props được truyền cho thành phần trang.
  :b&#x72;&#x2A;*`alias`**
  - **Type**: `string | string[]`:br Bí danh cho bản ghi. Cho phép định nghĩa các đường dẫn bổ sung sẽ hoạt động như một bản sao của bản ghi. Cho phép có các đường dẫn viết tắt như `/users/:id` và `/u/:id`. Tất cả giá trị `alias` và `path` phải chia sẻ cùng params.
  :b&#x72;&#x2A;*`keepalive`**
  - **Type**: `boolean` | [`KeepAliveProps`](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"}:br Đặt thành `true` khi bạn muốn bảo tồn trạng thái trang qua các thay đổi tuyến hoặc sử dụng [`KeepAliveProps`](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"} để kiểm soát chi tiết.
  :b&#x72;&#x2A;*`key`**
  - **Type**: `false` | `string` | `((route: RouteLocationNormalizedLoaded) => string)`:br Đặt giá trị `key` khi bạn cần kiểm soát nhiều hơn về khi thành phần `<NuxtPage>` được kết xuất lại.
  :b&#x72;&#x2A;*`layout`**
  - **Type**: `false` | `LayoutKey` | `Ref<LayoutKey>` | `ComputedRef<LayoutKey>`:br Đặt tên tĩnh hoặc động của layout cho mỗi tuyến. Điều này có thể được đặt thành `false` trong trường hợp layout mặc định cần được tắt.
  :b&#x72;&#x2A;*`layoutTransition`**
  - **Type**: `boolean` | [`TransitionProps`](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}:br Đặt tên của chuyển tiếp để áp dụng cho layout hiện tại. Bạn cũng có thể đặt giá trị này thành `false` để tắt chuyển tiếp layout.
  :b&#x72;&#x2A;*`middleware`**
  - **Type**: `MiddlewareKey` | [`NavigationGuard`](https://router.vuejs.org/api/interfaces/NavigationGuard.html#navigationguard){rel="nofollow"} | `Array<MiddlewareKey | NavigationGuard>`:br Định nghĩa middleware ẩn danh hoặc được đặt tên trực tiếp trong `definePageMeta`. Tìm hiểu thêm về [middleware tuyến](https://nuxt.com/docs/guide/directory-structure/middleware).
  :b&#x72;&#x2A;*`pageTransition`**
  - **Type**: `boolean` | [`TransitionProps`](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}:br Đặt tên của chuyển tiếp để áp dụng cho trang hiện tại. Bạn cũng có thể đặt giá trị này thành `false` để tắt chuyển tiếp trang.
  :b&#x72;&#x2A;*`viewTransition`**
  - **Type**: `boolean | 'always'`:br&#x2A;*Tính năng thử nghiệm, chỉ có sẵn khi [được bật trong tệp nuxt.config của bạn](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental)**:br
    Bật/tắt Chuyển tiếp Chế độ xem cho trang hiện tại.
    Nếu đặt thành true, Nuxt sẽ không áp dụng chuyển tiếp nếu trình duyệt của người dùng khớp với `prefers-reduced-motion: reduce` (khuyến nghị). Nếu đặt thành `always`, Nuxt sẽ luôn áp dụng chuyển tiếp.
  :b&#x72;&#x2A;*`redirect`**
  - **Type**: [`RouteRecordRedirectOption`](https://router.vuejs.org/guide/essentials/redirect-and-alias.html#redirect-and-alias){rel="nofollow"}:br Nơi chuyển hướng nếu tuyến được khớp trực tiếp. Việc chuyển hướng xảy ra trước bất kỳ bảo vệ điều hướng nào và kích hoạt một điều hướng mới với vị trí đích mới.
  :b&#x72;&#x2A;*`validate`**
  - **Type**: `(route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>`:br Xác thực xem một tuyến đã cho có thể được kết xuất hợp lệ với trang này hay không. Trả về true nếu hợp lệ, hoặc false nếu không. Nếu không tìm thấy khớp khác, điều này sẽ có nghĩa là 404. Bạn cũng có thể trực tiếp trả về một đối tượng với `statusCode`/`statusMessage` để phản hồi ngay lập tức với lỗi (các khớp khác sẽ không được kiểm tra).
  :b&#x72;&#x2A;*`scrollToTop`**
  - **Type**: `boolean | (to: RouteLocationNormalized, from: RouteLocationNormalized) => boolean`:br Yêu cầu Nuxt cuộn lên đầu trước khi kết xuất trang hay không. Nếu bạn muốn ghi đè hành vi cuộn mặc định của Nuxt, bạn có thể làm như vậy trong `~/router.options.ts` (xem [định tuyến tùy chỉnh](https://nuxt.com/docs/guide/recipes/custom-routing#using-approuteroptions)) để biết thêm thông tin.
  :b&#x72;&#x2A;*`[key: string]`**
  - **Type**: `any`:br Ngoài các thuộc tính ở trên, bạn cũng có thể đặt siêu dữ liệu **tùy chỉnh**. Bạn có thể muốn làm như vậy theo cách an toàn kiểu bằng cách [mở rộng loại của đối tượng `meta`](https://nuxt.com/docs/guide/directory-structure/pages/#typing-custom-metadata).

## Examples

### Basic Usage

Ví dụ dưới đây minh họa:

- cách `key` có thể là một hàm trả về một giá trị;
- cách thuộc tính `keepalive` đảm bảo rằng thành phần `<modal>` không được lưu trong bộ nhớ cache khi chuyển đổi giữa nhiều thành phần;
- thêm `pageType` làm thuộc tính tùy chỉnh:

```vue [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  key: (route) => route.fullPath,

  keepalive: {
    exclude: ['modal']
  },

  pageType: 'Checkout'
})
</script>
```

### Defining Middleware

Ví dụ dưới đây cho thấy cách middleware có thể được định nghĩa bằng cách sử dụng một `function` trực tiếp trong `definePageMeta` hoặc đặt làm `string` khớp với tên tệp middleware nằm trong thư mục `middleware/`:

```vue [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  // define middleware as a function
  middleware: [
    function (to, from) {
      const auth = useState('auth')

      if (!auth.value.authenticated) {
          return navigateTo('/login')
      }

      if (to.path !== '/checkout') {
        return navigateTo('/checkout')
      }
    }
  ],

  // ... or a string
  middleware: 'auth'

  // ... or multiple strings
  middleware: ['auth', 'another-named-middleware']
})
</script>
```

### Using a Custom Regular Expression

Biểu thức chính quy tùy chỉnh là một cách tốt để giải quyết xung đột giữa các tuyến chồng chéo, ví dụ:

Hai tuyến "/test-category" và "/1234-post" khớp với cả hai tuyến trang `[postId]-[postSlug].vue` và `[categorySlug].vue`.

Để đảm bảo rằng chúng ta chỉ khớp với chữ số (`\d+`) cho `postId` trong tuyến `[postId]-[postSlug]`, chúng ta có thể thêm như sau vào mẫu trang `[postId]-[postSlug].vue`:

```vue [pages/[postId\\]-[postSlug\\].vue]
<script setup lang="ts">
definePageMeta({
  path: '/:postId(\\d+)-:postSlug' 
})
</script>
```

Để biết thêm ví dụ, xem [Cú pháp Khớp của Vue Router](https://router.vuejs.org/guide/essentials/route-matching-syntax.html){rel="nofollow"}.

### Defining Layout

Bạn có thể định nghĩa layout khớp với tên tệp layout nằm (theo mặc định) trong thư mục [`layouts/`](https://nuxt.com/docs/guide/directory-structure/layouts). Bạn cũng có thể tắt layout bằng cách đặt `layout` thành `false`:

```vue [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  // set custom layout
  layout: 'admin'

  // ... or disable a default layout
  layout: false
})
</script>
```


# defineRouteRules

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#inlinerouterules
---
Tính năng này là thử nghiệm và để sử dụng nó, bạn phải bật tùy chọn `experimental.inlineRouteRules` trong `nuxt.config` của mình.
::

## Usage

```vue [pages/index.vue]
<script setup lang="ts">
defineRouteRules({
  prerender: true
})
</script>

<template>
  <h1>Hello world!</h1>
</template>
```

Sẽ được dịch sang:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true }
  }
})
```

::note
Khi chạy [`nuxt build`](https://nuxt.com/docs/api/commands/build), trang chủ sẽ được pre-rendered trong `.output/public/index.html` và được phục vụ tĩnh.
::

## Notes

- Một quy tắc được định nghĩa trong `~/pages/foo/bar.vue` sẽ được áp dụng cho các yêu cầu `/foo/bar`.
- Một quy tắc trong `~/pages/foo/[id].vue` sẽ được áp dụng cho các yêu cầu `/foo/**`.

Để kiểm soát nhiều hơn, chẳng hạn như nếu bạn đang sử dụng `path` hoặc `alias` tùy chỉnh được đặt trong [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) của trang, bạn nên đặt `routeRules` trực tiếp trong `nuxt.config` của mình.

::read-more
---
icon: i-lucide-medal
to: https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering
---
Đọc thêm về `routeRules`.
::


# navigateTo

## Usage

`navigateTo` có sẵn ở cả phía máy chủ và phía máy khách. Nó có thể được sử dụng trong [bối cảnh Nuxt](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context), hoặc trực tiếp, để thực hiện điều hướng trang.

::warning
Đảm bảo luôn sử dụng `await` hoặc `return` trên kết quả của `navigateTo` khi gọi nó.
::

::note
`navigateTo` không thể được sử dụng trong các tuyến Nitro. Để thực hiện chuyển hướng phía máy chủ trong các tuyến Nitro, hãy sử dụng [`sendRedirect`](https://h3.dev/utils/response#sendredirectevent-location-code){rel="nofollow"} thay thế.
::

### Within a Vue Component

```vue
<script setup lang="ts">
// passing 'to' as a string
await navigateTo('/search')

// ... or as a route object
await navigateTo({ path: '/search' })

// ... or as a route object with query parameters
await navigateTo({
  path: '/search',
  query: {
    page: 1,
    sort: 'asc'
  }
})
</script>
```

### Within Route Middleware

```ts
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.path !== '/search') {
    // setting the redirect code to '301 Moved Permanently'
    return navigateTo('/search', { redirectCode: 301 })
  }
})
```

Khi sử dụng `navigateTo` trong middleware tuyến, bạn phải **trả về kết quả của nó** để đảm bảo luồng thực thi middleware hoạt động đúng cách.

Ví dụ, việc triển khai sau **sẽ không hoạt động như mong đợi**:

```ts
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.path !== '/search') {
    // ❌ This will not work as expected
    navigateTo('/search', { redirectCode: 301 })
    return
  }
})
```

Trong trường hợp này, `navigateTo` sẽ được thực thi nhưng không được trả về, điều này có thể dẫn đến hành vi không mong muốn.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/middleware"}
::

### Navigating to an External URL

Tham số `external` trong `navigateTo` ảnh hưởng đến cách điều hướng đến URL được xử lý:

- **Không có `external: true`**:
  - URL nội bộ điều hướng như mong đợi.
  - URL bên ngoài ném ra lỗi.
- **Với `external: true`**:
  - URL nội bộ điều hướng với tải lại toàn trang.
  - URL bên ngoài điều hướng như mong đợi.

#### Example

```vue
<script setup lang="ts">
// will throw an error;
// navigating to an external URL is not allowed by default
await navigateTo('https://nuxt.com')

// will redirect successfully with the 'external' parameter set to 'true'
await navigateTo('https://nuxt.com', {
  external: true
})
</script>
```

### Opening a Page in a New Tab

```vue
<script setup lang="ts">
// will open 'https://nuxt.com' in a new tab
await navigateTo('https://nuxt.com', {
  open: {
    target: '_blank',
    windowFeatures: {
      width: 500,
      height: 500
    }
  }
})
</script>
```

## Type

```ts
function navigateTo(
  to: RouteLocationRaw | undefined | null,
  options?: NavigateToOptions
) => Promise<void | NavigationFailure | false> | false | void | RouteLocationRaw 

interface NavigateToOptions {
  replace?: boolean
  redirectCode?: number
  external?: boolean
  open?: OpenOptions
}

type OpenOptions = {
  target: string
  windowFeatures?: OpenWindowFeatures
}

type OpenWindowFeatures = {
  popup?: boolean
  noopener?: boolean
  noreferrer?: boolean
} & XOR<{ width?: number }, { innerWidth?: number }>
  & XOR<{ height?: number }, { innerHeight?: number }>
  & XOR<{ left?: number }, { screenX?: number }>
  & XOR<{ top?: number }, { screenY?: number }>
```

## Parameters

### `to`

**Type**: [`RouteLocationRaw`](https://router.vuejs.org/api/interfaces/RouteLocationOptions.html#Interface-RouteLocationOptions){rel="nofollow"} | `undefined` | `null`

**Default**: `'/'`

`to` có thể là một chuỗi đơn giản hoặc một đối tượng tuyến để chuyển hướng đến. Khi được truyền dưới dạng `undefined` hoặc `null`, nó sẽ mặc định là `'/'`.

#### Example

```ts
// Passing the URL directly will redirect to the '/blog' page
await navigateTo('/blog')

// Using the route object, will redirect to the route with the name 'blog'
await navigateTo({ name: 'blog' })

// Redirects to the 'product' route while passing a parameter (id = 1) using the route object.
await navigateTo({ name: 'product', params: { id: 1 } })
```

### `options` (optional)

**Type**: `NavigateToOptions`

Một đối tượng chấp nhận các thuộc tính sau:

- `replace`
  - **Type**: `boolean`
  - **Default**: `false`
  - Theo mặc định, `navigateTo` đẩy tuyến đã cho vào instance của Vue Router ở phía máy khách. :br Hành vi này có thể được thay đổi bằng cách đặt `replace` thành `true`, để chỉ ra rằng tuyến đã cho nên được thay thế.
- `redirectCode`
  - **Type**: `number`
  - **Default**: `302`
  - `navigateTo` chuyển hướng đến đường dẫn đã cho và đặt mã chuyển hướng thành [`302 Found`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302){rel="nofollow"} theo mặc định khi chuyển hướng diễn ra ở phía máy chủ. :br Hành vi mặc định này có thể được sửa đổi bằng cách cung cấp `redirectCode` khác. Thường thì [`301 Moved Permanently`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301){rel="nofollow"} có thể được sử dụng cho các chuyển hướng vĩnh viễn.
- `external`
  - **Type**: `boolean`
  - **Default**: `false`
  - Cho phép điều hướng đến một URL bên ngoài khi đặt thành `true`. Nếu không, `navigateTo` sẽ ném ra lỗi, vì điều hướng bên ngoài không được phép theo mặc định.
- `open`
  - **Type**: `OpenOptions`
  - Cho phép điều hướng đến URL bằng cách sử dụng phương thức [open()](https://developer.mozilla.org/en-US/docs/Web/API/Window/open){rel="nofollow"} của cửa sổ. Tùy chọn này chỉ áp dụng ở phía máy khách và sẽ bị bỏ qua ở phía máy chủ. :br Một đối tượng chấp nhận các thuộc tính sau:
  - `target`
    - **Type**: `string`
    - **Default**: `'_blank'`
    - Một chuỗi, không có khoảng trắng, chỉ định tên của bối cảnh duyệt mà tài nguyên được tải vào.
  - `windowFeatures`
    - **Type**: `OpenWindowFeatures`
    - Một đối tượng chấp nhận các thuộc tính sau:
      | Property                  | Type      | Description                                                                                               |
      | ------------------------- | --------- | --------------------------------------------------------------------------------------------------------- |
      | `popup`                   | `boolean` | Yêu cầu một cửa sổ popup tối thiểu thay vì tab mới, với các tính năng UI được quyết định bởi trình duyệt. |
      | `width` or `innerWidth`   | `number`  | Chỉ định chiều rộng của khu vực nội dung (tối thiểu 100 pixel), bao gồm thanh cuộn.                       |
      | `height` or `innerHeight` | `number`  | Chỉ định chiều cao của khu vực nội dung (tối thiểu 100 pixel), bao gồm thanh cuộn.                        |
      | `left` or `screenX`       | `number`  | Đặt vị trí ngang của cửa sổ mới tương đối với cạnh trái của màn hình.                                     |
      | `top` or `screenY`        | `number`  | Đặt vị trí dọc của cửa sổ mới tương đối với cạnh trên của màn hình.                                       |
      | `noopener`                | `boolean` | Ngăn cửa sổ mới truy cập cửa sổ gốc qua `window.opener`.                                                  |
      | `noreferrer`              | `boolean` | Ngăn tiêu đề Referer được gửi và ngầm bật `noopener`.                                                     |
      :brTham khảo [tài liệu](https://developer.mozilla.org/en-US/docs/Web/API/Window/open#windowfeatures){rel="nofollow"} để biết thông tin chi tiết hơn về các thuộc tính **windowFeatures**.


# onBeforeRouteLeave

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Vue Router Docs
to: https://router.vuejs.org/api/functions/onBeforeRouteLeave.html
---
::


# onBeforeRouteUpdate

::read-more
---
icon: i-simple-icons-vuedotjs
target: _blank
title: Vue Router Docs
to: https://router.vuejs.org/api/functions/onBeforeRouteUpdate.html
---
::


# onNuxtReady

::important
`onNuxtReady` chỉ chạy ở phía máy khách. :br
Nó lý tưởng để chạy mã không nên chặn việc kết xuất ban đầu của ứng dụng của bạn.
::

```ts [plugins/ready.client.ts]
export default defineNuxtPlugin(() => {
  onNuxtReady(async () => {
    const myAnalyticsLibrary = await import('my-big-analytics-library')
    // do something with myAnalyticsLibrary
  })
})
```

Nó 'an toàn' để chạy ngay cả sau khi ứng dụng của bạn đã khởi tạo. Trong trường hợp này, thì mã sẽ được đăng ký để chạy trong callback rảnh tiếp theo.


# prefetchComponents

Việc prefetching component tải xuống mã code trong nền, điều này dựa trên giả định rằng component có khả năng sẽ được sử dụng để render, cho phép component tải ngay lập tức nếu và khi người dùng yêu cầu. Component được tải xuống và lưu cache cho việc sử dụng tương lai dự kiến mà không cần người dùng thực hiện yêu cầu rõ ràng.

Sử dụng `prefetchComponents` để prefetch thủ công các component riêng lẻ đã được đăng ký toàn cục trong ứng dụng Nuxt của bạn. Theo mặc định, Nuxt đăng ký chúng như các async components. Bạn phải sử dụng phiên bản Pascal-cased của tên component.

```ts
await prefetchComponents('MyGlobalComponent')

await prefetchComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])
```

::note
Việc triển khai hiện tại hoạt động giống hệt như [`preloadComponents`](https://nuxt.com/docs/api/utils/preload-components) bằng cách preload components thay vì chỉ prefetch, chúng tôi đang làm việc để cải thiện hành vi này.
::

::note
Trên server, `prefetchComponents` sẽ không có hiệu lực.
::


# preloadComponents

Việc preloading components tải các components mà trang của bạn sẽ cần rất sớm, mà bạn muốn bắt đầu tải sớm trong vòng đời render. Điều này đảm bảo chúng có sẵn sớm hơn và ít có khả năng chặn việc render trang, cải thiện hiệu suất.

Sử dụng `preloadComponents` để preload thủ công các component riêng lẻ đã được đăng ký toàn cục trong ứng dụng Nuxt của bạn. Theo mặc định, Nuxt đăng ký chúng như các async components. Bạn phải sử dụng phiên bản Pascal-cased của tên component.

```js
await preloadComponents('MyGlobalComponent')

await preloadComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])
```

::note
Trên server, `preloadComponents` sẽ không có hiệu lực.
::


# preloadRouteComponents

Việc preloading routes tải các components của một route nhất định mà người dùng có thể điều hướng đến trong tương lai. Điều này đảm bảo rằng các components có sẵn sớm hơn và ít có khả năng chặn việc điều hướng, cải thiện hiệu suất.

::tip{icon="i-lucide-rocket"}
Nuxt đã tự động preload các routes cần thiết nếu bạn đang sử dụng component `NuxtLink`.
::

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
::

## Example

Preload một route khi sử dụng `navigateTo`.

```ts
// chúng ta không await hàm async này, để tránh chặn việc render
// hàm setup của component này
preloadRouteComponents('/dashboard')

const submit = async () => {
  const results = await $fetch('/api/authentication')

  if (results.token) {
    await navigateTo('/dashboard')
  }
}
```

::read-more{to="https://nuxt.com/docs/api/utils/navigate-to"}
::

::note
Trên server, `preloadRouteComponents` sẽ không có hiệu lực.
::


# prerenderRoutes

Khi prerendering, bạn có thể gợi ý cho Nitro prerender các đường dẫn bổ sung, ngay cả khi URL của chúng không xuất hiện trong HTML của trang được tạo.

::important
`prerenderRoutes` chỉ có thể được gọi trong [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

::note
`prerenderRoutes` phải được thực thi trong quá trình prerendering. Nếu `prerenderRoutes` được sử dụng trong các trang/routes động không được prerender, thì nó sẽ không được thực thi.
::

```js
const route = useRoute()

prerenderRoutes('/')
prerenderRoutes(['/', '/about'])
```

::note
Trong trình duyệt, hoặc nếu được gọi bên ngoài prerendering, `prerenderRoutes` sẽ không có hiệu lực.
::

Bạn thậm chí có thể prerender các API routes, điều này đặc biệt hữu ích cho các trang web được tạo tĩnh hoàn toàn (SSG) vì bạn có thể `$fetch` dữ liệu như thể có một server khả dụng!

```js
prerenderRoutes('/api/content/article/name-of-article')

// Ở đâu đó sau này trong App
const articleContent = await $fetch('/api/content/article/name-of-article', {
  responseType: 'json',
})
```

::warning
Các API routes được prerender trong production có thể không trả về các header phản hồi mong đợi, tùy thuộc vào nhà cung cấp bạn triển khai. Ví dụ, một phản hồi JSON có thể được phục vụ với loại content `application/octet-stream`.
Luôn đặt `responseType` thủ công khi fetch các API routes được prerender.
::


# refreshCookie

::important
Tiện ích này có sẵn kể từ [Nuxt v3.10](https://nuxt.com/blog/v3-10).
::

## Purpose

Hàm `refreshCookie` được thiết kế để làm mới giá trị cookie được trả về bởi `useCookie`.

Điều này hữu ích để cập nhật ref `useCookie` khi chúng ta biết giá trị cookie mới đã được đặt trong trình duyệt.

## Usage

```vue [app.vue]
<script setup lang="ts">
const tokenCookie = useCookie('token')

const login = async (username, password) => {
  const token = await $fetch('/api/token', { ... }) // Sets `token` cookie on response
  refreshCookie('token')
}

const loggedIn = computed(() => !!tokenCookie.value)
</script>
```

::note
---
to: https://nuxt.com/docs/guide/going-further/experimental-features#cookiestore
---
Bạn có thể bật tùy chọn `cookieStore` thử nghiệm để tự động làm mới giá trị `useCookie` khi cookie thay đổi trong trình duyệt.
::

## Type

```ts
refreshCookie(name: string): void
```


# refreshNuxtData

`refreshNuxtData` được sử dụng để refetch tất cả hoặc các instance `asyncData` cụ thể, bao gồm những instance từ [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data), [`useLazyAsyncData`](https://nuxt.com/docs/api/composables/use-lazy-async-data), [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch), và [`useLazyFetch`](https://nuxt.com/docs/api/composables/use-lazy-fetch).

::note
Nếu component của bạn được cache bởi `<KeepAlive>` và vào trạng thái deactivated, `asyncData` bên trong component vẫn sẽ được refetch cho đến khi component bị unmount.
::

## Type

```ts
refreshNuxtData(keys?: string | string[])
```

## Parameters

- `keys`: Một chuỗi đơn hoặc mảng các chuỗi làm `keys` được sử dụng để fetch dữ liệu. Tham số này là **tùy chọn**. Tất cả keys [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) được re-fetch khi không có `keys` nào được chỉ định rõ ràng.

## Return Values

`refreshNuxtData` trả về một promise, resolve khi tất cả hoặc các instance `asyncData` cụ thể đã được làm mới.

## Examples

### Refresh All Data

Ví dụ dưới đây làm mới tất cả dữ liệu đang được fetch bằng `useAsyncData` và `useFetch` trong ứng dụng Nuxt.

```vue [pages/some-page.vue]
<script setup lang="ts">
const refreshing = ref(false)

async function refreshAll () {
  refreshing.value = true
  try {
    await refreshNuxtData()
  } finally {
    refreshing.value = false
  }
}
</script>

<template>
  <div>
    <button :disabled="refreshing" @click="refreshAll">
      Refetch Tất Cả Dữ Liệu
    </button>
  </div>
</template>
```

### Refresh Specific Data

Ví dụ dưới đây chỉ làm mới dữ liệu nơi key khớp với `count` và `user`.

```vue [pages/some-page.vue]
<script setup lang="ts">
const refreshing = ref(false)

async function refresh () {
  refreshing.value = true
  try {
    // bạn cũng có thể truyền một mảng các keys để làm mới nhiều dữ liệu
    await refreshNuxtData(['count', 'user'])
  } finally {
    refreshing.value = false
  }
}
</script>

<template>
  <div v-if="refreshing">
    Đang tải
  </div>
  <button @click="refresh">Refresh</button>
</template>
```

::note
Nếu bạn có quyền truy cập vào instance `asyncData`, bạn nên sử dụng phương thức `refresh` hoặc `execute` của nó như cách ưu tiên để refetch dữ liệu.
::

::read-more{to="https://nuxt.com/docs/getting-started/data-fetching"}
::


# reloadNuxtApp

::note
`reloadNuxtApp` sẽ thực hiện một hard reload của ứng dụng của bạn, re-request trang và các dependencies từ server.
::

Theo mặc định, nó cũng sẽ lưu `state` hiện tại của ứng dụng của bạn (tức là bất kỳ state nào bạn có thể truy cập với `useState`).

::read-more
---
icon: i-lucide-star
to: https://nuxt.com/docs/guide/going-further/experimental-features#restorestate
---
Bạn có thể bật việc khôi phục thử nghiệm của state này bằng cách bật tùy chọn `experimental.restoreState` trong file `nuxt.config` của bạn.
::

## Type

```ts
reloadNuxtApp(options?: ReloadNuxtAppOptions)

interface ReloadNuxtAppOptions {
  ttl?: number
  force?: boolean
  path?: string
  persistState?: boolean
}
```

### `options` (optional)

**Type**: `ReloadNuxtAppOptions`

Một object chấp nhận các thuộc tính sau:

- `path` (optional) :br**Type**: `string`:br**Default**: `window.location.pathname`:br Đường dẫn để reload (mặc định là đường dẫn hiện tại). Nếu khác với vị trí cửa sổ hiện tại, nó sẽ kích hoạt điều hướng và thêm một entry vào lịch sử trình duyệt.
- `ttl` (optional) :br**Type**: `number`:br**Default**: `10000`:br Số mili giây để bỏ qua các yêu cầu reload trong tương lai. Nếu được gọi lại trong khoảng thời gian này, `reloadNuxtApp` sẽ không reload ứng dụng của bạn để tránh vòng lặp reload.
- `force` (optional) :br**Type**: `boolean`:br**Default**: `false`:br Tùy chọn này cho phép bỏ qua hoàn toàn bảo vệ vòng lặp reload, buộc reload ngay cả khi đã xảy ra trong TTL đã chỉ định trước đó.
- `persistState` (optional) :br**Type**: `boolean`:br**Default**: `false`:br Có dump state Nuxt hiện tại vào sessionStorage (như `nuxt:reload:state`) hay không. Theo mặc định, điều này sẽ không có hiệu lực trên reload trừ khi `experimental.restoreState` cũng được đặt, hoặc trừ khi bạn xử lý việc khôi phục state bằng chính mình.


# setPageLayout

::important
`setPageLayout` cho phép bạn thay đổi động layout của một trang. Nó dựa vào việc truy cập Nuxt context và do đó chỉ có thể được gọi trong [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

```ts [middleware/custom-layout.ts]
export default defineNuxtRouteMiddleware((to) => {
  // Đặt layout trên route bạn đang điều hướng _đến_
  setPageLayout('other')
})
```

::note
Nếu bạn chọn đặt layout động ở phía server, bạn *phải* làm như vậy trước khi layout được render bởi Vue (tức là trong plugin hoặc route middleware) để tránh mismatch hydration.
::


# setResponseStatus

Nuxt cung cấp composables và utilities cho hỗ trợ server-side-rendering hạng nhất.

`setResponseStatus` đặt statusCode (và tùy chọn statusMessage) của response.

::important
`setResponseStatus` chỉ có thể được gọi trong [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context).
::

```js
const event = useRequestEvent()

// event sẽ undefined trong trình duyệt
if (event) {
  // Đặt status code thành 404 cho trang 404 tùy chỉnh
  setResponseStatus(event, 404)

  // Đặt status message cũng vậy
  setResponseStatus(event, 404, 'Page Not Found')
}
```

::note
Trong trình duyệt, `setResponseStatus` sẽ không có hiệu lực.
::

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# showError

Trong [Nuxt context](https://nuxt.com/docs/guide/going-further/nuxt-app#the-nuxt-context) bạn có thể sử dụng `showError` để hiển thị lỗi.

**Parameters:**

- `error`: `string | Error | Partial<{ cause, data, message, name, stack, statusCode, statusMessage }>`

```ts
showError("😱 Ôi không, một lỗi đã được ném ra.")
showError({
  statusCode: 404,
  statusMessage: "Không Tìm Thấy Trang"
})
```

Lỗi được đặt trong state bằng cách sử dụng [`useError()`](https://nuxt.com/docs/api/composables/use-error) để tạo một shared error state reactive và SSR-friendly trên các components.

::tip
`showError` gọi hook `app:error`.
::

::read-more{to="https://nuxt.com/docs/getting-started/error-handling"}
::


# updateAppConfig

::note
Cập nhật [`app.config`](https://nuxt.com/docs/guide/directory-structure/app-config) bằng cách sử dụng deep assignment. Các thuộc tính (nested) hiện có sẽ được bảo toàn.
::

## Usage

```js
const appConfig = useAppConfig() // { foo: 'bar' }

const newAppConfig = { foo: 'baz' }

updateAppConfig(newAppConfig)

console.log(appConfig) // { foo: 'baz' }
```

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app-config"}
::


# nuxt add

```bash [Terminal]
npx nuxt add <TEMPLATE> <NAME> [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--force]
```

### Arguments

| Argument   | Description                                                                                                |
| ---------- | ---------------------------------------------------------------------------------------------------------- |
| `TEMPLATE` | Chỉ định mẫu nào để tạo (tùy chọn: \<api\|plugin\|component\|composable\|middleware\|layout\|page\|layer>) |
| `NAME`     | Chỉ định tên của tệp được tạo                                                                              |

### Options

| Option                             | Default | Description                            |
| ---------------------------------- | ------- | -------------------------------------- |
| `--cwd=<directory>`                | `.`     | Chỉ định thư mục làm việc              |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng |
| `--force`                          | `false` | Buộc ghi đè tệp nếu nó đã tồn tại      |

**Modifiers:**

Một số mẫu hỗ trợ cờ bổ ngữ bổ sung để thêm hậu tố (như `.client` hoặc `.get`) vào tên của chúng.

```bash [Terminal]
# Tạo `/plugins/sockets.client.ts`
npx nuxt add plugin sockets --client
```

## `nuxt add component`

- Cờ bổ ngữ: `--mode client|server` hoặc `--client` hoặc `--server`

```bash [Terminal]
# Tạo `components/TheHeader.vue`
npx nuxt add component TheHeader
```

## `nuxt add composable`

```bash [Terminal]
# Tạo `composables/foo.ts`
npx nuxt add composable foo
```

## `nuxt add layout`

```bash [Terminal]
# Tạo `layouts/custom.vue`
npx nuxt add layout custom
```

## `nuxt add plugin`

- Modifier flags: `--mode client|server` or `--client`or `--server`

```bash [Terminal]
# Tạo `plugins/analytics.ts`
npx nuxt add plugin analytics
```

## `nuxt add page`

```bash [Terminal]
# Tạo `pages/about.vue`
npx nuxt add page about
```

```bash [Terminal]
# Tạo `pages/category/[id].vue`
npx nuxt add page "category/[id]"
```

## `nuxt add middleware`

- Cờ bổ ngữ: `--global`

```bash [Terminal]
# Tạo `middleware/auth.ts`
npx nuxt add middleware auth
```

## `nuxt add api`

- Cờ bổ ngữ: `--method` (có thể chấp nhận `connect`, `delete`, `get`, `head`, `options`, `patch`, `post`, `put` hoặc `trace`) hoặc thay thế bạn có thể sử dụng trực tiếp `--get`, `--post`, v.v.

```bash [Terminal]
# Tạo `server/api/hello.ts`
npx nuxt add api hello
```

## `nuxt add layer`

```bash [Terminal]
# Tạo `layers/subscribe/nuxt.config.ts`
npx nuxt add layer subscribe
```


# nuxt analyze

```bash [Terminal]
npx nuxt analyze [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dotenv] [--name=<name>] [--no-serve]
```

Lệnh `analyze` xây dựng Nuxt và phân tích gói sản xuất (thử nghiệm).

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default   | Description                                                             |
| ---------------------------------- | --------- | ----------------------------------------------------------------------- |
| `--cwd=<directory>`                |           | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`) |
| `--logLevel=<silent|info|verbose>` |           | Chỉ định cấp độ log thời gian xây dựng                                  |
| `--dotenv`                         |           | Đường dẫn đến tệp `.env` để tải, tương đối với thư mục gốc              |
| `--name=<name>`                    | `default` | Tên của phân tích                                                       |
| `--no-serve`                       |           | Bỏ qua phục vụ kết quả phân tích                                        |

::note
Lệnh này đặt `process.env.NODE_ENV` thành `production`.
::


# nuxt build

```bash [Terminal]
npx nuxt build [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--prerender] [--preset] [--dotenv] [--envName]
```

Lệnh `build` tạo thư mục `.output` với tất cả ứng dụng, máy chủ và dependencies sẵn sàng cho sản xuất.

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default | Description                                                                                                                         |
| ---------------------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`)                                                             |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng                                                                                              |
| `--prerender`                      |         | Xây dựng Nuxt và prerender các route tĩnh                                                                                           |
| `--preset`                         |         | Preset máy chủ Nitro                                                                                                                |
| `--dotenv`                         |         | Đường dẫn đến tệp `.env` để tải, tương đối với thư mục gốc                                                                          |
| `--envName`                        |         | Môi trường để sử dụng khi giải quyết ghi đè cấu hình (mặc định là `production` khi xây dựng, và `development` khi chạy máy chủ dev) |

::note
Lệnh này đặt `process.env.NODE_ENV` thành `production`.
::

::note
`--prerender` sẽ luôn đặt `preset` thành `static`
::


# nuxt build-module

```bash [Terminal]
npx nuxt build-module [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--build] [--stub] [--sourcemap] [--prepare]
```

Lệnh `build-module` chạy `@nuxt/module-builder` để tạo thư mục `dist` trong `rootDir` của bạn chứa bản build đầy đủ cho **nuxt-module** của bạn.

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default | Description                                                             |
| ---------------------------------- | ------- | ----------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`) |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng                                  |
| `--build`                          | `false` | Xây dựng module để phân phối                                            |
| `--stub`                           | `false` | Stub dist thay vì thực sự xây dựng nó cho phát triển                    |
| `--sourcemap`                      | `false` | Tạo sourcemaps                                                          |
| `--prepare`                        | `false` | Chuẩn bị module cho phát triển cục bộ                                   |

::read-more
---
icon: i-simple-icons-github
target: \_blank
to: https://github.com/nuxt/module-builder
---
Đọc thêm về `@nuxt/module-builder`.
::


# nuxt cleanup

```bash [Terminal]
npx nuxt cleanup [ROOTDIR] [--cwd=<directory>]
```

Lệnh `cleanup` xóa các tệp và bộ nhớ cache Nuxt được tạo phổ biến, bao gồm:

- `.nuxt`
- `.output`
- `node_modules/.vite`
- `node_modules/.cache`

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option              | Default | Description                                                             |
| ------------------- | ------- | ----------------------------------------------------------------------- |
| `--cwd=<directory>` |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`) |


# nuxt dev

```bash [Terminal]
npx nuxt dev [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dotenv] [--envName] [--no-clear] [--no-fork] [-p, --port] [-h, --host] [--clipboard] [-o, --open] [--https] [--publicURL] [--qr] [--public] [--tunnel] [--sslCert] [--sslKey]
```

Lệnh `dev` khởi động máy chủ phát triển với hot module replacement tại [http://localhost:3000](https://localhost:3000){rel="nofollow"}

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default | Description                                                                                                                         |
| ---------------------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`)                                                             |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng                                                                                              |
| `--dotenv`                         |         | Đường dẫn đến tệp `.env` để tải, tương đối với thư mục gốc                                                                          |
| `--envName`                        |         | Môi trường để sử dụng khi giải quyết ghi đè cấu hình (mặc định là `production` khi xây dựng, và `development` khi chạy máy chủ dev) |
| `--no-clear`                       |         | Vô hiệu hóa xóa console khi khởi động lại                                                                                           |
| `--no-fork`                        |         | Vô hiệu hóa chế độ forked                                                                                                           |
| `-p, --port`                       |         | Port để lắng nghe (mặc định: `NUXT_PORT || NITRO_PORT || PORT || nuxtOptions.devServer.port`)                                       |
| `-h, --host`                       |         | Host để lắng nghe (mặc định: `NUXT_HOST || NITRO_HOST || HOST || nuxtOptions._layers?.[0]?.devServer?.host`)                        |
| `--clipboard`                      | `false` | Sao chép URL vào clipboard                                                                                                          |
| `-o, --open`                       | `false` | Mở URL trong trình duyệt                                                                                                            |
| `--https`                          |         | Bật HTTPS                                                                                                                           |
| `--publicURL`                      |         | URL công khai hiển thị (được sử dụng cho mã QR)                                                                                     |
| `--qr`                             |         | Hiển thị mã QR của URL công khai khi có sẵn                                                                                         |
| `--public`                         |         | Lắng nghe tất cả giao diện mạng                                                                                                     |
| `--tunnel`                         |         | Mở tunnel sử dụng <https://github.com/unjs/untun>{rel="nofollow"}                                                                   |
| `--sslCert`                        |         | (ĐÃ LỖI THỜI) Sử dụng `--https.cert` thay thế.                                                                                      |
| `--sslKey`                         |         | (ĐÃ LỖI THỜI) Sử dụng `--https.key` thay thế.                                                                                       |

Port và host cũng có thể được đặt qua biến môi trường NUXT\_PORT, PORT, NUXT\_HOST hoặc HOST.

Ngoài các tùy chọn trên, `@nuxt/cli` có thể truyền tùy chọn qua `listhen`, ví dụ `--no-qr` để tắt mã QR máy chủ dev. Bạn có thể tìm danh sách tùy chọn `listhen` trong tài liệu [unjs/listhen](https://github.com/unjs/listhen){rel="nofollow"}.

Lệnh này đặt `process.env.NODE_ENV` thành `development`.

::note
Nếu bạn đang sử dụng chứng chỉ tự ký trong phát triển, bạn sẽ cần đặt `NODE_TLS_REJECT_UNAUTHORIZED=0` trong môi trường của bạn.
::


# nuxt devtools

```bash [Terminal]
npx nuxt devtools <COMMAND> [ROOTDIR] [--cwd=<directory>]
```

Chạy `nuxt devtools enable` sẽ cài đặt Nuxt DevTools toàn cầu, và cũng bật nó trong dự án cụ thể bạn đang sử dụng. Nó được lưu như một tùy chọn trong `.nuxtrc` cấp người dùng của bạn. Nếu bạn muốn xóa hỗ trợ devtools cho một dự án cụ thể, bạn có thể chạy `nuxt devtools disable`.

## Arguments

| Argument      | Description                                 |
| ------------- | ------------------------------------------- |
| `COMMAND`     | Lệnh để chạy (tùy chọn: \<enable\|disable>) |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`)   |

## Options

| Option              | Default | Description                                                             |
| ------------------- | ------- | ----------------------------------------------------------------------- |
| `--cwd=<directory>` |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`) |

::read-more
---
icon: i-simple-icons-nuxtdotjs
target: \_blank
to: https://devtools.nuxt.com
---
Đọc thêm về **Nuxt DevTools**.
::


# nuxt generate

```bash [Terminal]
npx nuxt generate [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--preset] [--dotenv] [--envName]
```

Lệnh `generate` pre-render mọi route của ứng dụng của bạn và lưu kết quả trong các tệp HTML thuần mà bạn có thể triển khai trên bất kỳ dịch vụ hosting tĩnh nào. Lệnh kích hoạt lệnh `nuxt build` với đối số `prerender` được đặt thành `true`

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default | Description                                                                                                                         |
| ---------------------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`)                                                             |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng                                                                                              |
| `--preset`                         |         | Preset máy chủ Nitro                                                                                                                |
| `--dotenv`                         |         | Đường dẫn đến tệp `.env` để tải, tương đối với thư mục gốc                                                                          |
| `--envName`                        |         | Môi trường để sử dụng khi giải quyết ghi đè cấu hình (mặc định là `production` khi xây dựng, và `development` khi chạy máy chủ dev) |

::read-more
---
to: https://nuxt.com/docs/getting-started/deployment#static-hosting
---
Đọc thêm về pre-rendering và hosting tĩnh.
::


# nuxt info

```bash [Terminal]
npx nuxt info [ROOTDIR] [--cwd=<directory>]
```

Lệnh `info` ghi log thông tin về dự án Nuxt hiện tại hoặc được chỉ định.

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option              | Default | Description                                                             |
| ------------------- | ------- | ----------------------------------------------------------------------- |
| `--cwd=<directory>` |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`) |


# create nuxt

```bash [Terminal]
npm create nuxt@latest [DIR] [--cwd=<directory>] [-t, --template] [-f, --force] [--offline] [--preferOffline] [--no-install] [--gitInit] [--shell] [--packageManager] [--nightly]
```

Lệnh `create-nuxt` khởi tạo một dự án Nuxt mới sử dụng [unjs/giget](https://github.com/unjs/giget){rel="nofollow"}.

## Arguments

| Argument | Description   |
| -------- | ------------- |
| `DIR=""` | Thư mục dự án |

## Options

| Option              | Default | Description                                                                |
| ------------------- | ------- | -------------------------------------------------------------------------- |
| `--cwd=<directory>` | `.`     | Chỉ định thư mục làm việc                                                  |
| `-t, --template`    |         | Tên mẫu                                                                    |
| `-f, --force`       |         | Ghi đè thư mục hiện có                                                     |
| `--offline`         |         | Buộc chế độ offline                                                        |
| `--preferOffline`   |         | Ưu tiên chế độ offline                                                     |
| `--no-install`      |         | Bỏ qua cài đặt dependencies                                                |
| `--gitInit`         |         | Khởi tạo kho git                                                           |
| `--shell`           |         | Khởi động shell sau cài đặt trong thư mục dự án                            |
| `--packageManager`  |         | Lựa chọn trình quản lý gói (npm, pnpm, yarn, bun)                          |
| `--modules`         |         | Các module Nuxt để cài đặt (phân tách bằng dấu phẩy không có khoảng trắng) |
| `--no-modules`      |         | Bỏ qua lời nhắc cài đặt module                                             |
| `--nightly`         |         | Sử dụng kênh phát hành nightly của Nuxt (3x hoặc latest)                   |

## Environment variables

- `NUXI_INIT_REGISTRY`: Đặt thành registry mẫu tùy chỉnh. ([tìm hiểu thêm](https://github.com/unjs/giget#custom-registry){rel="nofollow"}).

  - Registry mặc định được tải từ [nuxt/starter/templates](https://github.com/nuxt/starter/tree/templates/templates){rel="nofollow"}


# nuxt module

Nuxt cung cấp một số tiện ích để làm việc với [Nuxt modules](https://nuxt.com/modules) một cách liền mạch.

## nuxt module add

```bash [Terminal]
npx nuxt module add <MODULENAME> [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--skipInstall] [--skipConfig] [--dev]
```

| Argument     | Description |
| ------------ | ----------- |
| `MODULENAME` | Tên module  |

| Option                             | Default | Description                            |
| ---------------------------------- | ------- | -------------------------------------- |
| `--cwd=<directory>`                | `.`     | Chỉ định thư mục làm việc              |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng |
| `--skipInstall`                    |         | Bỏ qua npm install                     |
| `--skipConfig`                     |         | Bỏ qua cập nhật nuxt.config.ts         |
| `--dev`                            |         | Cài đặt module như dev dependency      |

Lệnh cho phép bạn cài đặt [Nuxt modules](https://nuxt.com/modules) trong ứng dụng của bạn mà không cần công việc thủ công.

Khi chạy lệnh, nó sẽ:

- cài đặt module như một dependency sử dụng trình quản lý gói của bạn
- thêm nó vào tệp [package.json](https://nuxt.com/docs/guide/directory-structure/package) của bạn
- cập nhật tệp [`nuxt.config`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) của bạn

**Ví dụ:**

Cài đặt module [`Pinia`](https://nuxt.com/modules/pinia)

```bash [Terminal]
npx nuxt module add pinia
```

## nuxt module search

```bash [Terminal]
npx nuxt module search <QUERY> [--cwd=<directory>] [--nuxtVersion=<2|3>]
```

### Arguments

| Argument | Description         |
| -------- | ------------------- |
| `QUERY`  | từ khóa để tìm kiếm |

### Options

| Option                | Default | Description                                                                                     |
| --------------------- | ------- | ----------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`   | `.`     | Chỉ định thư mục làm việc                                                                       |
| `--nuxtVersion=<2|3>` |         | Lọc theo phiên bản Nuxt và chỉ liệt kê các module tương thích (tự động phát hiện theo mặc định) |

Lệnh tìm kiếm các module Nuxt khớp với truy vấn của bạn mà tương thích với phiên bản Nuxt của bạn.

**Ví dụ:**

```bash [Terminal]
npx nuxt module search pinia
```


# nuxt prepare

```bash [Terminal]
npx nuxt prepare [ROOTDIR] [--dotenv] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--envName]
```

Lệnh `prepare` tạo thư mục [`.nuxt`](https://nuxt.com/docs/guide/directory-structure/nuxt) trong ứng dụng của bạn và tạo các loại. Điều này có thể hữu ích trong môi trường CI hoặc như lệnh `postinstall` trong [`package.json`](https://nuxt.com/docs/guide/directory-structure/package) của bạn.

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default | Description                                                                                                                         |
| ---------------------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `--dotenv`                         |         | Đường dẫn đến tệp `.env` để tải, tương đối với thư mục gốc                                                                          |
| `--cwd=<directory>`                |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`)                                                             |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng                                                                                              |
| `--envName`                        |         | Môi trường để sử dụng khi giải quyết ghi đè cấu hình (mặc định là `production` khi xây dựng, và `development` khi chạy máy chủ dev) |


# nuxt preview

```bash [Terminal]
npx nuxt preview [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--envName] [--dotenv] [-p, --port]
```

Lệnh `preview` khởi động máy chủ để xem trước ứng dụng Nuxt của bạn sau khi chạy lệnh `build`. Lệnh `start` là bí danh cho `preview`. Khi chạy ứng dụng của bạn trong sản xuất, hãy tham khảo phần [Deployment](https://nuxt.com/docs/getting-started/deployment).

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default | Description                                                                                                                         |
| ---------------------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`)                                                             |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng                                                                                              |
| `--envName`                        |         | Môi trường để sử dụng khi giải quyết ghi đè cấu hình (mặc định là `production` khi xây dựng, và `development` khi chạy máy chủ dev) |
| `--dotenv`                         |         | Đường dẫn đến tệp `.env` để tải, tương đối với thư mục gốc                                                                          |
| `-p, --port`                       |         | Port để lắng nghe (mặc định: `NUXT_PORT || NITRO_PORT || PORT`)                                                                     |

Lệnh này đặt `process.env.NODE_ENV` thành `production`. Để ghi đè, định nghĩa `NODE_ENV` trong tệp `.env` hoặc như đối số dòng lệnh.

::note
Để thuận tiện, trong chế độ preview, tệp [`.env`](https://nuxt.com/docs/guide/directory-structure/env) của bạn sẽ được tải vào `process.env`. (Tuy nhiên, trong sản xuất bạn sẽ cần đảm bảo các biến môi trường được đặt bởi chính bạn. Ví dụ, với Node.js 20+ bạn có thể làm điều này bằng cách chạy `node --env-file .env .output/server/index.mjs` để khởi động máy chủ của bạn.)
::


# nuxt typecheck

```bash [Terminal]
npx nuxt typecheck [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>]
```

Lệnh `typecheck` chạy [`vue-tsc`](https://github.com/vuejs/language-tools/tree/master/packages/tsc){rel="nofollow"} để kiểm tra các loại trong toàn bộ ứng dụng của bạn.

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default | Description                                                             |
| ---------------------------------- | ------- | ----------------------------------------------------------------------- |
| `--cwd=<directory>`                |         | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`) |
| `--logLevel=<silent|info|verbose>` |         | Chỉ định cấp độ log thời gian xây dựng                                  |

::note
Lệnh này đặt `process.env.NODE_ENV` thành `production`. Để ghi đè, định nghĩa `NODE_ENV` trong tệp [`.env`](https://nuxt.com/docs/guide/directory-structure/env) hoặc như đối số dòng lệnh.
::

::read-more{to="https://nuxt.com/docs/guide/concepts/typescript#type-checking"}
Đọc thêm về cách bật kiểm tra loại tại thời gian xây dựng hoặc phát triển.
::


# nuxt upgrade

```bash [Terminal]
npx nuxt upgrade [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dedupe] [-f, --force] [-ch, --channel=<stable|nightly>]
```

Lệnh `upgrade` nâng cấp Nuxt lên phiên bản mới nhất.

## Arguments

| Argument      | Description                               |
| ------------- | ----------------------------------------- |
| `ROOTDIR="."` | Chỉ định thư mục làm việc (mặc định: `.`) |

## Options

| Option                             | Default  | Description                                                             |
| ---------------------------------- | -------- | ----------------------------------------------------------------------- |
| `--cwd=<directory>`                |          | Chỉ định thư mục làm việc, điều này ưu tiên hơn ROOTDIR (mặc định: `.`) |
| `--logLevel=<silent|info|verbose>` |          | Chỉ định cấp độ log thời gian xây dựng                                  |
| `--dedupe`                         |          | Sẽ loại bỏ trùng lặp dependencies nhưng không tạo lại lockfile          |
| `-f, --force`                      |          | Buộc nâng cấp để tạo lại lockfile và node\_modules                      |
| `-ch, --channel=<stable|nightly>`  | `stable` | Chỉ định kênh để cài đặt từ (mặc định: stable)                          |


# Modules

Các module là khối xây dựng của Nuxt. Kit cung cấp một bộ tiện ích để giúp bạn tạo và sử dụng module. Bạn có thể sử dụng các tiện ích này để tạo module của riêng mình hoặc tái sử dụng các module hiện có. Ví dụ, bạn có thể sử dụng hàm `defineNuxtModule` để định nghĩa một module và hàm `installModule` để cài đặt một module theo chương trình.

## `defineNuxtModule`

Định nghĩa một module Nuxt, tự động hợp nhất các giá trị mặc định với các tùy chọn do người dùng cung cấp, cài đặt bất kỳ hook nào được cung cấp, và gọi một hàm setup tùy chọn để kiểm soát đầy đủ.

### Usage

```ts twoslash
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule'
  },
  defaults: {
    enabled: true
  },
  setup (options) {
    if (options.enabled) {
      console.log('My Nuxt module is enabled!')
    }
  }
})
```

### Type

```ts twoslash
// @errors: 2391
import type { ModuleDefinition, ModuleOptions, NuxtModule } from '@nuxt/schema'
// ---cut---
export function defineNuxtModule<TOptions extends ModuleOptions> (
  definition?: ModuleDefinition<TOptions, Partial<TOptions>, false> | NuxtModule<TOptions, Partial<TOptions>, false>,
): NuxtModule<TOptions, TOptions, false>

export function defineNuxtModule<TOptions extends ModuleOptions> (): {
  with: <TOptionsDefaults extends Partial<TOptions>> (
    definition: ModuleDefinition<TOptions, TOptionsDefaults, true> | NuxtModule<TOptions, TOptionsDefaults, true>
  ) => NuxtModule<TOptions, TOptionsDefaults, true>
}
```

### Parameters

**definition**: Một đối tượng định nghĩa module hoặc một hàm module. Đối tượng định nghĩa module nên chứa các thuộc tính sau:

| Property   | Type                                                                                                                                                                                                                   | Required | Description                                                                                                    |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------- |
| `meta`     | `ModuleMeta`                                                                                                                                                                                                           | `false`  | Metadata của module. Nó định nghĩa tên module, phiên bản, khóa cấu hình và khả năng tương thích.               |
| `defaults` | `T | ((nuxt: Nuxt) => T)`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                                            | `false`  | Tùy chọn mặc định cho module. Nếu một hàm được cung cấp, nó sẽ được gọi với instance Nuxt làm đối số đầu tiên. |
| `schema`   | `T`                                                                                                                                                                                                                    | `false`  | Schema cho các tùy chọn module. Nếu được cung cấp, các tùy chọn sẽ được áp dụng cho schema.                    |
| `hooks`    | `Partial<NuxtHooks>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                                                 | `false`  | Các hook để được cài đặt cho module. Nếu được cung cấp, module sẽ cài đặt các hook.                            |
| `setup`    | `(this: void, resolvedOptions: T, nuxt: Nuxt) => Awaitable<void | false | ModuleSetupInstallResult>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Hàm setup cho module. Nếu được cung cấp, module sẽ gọi hàm setup.                                              |

### Examples

#### Using `configKey` to Make Your Module Configurable

Khi định nghĩa một module Nuxt, bạn có thể đặt `configKey` để chỉ định cách người dùng nên cấu hình module trong `nuxt.config` của họ.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule'
  },
  defaults: {
    // Module options
    enabled: true
  },
  setup (options) {
    if (options.enabled) {
      console.log('My Nuxt module is enabled!')
    }
  }
})
```

Người dùng có thể cung cấp tùy chọn cho module này dưới khóa tương ứng trong `nuxt.config`.

```ts
export default defineNuxtConfig({
  myModule: {
    enabled: false
  }
})
```

#### Defining Module Compatibility Requirements

Nếu bạn đang phát triển một module Nuxt và sử dụng các API chỉ được hỗ trợ trong các phiên bản Nuxt cụ thể, bạn nên bao gồm `compatibility.nuxt`.

```ts
export default defineNuxtModule({
  meta: {
    name: '@nuxt/icon',
    configKey: 'icon',
    compatibility: {
      // Required nuxt version in semver format.
      nuxt: '>=3.0.0', // or use '^3.0.0'
    },
  },
  async setup() {
    const resolver = createResolver(import.meta.url)
    // Implement
  },
})
```

Nếu người dùng cố gắng sử dụng module của bạn với phiên bản Nuxt không tương thích, họ sẽ nhận được cảnh báo trong console.

```terminal
 WARN  Module @nuxt/icon is disabled due to incompatibility issues:
 - [nuxt] Nuxt version ^3.1.0 is required but currently using 3.0.0
```

#### Type Safety for Resolved Options with `.with()`

Khi bạn cần an toàn kiểu cho các tùy chọn module đã giải quyết/hợp nhất của mình, bạn có thể sử dụng phương thức `.with()`. Điều này cho phép TypeScript suy luận đúng mối quan hệ giữa các giá trị mặc định của module và các tùy chọn cuối cùng mà hàm setup của bạn nhận được.

```ts
import { defineNuxtModule } from '@nuxt/kit'

// Define your module options interface
interface ModuleOptions {
  apiKey: string
  baseURL: string
  timeout?: number
  retries?: number
}

export default defineNuxtModule<ModuleOptions>().with({
  meta: {
    name: '@nuxtjs/my-api',
    configKey: 'myApi'
  },
  defaults: {
    baseURL: 'https://api.example.com',
    timeout: 5000,
    retries: 3
  },
  setup(resolvedOptions, nuxt) {
    // resolvedOptions is properly typed as:
    // {
    //   apiKey: string          // Required, no default provided
    //   baseURL: string         // Required, has default value
    //   timeout: number         // Optional, has default value
    //   retries: number         // Optional, has default value  
    // }
    
    console.log(resolvedOptions.baseURL) // ✅ TypeScript knows this is always defined
    console.log(resolvedOptions.timeout) // ✅ TypeScript knows this is always defined
    console.log(resolvedOptions.retries) // ✅ TypeScript knows this is always defined
  }
})
```

Nếu không sử dụng `.with()`, tham số `resolvedOptions` sẽ được gõ như giao diện `ModuleOptions` thô, nơi `timeout` và `retries` có thể là `undefined` ngay cả khi các giá trị mặc định được cung cấp. Phương thức `.with()` cho phép TypeScript hiểu rằng các giá trị mặc định làm cho những thuộc tính đó không tùy chọn trong các tùy chọn đã giải quyết.

## `installModule`

Cài đặt module Nuxt được chỉ định theo chương trình. Điều này hữu ích khi module của bạn phụ thuộc vào các module khác. Bạn có thể truyền các tùy chọn module dưới dạng đối tượng cho `inlineOptions` và chúng sẽ được truyền cho hàm `setup` của module.

### Usage

```ts twoslash
import { defineNuxtModule, installModule } from '@nuxt/kit'

export default defineNuxtModule({  
  async setup () {
    // sẽ cài đặt @nuxtjs/fontaine với font Roboto và fallback Impact
    await installModule('@nuxtjs/fontaine', {
      // module configuration
      fonts: [
        {
          family: 'Roboto',
          fallbacks: ['Impact'],
          fallbackName: 'fallback-a',
        }
      ]
    })
  }
})
```

### Type

```ts
async function installModule (moduleToInstall: string | NuxtModule, inlineOptions?: any, nuxt?: Nuxt)
```

### Parameters

| Property          | Type                                                                                                                                    | Required | Description                                                                                 |
| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------- |
| `moduleToInstall` | `string | NuxtModule`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | Module để cài đặt. Có thể là một chuỗi với tên module hoặc chính đối tượng module.          |
| `inlineOptions`   | `any`                                                                                                                                   | `false`  | Một đối tượng với các tùy chọn module để được truyền cho hàm `setup` của module.            |
| `nuxt`            | `Nuxt`                                                                                                                                  | `false`  | Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`. |

### Examples

```ts
import { defineNuxtModule, installModule } from '@nuxt/kit'

export default defineNuxtModule({  
  async setup (options, nuxt) {
    // will install @nuxtjs/fontaine with Roboto font and Impact fallback
    await installModule('@nuxtjs/fontaine', {
      // module configuration
      fonts: [
        {
          family: 'Roboto',
          fallbacks: ['Impact'],
          fallbackName: 'fallback-a',
        }
      ]
    })
  }
})
```


# Runtime Config

## `useRuntimeConfig`

Tại thời điểm build, có thể truy cập cấu hình runtime Nuxt đã giải quyết.

### Type

```ts
function useRuntimeConfig (): Record<string, unknown>
```

## `updateRuntimeConfig`

Cũng có thể cập nhật cấu hình runtime. Điều này sẽ được hợp nhất với cấu hình runtime hiện có, và nếu Nitro đã được khởi tạo, nó sẽ kích hoạt sự kiện HMR để tải lại cấu hình runtime Nitro.

### Type

```ts
function updateRuntimeConfig (config: Record<string, unknown>): void | Promise<void>
```


# Templates

Templates cho phép bạn tạo các tệp bổ sung trong quá trình phát triển và build. Các tệp này sẽ có sẵn trong virtual filesystem và có thể được sử dụng trong plugins, layouts, components, v.v. `addTemplate` và `addTypeTemplate` cho phép bạn thêm templates vào ứng dụng Nuxt. `updateTemplates` cho phép bạn tái tạo templates khớp với bộ lọc.

## `addTemplate`

Render template được cung cấp trong quá trình build vào virtual file system, và tùy chọn vào disk trong `buildDir` của dự án

### Usage

```ts twoslash
import { addTemplate, defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup(options, nuxt) {
    const globalMeta = defu(nuxt.options.app.head, {
      charset: options.charset,
      viewport: options.viewport
    })

    addTemplate({
      filename: 'meta.config.mjs',
      getContents: () => 'export default ' + JSON.stringify({ globalMeta, mixinKey: 'setup' })
    })
  }
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NuxtTemplate, ResolvedNuxtTemplate } from '@nuxt/schema'
// ---cut---
function addTemplate (template: NuxtTemplate | string): ResolvedNuxtTemplate
```

### Parameters

**template**: Một đối tượng template hoặc một chuỗi với đường dẫn đến template. Nếu một chuỗi được cung cấp, nó sẽ được chuyển đổi thành đối tượng template với `src` được đặt thành giá trị chuỗi. Nếu một đối tượng template được cung cấp, nó phải có các thuộc tính sau:

| Property      | Type                                                                                                                                                            | Required | Description                                                                                                                                                      |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                                                                                                                                        | `false`  | Đường dẫn đến template. Nếu `src` không được cung cấp, `getContents` phải được cung cấp thay thế.                                                                |
| `filename`    | `string`                                                                                                                                                        | `false`  | Tên tệp của template. Nếu `filename` không được cung cấp, nó sẽ được tạo từ đường dẫn `src`. Trong trường hợp này, tùy chọn `src` là bắt buộc.                   |
| `dst`         | `string`                                                                                                                                                        | `false`  | Đường dẫn đến tệp đích. Nếu `dst` không được cung cấp, nó sẽ được tạo từ đường dẫn `filename` và tùy chọn `buildDir` của nuxt.                                   |
| `options`     | `Options`                                                                                                                                                       | `false`  | Tùy chọn để truyền cho template.                                                                                                                                 |
| `getContents` | `(data: Options) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Một hàm sẽ được gọi với đối tượng `options`. Nó nên trả về một chuỗi hoặc một promise giải quyết thành một chuỗi. Nếu `src` được cung cấp, hàm này sẽ bị bỏ qua. |
| `write`       | `boolean`                                                                                                                                                       | `false`  | Nếu đặt thành `true`, template sẽ được ghi vào tệp đích. Nếu không, template sẽ chỉ được sử dụng trong virtual filesystem.                                       |

### Examples

#### Tạo tệp ảo cho Runtime Plugin

Trong ví dụ này, chúng ta hợp nhất một đối tượng bên trong module và tiêu thụ kết quả trong runtime plugin.

```ts [module.ts] twoslash
import { addTemplate, defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    const globalMeta = defu(nuxt.options.app.head, {
      charset: options.charset,
      viewport: options.viewport,
    })

    addTemplate({
      filename: 'meta.config.mjs',
      getContents: () => 'export default ' + JSON.stringify({ globalMeta, mixinKey: 'setup' }),
    })
  },
})
```

Trong module ở trên, chúng ta tạo một tệp ảo có tên `meta.config.mjs`. Trong runtime plugin, chúng ta có thể nhập nó bằng alias `#build`:

```ts [runtime/plugin.ts]
import { createHead as createServerHead } from '@unhead/vue/server'
import { createHead as createClientHead } from '@unhead/vue/client'
import { defineNuxtPlugin } from '#imports'
// @ts-ignore
import metaConfig from '#build/meta.config.mjs'

export default defineNuxtPlugin((nuxtApp) => {
  const createHead = import.meta.server ? createServerHead : createClientHead
  const head = createHead()
  head.push(metaConfig.globalMeta)

  nuxtApp.vueApp.use(head)
})
```

## `addTypeTemplate`

Render template được cung cấp trong quá trình build vào buildDir của dự án, sau đó đăng ký nó làm types.

### Usage

```ts twoslash
import { addTypeTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addTypeTemplate({
      filename: 'types/markdown.d.ts',
      getContents: () => `declare module '*.md' {
  import type { ComponentOptions } from 'vue'
  const Component: ComponentOptions
  export default Component
}`,
    })
  },
})
```

### Type

```ts
function addTypeTemplate (template: NuxtTypeTemplate | string, context?: { nitro?: boolean, nuxt?: boolean }): ResolvedNuxtTemplate
```

### Parameters

**template**: Một đối tượng template hoặc một chuỗi với đường dẫn đến template. Nếu một chuỗi được cung cấp, nó sẽ được chuyển đổi thành đối tượng template với `src` được đặt thành giá trị chuỗi. Nếu một đối tượng template được cung cấp, nó phải có các thuộc tính sau:

| Property      | Type                                                                                                                                                            | Required | Description                                                                                                                                                      |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                                                                                                                                        | `false`  | Đường dẫn đến template. Nếu `src` không được cung cấp, `getContents` phải được cung cấp thay thế.                                                                |
| `filename`    | `string`                                                                                                                                                        | `false`  | Tên tệp của template. Nếu `filename` không được cung cấp, nó sẽ được tạo từ đường dẫn `src`. Trong trường hợp này, tùy chọn `src` là bắt buộc.                   |
| `dst`         | `string`                                                                                                                                                        | `false`  | Đường dẫn đến tệp đích. Nếu `dst` không được cung cấp, nó sẽ được tạo từ đường dẫn `filename` và tùy chọn `buildDir` của nuxt.                                   |
| `options`     | `Options`                                                                                                                                                       | `false`  | Tùy chọn để truyền cho template.                                                                                                                                 |
| `getContents` | `(data: Options) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Một hàm sẽ được gọi với đối tượng `options`. Nó nên trả về một chuỗi hoặc một promise giải quyết thành một chuỗi. Nếu `src` được cung cấp, hàm này sẽ bị bỏ qua. |

**context**: Một đối tượng context tùy chọn có thể được truyền để kiểm soát nơi type được thêm. Nếu bị bỏ qua, type sẽ chỉ được thêm vào context Nuxt. Đối tượng này hỗ trợ các thuộc tính sau:

| Property | Type      | Required | Description                                                |
| -------- | --------- | -------- | ---------------------------------------------------------- |
| `nuxt`   | `boolean` | `false`  | Nếu đặt thành `true`, type sẽ được thêm vào context Nuxt.  |
| `nitro`  | `boolean` | `false`  | Nếu đặt thành `true`, type sẽ được thêm vào context Nitro. |

### Examples

#### Thêm Type Templates vào Nitro Context

Theo mặc định, chỉ thêm khai báo type vào context Nuxt. Để cũng thêm chúng vào context Nitro, đặt nitro thành true.

```ts twoslash
import { addTypeTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addTypeTemplate({
      filename: 'types/auth.d.ts',
      getContents: () => `declare module '#auth-utils' {
  interface User {
    id: string;
    name: string;
  }

}`,
    }, {
      nitro: true,
    })
  },
})
```

Điều này cho phép module `#auth-utils` được sử dụng trong context Nitro.

```ts [server/api/auth.ts]
import type { User } from '#auth-utils'

export default eventHandler(() => {
  const user: User = {
    id: '123',
    name: 'John Doe',
  }

  // do something with the user

  return user
})
```

## `addServerTemplate`

Thêm một tệp ảo có thể được sử dụng trong build server Nuxt Nitro.

### Usage

```ts twoslash
import { addServerTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addServerTemplate({
      filename: '#my-module/test.mjs',
      getContents () {
        return 'export const test = 123'
      },
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NuxtServerTemplate } from '@nuxt/schema'
// ---cut---
function addServerTemplate (template: NuxtServerTemplate): NuxtServerTemplate
```

### Parameters

**template**: Một đối tượng template. Nó phải có các thuộc tính sau:

| Property      | Type                                                                                                                                               | Required | Description                                                                                                       |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------- |
| `filename`    | `string`                                                                                                                                           | `true`   | Tên tệp của template.                                                                                             |
| `getContents` | `() => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | Một hàm sẽ được gọi với đối tượng `options`. Nó nên trả về một chuỗi hoặc một promise giải quyết thành một chuỗi. |

### Examples

### Tạo tệp ảo cho Nitro

Trong ví dụ này, chúng ta tạo một tệp ảo có thể được sử dụng trong build server Nuxt Nitro.

```ts twoslash
import { addServerTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addServerTemplate({
      filename: '#my-module/test.mjs',
      getContents () {
        return 'export const test = 123'
      },
    })
  },
})
```

And then in a runtime file

```ts [server/api/test.ts]
import { test } from '#my-module/test.js'

export default eventHandler(() => {
  return test
})
```

## `updateTemplates`

Tái tạo templates khớp với bộ lọc. Nếu không có bộ lọc được cung cấp, tất cả templates sẽ được tái tạo.

### Usage

```ts
import { defineNuxtModule, updateTemplates } from '@nuxt/kit'
import { resolve } from 'pathe'

export default defineNuxtModule({
  setup (options, nuxt) {
    const updateTemplatePaths = [
      resolve(nuxt.options.srcDir, 'pages'),
    ]
    // watch and rebuild routes template list when one of the pages changes
    nuxt.hook('builder:watch', async (event, relativePath) => {
      if (event === 'change') { return }

      const path = resolve(nuxt.options.srcDir, relativePath)
      if (updateTemplatePaths.some(dir => path.startsWith(dir))) {
        await updateTemplates({
          filter: template => template.filename === 'routes.mjs',
        })
      }
    })
  },
})
```

### Type

```ts
async function updateTemplates (options: UpdateTemplatesOptions): void
```

### Parameters

**options**: Tùy chọn để truyền cho template. Đối tượng này có thể có thuộc tính sau:

| Property | Type                                                                                                                                                            | Required | Description                                                                                                                                                                                                  |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `filter` | `(template: ResolvedNuxtTemplate) => boolean`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | A function that will be called with the `template` object. It should return a boolean indicating whether the template should be regenerated. If `filter` is not provided, all templates will be regenerated. |


# Nitro

Nitro là một framework TypeScript mã nguồn mở để xây dựng web servers siêu nhanh. Nuxt sử dụng Nitro làm engine server. Bạn có thể sử dụng `useNitro` để truy cập instance Nitro, `addServerHandler` để thêm server handler, `addDevServerHandler` để thêm server handler chỉ được sử dụng ở chế độ phát triển, `addServerPlugin` để thêm plugin mở rộng hành vi runtime của Nitro, và `addPrerenderRoutes` để thêm routes được prerender bởi Nitro.

## `addServerHandler`

Thêm Nitro server handler. Sử dụng cái này nếu bạn muốn tạo server middleware hoặc custom route.

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, addServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options) {
    const { resolve } = createResolver(import.meta.url)

    addServerHandler({
      route: '/robots.txt',
      handler: resolve('./runtime/robots.get')
    })
  }
})
```

### Type

```ts
function addServerHandler (handler: NitroEventHandler): void
```

### Parameters

**handler**: Một đối tượng handler với các thuộc tính sau:

| Property     | Type      | Required | Description                                                                                                                                |
| ------------ | --------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `handler`    | `string`  | `true`   | Đường dẫn đến event handler.                                                                                                               |
| `route`      | `string`  | `false`  | Tiền tố đường dẫn hoặc route. Nếu chuỗi rỗng được sử dụng, sẽ được sử dụng làm middleware.                                                 |
| `middleware` | `boolean` | `false`  | Chỉ định đây là middleware handler. Middleware được gọi trên mọi route và thường nên không trả về gì để truyền đến các handlers tiếp theo. |
| `lazy`       | `boolean` | `false`  | Sử dụng lazy loading để nhập handler. Điều này hữu ích khi bạn chỉ muốn tải handler theo yêu cầu.                                          |
| `method`     | `string`  | `false`  | Bộ khớp phương thức router. Nếu tên handler chứa tên phương thức, nó sẽ được sử dụng làm giá trị mặc định.                                 |

### Examples

#### Cách sử dụng cơ bản

Bạn có thể sử dụng `addServerHandler` để thêm server handler từ module của bạn.

::code-group
```ts [module.ts] twoslash
import { createResolver, defineNuxtModule, addServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options) {
    const { resolve } = createResolver(import.meta.url)

    addServerHandler({
      route: '/robots.txt',
      handler: resolve('./runtime/robots.get')
    })
  }
})
```

```ts [runtime/robots.get.ts] twoslash
export default defineEventHandler(() => {
  return {
    body: `User-agent: *\nDisallow: /`
  }
})
```
::

Khi bạn truy cập `/robots.txt`, nó sẽ trả về response sau:

```txt
User-agent: *
Disallow: /
```

## `addDevServerHandler`

Thêm Nitro server handler chỉ được sử dụng ở chế độ phát triển. Handler này sẽ được loại trừ khỏi production build.

### Usage

```ts twoslash
import { defineEventHandler } from 'h3'
import { createResolver, defineNuxtModule, addDevServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    addDevServerHandler({
      handler: defineEventHandler(() => {
        return {
          body: `Response generated at ${new Date().toISOString()}`
        }
      }),
      route: '/_handler'
    })
  }
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NitroDevEventHandler } from 'nitropack/types'
// ---cut---
function addDevServerHandler (handler: NitroDevEventHandler): void
```

### Parameters

**handler**: Một đối tượng handler với các thuộc tính sau:

| Property  | Type           | Required | Description                                                                                |
| --------- | -------------- | -------- | ------------------------------------------------------------------------------------------ |
| `handler` | `EventHandler` | `true`   | Event handler.                                                                             |
| `route`   | `string`       | `false`  | Tiền tố đường dẫn hoặc route. Nếu chuỗi rỗng được sử dụng, sẽ được sử dụng làm middleware. |

### Examples

#### Cách sử dụng cơ bản

Trong một số trường hợp, bạn có thể muốn tạo server handler cụ thể cho mục đích phát triển, chẳng hạn như Tailwind config viewer.

```ts
import { joinURL } from 'ufo'
import { defineNuxtModule, addDevServerHandler } from '@nuxt/kit'

export default defineNuxtModule({
  async setup(options, nuxt) {
    const route = joinURL(nuxt.options.app?.baseURL, '/_tailwind')

    // @ts-ignore
    const createServer = await import('tailwind-config-viewer/server/index.js').then(r => r.default || r) as any
    const viewerDevMiddleware = createServer({ tailwindConfigProvider: () => options, routerPrefix: route }).asMiddleware()

    addDevServerHandler({ route, handler: viewerDevMiddleware })
  }
})
```

## `useNitro`

Trả về instance Nitro.

::warning
Bạn chỉ có thể gọi `useNitro()` sau hook `ready`.
::

::note
Các thay đổi đối với cấu hình instance Nitro không được áp dụng.
::

### Usage

```ts
import { defineNuxtModule, useNitro } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('ready', () => {
      const nitro = useNitro()
      // Do something with Nitro instance
    })
  }
})
```

### Type

```ts
function useNitro (): Nitro
```

## `addServerPlugin`

Thêm plugin để mở rộng hành vi runtime của Nitro.

::tip
Bạn có thể đọc thêm về Nitro plugins trong [tài liệu Nitro](https://nitro.build/guide/plugins){rel="nofollow"}.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, addServerPlugin } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const { resolve } = createResolver(import.meta.url)
    addServerPlugin(resolve('./runtime/plugin.ts'))
  }
})
```

### Type

```ts
function addServerPlugin (plugin: string): void
```

### Parameters

| Property | Type     | Required | Description                                                                                    |
| -------- | -------- | -------- | ---------------------------------------------------------------------------------------------- |
| `plugin` | `string` | `true`   | Đường dẫn đến plugin. Plugin phải export một hàm mặc định chấp nhận instance Nitro làm đối số. |

### Examples

::code-group
```ts [module.ts]
import { createResolver, defineNuxtModule, addServerPlugin } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    const { resolve } = createResolver(import.meta.url)
    addServerPlugin(resolve('./runtime/plugin.ts'))
  }
})
```

```ts [runtime/plugin.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook("request", (event) => {
    console.log("on request", event.path);
  });

  nitroApp.hooks.hook("beforeResponse", (event, { body }) => {
    console.log("on response", event.path, { body });
  });

  nitroApp.hooks.hook("afterResponse", (event, { body }) => {
    console.log("on after response", event.path, { body });
  });
});
```
::

## `addPrerenderRoutes`

Thêm routes để được prerender vào Nitro.

### Usage

```ts
import { defineNuxtModule, addPrerenderRoutes } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-sitemap',
    configKey: 'sitemap',
  },
  defaults: {
    sitemapUrl: '/sitemap.xml',
    prerender: true,
  },
  setup(options) {
    if (options.prerender) {
      addPrerenderRoutes(options.sitemapUrl)
    }
  }
})
```

### Type

```ts
function addPrerenderRoutes (routes: string | string[]): void
```

### Parameters

| Property | Type                                                                                                                                  | Required | Description                                  |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------- |
| `routes` | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | Một route hoặc một mảng routes để prerender. |

## `addServerImports`

Thêm imports vào server. Nó làm cho imports của bạn có sẵn trong Nitro mà không cần nhập chúng thủ công.

### Usage

```ts twoslash
import { defineNuxtModule, createResolver, addServerImports } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options) {
    const names = [
      'useStoryblok',
      'useStoryblokApi',
      'useStoryblokBridge',
      'renderRichText',
      'RichTextSchema'
    ]

    names.forEach((name) =>
      addServerImports({ name, as: name, from: '@storyblok/vue' })
    )
  }
})
```

### Type

```ts
function addServerImports (dirs: Import | Import[]): void
```

### Parameters

`imports`: Một đối tượng hoặc một mảng các đối tượng với các thuộc tính sau:

| Property   | Type                  | Required | Description                                                                                 |
| ---------- | --------------------- | -------- | ------------------------------------------------------------------------------------------- |
| `name`     | `string`              | `true`   | Tên import để được phát hiện.                                                               |
| `from`     | `string`              | `true`   | Bộ chỉ định module để nhập từ.                                                              |
| `priority` | `number`              | `false`  | Ưu tiên của import; nếu nhiều imports có cùng tên, cái có ưu tiên cao nhất sẽ được sử dụng. |
| `disabled` | `boolean`             | `false`  | Nếu import này bị vô hiệu hóa.                                                              |
| `meta`     | `Record<string, any>` | `false`  | Metadata của import.                                                                        |
| `type`     | `boolean`             | `false`  | Nếu import này là một import kiểu thuần túy.                                                |
| `typeFrom` | `string`              | `false`  | Sử dụng cái này làm giá trị `from` khi tạo khai báo kiểu.                                   |
| `as`       | `string`              | `false`  | Nhập dưới tên này.                                                                          |

## `addServerImportsDir`

Thêm thư mục để được quét cho auto-imports bởi Nitro.

### Usage

```ts twoslash
import { defineNuxtModule, createResolver, addServerImportsDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerImportsDir(resolve('./runtime/server/composables'))
  }
})
```

### Type

```ts
function addServerImportsDir (dirs: string | string[], opts: { prepend?: boolean }): void
```

### Parameters

| Property | Type                                                                                                                                  | Required | Description                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------- |
| `dirs`   | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | Một thư mục hoặc một mảng thư mục để đăng ký để được quét bởi Nitro.                            |
| `opts`   | `{ prepend?: boolean }`                                                                                                               | `false`  | Tùy chọn cho thư mục import. Nếu `prepend` là `true`, thư mục được thêm vào đầu danh sách quét. |

### Examples

Bạn có thể sử dụng `addServerImportsDir` để thêm thư mục để được quét bởi Nitro. Điều này hữu ích khi bạn muốn Nitro auto-import functions từ custom server directory.

::code-group
```ts [module.ts] twoslash
import { defineNuxtModule, createResolver, addServerImportsDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerImportsDir(resolve('./runtime/server/composables'))
  }
})
```

```ts [runtime/server/composables/index.ts] twoslash
export function useApiSecret() {
  const { apiSecret } = useRuntimeConfig()
  return apiSecret
}
```
::

Sau đó, bạn có thể sử dụng hàm `useApiSecret` trong server code của mình:

```ts [runtime/server/api/hello.ts] twoslash
const useApiSecret = (): string => ''
// ---cut---
export default defineEventHandler(() => {
  const apiSecret = useApiSecret()
  // Do something with the apiSecret
})
```

## `addServerScanDir`

Thêm thư mục để được quét bởi Nitro. Nó sẽ kiểm tra subdirectories, sẽ được đăng ký
giống như thư mục `~/server`.

::note
Chỉ `~/server/api`, `~/server/routes`, `~/server/middleware`, và `~/server/utils` được quét.
::

### Usage

```ts twoslash
import { defineNuxtModule, createResolver, addServerScanDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerScanDir(resolve('./runtime/server'))
  }
})
```

### Type

```ts
function addServerScanDir (dirs: string | string[], opts: { prepend?: boolean }): void
```

### Parameters

| Property | Type                                                                                                                                  | Required | Description                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------- |
| `dirs`   | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | Một thư mục hoặc một mảng thư mục để đăng ký để được quét bởi Nitro làm server dirs.            |
| `opts`   | `{ prepend?: boolean }`                                                                                                               | `false`  | Tùy chọn cho thư mục import. Nếu `prepend` là `true`, thư mục được thêm vào đầu danh sách quét. |

### Examples

Bạn có thể sử dụng `addServerScanDir` để thêm thư mục để được quét bởi Nitro. Điều này hữu ích khi bạn muốn thêm custom server directory.

::code-group
```ts [module.ts] twoslash
import { defineNuxtModule, createResolver, addServerScanDir } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup(options) {
    const { resolve } = createResolver(import.meta.url)
    addServerScanDir(resolve('./runtime/server'))
  }
})
```

```ts [runtime/server/utils/index.ts] twoslash
export function hello() {
  return 'Hello from server utils!'
}
```
::

Sau đó, bạn có thể sử dụng hàm `hello` trong server code của mình.

```ts [runtime/server/api/hello.ts] twoslash
function hello() {
  return 'Hello from server utils!'
}
// ---cut---
export default defineEventHandler(() => {
  return hello() // Hello from server utils!
})
```


# Resolving

Đôi khi bạn cần resolve paths: tương đối với module hiện tại, với tên hoặc extension không xác định. Ví dụ, bạn có thể muốn thêm plugin nằm trong cùng thư mục với module. Để xử lý các trường hợp này, nuxt cung cấp một bộ tiện ích để resolve paths. `resolvePath` và `resolveAlias` được sử dụng để resolve paths tương đối với module hiện tại. `findPath` được sử dụng để tìm tệp hiện có đầu tiên trong các paths đã cho. `createResolver` được sử dụng để tạo resolver tương đối với base path.

## `resolvePath`

Resolve đường dẫn đầy đủ đến tệp hoặc thư mục tôn trọng tùy chọn alias và extensions của Nuxt. Nếu path không thể được resolve, normalized input path sẽ được trả về.

### Usage

```ts
import { defineNuxtModule, resolvePath } from '@nuxt/kit'

export default defineNuxtModule({
  async setup () {
    const entrypoint = await resolvePath('@unhead/vue')
    console.log(`Unhead entrypoint is ${entrypoint}`)
  },
})
```

### Type

```ts
function resolvePath (path: string, options?: ResolvePathOptions): Promise<string>
```

### Parameters

**`path`**: A path to resolve.

**`options`**: Options to pass to the resolver. This object can have the following properties:

| Property             | Type                                                                                                                                       | Required | Description                                                                                    |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | -------- | ---------------------------------------------------------------------------------------------- |
| `cwd`                | `string`                                                                                                                                   | `false`  | Cơ sở để resolve paths từ. Mặc định là Nuxt rootDir.                                           |
| `alias`              | `Record<string, string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Một đối tượng aliases. Mặc định là Nuxt configured aliases.                                    |
| `extensions`         | `string[]`                                                                                                                                 | `false`  | Các phần mở rộng tệp để thử. Mặc định là Nuxt configured extensions.                           |
| `virtual`            | `boolean`                                                                                                                                  | `false`  | Có resolve files tồn tại trong Nuxt VFS hay không (ví dụ, như Nuxt template).                  |
| `fallbackToOriginal` | `boolean`                                                                                                                                  | `false`  | Có fallback đến path gốc nếu resolved path không tồn tại thay vì trả về normalized input path. |

### Examples

```ts
import { defineNuxtModule, resolvePath } from '@nuxt/kit'
import { join } from 'pathe'

const headlessComponents: ComponentGroup[] = [
  {
    relativePath: 'combobox/combobox.js',
    chunkName: 'headlessui/combobox',
    exports: [
      'Combobox',
      'ComboboxLabel',
      'ComboboxButton',
      'ComboboxInput',
      'ComboboxOptions',
      'ComboboxOption',
    ],
  },
]

export default defineNuxtModule({
  meta: {
    name: 'nuxt-headlessui',
    configKey: 'headlessui',
  },
  defaults: {
    prefix: 'Headless',
  },
  async setup (options) {
    const entrypoint = await resolvePath('@headlessui/vue')
    const root = join(entrypoint, '../components')

    for (const group of headlessComponents) {
      for (const e of group.exports) {
        addComponent(
          {
            name: e,
            export: e,
            filePath: join(root, group.relativePath),
            chunkName: group.chunkName,
            mode: 'all',
          },
        )
      }
    }
  },
})
```

## `resolveAlias`

Resolve path aliases tôn trọng tùy chọn alias của Nuxt.

### Type

```ts
function resolveAlias (path: string, alias?: Record<string, string>): string
```

### Parameters

**`path`**: A path to resolve.

**`alias`**: An object of aliases. If not provided, it will be read from `nuxt.options.alias`.

## `findPath`

Thử resolve tệp hiện có đầu tiên trong các paths đã cho.

### Usage

```ts
import { defineNuxtModule, findPath } from '@nuxt/kit'
import { join } from 'pathe'

export default defineNuxtModule({
  async setup (_, nuxt) {
    // Resolve main (app.vue)
    const mainComponent = await findPath([
      join(nuxt.options.srcDir, 'App'),
      join(nuxt.options.srcDir, 'app'),
    ])
  },
})
```

### Type

```ts
function findPath (paths: string | string[], options?: ResolvePathOptions, pathType: 'file' | 'dir'): Promise<string | null>
```

### Parameters

**`paths`**: A path or an array of paths to resolve.

**`options`**: Options to pass to the resolver. This object can have the following properties:

| Property             | Type                                                                                                                                       | Required | Description                                                                                    |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | -------- | ---------------------------------------------------------------------------------------------- |
| `cwd`                | `string`                                                                                                                                   | `false`  | Cơ sở để resolve paths từ. Mặc định là Nuxt rootDir.                                           |
| `alias`              | `Record<string, string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Một đối tượng aliases. Mặc định là Nuxt configured aliases.                                    |
| `extensions`         | `string[]`                                                                                                                                 | `false`  | Các phần mở rộng tệp để thử. Mặc định là Nuxt configured extensions.                           |
| `virtual`            | `boolean`                                                                                                                                  | `false`  | Có resolve files tồn tại trong Nuxt VFS hay không (ví dụ, như Nuxt template).                  |
| `fallbackToOriginal` | `boolean`                                                                                                                                  | `false`  | Có fallback đến path gốc nếu resolved path không tồn tại thay vì trả về normalized input path. |

## `createResolver`

Tạo resolver tương đối với base path.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/resolving-paths-and-injecting-assets-to-the-app?friend=nuxt
---
Watch Vue School video about createResolver.
::

### Usage

```ts
import { defineNuxtModule, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_, nuxt) {
    const { resolve, resolvePath } = createResolver(import.meta.url)
  },
})
```

### Type

```ts
function createResolver (basePath: string | URL): Resolver
```

### Parameters

**`basePath`**: A base path to resolve from. It can be a string or a URL.

### Return Value

Hàm `createResolver` trả về một đối tượng với các thuộc tính sau:

| Property      | Type                                                                                                                                                                                | Description                                                                                      |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| `resolve`     | `(path: string) => string`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                        | Một hàm resolve path tương đối với base path.                                                    |
| `resolvePath` | `(path: string, options?: ResolvePathOptions) => Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | Một hàm resolve path tương đối với base path và tôn trọng tùy chọn alias và extensions của Nuxt. |

### Examples

```ts
import { createResolver, defineNuxtModule, isNuxt2 } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('modules:done', () => {
      if (isNuxt2()) {
        addPlugin(resolver.resolve('./runtime/plugin.vue2'))
      } else {
        addPlugin(resolver.resolve('./runtime/plugin.vue3'))
      }
    })
  },
})
```


# Logging

Nuxt cung cấp một instance logger mà bạn có thể sử dụng để log messages với các tính năng bổ sung. `useLogger` cho phép bạn lấy một instance logger.

## `useLogger`

Trả về một instance logger. Nó sử dụng [consola](https://github.com/unjs/consola){rel="nofollow"} dưới hood.

### Usage

```ts twoslash
import { defineNuxtModule, useLogger } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const logger = useLogger('my-module')

    logger.info('Hello from my module!')
  },
})
```

### Type

```ts
function useLogger (tag?: string, options?: Partial<ConsolaOptions>): ConsolaInstance
```

### Parameters

**`tag`**: A tag to suffix all log messages with, displayed on the right near the timestamp.

**`options`**: Consola configuration options.

### Examples

```ts twoslash
import { defineNuxtModule, useLogger } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const logger = useLogger('my-module', { level: options.quiet ? 0 : 3 })

    logger.info('Hello from my module!')
  },
})
```


# Builder

Nuxt have builders based on [Vite](https://github.com/nuxt/nuxt/tree/main/packages/vite){rel="nofollow"} and [webpack](https://github.com/nuxt/nuxt/tree/main/packages/webpack){rel="nofollow"}. You can extend the config passed to each one using `extendViteConfig` and `extendWebpackConfig` functions. You can also add additional plugins via `addVitePlugin`, `addWebpackPlugin` and `addBuildPlugin`.

## `extendViteConfig`

Extends the Vite configuration. Callback function can be called multiple times, when applying to both client and server builds.

### Usage

```ts twoslash
import { defineNuxtModule, extendViteConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    extendViteConfig((config) => {
      config.optimizeDeps ||= {}
      config.optimizeDeps.include ||= []
      config.optimizeDeps.include.push('cross-fetch')
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { UserConfig as ViteConfig } from 'vite'
import type { ExtendViteConfigOptions } from '@nuxt/kit'
// ---cut---
function extendViteConfig (callback: ((config: ViteConfig) => void), options?: ExtendViteConfigOptions): void
```

::read-more
---
icon: i-simple-icons-vite
target: _blank
to: https://vite.dev/config
---
Checkout Vite website for more information about its configuration.
::

### Parameters

**`callback`**: A callback function that will be called with the Vite configuration object.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `extendWebpackConfig`

Extends the webpack configuration. Callback function can be called multiple times, when applying to both client and server builds.

### Usage

```ts twoslash
import { defineNuxtModule, extendWebpackConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    extendWebpackConfig((config) => {
      config.module!.rules!.push({
        test: /\.txt$/,
        use: 'raw-loader',
      })
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Configuration as WebpackConfig } from 'webpack'
import type { ExtendWebpackConfigOptions } from '@nuxt/kit'
// ---cut---
function extendWebpackConfig (callback: ((config: WebpackConfig) => void), options?: ExtendWebpackConfigOptions): void
```

::read-more
---
icon: i-simple-icons-webpack
target: _blank
to: https://webpack.js.org/configuration
---
Checkout webpack website for more information about its configuration.
::

### Parameters

**`callback`**: A callback function that will be called with the webpack configuration object.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addVitePlugin`

Append Vite plugin to the config.

### Usage

```ts twoslash
// @errors: 2307
// ---cut---
import { addVitePlugin, defineNuxtModule } from '@nuxt/kit'
import { svg4VuePlugin } from 'vite-plugin-svg4vue'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-svg-icons',
    configKey: 'nuxtSvgIcons',
  },
  defaults: {
    svg4vue: {
      assetsDirName: 'assets/icons',
    },
  },
  setup (options) {
    addVitePlugin(svg4VuePlugin(options.svg4vue))
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Plugin as VitePlugin } from 'vite'
import type { ExtendViteConfigOptions } from '@nuxt/kit'
// ---cut---
function addVitePlugin (pluginOrGetter: VitePlugin | VitePlugin[] | (() => VitePlugin | VitePlugin[]), options?: ExtendViteConfigOptions): void
```

::tip
See [Vite website](https://vite.dev/guide/api-plugin.html){rel="nofollow"} for more information about Vite plugins. You can also use [this repository](https://github.com/vitejs/awesome-vite#plugins){rel="nofollow"} to find a plugin that suits your needs.
::

### Parameters

**`pluginOrGetter`**: A Vite plugin instance or an array of Vite plugin instances. If a function is provided, it must return a Vite plugin instance or an array of Vite plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addWebpackPlugin`

Append webpack plugin to the config.

### Usage

```ts
import EslintWebpackPlugin from 'eslint-webpack-plugin'
import { addWebpackPlugin, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-eslint',
    configKey: 'eslint',
  },
  defaults: nuxt => ({
    include: [`${nuxt.options.srcDir}/**/*.{js,jsx,ts,tsx,vue}`],
    lintOnStart: true,
  }),
  setup (options, nuxt) {
    const webpackOptions = {
      ...options,
      context: nuxt.options.srcDir,
      files: options.include,
      lintDirtyModulesOnly: !options.lintOnStart,
    }
    addWebpackPlugin(new EslintWebpackPlugin(webpackOptions), { server: false })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { WebpackPluginInstance } from 'webpack'
import type { ExtendWebpackConfigOptions } from '@nuxt/kit'
// ---cut---
function addWebpackPlugin (pluginOrGetter: WebpackPluginInstance | WebpackPluginInstance[] | (() => WebpackPluginInstance | WebpackPluginInstance[]), options?: ExtendWebpackConfigOptions): void
```

::tip
See [webpack website](https://webpack.js.org/concepts/plugins){rel="nofollow"} for more information about webpack plugins. You can also use [this collection](https://webpack.js.org/awesome-webpack/#webpack-plugins){rel="nofollow"} to find a plugin that suits your needs.
::

### Parameters

**`pluginOrGetter`**: A webpack plugin instance or an array of webpack plugin instances. If a function is provided, it must return a webpack plugin instance or an array of webpack plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addBuildPlugin`

Builder-agnostic version of `addVitePlugin` and `addWebpackPlugin`. It will add the plugin to both Vite and webpack configurations if they are present.

### Type

```ts twoslash
// @errors: 2391
import type { ExtendConfigOptions } from '@nuxt/kit'
import type { Plugin as VitePlugin } from 'vite'
import type { WebpackPluginInstance } from 'webpack'
import type { RspackPluginInstance } from '@rspack/core'
interface AddBuildPluginFactory {
  vite?: () => VitePlugin | VitePlugin[]
  webpack?: () => WebpackPluginInstance | WebpackPluginInstance[]
  rspack?: () => RspackPluginInstance | RspackPluginInstance[]
}
// ---cut---
function addBuildPlugin (pluginFactory: AddBuildPluginFactory, options?: ExtendConfigOptions): void
```

### Parameters

**`pluginFactory`**: A factory function that returns an object with `vite` and/or `webpack` properties. These properties must be functions that return a Vite plugin instance or an array of Vite plugin instances and/or a webpack plugin instance or an array of webpack plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
| --------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------ |
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |


# Examples

## Truy cập Nuxt Vite Config

Nếu bạn đang xây dựng một integration cần truy cập config Vite hoặc webpack runtime mà Nuxt sử dụng, có thể extract nó bằng Kit utilities.

Một số ví dụ về projects đã làm điều này:

- [histoire](https://github.com/histoire-dev/histoire/blob/main/packages/histoire-plugin-nuxt/src/index.ts){rel="nofollow"}
- [nuxt-vitest](https://github.com/danielroe/nuxt-vitest/blob/main/packages/nuxt-vitest/src/config.ts){rel="nofollow"}
- [@storybook-vue/nuxt](https://github.com/storybook-vue/storybook-nuxt/blob/main/packages/storybook-nuxt/src/preset.ts){rel="nofollow"}

Đây là một ví dụ ngắn về cách bạn có thể truy cập Vite config từ một project; bạn có thể implement approach tương tự để lấy webpack configuration.

```js
import { loadNuxt, buildNuxt } from '@nuxt/kit'

// https://github.com/nuxt/nuxt/issues/14534
async function getViteConfig() {
  const nuxt = await loadNuxt({ cwd: process.cwd(), dev: false, overrides: { ssr: false } })
  return new Promise((resolve, reject) => {
    nuxt.hook('vite:extendConfig', (config, { isClient }) => {
      if (isClient) {
        resolve(config)
        throw new Error('_stop_')
      }
    })
    buildNuxt(nuxt).catch((err) => {
      if (!err.toString().includes('_stop_')) {
        reject(err)
      }
    })
  }).finally(() => nuxt.close())
}

const viteConfig = await getViteConfig()
console.log(viteConfig)
```


# Programmatic Usage

Việc sử dụng theo chương trình có thể hữu ích khi bạn muốn sử dụng Nuxt theo chương trình, ví dụ, khi xây dựng một [công cụ CLI](https://github.com/nuxt/cli){rel="nofollow"} hoặc [tiện ích kiểm tra](https://github.com/nuxt/nuxt/tree/main/packages/test-utils){rel="nofollow"}.

## `loadNuxt`

Tải Nuxt theo chương trình. Nó sẽ tải cấu hình Nuxt, khởi tạo và trả về promise với instance Nuxt.

### Type

```ts
function loadNuxt (loadOptions?: LoadNuxtOptions): Promise<Nuxt>
```

### Parameters

**`loadOptions`**: Điều kiện tải cho Nuxt. `loadNuxt` sử dụng [`c12`](https://github.com/unjs/c12){rel="nofollow"} dưới hood, vì vậy nó chấp nhận các tùy chọn giống như `c12.loadConfig` với một số tùy chọn bổ sung:

| Property | Type      | Required | Description                                                                                                                                                    |
| -------- | --------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dev`    | `boolean` | `false`  | Nếu đặt thành `true`, Nuxt sẽ được tải ở chế độ phát triển.                                                                                                    |
| `ready`  | `boolean` | `true`   | Nếu đặt thành `true`, Nuxt sẽ sẵn sàng sử dụng sau lệnh gọi `loadNuxt`. Nếu đặt thành `false`, bạn sẽ cần gọi `nuxt.ready()` để đảm bảo Nuxt sẵn sàng sử dụng. |

## `buildNuxt`

Xây dựng Nuxt theo chương trình. Nó sẽ gọi builder (hiện tại [@nuxt/vite-builder](https://github.com/nuxt/nuxt/tree/main/packages/vite){rel="nofollow"} hoặc [@nuxt/webpack-builder](https://github.com/nuxt/nuxt/tree/main/packages/webpack){rel="nofollow"}) để đóng gói ứng dụng.

### Type

```ts
function buildNuxt (nuxt: Nuxt): Promise<any>
```

### Parameters

**`nuxt`**: Instance Nuxt để xây dựng. Nó có thể được lấy từ context qua lệnh gọi `useNuxt()`.

## `loadNuxtConfig`

Tải cấu hình Nuxt. Nó sẽ trả về promise với đối tượng cấu hình.

### Type

```ts
function loadNuxtConfig (options: LoadNuxtConfigOptions): Promise<NuxtOptions>
```

### Parameters

**`options`**: Tùy chọn để truyền trong lệnh gọi `loadConfig` của [`c12`](https://github.com/unjs/c12#options){rel="nofollow"}.

## `writeTypes`

Tạo `tsconfig.json` và ghi nó vào buildDir của dự án.

### Type

```ts
function writeTypes (nuxt?: Nuxt): void
```

### Parameters

**`nuxt`**: Instance Nuxt để xây dựng. Nó có thể được lấy từ context qua lệnh gọi `useNuxt()`.


# Compatibility

Các tiện ích Nuxt Kit có thể được sử dụng trong Nuxt 3, Nuxt 2 với Bridge và thậm chí Nuxt 2 mà không có Bridge. Để đảm bảo module của bạn tương thích với tất cả các phiên bản, bạn có thể sử dụng các hàm `checkNuxtCompatibility`, `assertNuxtCompatibility` và `hasNuxtCompatibility`. Chúng sẽ kiểm tra xem phiên bản Nuxt hiện tại có đáp ứng các ràng buộc bạn cung cấp hay không. Ngoài ra, bạn có thể sử dụng các hàm `isNuxt2`, `isNuxt3` và `getNuxtVersion` để kiểm tra chi tiết hơn.

## `checkNuxtCompatibility`

Kiểm tra xem các ràng buộc có được đáp ứng cho phiên bản Nuxt hiện tại hay không. Nếu không, trả về một mảng các thông báo. Phiên bản Nuxt 2 cũng kiểm tra hỗ trợ `bridge`.

### Usage

```ts twoslash
import { defineNuxtModule, checkNuxtCompatibility } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_options, nuxt) {
    const issues = await checkNuxtCompatibility({ nuxt: '^2.16.0' }, nuxt)
    if (issues.length) {
      console.warn('Nuxt compatibility issues found:\n' + issues.toString())
    } else {
      // do something
    }
  }
})
```

### Type

```ts
function checkNuxtCompatibility(constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<NuxtCompatibilityIssues>;
```

### Parameters

**`constraints`**: Ràng buộc phiên bản và builder để kiểm tra. Nó chấp nhận các thuộc tính sau:

| Property | Type                                                                                                                                               | Required | Description                                                                                                                                                          |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `nuxt`   | `string`                                                                                                                                           | `false`  | Phiên bản Nuxt ở định dạng semver. Các phiên bản có thể được định nghĩa theo cách Node.js, ví dụ: `>=2.15.0 <3.0.0`.                                                 |
| `bridge` | `Record<string, string | false>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Chỉ định ràng buộc phiên bản hoặc vô hiệu hóa khả năng tương thích cho các builder Nuxt cụ thể như `vite`, `webpack`, hoặc `rspack`. Sử dụng `false` để vô hiệu hóa. |

**`nuxt`**: Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`.

## `assertNuxtCompatibility`

Khẳng định rằng các ràng buộc được đáp ứng cho phiên bản Nuxt hiện tại. Nếu không, ném lỗi với danh sách các vấn đề dưới dạng chuỗi.

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt, NuxtCompatibility } from '@nuxt/schema'
// ---cut---
function assertNuxtCompatibility(constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<true>;
```

### Parameters

**`constraints`**: Ràng buộc phiên bản và builder để kiểm tra. Tham khảo [bảng ràng buộc trong `checkNuxtCompatibility`](https://nuxt.com/#parameters) để biết chi tiết.

**`nuxt`**: Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`.

## `hasNuxtCompatibility`

Kiểm tra xem các ràng buộc có được đáp ứng cho phiên bản Nuxt hiện tại hay không. Trả về `true` nếu tất cả các ràng buộc được đáp ứng, nếu không trả về `false`. Phiên bản Nuxt 2 cũng kiểm tra hỗ trợ `bridge`.

### Usage

```ts twoslash
import { defineNuxtModule, hasNuxtCompatibility } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_options, nuxt) {
    const usingNewPostcss = await hasNuxtCompatibility({ nuxt: '^2.16.0' }, nuxt)
    if (usingNewPostcss) {
      // do something
    } else {
      // do something else
    }
  }
})
```

### Type

```ts
function hasNuxtCompatibility(constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<boolean>;
```

### Parameters

**`constraints`**: Ràng buộc phiên bản và builder để kiểm tra. Tham khảo [bảng ràng buộc trong `checkNuxtCompatibility`](https://nuxt.com/#parameters) để biết chi tiết.

**`nuxt`**: Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`.

## `isNuxtMajorVersion`

Kiểm tra xem instance Nuxt hiện tại có phải là phiên bản chính được chỉ định hay không

### Usage

```ts twoslash
import { defineNuxtModule, isNuxtMajorVersion } from '@nuxt/kit'

export default defineNuxtModule({
  async setup () {
    if (isNuxtMajorVersion(3)) {
      // do something for Nuxt 3
    } else {
      // do something else for other versions
    }
  }
})
```

### Type

```ts
function isNuxtMajorVersion(major: number, nuxt?: Nuxt): boolean;
```

### Parameters

**`major`**: Phiên bản chính để kiểm tra.

**`nuxt`**: Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`.

## `isNuxt3`

Kiểm tra xem phiên bản Nuxt hiện tại có phải là 3.x hay không.

::note
Use `isNuxtMajorVersion(2, nuxt)` instead. This may be removed in @nuxt/kit v5 or a future major version.
::

### Type

```ts
function isNuxt3(nuxt?: Nuxt): boolean;
```

### Parameters

**`nuxt`**: Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`.

## `isNuxt2`

Kiểm tra xem phiên bản Nuxt hiện tại có phải là 2.x hay không.

::note
Use `isNuxtMajorVersion(2, nuxt)` instead. This may be removed in @nuxt/kit v5 or a future major version.
::

### Type

```ts
function isNuxt2(nuxt?: Nuxt): boolean;
```

### Parameters

**`nuxt`**: Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`.

## `getNuxtVersion`

Trả về phiên bản Nuxt hiện tại.

### Type

```ts
function getNuxtVersion(nuxt?: Nuxt): string;
```

### Parameters

**`nuxt`**: Instance Nuxt. Nếu không được cung cấp, nó sẽ được lấy từ context qua lệnh gọi `useNuxt()`.


# Auto-imports

Nuxt tự động nhập các hàm trợ giúp, composables và Vue APIs để sử dụng trên toàn bộ ứng dụng mà không cần nhập chúng một cách rõ ràng. Dựa trên cấu trúc thư mục, mọi ứng dụng Nuxt cũng có thể sử dụng auto-imports cho các composables và plugins của riêng mình.

Với Nuxt Kit, bạn cũng có thể thêm các auto-imports của riêng mình. `addImports` và `addImportsDir` cho phép bạn thêm imports vào ứng dụng Nuxt. `addImportsSources` cho phép bạn thêm các imports được liệt kê từ các gói bên thứ ba vào ứng dụng Nuxt.

Các tiện ích này được cung cấp bởi [`unimport`](https://github.com/unjs/unimport){rel="nofollow"}, cung cấp cơ chế auto-import cơ bản được sử dụng trong Nuxt.

::note
These functions are designed for registering your own utils, composables and Vue APIs. For pages, components and plugins, please refer to the specific sections: [Pages](https://nuxt.com/docs/api/kit/pages), [Components](https://nuxt.com/docs/api/kit/components), [Plugins](https://nuxt.com/docs/api/kit/plugins).
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/expanding-nuxt-s-auto-imports?friend=nuxt
---
Watch Vue School video about Auto-imports Nuxt Kit utilities.
::

## `addImports`

Thêm imports vào ứng dụng Nuxt. Nó làm cho các imports của bạn có sẵn trong ứng dụng Nuxt mà không cần nhập chúng thủ công.

### Usage

```ts twoslash
import { defineNuxtModule, addImports } from "@nuxt/kit";

export default defineNuxtModule({
  setup(options, nuxt) {
    const names = [
      'useStoryblok',
      'useStoryblokApi',
      'useStoryblokBridge',
      'renderRichText',
      'RichTextSchema'
    ]

    names.forEach((name) =>
      addImports({ name, as: name, from: '@storyblok/vue' })
    )
  }
})
```

### Type

```ts
function addImports (imports: Import | Import[]): void
```

### Parameters

`imports`: Một đối tượng hoặc một mảng các đối tượng với các thuộc tính sau:

| Property   | Type                  | Required | Description                                                                                 |
| ---------- | --------------------- | -------- | ------------------------------------------------------------------------------------------- |
| `name`     | `string`              | `true`   | Tên import để được phát hiện.                                                               |
| `from`     | `string`              | `true`   | Bộ chỉ định module để nhập từ.                                                              |
| `priority` | `number`              | `false`  | Ưu tiên của import; nếu nhiều imports có cùng tên, cái có ưu tiên cao nhất sẽ được sử dụng. |
| `disabled` | `boolean`             | `false`  | Nếu import này bị vô hiệu hóa.                                                              |
| `meta`     | `Record<string, any>` | `false`  | Metadata của import.                                                                        |
| `type`     | `boolean`             | `false`  | Nếu import này là một import kiểu thuần túy.                                                |
| `typeFrom` | `string`              | `false`  | Sử dụng cái này làm giá trị `from` khi tạo khai báo kiểu.                                   |
| `as`       | `string`              | `false`  | Nhập dưới tên này.                                                                          |

## `addImportsDir`

Thêm imports từ một thư mục vào ứng dụng Nuxt. Nó sẽ tự động nhập tất cả các tệp từ thư mục và làm cho chúng có sẵn trong ứng dụng Nuxt mà không cần nhập chúng thủ công.

### Usage

```ts twoslash
import { defineNuxtModule, addImportsDir, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: '@vueuse/motion',
    configKey: 'motion',
  },
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    addImportsDir(resolver.resolve('./runtime/composables'))
  },
})
```

### Type

```ts
function addImportsDir (dirs: string | string[], options?: { prepend?: boolean }): void
```

### Parameters

| Property  | Type                                                                                                                                      | Required | Description                                                                                                             |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------- |
| `dirs`    | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}     | `true`   | Một chuỗi hoặc một mảng các chuỗi với đường dẫn đến thư mục để nhập từ.                                                 |
| `options` | `{ prepend?: boolean }`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Tùy chọn để truyền cho import. Nếu `prepend` được đặt thành `true`, các imports sẽ được thêm vào đầu danh sách imports. |

## `addImportsSources`

Thêm các imports được liệt kê vào ứng dụng Nuxt.

### Usage

```ts twoslash
import { defineNuxtModule, addImportsSources } from '@nuxt/kit'

export default defineNuxtModule({
  setup() {
    addImportsSources({
      from: 'h3',
      imports: [
        'defineEventHandler',
        'getQuery',
        'getRouterParams',
        'readBody',
        'sendRedirect'
      ],
    })
  }
})
```

### Type

```ts
function addImportsSources (importSources: ImportSource | ImportSource[]): void
```

### Parameters

**importSources**: Một đối tượng hoặc một mảng các đối tượng với các thuộc tính sau:

| Property  | Type                                                                                                                                              | Required | Description                                                                                             |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------- |
| `from`    | `string`                                                                                                                                          | `true`   | Bộ chỉ định module để nhập từ.                                                                          |
| `imports` | `PresetImport | ImportSource[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `true`   | Một đối tượng hoặc một mảng các đối tượng, có thể là tên imports, đối tượng imports hoặc nguồn imports. |


# Components

Các component là khối xây dựng của ứng dụng Nuxt của bạn. Chúng là các instance Vue có thể tái sử dụng để tạo giao diện người dùng. Trong Nuxt, các component từ thư mục components được nhập tự động theo mặc định. Tuy nhiên, nếu bạn cần nhập component từ một thư mục thay thế hoặc muốn nhập chúng một cách chọn lọc khi cần, `@nuxt/kit` cung cấp các phương thức `addComponentsDir` và `addComponent`. Các tiện ích này cho phép bạn tùy chỉnh cấu hình component để phù hợp hơn với nhu cầu của bạn.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/injecting-components-and-component-directories?friend=nuxt
---
Watch Vue School video about injecting components.
::

## `addComponentsDir`

Đăng ký một thư mục để quét các component và nhập chỉ khi được sử dụng. Hãy nhớ rằng, điều này không đăng ký component toàn cục, cho đến khi bạn chỉ định tùy chọn `global: true`.

### Usage

```ts
export default defineNuxtModule({
  meta: {
    name: '@nuxt/ui',
    configKey: 'ui',
  },
  setup() {
    addComponentsDir({
      path: resolve('./runtime/components'),
      prefix: 'U',
      pathPrefix: false
    })
  }
})
```

### Type

```ts
function addComponentsDir (dir: ComponentsDir, opts: { prepend?: boolean } = {}): void
```

### Parameters

`dir` Một đối tượng với các thuộc tính sau:

| Property          | Type                                                                                                                                                                                         | Required | Description                                                                                                                                                                                                                                                                                  |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `path`            | `string`                                                                                                                                                                                     | `true`   | Đường dẫn (tuyệt đối hoặc tương đối) đến thư mục chứa các component của bạn. Bạn có thể sử dụng các alias Nuxt (\~ hoặc @) để tham chiếu đến các thư mục bên trong dự án hoặc trực tiếp sử dụng đường dẫn gói npm tương tự như require.                                                      |
| `pattern`         | `string | string[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                        | `false`  | Mẫu chấp nhận sẽ được chạy đối với đường dẫn được chỉ định.                                                                                                                                                                                                                                  |
| `ignore`          | `string[]`                                                                                                                                                                                   | `false`  | Bỏ qua các mẫu sẽ được chạy đối với đường dẫn được chỉ định.                                                                                                                                                                                                                                 |
| `prefix`          | `string`                                                                                                                                                                                     | `false`  | Thêm tiền tố tất cả các component khớp với chuỗi này.                                                                                                                                                                                                                                        |
| `pathPrefix`      | `boolean`                                                                                                                                                                                    | `false`  | Thêm tiền tố tên component bằng đường dẫn của nó.                                                                                                                                                                                                                                            |
| `enabled`         | `boolean`                                                                                                                                                                                    | `false`  | Bỏ qua quét thư mục này nếu đặt thành `true`.                                                                                                                                                                                                                                                |
| `prefetch`        | `boolean`                                                                                                                                                                                    | `false`  | Các thuộc tính này (prefetch/preload) được sử dụng trong production để cấu hình cách các component với tiền tố Lazy được xử lý bởi webpack qua các comment ma thuật của nó. Tìm hiểu thêm trên [tài liệu webpack](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `preload`         | `boolean`                                                                                                                                                                                    | `false`  | Các thuộc tính này (prefetch/preload) được sử dụng trong production để cấu hình cách các component với tiền tố Lazy được xử lý bởi webpack qua các comment ma thuật của nó. Tìm hiểu thêm trên [tài liệu webpack](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `isAsync`         | `boolean`                                                                                                                                                                                    | `false`  | Cờ này chỉ ra, component nên được tải async (với một chunk riêng biệt) bất kể có sử dụng tiền tố Lazy hay không.                                                                                                                                                                             |
| `extendComponent` | `(component: Component) => Promise<Component | void> | (Component | void)`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Một hàm sẽ được gọi cho mỗi component được tìm thấy trong thư mục. Nó chấp nhận một đối tượng component và nên trả về một đối tượng component hoặc một promise giải quyết thành một đối tượng component.                                                                                     |
| `global`          | `boolean`                                                                                                                                                                                    | `false`  | Nếu được bật, đăng ký component để có sẵn toàn cục.                                                                                                                                                                                                                                          |
| `island`          | `boolean`                                                                                                                                                                                    | `false`  | Nếu được bật, đăng ký component dưới dạng islands. Bạn có thể đọc thêm về islands trong mô tả component [`<NuxtIsland/>`](https://nuxt.com/docs/api/components/nuxt-island#nuxtisland).                                                                                                      |
| `watch`           | `boolean`                                                                                                                                                                                    | `false`  | Theo dõi đường dẫn được chỉ định để thay đổi, bao gồm thêm và xóa tệp.                                                                                                                                                                                                                       |
| `extensions`      | `string[]`                                                                                                                                                                                   | `false`  | Các phần mở rộng được hỗ trợ bởi Nuxt builder.                                                                                                                                                                                                                                               |
| `transpile`       | `'auto' | boolean`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                                         | `false`  | Transpile đường dẫn được chỉ định bằng build.transpile. Nếu đặt thành `'auto'`, nó sẽ đặt `transpile: true` nếu `node_modules/` nằm trong đường dẫn.                                                                                                                                         |

`opts`

| Property  | Type      | Required | Description                                                                               |
| --------- | --------- | -------- | ----------------------------------------------------------------------------------------- |
| `prepend` | `boolean` | `false`  | Nếu đặt thành `true`, thư mục sẽ được thêm vào đầu mảng với `unshift()` thay vì `push()`. |

## `addComponent`

Đăng ký một component để được nhập tự động.

### Usage

```ts
import { defineNuxtModule, createResolver, addComponent } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: '@nuxt/image',
    configKey: 'image',
  },
  async setup() {
    const resolver = createResolver(import.meta.url)

    addComponent({
      name: 'NuxtImg',
      filePath: resolver.resolve('./runtime/components/NuxtImg.vue'),
    })

    addComponent({
      name: 'NuxtPicture',
      filePath: resolver.resolve('./runtime/components/NuxtPicture.vue'),
    })
  },
})
```

### Type

```ts
function addComponent (options: AddComponentOptions): void
```

### Parameters

`options`: Một đối tượng với các thuộc tính sau:

| Property     | Type                                                                                                                                            | Required | Description                                                                                                                                                                                                                                                                                  |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`       | `string`                                                                                                                                        | `true`   | Tên component.                                                                                                                                                                                                                                                                               |
| `filePath`   | `string`                                                                                                                                        | `true`   | Đường dẫn đến component.                                                                                                                                                                                                                                                                     |
| `pascalName` | `string`                                                                                                                                        | `false`  | Tên component dạng Pascal case. Nếu không được cung cấp, nó sẽ được tạo từ tên component.                                                                                                                                                                                                    |
| `kebabName`  | `string`                                                                                                                                        | `false`  | Tên component dạng kebab case. Nếu không được cung cấp, nó sẽ được tạo từ tên component.                                                                                                                                                                                                     |
| `export`     | `string`                                                                                                                                        | `false`  | Chỉ định export có tên hoặc mặc định. Nếu không được cung cấp, nó sẽ được đặt thành `'default'`.                                                                                                                                                                                             |
| `shortPath`  | `string`                                                                                                                                        | `false`  | Đường dẫn ngắn đến component. Nếu không được cung cấp, nó sẽ được tạo từ đường dẫn component.                                                                                                                                                                                                |
| `chunkName`  | `string`                                                                                                                                        | `false`  | Tên chunk cho component. Nếu không được cung cấp, nó sẽ được tạo từ tên component.                                                                                                                                                                                                           |
| `prefetch`   | `boolean`                                                                                                                                       | `false`  | Các thuộc tính này (prefetch/preload) được sử dụng trong production để cấu hình cách các component với tiền tố Lazy được xử lý bởi webpack qua các comment ma thuật của nó. Tìm hiểu thêm trên [tài liệu webpack](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `preload`    | `boolean`                                                                                                                                       | `false`  | Các thuộc tính này (prefetch/preload) được sử dụng trong production để cấu hình cách các component với tiền tố Lazy được xử lý bởi webpack qua các comment ma thuật của nó. Tìm hiểu thêm trên [tài liệu webpack](https://webpack.js.org/api/module-methods/#magic-comments){rel="nofollow"} |
| `global`     | `boolean`                                                                                                                                       | `false`  | Nếu được bật, đăng ký component để có sẵn toàn cục.                                                                                                                                                                                                                                          |
| `island`     | `boolean`                                                                                                                                       | `false`  | Nếu được bật, đăng ký component dưới dạng island. Bạn có thể đọc thêm về islands trong mô tả component [`<NuxtIsland/>`](https://nuxt.com/docs/api/components/nuxt-island#nuxtisland).                                                                                                       |
| `mode`       | `'client' | 'server' | 'all'`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Tùy chọn này chỉ ra nếu component nên render trên client, server hoặc cả hai. Theo mặc định, nó sẽ render trên cả client và server.                                                                                                                                                          |
| `priority`   | `number`                                                                                                                                        | `false`  | Ưu tiên của component, nếu nhiều component có cùng tên, cái có ưu tiên cao nhất sẽ được sử dụng.                                                                                                                                                                                             |

### Examples

Nếu bạn muốn auto-import một component từ một gói npm, và component là một export có tên (thay vì mặc định), bạn có thể sử dụng tùy chọn `export` để chỉ định nó.

```ts
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```


# Context

Các module Nuxt cho phép bạn nâng cao khả năng của Nuxt. Chúng cung cấp một cách có cấu trúc để giữ mã của bạn được tổ chức và mô-đun. Nếu bạn đang tìm cách chia module của mình thành các component nhỏ hơn, Nuxt cung cấp các hàm `useNuxt` và `tryUseNuxt`. Các hàm này cho phép bạn truy cập thuận tiện instance Nuxt từ context mà không cần truyền nó như một đối số.

::note
Khi bạn đang làm việc với hàm `setup` trong các module Nuxt, Nuxt đã được cung cấp như đối số thứ hai. Điều này có nghĩa là bạn có thể truy cập nó trực tiếp mà không cần gọi `useNuxt()`.
::

## `useNuxt`

Lấy instance Nuxt từ context. Nó sẽ ném lỗi nếu Nuxt không khả dụng.

### Usage

```ts
import { useNuxt } from '@nuxt/kit'

const setupSomeFeature = () => {
  const nuxt = useNuxt()

  // Bây giờ bạn có thể sử dụng instance nuxt
  console.log(nuxt.options)
}
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function useNuxt(): Nuxt
```

### Return Value

Hàm `useNuxt` trả về instance Nuxt, chứa tất cả các tùy chọn và phương thức có sẵn trong Nuxt.

| Property   | Type                                                                     | Description                                                                                                      |
| ---------- | ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------- |
| `options`  | `NuxtOptions`                                                            | Cấu hình Nuxt đã giải quyết.                                                                                     |
| `hooks`    | `Hookable<NuxtHooks>`                                                    | Hệ thống hook Nuxt. Cho phép đăng ký và lắng nghe các sự kiện vòng đời.                                          |
| `hook`     | `(name: string, (...args: any[]) => Promise<void> | void) => () => void` | Phím tắt cho `nuxt.hooks.hook`. Đăng ký một callback duy nhất cho một hook vòng đời cụ thể.                      |
| `callHook` | `(name: string, ...args: any[]) => Promise<any>`                         | Phím tắt cho `nuxt.hooks.callHook`. Kích hoạt một hook vòng đời thủ công và chạy tất cả các callback đã đăng ký. |
| `addHooks` | `(configHooks: NestedHooks) => () => void`                               | Phím tắt cho `nuxt.hooks.addHooks`. Đăng ký nhiều hook cùng một lúc.                                             |

### Examples

::code-group
```ts [setupTranspilation.ts] twoslash
import { useNuxt } from '@nuxt/kit'

export const setupTranspilation = () => {
  const nuxt = useNuxt()

  if (nuxt.options.builder === '@nuxt/webpack-builder') {
    nuxt.options.build.transpile ||= []
    nuxt.options.build.transpile.push('xstate')
  }
}
```

```ts [module.ts] twoslash
// @module: esnext
// @filename: setupTranspilation.ts
export const setupTranspilation = () => {}
// @filename: module.ts
import { defineNuxtModule } from '@nuxt/kit'
// ---cut---
import { setupTranspilation } from './setupTranspilation'

export default defineNuxtModule({
  setup () {
    setupTranspilation()
  },
})
```
::

## `tryUseNuxt`

Lấy instance Nuxt từ context. Nó sẽ trả về `null` nếu Nuxt không khả dụng.

### Usage

```ts twoslash
import { tryUseNuxt } from '@nuxt/kit'

function setupSomething () {
  const nuxt = tryUseNuxt()

  if (nuxt) {
    // You can now use the nuxt instance
    console.log(nuxt.options)
  } else {
    console.log('Nuxt không khả dụng')
  }
}
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function tryUseNuxt(): Nuxt | null
```

### Return Value

Hàm `tryUseNuxt` trả về instance Nuxt nếu có sẵn, hoặc `null` nếu Nuxt không khả dụng.

Instance Nuxt như mô tả trong phần `useNuxt`.

### Examples

::code-group
```ts [requireSiteConfig.ts] twoslash
declare module 'nuxt/schema' {
  interface NuxtOptions {
    siteConfig: SiteConfig
  }
}
// ---cut---
import { tryUseNuxt } from '@nuxt/kit'

interface SiteConfig {
  title?: string
}

export const requireSiteConfig = (): SiteConfig => {
  const nuxt = tryUseNuxt()
  if (!nuxt) {
    return {}
  }
  return nuxt.options.siteConfig
}
```

```ts [module.ts] twoslash
// @module: esnext
// @filename: requireSiteConfig.ts
interface SiteConfig {
  title?: string
}
export const requireSiteConfig = (): SiteConfig => {
 return {}
}
// @filename: module.ts
// ---cut---
import { defineNuxtModule, useNuxt } from '@nuxt/kit'
import { requireSiteConfig } from './requireSiteConfig'

export default defineNuxtModule({
  setup (_, nuxt) {
    const config = requireSiteConfig()
    nuxt.options.app.head.title = config.title
  },
})
```
::


# Pages

## `extendPages`

Trong Nuxt, các route được tạo tự động dựa trên cấu trúc của các tệp trong thư mục `pages`. Tuy nhiên, có thể có các tình huống mà bạn muốn tùy chỉnh các route này. Ví dụ, bạn có thể cần thêm một route cho một trang động không được tạo bởi Nuxt, xóa một route hiện có, hoặc sửa đổi cấu hình của một route. Đối với các tùy chỉnh như vậy, Nuxt cung cấp tính năng `extendPages`, cho phép bạn mở rộng và thay đổi cấu hình pages.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/extend-and-alter-nuxt-pages?friend=nuxt
---
Watch Vue School video about extendPages.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, extendPages } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    extendPages((pages) => {
      pages.unshift({
        name: 'prismic-preview',
        path: '/preview',
        file: resolve('runtime/preview.vue'),
      })
    })
  },
})
```

### Type

```ts
function extendPages(callback: (pages: NuxtPage[]) => void): void
```

### Parameters

**callback**: Một hàm sẽ được gọi với cấu hình pages. Bạn có thể thay đổi mảng này bằng cách thêm, xóa hoặc sửa đổi các phần tử của nó. Lưu ý: Bạn nên sửa đổi mảng pages được cung cấp trực tiếp, vì các thay đổi được thực hiện trên một mảng sao chép sẽ không được phản ánh trong cấu hình.

| Property   | Type                                                                                                                                    | Required | Description                                                                                          |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------- |
| `name`     | `string`                                                                                                                                | `false`  | Tên của route. Hữu ích cho điều hướng theo chương trình và xác định routes.                          |
| `path`     | `string`                                                                                                                                | `false`  | Đường dẫn URL của route. Nếu không đặt, Nuxt sẽ suy luận nó từ vị trí tệp.                           |
| `file`     | `string`                                                                                                                                | `false`  | Đường dẫn đến tệp Vue nên được sử dụng làm component cho route.                                      |
| `meta`     | `Record<string, any>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Metadata tùy chỉnh cho route. Có thể được sử dụng trong layouts, middlewares hoặc navigation guards. |
| `alias`    | `string[] | string`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}   | `false`  | Một hoặc nhiều đường dẫn alias cho route. Hữu ích để hỗ trợ nhiều URL.                               |
| `redirect` | `RouteLocationRaw`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}    | `false`  | Quy tắc chuyển hướng cho route. Hỗ trợ named routes, objects hoặc string paths.                      |
| `children` | `NuxtPage[]`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}          | `false`  | Các child routes lồng nhau dưới route này cho layout hoặc view nesting.                              |

## `extendRouteRules`

Nuxt được cung cấp bởi engine server [Nitro](https://nitro.build/){rel="nofollow"}. Với Nitro, bạn có thể kết hợp logic cấp cao trực tiếp vào cấu hình của mình, hữu ích cho các hành động như chuyển hướng, proxying, caching và thêm headers vào routes. Cấu hình này hoạt động bằng cách liên kết các pattern route với các cài đặt route cụ thể.

::tip
You can read more about Nitro route rules in the [Nitro documentation](https://nitro.build/guide/routing#route-rules){rel="nofollow"}.
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/adding-route-rules-and-route-middlewares?friend=nuxt
---
Watch Vue School video about adding route rules and route middelwares.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, extendPages, extendRouteRules } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    extendPages((pages) => {
      pages.unshift({
        name: 'preview-new',
        path: '/preview-new',
        file: resolve('runtime/preview.vue'),
      })
    })

    extendRouteRules('/preview', {
      redirect: {
        to: '/preview-new',
        statusCode: 302,
      },
    })

    extendRouteRules('/preview-new', {
      cache: {
        maxAge: 60 * 60 * 24 * 7,
      },
    })
  },
})
```

### Type

```ts
function extendRouteRules(route: string, rule: NitroRouteConfig, options?: ExtendRouteRulesOptions): void
```

### Parameters

**route**: Một pattern route để khớp với. :br**rule**: Cấu hình rule route để áp dụng cho route khớp.

::tip
About route rules configurations, you can get more detail in [Hybrid Rendering > Route Rules](https://nuxt.com/docs/guide/concepts/rendering#route-rules).
::

**options**: Một đối tượng để truyền cho cấu hình route. Nếu `override` được đặt thành `true`, nó sẽ ghi đè cấu hình route hiện có.

| Name       | Type      | Default | Description                                   |
| ---------- | --------- | ------- | --------------------------------------------- |
| `override` | `boolean` | `false` | Ghi đè cấu hình rule route, mặc định là false |

## `addRouteMiddleware`

Đăng ký route middlewares để có sẵn cho tất cả routes hoặc cho các routes cụ thể.

Route middlewares cũng có thể được định nghĩa trong plugins qua composable [`addRouteMiddleware`](https://nuxt.com/docs/api/utils/add-route-middleware).

::tip
Read more about route middlewares in the [Route middleware documentation](https://nuxt.com/docs/getting-started/routing#route-middleware).
::

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/adding-route-rules-and-route-middlewares?friend=nuxt
---
Watch Vue School video about adding route rules and route middelwares.
::

### Usage

::code-group
```ts [module.ts] twoslash
import { addRouteMiddleware, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addRouteMiddleware({
      name: 'auth',
      path: resolve('runtime/auth'),
      global: true,
    }, { prepend: true })
  },
})
```

```ts [runtime/auth.ts] twoslash
function isAuthenticated(): boolean { return false }
// ---cut---
export default defineNuxtRouteMiddleware((to, from) => {
  // isAuthenticated() là một phương thức ví dụ xác minh xem người dùng có được xác thực hay không
  if (to.path !== '/login' && isAuthenticated() === false) {
    return navigateTo('/login')
  }
})
```
::

### Type

```ts
function addRouteMiddleware(input: NuxtMiddleware | NuxtMiddleware[], options?: AddRouteMiddlewareOptions): void
```

### Parameters

**input**: A middleware object or an array of middleware objects with the following properties:

| Property | Type      | Required | Description                                                 |
| -------- | --------- | -------- | ----------------------------------------------------------- |
| `name`   | `string`  | `true`   | Tên của middleware.                                         |
| `path`   | `string`  | `true`   | Đường dẫn tệp đến middleware.                               |
| `global` | `boolean` | `false`  | Nếu đặt thành `true`, áp dụng middleware cho tất cả routes. |

**options**: Một đối tượng với các thuộc tính sau:

| Property   | Type      | Default | Description                                                |
| ---------- | --------- | ------- | ---------------------------------------------------------- |
| `override` | `boolean` | `false` | Nếu `true`, thay thế middleware với cùng tên.              |
| `prepend`  | `boolean` | `false` | Nếu `true`, thêm middleware trước các middlewares hiện có. |


# Layout

Layouts được sử dụng để làm wrapper xung quanh các pages của bạn. Nó có thể được sử dụng để wrap các pages với các component chung, ví dụ, một header và footer. Layouts có thể được đăng ký bằng tiện ích `addLayout`.

## `addLayout`

Đăng ký template làm layout và thêm nó vào layouts.

::note
Trong Nuxt 2 layout `error` cũng có thể được đăng ký bằng tiện ích này. Trong Nuxt 3+ layout `error` [được thay thế](https://nuxt.com/docs/getting-started/error-handling#rendering-an-error-page) với page `error.vue` trong root dự án.
::

### Usage

```ts twoslash
import { addLayout, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addLayout({
      src: resolve('templates/custom-layout.ts'),
      filename: 'custom-layout.ts',
    }, 'custom')
  },
})
```

### Type

```ts
function addLayout(layout: NuxtTemplate | string, name: string): void
```

### Parameters

**`layout`**: Một đối tượng template hoặc một chuỗi với đường dẫn đến template. Nếu một chuỗi được cung cấp, nó sẽ được chuyển đổi thành đối tượng template với `src` được đặt thành giá trị chuỗi. Nếu một đối tượng template được cung cấp, nó phải có các thuộc tính sau:

| Property      | Type                                                                                                                                                   | Required | Description                                                                                                                                                      |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                                                                                                                               | `false`  | Đường dẫn đến template. Nếu `src` không được cung cấp, `getContents` phải được cung cấp thay thế.                                                                |
| `filename`    | `string`                                                                                                                                               | `false`  | Tên tệp của template. Nếu `filename` không được cung cấp, nó sẽ được tạo từ đường dẫn `src`. Trong trường hợp này, tùy chọn `src` là bắt buộc.                   |
| `dst`         | `string`                                                                                                                                               | `false`  | Đường dẫn đến tệp đích. Nếu `dst` không được cung cấp, nó sẽ được tạo từ đường dẫn `filename` và tùy chọn `buildDir` của nuxt.                                   |
| `options`     | `Record<string, any>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                | `false`  | Tùy chọn để truyền cho template.                                                                                                                                 |
| `getContents` | `(data) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Một hàm sẽ được gọi với đối tượng `options`. Nó nên trả về một chuỗi hoặc một promise giải quyết thành một chuỗi. Nếu `src` được cung cấp, hàm này sẽ bị bỏ qua. |
| `write`       | `boolean`                                                                                                                                              | `false`  | Nếu đặt thành `true`, template sẽ được ghi vào tệp đích. Nếu không, template sẽ chỉ được sử dụng trong virtual filesystem.                                       |

**`name`**: Tên để đăng ký layout dưới (ví dụ, `default`, `custom`, v.v.).

### Example

Điều này sẽ đăng ký một layout có tên `custom` wrap pages với header và footer.

```ts twoslash
import { addLayout, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addLayout({
      write: true,
      filename: 'my-layout.vue',
      getContents: () => `<template>
  <div>
    <header>My Header</header>
    <slot />
    <footer>My Footer</footer>
  </div>
</template>`,
    }, 'custom')
  },
})
```

Sau đó, bạn có thể sử dụng layout này trong pages của mình:

```vue [pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'custom',
})
</script>

<template>
  <div>About Page</div>
</template>
```

::warning
Do thiếu hỗ trợ cho virtual `.vue` files bởi `@vitejs/plugin-vue`, bạn có thể khắc phục hạn chế này bằng cách truyền `write: true` cho đối số đầu tiên của `addLayout`.
::


# Plugins

Các plugin là mã tự chứa thường thêm chức năng cấp ứng dụng vào Vue. Trong Nuxt, các plugin được nhập tự động từ thư mục `plugins/`. Tuy nhiên, nếu bạn cần ship một plugin với module của mình, Nuxt Kit cung cấp các phương thức `addPlugin` và `addPluginTemplate`. Các tiện ích này cho phép bạn tùy chỉnh cấu hình plugin để phù hợp hơn với nhu cầu của bạn.

## `addPlugin`

Đăng ký một plugin Nuxt và thêm nó vào mảng plugins.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/injecting-plugins?friend=nuxt
---
Watch Vue School video about `addPlugin`.
::

### Usage

```ts twoslash
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addPlugin({
      src: resolve('runtime/plugin.js'),
      mode: 'client',
    })
  },
})
```

### Type

```ts
function addPlugin(plugin: NuxtPlugin | string, options?: AddPluginOptions): NuxtPlugin
```

### Parameters

**`plugin`**: A plugin object or a string with the path to the plugin. If a string is provided, it will be converted to a plugin object with `src` set to the string value.

Nếu một đối tượng plugin được cung cấp, nó phải có các thuộc tính sau:

| Property | Type                                                                                                                                            | Required | Description                                                                                                                                                                                                                                                                                                                                                                   |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`    | `string`                                                                                                                                        | `true`   | Đường dẫn đến tệp plugin.                                                                                                                                                                                                                                                                                                                                                     |
| `mode`   | `'all' | 'server' | 'client'`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Nếu đặt thành `'all'`, plugin sẽ được bao gồm trong cả client và server bundles. Nếu đặt thành `'server'`, plugin sẽ chỉ được bao gồm trong server bundle. Nếu đặt thành `'client'`, plugin sẽ chỉ được bao gồm trong client bundle. Bạn cũng có thể sử dụng các modifier `.client` và `.server` khi chỉ định tùy chọn `src` để sử dụng plugin chỉ ở phía client hoặc server. |
| `order`  | `number`                                                                                                                                        | `false`  | Thứ tự của plugin. Điều này cho phép kiểm soát chi tiết hơn về thứ tự plugin và chỉ nên được sử dụng bởi người dùng nâng cao. Số thấp hơn chạy trước, và user plugins mặc định là `0`. Bạn nên đặt `order` thành một số giữa `-20` cho `pre`-plugins (plugins chạy trước Nuxt plugins) và `20` cho `post`-plugins (plugins chạy sau Nuxt plugins).                            |

::warning
Tránh sử dụng `order` trừ khi cần thiết. Sử dụng `append` nếu bạn chỉ cần đăng ký plugins sau Nuxt defaults.
::

**`options`**: Optional object with the following properties:

| Property | Type      | Required | Description                                                                                                       |
| -------- | --------- | -------- | ----------------------------------------------------------------------------------------------------------------- |
| `append` | `boolean` | `false`  | Nếu `true`, plugin sẽ được thêm vào cuối mảng plugins. Nếu `false`, nó sẽ được thêm vào đầu. Mặc định là `false`. |

### Examples

::code-group
```ts [module.ts]
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addPlugin({
      src: resolve('runtime/plugin.js'),
      mode: 'client',
    })
  },
})
```

```ts [runtime/plugin.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const colorMode = useColorMode()

  nuxtApp.hook('app:mounted', () => {
    if (colorMode.preference !== 'dark') {
      colorMode.preference = 'dark'
    }
  })
})
```
::

## `addPluginTemplate`

Thêm một template và đăng ký làm plugin nuxt. Điều này hữu ích cho các plugin cần tạo mã tại thời điểm build.

::tip
---
icon: i-lucide-video
target: _blank
to: https://vueschool.io/lessons/injecting-plugin-templates?friend=nuxt
---
Watch Vue School video about `addPluginTemplate`.
::

### Usage

```ts twoslash
import { addPluginTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    addPluginTemplate({
      filename: 'module-plugin.mjs',
      getContents: () => `import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'module-plugin',
  setup (nuxtApp) {
    ${options.log ? 'console.log("Plugin install")' : ''}
  }
})`,
    })
  },
})
```

### Type

```ts
function addPluginTemplate(pluginOptions: NuxtPluginTemplate, options?: AddPluginOptions): NuxtPlugin
```

### Parameters

**`pluginOptions`**: A plugin template object with the following properties:

| Property      | Type                                                                                                                                                                        | Required | Description                                                                                                                                                                                                                                                                                                                                                                   |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                                                                                                                                                    | `false`  | Đường dẫn đến template. Nếu `src` không được cung cấp, `getContents` phải được cung cấp thay thế.                                                                                                                                                                                                                                                                             |
| `filename`    | `string`                                                                                                                                                                    | `false`  | Tên tệp của template. Nếu `filename` không được cung cấp, nó sẽ được tạo từ đường dẫn `src`. Trong trường hợp này, tùy chọn `src` là bắt buộc.                                                                                                                                                                                                                                |
| `dst`         | `string`                                                                                                                                                                    | `false`  | Đường dẫn đến tệp đích. Nếu `dst` không được cung cấp, nó sẽ được tạo từ đường dẫn `filename` và tùy chọn `buildDir` của nuxt.                                                                                                                                                                                                                                                |
| `mode`        | `'all' | 'server' | 'client'`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                             | `false`  | Nếu đặt thành `'all'`, plugin sẽ được bao gồm trong cả client và server bundles. Nếu đặt thành `'server'`, plugin sẽ chỉ được bao gồm trong server bundle. Nếu đặt thành `'client'`, plugin sẽ chỉ được bao gồm trong client bundle. Bạn cũng có thể sử dụng các modifier `.client` và `.server` khi chỉ định tùy chọn `src` để sử dụng plugin chỉ ở phía client hoặc server. |
| `options`     | `Record<string, any>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}                                     | `false`  | Tùy chọn để truyền cho template.                                                                                                                                                                                                                                                                                                                                              |
| `getContents` | `(data: Record<string, any>) => string | Promise<string>`{.language-ts.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} | `false`  | Một hàm sẽ được gọi với đối tượng `options`. Nó nên trả về một chuỗi hoặc một promise giải quyết thành một chuỗi. Nếu `src` được cung cấp, hàm này sẽ bị bỏ qua.                                                                                                                                                                                                              |
| `write`       | `boolean`                                                                                                                                                                   | `false`  | Nếu đặt thành `true`, template sẽ được ghi vào tệp đích. Nếu không, template sẽ chỉ được sử dụng trong virtual filesystem.                                                                                                                                                                                                                                                    |
| `order`       | `number`                                                                                                                                                                    | `false`  | Thứ tự của plugin. Điều này cho phép kiểm soát chi tiết hơn về thứ tự plugin và chỉ nên được sử dụng bởi người dùng nâng cao. Số thấp hơn chạy trước, và user plugins mặc định là `0`. Bạn nên đặt `order` thành một số giữa `-20` cho `pre`-plugins (plugins chạy trước Nuxt plugins) và `20` cho `post`-plugins (plugins chạy sau Nuxt plugins).                            |

::warning
Ưu tiên sử dụng `getContents` cho việc tạo plugin động. Tránh đặt `order` trừ khi cần thiết.
::

**`options`**: Optional object with the following properties:

| Property | Type      | Required | Description                                                                                                       |
| -------- | --------- | -------- | ----------------------------------------------------------------------------------------------------------------- |
| `append` | `boolean` | `false`  | Nếu `true`, plugin sẽ được thêm vào cuối mảng plugins. Nếu `false`, nó sẽ được thêm vào đầu. Mặc định là `false`. |

### Examples

#### Tạo template plugin với các tùy chọn khác nhau

Sử dụng `addPluginTemplate` khi bạn cần tạo mã plugin động tại thời điểm build. Điều này cho phép bạn tạo các nội dung plugin khác nhau dựa trên các tùy chọn được truyền cho nó. Ví dụ, Nuxt nội bộ sử dụng hàm này để tạo cấu hình ứng dụng Vue.

```ts [module.ts] twoslash
import { addPluginTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (_, nuxt) {
    if (nuxt.options.vue.config && Object.values(nuxt.options.vue.config).some(v => v !== null && v !== undefined)) {
      addPluginTemplate({
        filename: 'vue-app-config.mjs',
        write: true,
        getContents: () => `import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'nuxt:vue-app-config',
  enforce: 'pre',
  setup (nuxtApp) {
    ${Object.keys(nuxt.options.vue.config!)
        .map(k => `nuxtApp.vueApp.config[${JSON.stringify(k)}] = ${JSON.stringify(nuxt.options.vue.config![k as 'idPrefix'])}`)
        .join('\n')
    }
  }
})`,
      })
    }
  },
})
```

Điều này tạo ra mã plugin khác nhau tùy thuộc vào cấu hình được cung cấp.

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  vue: {
    config: {
      idPrefix: 'nuxt',
    },
  },
})
```

```ts [#build/vue-app-config.mjs]
import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'nuxt:vue-app-config',
  enforce: 'pre',
  setup (nuxtApp) {
    nuxtApp.vueApp.config["idPrefix"] = "nuxt"
  }
})
```
::


# Lifecycle Hooks

::read-more{to="https://nuxt.com/docs/guide/going-further/hooks"}
::

## App Hooks (runtime)

Kiểm tra [mã nguồn ứng dụng](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts#L37){rel="nofollow"} để biết tất cả các móc có sẵn.

| Hook                         | Arguments           | Environment     | Description                                                                                                                                                                                    |
| ---------------------------- | ------------------- | --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `app:created`                | `vueApp`            | Server & Client | Được gọi khi phiên bản `vueApp` ban đầu được tạo.                                                                                                                                              |
| `app:error`                  | `err`               | Server & Client | Được gọi khi xảy ra lỗi nghiêm trọng.                                                                                                                                                          |
| `app:error:cleared`          | `{ redirect? }`     | Server & Client | Được gọi khi lỗi nghiêm trọng xảy ra.                                                                                                                                                          |
| `vue:setup`                  | -                   | Server & Client | Được gọi khi thiết lập gốc của Nuxt được khởi tạo. Callback này phải đồng bộ.                                                                                                                  |
| `vue:error`                  | `err, target, info` | Server & Client | Được gọi khi lỗi vue lan truyền đến thành phần gốc. [Tìm hiểu thêm](https://vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured){rel="nofollow"}.                                     |
| `app:rendered`               | `renderContext`     | Server          | Được gọi khi kết xuất SSR hoàn tất.                                                                                                                                                            |
| `app:redirected`             | -                   | Server          | Được gọi trước khi chuyển hướng SSR.                                                                                                                                                           |
| `app:beforeMount`            | `vueApp`            | Client          | Được gọi trước khi gắn ứng dụng, chỉ được gọi ở phía máy khách.                                                                                                                                |
| `app:mounted`                | `vueApp`            | Client          | Được gọi khi Vue app được khởi tạo và gắn vào trình duyệt.                                                                                                                                     |
| `app:suspense:resolve`       | `appComponent`      | Client          | Khi sự kiện giải quyết [Suspense](https://vuejs.org/guide/built-ins/suspense.html#suspense){rel="nofollow"}.                                                                                   |
| `app:manifest:update`        | `{ id, timestamp }` | Client          | Được gọi khi phát hiện phiên bản mới hơn của ứng dụng.                                                                                                                                         |
| `app:data:refresh`           | `keys?`             | Client          | Được gọi khi `refreshNuxtData` được gọi.                                                                                                                                                       |
| `link:prefetch`              | `to`                | Client          | Được gọi khi `<NuxtLink>` được quan sát để được prefetch.                                                                                                                                      |
| `page:start`                 | `pageComponent?`    | Client          | Được gọi trên [Suspense](https://vuejs.org/guide/built-ins/suspense.html#suspense){rel="nofollow"} bên trong `NuxtPage` sự kiện đang chờ xử lý.                                                |
| `page:finish`                | `pageComponent?`    | Client          | Được gọi trên [Suspense](https://vuejs.org/guide/built-ins/suspense.html#suspense){rel="nofollow"} bên trong `NuxtPage` sự kiện đã giải quyết.                                                 |
| `page:loading:start`         | -                   | Client          | Được gọi khi `setup()` của trang mới đang chạy.                                                                                                                                                |
| `page:loading:end`           | -                   | Client          | Được gọi sau `page:finish`                                                                                                                                                                     |
| `page:transition:finish`     | `pageComponent?`    | Client          | Sau chuyển tiếp trang [onAfterLeave](https://vuejs.org/guide/built-ins/transition.html#javascript-hooks){rel="nofollow"} sự kiện.                                                              |
| `dev:ssr-logs`               | `logs`              | Client          | Được gọi với một mảng nhật ký phía máy chủ đã được truyền đến máy khách (nếu `features.devLogs` được bật).                                                                                     |
| `page:view-transition:start` | `transition`        | Client          | Được gọi sau khi `document.startViewTransition` được gọi khi [hỗ trợ viewTransition thử nghiệm được bật](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental). |

## Nuxt Hooks (build time)

Kiểm tra [mã nguồn schema](https://github.com/nuxt/nuxt/blob/main/packages/schema/src/types/hooks.ts#L83){rel="nofollow"} để biết tất cả các móc có sẵn.

| Hook                        | Arguments                                                | Description                                                                                                                                                                                                                                                                             |
| --------------------------- | -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `kit:compatibility`         | `compatibility, issues`                                  | Cho phép mở rộng kiểm tra tương thích.                                                                                                                                                                                                                                                  |
| `ready`                     | `nuxt`                                                   | Được gọi sau khi khởi tạo Nuxt, khi phiên bản Nuxt đã sẵn sàng hoạt động.                                                                                                                                                                                                               |
| `close`                     | `nuxt`                                                   | Được gọi khi phiên bản Nuxt đang đóng một cách nhẹ nhàng.                                                                                                                                                                                                                               |
| `restart`                   | `{ hard?: boolean }`                                     | Để được gọi để khởi động lại phiên bản Nuxt hiện tại.                                                                                                                                                                                                                                   |
| `modules:before`            | -                                                        | Được gọi trong quá trình khởi tạo Nuxt, trước khi cài đặt các module người dùng.                                                                                                                                                                                                        |
| `modules:done`              | -                                                        | Được gọi trong quá trình khởi tạo Nuxt, sau khi cài đặt các module người dùng.                                                                                                                                                                                                          |
| `app:resolve`               | `app`                                                    | Được gọi sau khi giải quyết phiên bản `app`.                                                                                                                                                                                                                                            |
| `app:templates`             | `app`                                                    | Được gọi trong quá trình tạo `NuxtApp`, để cho phép tùy chỉnh, sửa đổi hoặc thêm các tệp mới vào thư mục xây dựng (hoặc ảo hoặc ghi vào `.nuxt`).                                                                                                                                       |
| `app:templatesGenerated`    | `app`                                                    | Được gọi sau khi các mẫu được biên dịch vào [hệ thống tệp ảo](https://nuxt.com/docs/guide/directory-structure/nuxt#virtual-file-system) (vfs).                                                                                                                                          |
| `build:before`              | -                                                        | Được gọi trước khi trình xây dựng gói Nuxt.                                                                                                                                                                                                                                             |
| `build:done`                | -                                                        | Được gọi sau khi trình xây dựng gói Nuxt hoàn tất.                                                                                                                                                                                                                                      |
| `build:manifest`            | `manifest`                                               | Được gọi trong quá trình xây dựng manifest bởi Vite và webpack. Điều này cho phép tùy chỉnh manifest mà Nitro sẽ sử dụng để hiển thị thẻ `<script>` và `<link>` trong HTML cuối cùng.                                                                                                   |
| `builder:generateApp`       | `options`                                                | Được gọi trước khi tạo ứng dụng.                                                                                                                                                                                                                                                        |
| `builder:watch`             | `event, path`                                            | Được gọi tại thời điểm xây dựng trong phát triển khi trình theo dõi phát hiện thay đổi đối với tệp hoặc thư mục trong dự án.                                                                                                                                                            |
| `pages:extend`              | `pages`                                                  | Được gọi sau khi các tuyến trang được quét từ hệ thống tệp.                                                                                                                                                                                                                             |
| `pages:resolved`            | `pages`                                                  | Được gọi sau khi các tuyến trang được tăng cường với siêu dữ liệu được quét.                                                                                                                                                                                                            |
| `pages:routerOptions`       | `{ files: Array<{ path: string, optional?: boolean }> }` | Được gọi khi giải quyết `router.options` tệp. Các mục sau trong mảng ghi đè các mục trước đó.                                                                                                                                                                                           |
| `server:devHandler`         | `handler`                                                | Được gọi khi trình xử lý dev đang được đăng ký trên máy chủ Nitro dev.                                                                                                                                                                                                                  |
| `imports:sources`           | `presets`                                                | Được gọi tại thời điểm thiết lập cho phép các module mở rộng nguồn.                                                                                                                                                                                                                     |
| `imports:extend`            | `imports`                                                | Được gọi tại thời điểm thiết lập cho phép các module mở rộng nhập khẩu.                                                                                                                                                                                                                 |
| `imports:context`           | `context`                                                | Được gọi khi ngữ cảnh [unimport](https://github.com/unjs/unimport){rel="nofollow"} được tạo.                                                                                                                                                                                            |
| `imports:dirs`              | `dirs`                                                   | Cho phép mở rộng thư mục nhập khẩu.                                                                                                                                                                                                                                                     |
| `components:dirs`           | `dirs`                                                   | Được gọi trong `app:resolve` cho phép mở rộng các thư mục được quét để có các thành phần có thể nhập tự động.                                                                                                                                                                           |
| `components:extend`         | `components`                                             | Cho phép mở rộng các thành phần mới.                                                                                                                                                                                                                                                    |
| `nitro:config`              | `nitroConfig`                                            | Được gọi trước khi khởi tạo Nitro, cho phép tùy chỉnh cấu hình của Nitro.                                                                                                                                                                                                               |
| `nitro:init`                | `nitro`                                                  | Được gọi sau khi Nitro được khởi tạo, điều này cho phép đăng ký các móc Nitro và tương tác trực tiếp với Nitro.                                                                                                                                                                         |
| `nitro:build:before`        | `nitro`                                                  | Được gọi trước khi xây dựng phiên bản Nitro.                                                                                                                                                                                                                                            |
| `nitro:build:public-assets` | `nitro`                                                  | Được gọi sau khi sao chép tài sản công khai. Cho phép sửa đổi tài sản công khai trước khi máy chủ Nitro được xây dựng.                                                                                                                                                                  |
| `prerender:routes`          | `ctx`                                                    | Cho phép mở rộng các tuyến đường để prerender.                                                                                                                                                                                                                                          |
| `build:error`               | `error`                                                  | Được gọi khi xảy ra lỗi tại thời điểm xây dựng.                                                                                                                                                                                                                                         |
| `prepare:types`             | `options`                                                | Được gọi trước khi `@nuxt/cli` ghi các tệp cấu hình TypeScript (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, v.v.) và `.nuxt/nuxt.d.ts`, cho phép thêm các tham chiếu và khai báo tùy chỉnh trong `nuxt.d.ts`, hoặc trực tiếp sửa đổi các tùy chọn trong cấu hình được tạo. |
| `listen`                    | `listenerServer, listener`                               | Được gọi khi máy chủ dev đang tải.                                                                                                                                                                                                                                                      |
| `schema:extend`             | `schemas`                                                | Cho phép mở rộng các schema mặc định.                                                                                                                                                                                                                                                   |
| `schema:resolved`           | `schema`                                                 | Cho phép mở rộng schema đã giải quyết.                                                                                                                                                                                                                                                  |
| `schema:beforeWrite`        | `schema`                                                 | Được gọi trước khi ghi schema đã cho.                                                                                                                                                                                                                                                   |
| `schema:written`            | -                                                        | Được gọi sau khi schema được ghi.                                                                                                                                                                                                                                                       |
| `vite:extend`               | `viteBuildContext`                                       | Cho phép mở rộng ngữ cảnh Vite mặc định.                                                                                                                                                                                                                                                |
| `vite:extendConfig`         | `viteInlineConfig, env`                                  | Cho phép mở rộng cấu hình Vite mặc định.                                                                                                                                                                                                                                                |
| `vite:configResolved`       | `viteInlineConfig, env`                                  | Cho phép đọc cấu hình Vite đã giải quyết.                                                                                                                                                                                                                                               |
| `vite:serverCreated`        | `viteServer, env`                                        | Được gọi khi máy chủ Vite được tạo.                                                                                                                                                                                                                                                     |
| `vite:compiled`             | -                                                        | Được gọi sau khi máy chủ Vite được biên dịch.                                                                                                                                                                                                                                           |
| `webpack:config`            | `webpackConfigs`                                         | Được gọi trước khi cấu hình trình biên dịch webpack.                                                                                                                                                                                                                                    |
| `webpack:configResolved`    | `webpackConfigs`                                         | Cho phép đọc cấu hình webpack đã giải quyết.                                                                                                                                                                                                                                            |
| `webpack:compile`           | `options`                                                | Được gọi ngay trước khi biên dịch.                                                                                                                                                                                                                                                      |
| `webpack:compiled`          | `options`                                                | Được gọi sau khi tài nguyên được tải.                                                                                                                                                                                                                                                   |
| `webpack:change`            | `shortPath`                                              | Được gọi khi `change` trên WebpackBar.                                                                                                                                                                                                                                                  |
| `webpack:error`             | -                                                        | Được gọi khi `done` nếu có lỗi trên WebpackBar.                                                                                                                                                                                                                                         |
| `webpack:done`              | -                                                        | Được gọi khi `allDone` trên WebpackBar.                                                                                                                                                                                                                                                 |
| `webpack:progress`          | `statesArray`                                            | Được gọi khi `progress` trên WebpackBar.                                                                                                                                                                                                                                                |

## Nitro App Hooks (runtime, server-side)

Xem [Nitro](https://nitro.build/guide/plugins#available-hooks){rel="nofollow"} để biết tất cả các móc có sẵn.

| Hook              | Arguments                                  | Description                           | Types                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ----------------- | ------------------------------------------ | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dev:ssr-logs`    | `{ path, logs }`                           | Máy chủ                               | Được gọi ở cuối chu kỳ yêu cầu với một mảng nhật ký phía máy chủ.                                                                                                                                                                                                                                                                                                                                                                                       |
| `render:response` | `response, { event }`                      | Được gọi trước khi gửi phản hồi.      | [response](https://github.com/nuxt/nuxt/blob/71ef8bd3ff207fd51c2ca18d5a8c7140476780c7/packages/nuxt/src/core/runtime/nitro/renderer.ts#L24){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                         |
| `render:html`     | `html, { event }`                          | Được gọi trước khi xây dựng HTML.     | [html](https://github.com/nuxt/nuxt/blob/71ef8bd3ff207fd51c2ca18d5a8c7140476780c7/packages/nuxt/src/core/runtime/nitro/renderer.ts#L15){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                             |
| `render:island`   | `islandResponse, { event, islandContext }` | Được gọi trước khi xây dựng HTML đảo. | [islandResponse](https://github.com/nuxt/nuxt/blob/e50cabfed1984c341af0d0c056a325a8aec26980/packages/nuxt/src/core/runtime/nitro/renderer.ts#L28){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}, [islandContext](https://github.com/nuxt/nuxt/blob/e50cabfed1984c341af0d0c056a325a8aec26980/packages/nuxt/src/core/runtime/nitro/renderer.ts#L38){rel="nofollow"} |
| `close`           | -                                          | Được gọi khi Nitro được đóng.         | -                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `error`           | `error, { event? }`                        | Được gọi khi xảy ra lỗi.              | [error](https://github.com/nitrojs/nitro/blob/d20ffcbd16fc4003b774445e1a01e698c2bb078a/src/types/runtime/nitro.ts#L48){rel="nofollow"}, [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                                              |
| `request`         | `event`                                    | Được gọi khi nhận được yêu cầu.       | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}                                                                                                                                                                                                                                                                                                                                      |
| `beforeResponse`  | `event, { body }`                          | Được gọi trước khi gửi phản hồi.      | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}, unknown                                                                                                                                                                                                                                                                                                                             |
| `afterResponse`   | `event, { body }`                          | Được gọi sau khi gửi phản hồi.        | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38){rel="nofollow"}, unknown                                                                                                                                                                                                                                                                                                                             |


# Import meta

## The `import.meta` object

Với ES modules bạn có thể lấy một số siêu dữ liệu từ mã nhập khẩu hoặc biên dịch ES-module của bạn.
Điều này được thực hiện thông qua `import.meta`, là một đối tượng cung cấp mã của bạn với thông tin này.
Trong suốt tài liệu Nuxt bạn có thể thấy các đoạn mã sử dụng điều này để tìm ra mã hiện tại đang chạy trên phía máy khách hay máy chủ.

::read-more
---
to: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta
---
Đọc thêm về `import.meta`.
::

## Runtime (App) Properties

Những giá trị này được tiêm tĩnh và có thể được sử dụng để tree-shaking mã runtime của bạn.

| Property                | Type    | Description                                                                          |
| ----------------------- | ------- | ------------------------------------------------------------------------------------ |
| `import.meta.client`    | boolean | True khi được đánh giá trên phía máy khách.                                          |
| `import.meta.browser`   | boolean | True khi được đánh giá trên phía máy khách.                                          |
| `import.meta.server`    | boolean | True khi được đánh giá trên phía máy chủ.                                            |
| `import.meta.nitro`     | boolean | True khi được đánh giá trên phía máy chủ.                                            |
| `import.meta.dev`       | boolean | True khi chạy máy chủ dev Nuxt.                                                      |
| `import.meta.test`      | boolean | True khi chạy trong ngữ cảnh kiểm tra.                                               |
| `import.meta.prerender` | boolean | True khi hiển thị HTML trên máy chủ trong giai đoạn prerender của bản build của bạn. |

## Builder Properties

Những giá trị này có sẵn cả trong module và trong `nuxt.config` của bạn.

| Property          | Type   | Description                                   |
| ----------------- | ------ | --------------------------------------------- |
| `import.meta.env` | object | Bằng `process.env`                            |
| `import.meta.url` | string | Đường dẫn có thể giải quyết cho tệp hiện tại. |

## Examples

### Using `import.meta.url` to resolve files within modules

```ts [modules/my-module/index.ts]
import { createResolver } from 'nuxt/kit'

// Resolve relative from the current file
const resolver = createResolver(import.meta.url)

export default defineNuxtModule({
  meta: { name: 'myModule' },
  setup() {
    addComponent({
      name: 'MyModuleComponent',
      // Resolves to '/modules/my-module/components/MyModuleComponent.vue'
      filePath: resolver.resolve('./components/MyModuleComponent.vue')
    })
  }
})
```


# Nuxt Configuration

## alias

Bạn có thể cải thiện DX của mình bằng cách định nghĩa các bí danh bổ sung để truy cập các thư mục tùy chỉnh trong JavaScript và CSS của bạn.

- **Type**: `object`
- **Default**

```json
{
  "~": "/<srcDir>",
  "@": "/<srcDir>",
  "~~": "/<rootDir>",
  "@@": "/<rootDir>",
  "#shared": "/<rootDir>/shared",
  "assets": "/<srcDir>/assets",
  "public": "/<rootDir>/public",
  "#build": "/<rootDir>/.nuxt",
  "#internal/nuxt/paths": "/<rootDir>/.nuxt/paths.mjs"
}
```

::callout
**Lưu ý**: Trong ngữ cảnh webpack (nguồn hình ảnh, CSS - nhưng không phải JavaScript) bạn *phải* truy cập bí danh của mình bằng cách thêm tiền tố `~`.
::

::callout
**Lưu ý**: Các bí danh này sẽ được tự động thêm vào các cấu hình TypeScript được tạo (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, v.v.) để bạn có thể có hỗ trợ kiểu đầy đủ và tự động hoàn thành đường dẫn. Trong trường hợp bạn cần mở rộng các tùy chọn được cung cấp bởi các cấu hình được tạo thêm, hãy đảm bảo thêm chúng ở đây hoặc trong thuộc tính `typescript.tsConfig` trong `nuxt.config`.
::

**Example**:

```js
import { fileURLToPath } from "node:url";

export default defineNuxtConfig({
  alias: {
    'images': fileURLToPath(new URL('./assets/images', import.meta.url)),
    'style': fileURLToPath(new URL('./assets/style', import.meta.url)),
    'data': fileURLToPath(new URL('./assets/other/data', import.meta.url))
  }
})
```

```html
<template>
  <img src="~images/main-bg.jpg">
</template>

<script>
import data from 'data/test.json'
</script>

<style>
// Uncomment the below
//@import '~style/variables.scss';
//@import '~style/utils.scss';
//@import '~style/base.scss';
body {
  background-image: url('~images/main-bg.jpg');
}
</style>
```

## analyzeDir

Thư mục nơi Nuxt sẽ lưu trữ các tệp được tạo khi chạy `nuxt analyze`.

Nếu một đường dẫn tương đối được chỉ định, nó sẽ tương đối với `rootDir` của bạn.

- **Type**: `string`
- **Default:** `"/<rootDir>/.nuxt/analyze"`

## app

Cấu hình Ứng dụng Nuxt.

### `baseURL`

Đường dẫn cơ sở của ứng dụng Nuxt của bạn.

Ví dụ:

- **Type**: `string`
- **Default:** `"/"`

**Example**:

```ts
export default defineNuxtConfig({
  app: {
    baseURL: '/prefix/'
  }
})
```

Điều này cũng có thể được đặt tại thời gian chạy bằng cách đặt biến môi trường NUXT\_APP\_BASE\_URL.

**Example**:

```bash
NUXT_APP_BASE_URL=/prefix/ node .output/server/index.mjs
```

### `buildAssetsDir`

Tên thư mục cho các tài sản trang web được xây dựng, tương đối với `baseURL` (hoặc `cdnURL` nếu được đặt). Điều này được đặt tại thời gian xây dựng và không nên được tùy chỉnh tại thời gian chạy.

- **Type**: `string`
- **Default:** `"/_nuxt/"`

### `cdnURL`

Một URL tuyệt đối để phục vụ thư mục công khai từ đó (chỉ sản xuất).

Ví dụ:

- **Type**: `string`
- **Default:** `""`

**Example**:

```ts
export default defineNuxtConfig({
  app: {
    cdnURL: 'https://mycdn.org/'
  }
})
```

Điều này có thể được đặt thành một giá trị khác tại thời gian chạy bằng cách đặt biến môi trường `NUXT_APP_CDN_URL`.

**Example**:

```bash
NUXT_APP_CDN_URL=https://mycdn.org/ node .output/server/index.mjs
```

### `head`

Đặt cấu hình mặc định cho `<head>` trên mọi trang.

- **Type**: `object`
- **Default**

```json
{
  "meta": [
    {
      "name": "viewport",
      "content": "width=device-width, initial-scale=1"
    },
    {
      "charset": "utf-8"
    }
  ],
  "link": [],
  "style": [],
  "script": [],
  "noscript": []
}
```

**Example**:

```js
app: {
  head: {
    meta: [
      // <meta name="viewport" content="width=device-width, initial-scale=1">
      { name: 'viewport', content: 'width=device-width, initial-scale=1' }
    ],
    script: [
      // <script src="https://myawesome-lib.js"></script>
      { src: 'https://awesome-lib.js' }
    ],
    link: [
      // <link rel="stylesheet" href="https://myawesome-lib.css">
      { rel: 'stylesheet', href: 'https://awesome-lib.css' }
    ],
    // please note that this is an area that is likely to change
    style: [
      // <style>:root { color: red }</style>
      { textContent: ':root { color: red }' }
    ],
    noscript: [
      // <noscript>JavaScript is required</noscript>
      { textContent: 'JavaScript is required' }
    ]
  }
}
```

### `keepalive`

Giá trị mặc định cho cấu hình KeepAlive giữa các trang.

Điều này có thể được ghi đè với `definePageMeta` trên một trang riêng lẻ. Chỉ các giá trị có thể tuần tự hóa JSON được cho phép.

- **Type**: `boolean`
- **Default:** `false`

**Xem**: [Vue KeepAlive](https://vuejs.org/api/built-in-components.html#keepalive){rel="nofollow"}

### `layoutTransition`

Giá trị mặc định cho các chuyển tiếp bố cục.

Điều này có thể được ghi đè với `definePageMeta` trên một trang riêng lẻ. Chỉ các giá trị có thể tuần tự hóa JSON được cho phép.

- **Type**: `boolean`
- **Default:** `false`

**Xem**: [Vue Transition docs](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}

### `pageTransition`

Giá trị mặc định cho các chuyển tiếp trang.

Điều này có thể được ghi đè với `definePageMeta` trên một trang riêng lẻ. Chỉ các giá trị có thể tuần tự hóa JSON được cho phép.

- **Type**: `boolean`
- **Default:** `false`

**Xem**: [Vue Transition docs](https://vuejs.org/api/built-in-components.html#transition){rel="nofollow"}

### `rootAttrs`

Tùy chỉnh id phần tử gốc Nuxt.

- **Type**: `object`
- **Default**

```json
{
  "id": "__nuxt"
}
```

### `rootId`

Tùy chỉnh id phần tử gốc Nuxt.

- **Type**: `string`
- **Default:** `"__nuxt"`

### `rootTag`

Tùy chỉnh thẻ phần tử gốc Nuxt.

- **Type**: `string`
- **Default:** `"div"`

### `spaLoaderAttrs`

Tùy chỉnh thuộc tính phần tử mẫu tải SPA Nuxt.

- **Type**: `object`
- **Default:**

```json
{
" id": "__nuxt-loader"
}
```

#### `id`

- **Type**: `string`
- **Default:** `"__nuxt-loader"`

### `spaLoaderTag`

Tùy chỉnh thẻ phần tử SpaLoader Nuxt.

- **Type**: `string`
- **Default:** `"div"`

### `teleportAttrs`

Tùy chỉnh thuộc tính phần tử Teleport Nuxt.

- **Type**: `object`
- **Default**

```json
{
  "id": "teleports"
}
```

### `teleportId`

Tùy chỉnh id phần tử Teleport Nuxt.

- **Type**: `string`
- **Default:** `"teleports"`

### `teleportTag`

Tùy chỉnh thẻ phần tử Teleport Nuxt.

- **Type**: `string`
- **Default:** `"div"`

### `viewTransition`

Giá trị mặc định cho các chuyển tiếp chế độ xem.

Điều này chỉ có hiệu lực khi hỗ trợ **thử nghiệm** cho View Transitions được [bật trong tệp nuxt.config của bạn](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental).
Điều này có thể được ghi đè với `definePageMeta` trên một trang riêng lẻ.

- **Type**: `boolean`
- **Default:** `false`

**Xem**: [Nuxt View Transition API docs](https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental){rel="nofollow"}

## appConfig

Cấu hình ứng dụng bổ sung

Để sử dụng lập trình và hỗ trợ kiểu, bạn có thể cung cấp cấu hình ứng dụng trực tiếp với tùy chọn này. Nó sẽ được hợp nhất với tệp `app.config` làm giá trị mặc định.

### `nuxt`

## appId

Đối với các dự án đa ứng dụng, id duy nhất của ứng dụng Nuxt.

Mặc định là `nuxt-app`.

- **Type**: `string`
- **Default:** `"nuxt-app"`

## build

Cấu hình xây dựng chia sẻ.

### `analyze`

Nuxt cho phép trực quan hóa các gói của bạn và cách tối ưu hóa chúng.

Đặt thành `true` để bật phân tích gói, hoặc truyền một đối tượng với các tùy chọn: [cho webpack](https://github.com/webpack-contrib/webpack-bundle-analyzer#options-for-plugin){rel="nofollow"} hoặc [cho vite](https://github.com/btd/rollup-plugin-visualizer#options){rel="nofollow"}.

- **Type**: `object`
- **Default**

```json
{
  "template": "treemap",
  "projectRoot": "/<rootDir>",
  "filename": "/<rootDir>/.nuxt/analyze/{name}.html"
}
```

**Example**:

```js
analyze: {
  analyzerMode: 'static'
}
```

### `templates`

Khuyến nghị sử dụng `addTemplate` từ `@nuxt/kit` thay vì tùy chọn này.

- **Type**: `array`

**Example**:

```js
templates: [
  {
    src: '~/modules/support/plugin.js', // `src` can be absolute or relative
    dst: 'support.js', // `dst` is relative to project `.nuxt` dir
  }
]
```

### `transpile`

Nếu bạn muốn chuyển đổi các phụ thuộc cụ thể với Babel, bạn có thể thêm chúng ở đây. Mỗi mục trong transpile có thể là tên gói, một hàm, một chuỗi hoặc đối tượng regex khớp với tên tệp phụ thuộc.

Bạn cũng có thể sử dụng một hàm để chuyển đổi có điều kiện. Hàm sẽ nhận một đối tượng ({ isDev, isServer, isClient, isModern, isLegacy }).

- **Type**: `array`

**Example**:

```js
transpile: [({ isLegacy }) => isLegacy && 'ky']
```

## buildDir

Định nghĩa thư mục nơi các tệp Nuxt được xây dựng của bạn sẽ được đặt.

Nhiều công cụ giả định rằng `.nuxt` là một thư mục ẩn (vì nó bắt đầu bằng `.`). Nếu đó là một vấn đề, bạn có thể sử dụng tùy chọn này để ngăn chặn điều đó.

- **Type**: `string`
- **Default:** `"/<rootDir>/.nuxt"`

**Example**:

```js
export default {
  buildDir: 'nuxt-build'
}
```

## buildId

Một định danh duy nhất khớp với bản xây dựng. Điều này có thể chứa hash của trạng thái hiện tại của dự án.

- **Type**: `string`
- **Default:** `"4a2e2d30-418f-41df-8e58-ed5df06de7fd"`

## builder

Trình xây dựng để sử dụng cho việc đóng gói phần Vue của ứng dụng của bạn.

- **Type**: `string`
- **Default:** `"@nuxt/vite-builder"`

## compatibilityDate

Chỉ định ngày tương thích cho ứng dụng của bạn.

Điều này được sử dụng để kiểm soát hành vi của các preset trong Nitro, Nuxt Image và các module khác có thể thay đổi hành vi mà không có phiên bản chính.
Chúng tôi dự định cải thiện công cụ xung quanh tính năng này trong tương lai.

## components

Cấu hình tự động đăng ký thành phần Nuxt.

Bất kỳ thành phần nào trong các thư mục được cấu hình ở đây có thể được sử dụng trong toàn bộ các trang, bố cục (và các thành phần khác) của bạn mà không cần nhập chúng một cách rõ ràng.

- **Type**: `object`
- **Default**

```json
{
  "dirs": [
    {
      "path": "~/components/global",
      "global": true
    },
    "~/components"
  ]
}
```

**Xem**: [`components/` directory documentation](https://nuxt.com/docs/guide/directory-structure/components){rel="nofollow"}

## css

Bạn có thể định nghĩa các tệp/module/thư viện CSS mà bạn muốn đặt toàn cục (bao gồm trong mọi trang).

Nuxt sẽ tự động đoán loại tệp theo phần mở rộng của nó và sử dụng bộ xử lý trước thích hợp. Bạn vẫn sẽ cần cài đặt bộ tải cần thiết nếu bạn cần sử dụng chúng.

- **Type**: `array`

**Example**:

```js
css: [
  // Load a Node.js module directly (here it's a Sass file).
  'bulma',
  // CSS file in the project
  '~/assets/css/main.css',
  // SCSS file in the project
  '~/assets/css/main.scss'
]
```

## debug

Đặt thành `true` để bật chế độ gỡ lỗi.

Hiện tại, nó in ra tên hook và thời gian trên máy chủ, và ghi log đối số hook cũng trong trình duyệt.
Bạn cũng có thể đặt điều này thành một đối tượng để bật các tùy chọn gỡ lỗi cụ thể.

- **Type**: `boolean`
- **Default:** `false`

## dev

Nuxt có đang chạy ở chế độ phát triển hay không.

Thông thường, bạn không cần đặt điều này.

- **Type**: `boolean`
- **Default:** `false`

## devServer

### `cors`

Đặt tùy chọn CORS cho máy chủ dev

#### `origin`

- **Type**: `array`
- **Default**

```json
[
  {}
]
```

### `host`

Máy chủ dev lắng nghe host

### `https`

Có bật HTTPS hay không.

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
export default defineNuxtConfig({
  devServer: {
    https: {
      key: './server.key',
      cert: './server.crt'
    }
  }
})
```

### `loadingTemplate`

Mẫu để hiển thị màn hình tải

- **Type**: `function`

### `port`

Máy chủ dev lắng nghe port

- **Type**: `number`
- **Default:** `3000`

### `url`

URL máy chủ dev đang lắng nghe.

Điều này không nên được đặt trực tiếp vì nó sẽ luôn bị ghi đè bởi máy chủ dev với URL đầy đủ (để sử dụng module và nội bộ).

- **Type**: `string`
- **Default:** `"http://localhost:3000"`

## devServerHandlers

Các trình xử lý máy chủ chỉ phát triển Nitro.

- **Type**: `array`

**Xem**: [Nitro server routes documentation](https://nitro.build/guide/routing){rel="nofollow"}

## devtools

Bật Nuxt DevTools cho phát triển.

Các thay đổi đột phá cho devtools có thể không phản ánh trên phiên bản của Nuxt.

**Xem**: [Nuxt DevTools](https://devtools.nuxt.com/){rel="nofollow"} for more information.

## dir

Tùy chỉnh cấu trúc thư mục mặc định được sử dụng bởi Nuxt.

Tốt hơn là giữ nguyên mặc định trừ khi cần thiết.

### `app`

- **Type**: `string`
- **Default:** `"app"`

### `assets`

Thư mục tài sản (bí danh là `~assets` trong bản xây dựng của bạn).

- **Type**: `string`
- **Default:** `"assets"`

### `layouts`

Thư mục bố cục, mỗi tệp của nó sẽ được tự động đăng ký làm bố cục Nuxt.

- **Type**: `string`
- **Default:** `"layouts"`

### `middleware`

Thư mục middleware, mỗi tệp của nó sẽ được tự động đăng ký làm middleware Nuxt.

- **Type**: `string`
- **Default:** `"middleware"`

### `modules`

Thư mục module, mỗi tệp trong đó sẽ được tự động đăng ký làm module Nuxt.

- **Type**: `string`
- **Default:** `"modules"`

### `pages`

Thư mục sẽ được xử lý để tự động tạo các tuyến trang ứng dụng của bạn.

- **Type**: `string`
- **Default:** `"pages"`

### `plugins`

Thư mục plugin, mỗi tệp của nó sẽ được tự động đăng ký làm plugin Nuxt.

- **Type**: `string`
- **Default:** `"plugins"`

### `public`

Thư mục chứa các tệp tĩnh của bạn, sẽ được truy cập trực tiếp qua máy chủ Nuxt và sao chép vào thư mục `dist` khi ứng dụng của bạn được tạo.

- **Type**: `string`
- **Default:** `"public"`

### `shared`

Thư mục chia sẻ. Thư mục này được chia sẻ giữa ứng dụng và máy chủ.

- **Type**: `string`
- **Default:** `"shared"`

### `static`

- **Type**: `string`
- **Default:** `"public"`

## esbuild

### `options`

Cấu hình các tùy chọn esbuild chia sẻ được sử dụng trong Nuxt và truyền cho các trình xây dựng khác, chẳng hạn như Vite hoặc webpack.

#### `jsxFactory`

- **Type**: `string`
- **Default:** `"h"`

#### `jsxFragment`

- **Type**: `string`
- **Default:** `"Fragment"`

#### `target`

- **Type**: `string`
- **Default:** `"esnext"`

#### `tsconfigRaw`

- **Type**: `object`

## experimental

### `alwaysRunFetchOnKeyChange`

Có chạy `useFetch` khi khóa thay đổi hay không, ngay cả khi nó được đặt thành `immediate: false` và chưa được kích hoạt.

`useFetch` và `useAsyncData` sẽ luôn chạy khi khóa thay đổi nếu `immediate: true` hoặc nếu nó đã được kích hoạt.

- **Type**: `boolean`
- **Default:** `true`

### `appManifest`

Sử dụng manifest ứng dụng để tôn trọng quy tắc route ở phía client.

- **Type**: `boolean`
- **Default:** `true`

### `asyncContext`

Bật ngữ cảnh async gốc để có thể truy cập cho các composables lồng nhau

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt PR #20918](https://github.com/nuxt/nuxt/pull/20918){rel="nofollow"}

### `asyncEntry`

Đặt thành true để tạo điểm nhập async cho bundle Vue (để hỗ trợ liên kết module).

- **Type**: `boolean`
- **Default:** `false`

### `browserDevtoolsTiming`

Bật thời gian cho các hook ứng dụng Nuxt trong bảng hiệu suất của trình duyệt dựa trên Chromium.

Tính năng này thêm các dấu hiệu suất cho các hook Nuxt, cho phép bạn theo dõi thời gian thực thi của chúng trong tab Hiệu suất của trình duyệt. Điều này đặc biệt hữu ích để gỡ lỗi các vấn đề hiệu suất.

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Enable performance markers for Nuxt hooks in browser devtools
    browserDevtoolsTiming: true
  }
})
```

**See**: [PR #29922](https://github.com/nuxt/nuxt/pull/29922){rel="nofollow"}

**See**: [Chrome DevTools Performance API](https://developer.chrome.com/docs/devtools/performance/extension#tracks){rel="nofollow"}

### `buildCache`

Lưu cache các artifact build Nuxt/Nitro dựa trên hash của cấu hình và tệp nguồn.

Điều này chỉ hoạt động cho các tệp nguồn trong `srcDir` và `serverDir` cho các phần Vue/Nitro của ứng dụng của bạn.

- **Type**: `boolean`
- **Default:** `false`

### `checkOutdatedBuildInterval`

Đặt khoảng thời gian (tính bằng ms) để kiểm tra các build mới. Tắt khi `experimental.appManifest` là `false`.

Đặt thành `false` để tắt.

- **Type**: `number`
- **Default:** `3600000`

### `clientFallback`

Có bật thành phần thử nghiệm `<NuxtClientFallback>` để render nội dung trên client nếu có lỗi trong SSR hay không.

- **Type**: `boolean`
- **Default:** `false`

### `clientNodeCompat`

Tự động polyfill các import Node.js trong build client bằng `unenv`.

- **Type**: `boolean`
- **Default:** `false`

**See**: [unenv](https://github.com/unjs/unenv){rel="nofollow"}

**Note:** Để làm cho các global như `Buffer` hoạt động trong trình duyệt, bạn cần inject chúng thủ công.

```ts
import { Buffer } from 'node:buffer'

globalThis.Buffer = globalThis.Buffer || Buffer
```

### `compileTemplate`

Có sử dụng `lodash.template` để compile các template Nuxt hay không.

Cờ này sẽ bị xóa với bản phát hành v4 và chỉ tồn tại để kiểm tra nâng cao trong Nuxt v3.12+ hoặc trong [kênh phát hành nightly](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

- **Type**: `boolean`
- **Default:** `true`

### `componentIslands`

Hỗ trợ thử nghiệm component islands với `<NuxtIsland>` và tệp `.island.vue`.

Theo mặc định, nó được đặt thành 'auto', nghĩa là nó sẽ được bật chỉ khi có islands, server components hoặc server pages trong ứng dụng của bạn.

- **Type**: `string`
- **Default:** `"auto"`

### `configSchema`

Hỗ trợ schema cấu hình

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Issue #15592](https://github.com/nuxt/nuxt/issues/15592){rel="nofollow"}

### `cookieStore`

Bật hỗ trợ CookieStore để lắng nghe cập nhật cookie (nếu được hỗ trợ bởi trình duyệt) và làm mới giá trị ref `useCookie`.

- **Type**: `boolean`
- **Default:** `true`

**See**: [CookieStore](https://developer.mozilla.org/en-US/docs/Web/API/CookieStore){rel="nofollow"}

### `crossOriginPrefetch`

Bật prefetch cross-origin bằng Speculation Rules API.

- **Type**: `boolean`
- **Default:** `false`

### `debugModuleMutation`

Ghi lại các mutation đến `nuxt.options` trong ngữ cảnh module, giúp gỡ lỗi các thay đổi cấu hình được thực hiện bởi các module trong giai đoạn khởi tạo Nuxt.

Khi được bật, Nuxt sẽ theo dõi các module nào sửa đổi tùy chọn cấu hình, giúp dễ dàng theo dõi các thay đổi cấu hình không mong muốn.

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Enable tracking of config mutations by modules
    debugModuleMutation: true
  }
})
```

**See**: [PR #30555](https://github.com/nuxt/nuxt/pull/30555){rel="nofollow"}

### `decorators`

Bật việc sử dụng decorators thử nghiệm trong Nuxt và Nitro.

- **Type**: `boolean`
- **Default:** `false`

**See**: <https://github.com/tc39/proposal-decorators>{rel="nofollow"}

### `defaults`

Điều này cho phép chỉ định các tùy chọn mặc định cho các thành phần và composables cốt lõi của Nuxt.

Các tùy chọn này có thể sẽ được chuyển đến nơi khác trong tương lai, chẳng hạn như vào `app.config` hoặc vào thư mục `app/`.

#### `nuxtLink`

##### `componentName`

- **Type**: `string`
- **Default:** `"NuxtLink"`

##### `prefetch`

- **Type**: `boolean`
- **Default:** `true`

##### `prefetchOn`

###### `visibility`

- **Type**: `boolean`
- **Default:** `true`

#### `useAsyncData`

Các tùy chọn áp dụng cho `useAsyncData` (và do đó cũng cho `useFetch`)

##### `deep`

- **Type**: `boolean`
- **Default:** `true`

##### `errorValue`

- **Type**: `string`
- **Default:** `"null"`

##### `value`

- **Type**: `string`
- **Default:** `"null"`

#### `useFetch`

### `emitRouteChunkError`

Phát hook `app:chunkError` khi có lỗi tải chunk vite/webpack.

Theo mặc định, Nuxt cũng sẽ thực hiện reload route mới khi chunk thất bại tải khi điều hướng đến route mới (`automatic`).
Đặt `automatic-immediate` sẽ dẫn đến Nuxt thực hiện reload route hiện tại ngay khi chunk thất bại tải (thay vì chờ điều hướng).
Bạn có thể tắt xử lý tự động bằng cách đặt thành `false`, hoặc xử lý lỗi chunk thủ công bằng cách đặt thành `manual`.

- **Type**: `string`
- **Default:** `"automatic"`

**See**: [Nuxt PR #19038](https://github.com/nuxt/nuxt/pull/19038){rel="nofollow"}

### `enforceModuleCompatibility`

Nuxt có nên dừng lại nếu một module Nuxt không tương thích hay không.

- **Type**: `boolean`
- **Default:** `false`

### `externalVue`

Externalize `vue`, `@vue/*` và `vue-router` khi build.

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Issue #13632](https://github.com/nuxt/nuxt/issues/13632){rel="nofollow"}

### `extraPageMetaExtractionKeys`

Cấu hình các khóa bổ sung để trích xuất từ metadata trang khi sử dụng `scanPageMeta`.

Điều này cho phép các module truy cập metadata bổ sung từ metadata trang. Khuyến nghị tăng cường các loại NuxtPage với các khóa của bạn.

- **Type**: `array`

### `granularCachedData`

Có gọi và sử dụng kết quả từ `getCachedData` trên refresh thủ công cho `useAsyncData` và `useFetch` hay không.

- **Type**: `boolean`
- **Default:** `false`

### `headNext`

Sử dụng các tối ưu hóa head thử nghiệm mới:

- Thêm plugin head capo.js để render các tag trong head theo cách hiệu quả hơn. - Sử dụng plugin hydration hash để giảm hydration ban đầu
- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Discussion #22632](https://github.com/nuxt/nuxt/discussions/22632){rel="nofollow"}

### `inlineRouteRules`

Cho phép định nghĩa `routeRules` trực tiếp trong thư mục `~/pages` của bạn bằng `defineRouteRules`.

Các quy tắc được chuyển đổi (dựa trên đường dẫn) và áp dụng cho các yêu cầu server. Ví dụ, một quy tắc được định nghĩa trong `~/pages/foo/bar.vue` sẽ được áp dụng cho các yêu cầu `/foo/bar`. Một quy tắc trong `~/pages/foo/[id].vue` sẽ được áp dụng cho các yêu cầu `/foo/**`.
Để kiểm soát nhiều hơn, chẳng hạn như nếu bạn đang sử dụng `path` hoặc `alias` tùy chỉnh được đặt trong `definePageMeta` của trang, bạn nên đặt `routeRules` trực tiếp trong `nuxt.config` của bạn.

- **Type**: `boolean`
- **Default:** `false`

### `lazyHydration`

Bật cấu hình tự động các chiến lược hydration cho các thành phần `<Lazy>`.

Tính năng này thông minh xác định khi hydrate các thành phần lazy dựa trên visibility, thời gian idle, hoặc các trigger khác, cải thiện hiệu suất bằng cách trì hoãn hydration của các thành phần cho đến khi chúng được cần.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    lazyHydration: true // Enable smart hydration strategies for Lazy components
  }
})

// In your Vue components
<template>
  <Lazy>
    <ExpensiveComponent />
  </Lazy>
</template>
```

**See**: [PR #26468](https://github.com/nuxt/nuxt/pull/26468){rel="nofollow"}

### `localLayerAliases`

Giải quyết các alias `~`, `~~`, `@` và `@@` nằm trong các layer với tôn trọng đến thư mục nguồn và root của layer.

- **Type**: `boolean`
- **Default:** `true`

### `navigationRepaint`

Chờ một khung hình động duy nhất trước khi điều hướng, điều này cho cơ hội trình duyệt repaint, thừa nhận tương tác người dùng.

Nó có thể giảm INP khi điều hướng trên các route được prerender.

- **Type**: `boolean`
- **Default:** `true`

### `noVueServer`

Tắt endpoint renderer server vue trong nitro.

- **Type**: `boolean`
- **Default:** `false`

### `normalizeComponentNames`

Đảm bảo rằng các tên thành phần Vue được tạo tự động khớp với tên thành phần đầy đủ mà bạn sẽ sử dụng để auto-import thành phần.

- **Type**: `boolean`
- **Default:** `false`

### `parseErrorData`

Có parse `error.data` khi render trang lỗi server hay không.

- **Type**: `boolean`
- **Default:** `false`

### `payloadExtraction`

Khi tùy chọn này được bật (theo mặc định) payload của các trang được prerender sẽ được trích xuất

- **Type**: `boolean`
- **Default:** `true`

### `pendingWhenIdle`

Cho `useAsyncData` và `useFetch`, `pending` có nên là `true` khi dữ liệu chưa bắt đầu được fetch hay không.

- **Type**: `boolean`
- **Default:** `true`

### `polyfillVueUseHead`

Có thêm lớp tương thích cho các module, plugin hoặc mã người dùng dựa vào API `@vueuse/head` cũ hay không.

Điều này bị tắt để giảm bundle phía client khoảng \~0.5kb.

- **Type**: `boolean`
- **Default:** `false`

### `purgeCachedData`

Có dọn dẹp cache static và asyncData của Nuxt trên điều hướng route hay không.

Nuxt sẽ tự động purge dữ liệu cache từ `useAsyncData` và `nuxtApp.static.data`. Điều này giúp ngăn rò rỉ bộ nhớ và đảm bảo dữ liệu mới được tải khi cần, nhưng có thể tắt nó.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Disable automatic cache cleanup (default is true)
    purgeCachedData: false
  }
})
```

**See**: [PR #31379](https://github.com/nuxt/nuxt/pull/31379){rel="nofollow"}

### `relativeWatchPaths`

Có cung cấp đường dẫn tương đối trong hook `builder:watch` hay không.

Cờ này sẽ bị xóa với bản phát hành v4 và chỉ tồn tại để kiểm tra nâng cao trong Nuxt v3.12+ hoặc trong [kênh phát hành nightly](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

- **Type**: `boolean`
- **Default:** `true`

### `renderJsonPayloads`

Render payload JSON với hỗ trợ revive các loại phức tạp.

- **Type**: `boolean`
- **Default:** `true`

### `resetAsyncDataToUndefined`

`clear` và `clearNuxtData` có nên reset dữ liệu async về giá trị *mặc định* hay cập nhật thành `null`/`undefined`.

- **Type**: `boolean`
- **Default:** `true`

### `respectNoSSRHeader`

Cho phép tắt phản hồi SSR Nuxt bằng cách đặt header `x-nuxt-no-ssr`.

- **Type**: `boolean`
- **Default:** `false`

### `restoreState`

Có khôi phục trạng thái ứng dụng Nuxt từ `sessionStorage` khi reload trang sau lỗi chunk hoặc gọi `reloadNuxtApp()` thủ công hay không.

Để tránh lỗi hydration, nó sẽ được áp dụng chỉ sau khi ứng dụng Vue đã được mount, nghĩa là có thể có flicker trên load ban đầu.
Cân nhắc cẩn thận trước khi bật vì nó có thể gây ra hành vi không mong muốn, và cân nhắc cung cấp khóa rõ ràng cho `useState` vì khóa tự động tạo có thể không khớp qua các build.

- **Type**: `boolean`
- **Default:** `false`

### `scanPageMeta`

Cho phép expose một số metadata route được định nghĩa trong `definePageMeta` tại build-time cho các module (alias, name, path, redirect, props, middleware).

Điều này chỉ hoạt động với static hoặc strings/arrays chứ không phải biến hoặc assignment có điều kiện.

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt Issues #24770](https://github.com/nuxt/nuxt/issues/24770){rel="nofollow"}

### `sharedPrerenderData`

Tự động chia sẻ payload *data* giữa các trang được prerender. Điều này có thể dẫn đến cải thiện hiệu suất đáng kể khi prerender các site sử dụng `useAsyncData` hoặc `useFetch` và fetch cùng dữ liệu trong các trang khác nhau.

Đặc biệt quan trọng khi bật tính năng này để đảm bảo rằng bất kỳ khóa duy nhất nào của dữ liệu của bạn luôn có thể giải quyết thành cùng dữ liệu. Ví dụ, nếu bạn đang sử dụng `useAsyncData` để fetch dữ liệu liên quan đến một trang cụ thể, bạn nên cung cấp khóa khớp duy nhất với dữ liệu đó. (`useFetch` nên làm điều này tự động cho bạn.)

- **Type**: `boolean`
- **Default:** `false`

**Example**:

```ts
// This would be unsafe in a dynamic page (e.g. `[slug].vue`) because the route slug makes a difference
// to the data fetched, but Nuxt can't know that because it's not reflected in the key.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Instead, you should use a key that uniquely identifies the data fetched.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

### `spaLoadingTemplateLocation`

Tiếp tục hiển thị spa-loading-template cho đến khi suspense\:resolve

- **Type**: `string`
- **Default:** `"within"`

**See**: [Nuxt Issues #24770](https://github.com/nuxt/nuxt/issues/21721){rel="nofollow"}

### `templateImportResolution`

Tắt việc giải quyết import vào template Nuxt từ đường dẫn của module đã thêm template.

Theo mặc định, Nuxt cố gắng giải quyết import trong template tương đối với module đã thêm chúng. Đặt thành `false` tắt hành vi này, có thể hữu ích nếu bạn đang gặp xung đột giải quyết trong một số môi trường.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  experimental: {
    // Disable template import resolution from module path
    templateImportResolution: false
  }
})
```

**See**: [PR #31175](https://github.com/nuxt/nuxt/pull/31175){rel="nofollow"}

### `templateRouteInjection`

Theo mặc định, đối tượng route được trả về bởi composable `useRoute()` được auto-import được giữ đồng bộ với trang hiện tại đang xem trong `<NuxtPage>`. Điều này không đúng cho `useRoute` được export của `vue-router` hoặc đối tượng `$route` mặc định có sẵn trong template Vue của bạn.

Bằng cách bật tùy chọn này, một mixin sẽ được inject để giữ đối tượng template `$route` đồng bộ với `useRoute()` được quản lý của Nuxt.

- **Type**: `boolean`
- **Default:** `true`

### `templateUtils`

Có cung cấp đối tượng `templateUtils` legacy (với `serialize`, `importName` và `importSources`) khi compile template Nuxt hay không.

Cờ này sẽ bị xóa với bản phát hành v4 và chỉ tồn tại để kiểm tra nâng cao trong Nuxt v3.12+ hoặc trong [kênh phát hành nightly](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

- **Type**: `boolean`
- **Default:** `true`

### `treeshakeClientOnly`

Tree shakes nội dung của các thành phần client-only từ bundle server.

- **Type**: `boolean`
- **Default:** `true`

**See**: [Nuxt PR #5750](https://github.com/nuxt/framework/pull/5750){rel="nofollow"}

### `typedPages`

Bật router typed thử nghiệm mới sử dụng [unplugin-vue-router](https://github.com/posva/unplugin-vue-router){rel="nofollow"}.

- **Type**: `boolean`
- **Default:** `false`

### `viewTransition`

Bật tích hợp View Transition API với router phía client.

- **Type**: `boolean`
- **Default:** `false`

**See**: [View Transitions API](https://developer.chrome.com/docs/web-platform/view-transitions){rel="nofollow"}

### `watcher`

Đặt watcher thay thế sẽ được sử dụng làm dịch vụ watching cho Nuxt.

Nuxt sử dụng 'chokidar-granular' nếu thư mục nguồn của bạn giống với thư mục root của bạn. Điều này sẽ bỏ qua các thư mục cấp cao (như `node_modules` và `.git`) bị loại trừ khỏi watching.
Bạn có thể đặt thành `parcel` để sử dụng `@parcel/watcher`, có thể cải thiện hiệu suất trong dự án lớn hoặc trên nền tảng Windows.
Bạn cũng có thể đặt thành `chokidar` để watch tất cả tệp trong thư mục nguồn của bạn.

- **Type**: `string`
- **Default:** `"chokidar"`

**See**: [chokidar](https://github.com/paulmillr/chokidar){rel="nofollow"}

**See**: [@parcel/watcher](https://github.com/parcel-bundler/watcher){rel="nofollow"}

### `writeEarlyHints`

Ghi early hints khi sử dụng server node.

- **Type**: `boolean`
- **Default:** `false`

::callout
**Note**: nginx không hỗ trợ 103 Early hints trong phiên bản hiện tại.
::

## extends

Mở rộng dự án từ nhiều nguồn local hoặc remote.

Giá trị nên là string hoặc array của string trỏ đến thư mục nguồn hoặc đường dẫn cấu hình tương đối với cấu hình hiện tại.
Bạn có thể sử dụng `github:`, `gh:` `gitlab:` hoặc `bitbucket:`

**See**: [`c12` docs on extending config layers](https://github.com/unjs/c12#extending-config-layer-from-remote-sources){rel="nofollow"}

**See**: [`giget` documentation](https://github.com/unjs/giget){rel="nofollow"}

## extensions

Các phần mở rộng nên được giải quyết bởi Nuxt resolver.

- **Type**: `array`
- **Default**

```json
[
  ".js",
  ".jsx",
  ".mjs",
  ".ts",
  ".tsx",
  ".vue"
]
```

## features

Một số tính năng của Nuxt có sẵn trên cơ sở opt-in, hoặc có thể bị tắt dựa trên nhu cầu của bạn.

### `devLogs`

Truyền log server đến client khi bạn đang phát triển. Các log này có thể được xử lý trong hook `dev:ssr-logs`.

Nếu đặt thành `silent`, các log sẽ không được in ra console trình duyệt.

- **Type**: `boolean`
- **Default:** `false`

### `inlineStyles`

Inline styles khi render HTML (hiện tại chỉ vite).

Bạn cũng có thể truyền một hàm nhận đường dẫn của thành phần Vue và trả về boolean chỉ ra có inline styles cho thành phần đó hay không.

- **Type**: `boolean`
- **Default:** `(id) => id.includes('.vue')`

### `noScripts`

Tắt render của Nuxt scripts và JS resource hints. Bạn cũng có thể tắt scripts chi tiết hơn trong `routeRules`.

Nếu đặt thành 'production' hoặc `true`, JS sẽ bị tắt chỉ trong chế độ production.

- **Type**: `boolean`
- **Default:** `false`

## future

`future` là để opt-in sớm vào các tính năng mới sẽ trở thành mặc định trong phiên bản framework tương lai (có thể là major).

### `compatibilityVersion`

Điều này được sử dụng để bật truy cập sớm vào các tính năng hoặc cờ Nuxt.

Nó chưa thể cấu hình trong Nuxt 4, nhưng một khi chúng ta bắt đầu merge các thay đổi breaking cho v5, nó sẽ có thể bật.

### `multiApp`

Điều này bật truy cập sớm vào hỗ trợ multi-app thử nghiệm.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt Issue #21635](https://github.com/nuxt/nuxt/issues/21635){rel="nofollow"}

### `typescriptBundlerResolution`

Điều này bật chế độ giải quyết module 'Bundler' cho TypeScript, là cài đặt được khuyến nghị cho các framework như Nuxt và Vite.

Nó cải thiện hỗ trợ type khi sử dụng các thư viện hiện đại với `exports`.
Bạn có thể đặt thành false để sử dụng chế độ 'Node' legacy, là mặc định cho TypeScript.

- **Type**: `boolean`
- **Default:** `true`

**See**: [TypeScript PR implementing `bundler` module resolution](https://github.com/microsoft/TypeScript/pull/51669){rel="nofollow"}

## hooks

Hooks là listeners cho các sự kiện Nuxt thường được sử dụng trong modules, nhưng cũng có sẵn trong `nuxt.config`.

Nội bộ, hooks theo mẫu đặt tên sử dụng dấu hai chấm (ví dụ, build\:done).
Để dễ cấu hình, bạn cũng có thể cấu trúc chúng như một đối tượng hierarchical trong `nuxt.config` (như dưới).

**Example**:

```js
import fs from 'node:fs'
import path from 'node:path'
export default {
  hooks: {
    build: {
      done(builder) {
        const extraFilePath = path.join(
          builder.nuxt.options.buildDir,
          'extra-file'
        )
        fs.writeFileSync(extraFilePath, 'Something extra')
      }
    }
  }
}
```

## ignore

Tùy chỉnh hơn `ignorePrefix`: tất cả tệp khớp với các pattern glob được chỉ định trong mảng `ignore` sẽ bị bỏ qua khi build.

- **Type**: `array`
- **Default**

```json
[
  "**/*.stories.{js,cts,mts,ts,jsx,tsx}",
  "**/*.{spec,test}.{js,cts,mts,ts,jsx,tsx}",
  "**/*.d.{cts,mts,ts}",
  "**/.{pnpm-store,vercel,netlify,output,git,cache,data}",
  "**/*.sock",
  ".nuxt/analyze",
  ".nuxt",
  "**/-*.*"
]
```

## ignoreOptions

Truyền tùy chọn trực tiếp đến `node-ignore` (được Nuxt sử dụng để bỏ qua tệp).

**See**: [node-ignore](https://github.com/kaelzhang/node-ignore){rel="nofollow"}

**Example**:

```js
ignoreOptions: {
  ignorecase: false
}
```

## ignorePrefix

Bất kỳ tệp nào trong thư mục `pages/`, `layouts/`, `middleware/`, và `public/` sẽ bị bỏ qua trong quá trình build nếu tên tệp của nó bắt đầu với prefix được chỉ định bởi `ignorePrefix`. Điều này nhằm ngăn chặn một số tệp được xử lý hoặc phục vụ trong ứng dụng đã build. Theo mặc định, `ignorePrefix` được đặt thành '-', bỏ qua bất kỳ tệp nào bắt đầu với '-'.

- **Type**: `string`
- **Default:** `"-"`

## imports

Cấu hình cách Nuxt auto-import composables vào ứng dụng của bạn.

**See**: [Nuxt documentation](https://nuxt.com/docs/guide/directory-structure/composables){rel="nofollow"}

### `dirs`

Một mảng các thư mục tùy chỉnh sẽ được auto-import. Lưu ý rằng tùy chọn này sẽ không override các thư mục mặc định (\~/composables, \~/utils).

- **Type**: `array`

**Example**:

```js
imports: {
  // Auto-import pinia stores defined in `~/stores`
  dirs: ['stores']
}
```

### `global`

- **Type**: `boolean`
- **Default:** `false`

### `scan`

Có scan thư mục `composables/` và `utils/` của bạn cho composables để auto-import hay không. Auto-imports được đăng ký bởi Nuxt hoặc các module khác, chẳng hạn như imports từ `vue` hoặc `nuxt`, sẽ vẫn được bật.

- **Type**: `boolean`
- **Default:** `true`

## logLevel

Mức log khi build logs.

Mặc định là 'silent' khi chạy trong CI hoặc khi TTY không khả dụng. Tùy chọn này sau đó được sử dụng như 'silent' trong Vite và 'none' trong webpack

- **Type**: `string`
- **Default:** `"info"`

## modules

Modules là các phần mở rộng Nuxt có thể mở rộng chức năng cốt lõi của nó và thêm vô số tích hợp.

Mỗi module là một string (có thể tham chiếu đến một package, hoặc là đường dẫn đến tệp), một tuple với module là string đầu tiên và tùy chọn là đối tượng thứ hai, hoặc một hàm module inline.
Nuxt cố gắng giải quyết mỗi item trong mảng modules sử dụng node require path (trong `node_modules`) và sau đó sẽ được giải quyết từ project `srcDir` nếu alias `~` được sử dụng.

- **Type**: `array`

::callout
**Note**: Modules được thực thi tuần tự nên thứ tự là quan trọng. Đầu tiên, các modules được định nghĩa trong `nuxt.config.ts` được tải. Sau đó, modules được tìm thấy trong thư mục `modules/`
được thực thi, và chúng tải theo thứ tự alphabet.
::

**Example**:

```js
modules: [
  // Using package name
  '@nuxtjs/axios',
  // Relative to your project srcDir
  '~/modules/awesome.js',
  // Providing options
  ['@nuxtjs/google-analytics', { ua: 'X1234567' }],
  // Inline definition
  function () {}
]
```

## modulesDir

Được sử dụng để đặt các thư mục modules cho path resolving (ví dụ, webpack's `resolveLoading`, `nodeExternals` và `postcss`).

Đường dẫn cấu hình tương đối với `options.rootDir` (mặc định là thư mục làm việc hiện tại).
Đặt trường này có thể cần thiết nếu dự án của bạn được tổ chức như một mono-repository kiểu yarn workspace.

- **Type**: `array`
- **Default**

```json
[
  "/<rootDir>/node_modules"
]
```

**Example**:

```js
export default {
  modulesDir: ['../../node_modules']
}
```

## nitro

Cấu hình cho Nitro.

**See**: [Nitro configuration docs](https://nitro.build/config){rel="nofollow"}

### `routeRules`

- **Type**: `object`

### `runtimeConfig`

- **Type**: `object`
- **Default**

```json
{
  "public": {},
  "app": {
    "buildId": "4a2e2d30-418f-41df-8e58-ed5df06de7fd",
    "baseURL": "/",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  },
  "nitro": {
    "envPrefix": "NUXT_"
  }
}
```

## optimization

Cấu hình tối ưu hóa thời gian build.

### `asyncTransforms`

Tùy chọn được truyền trực tiếp đến transformer từ `unctx` bảo toàn ngữ cảnh async sau `await`.

#### `asyncFunctions`

- **Type**: `array`
- **Default**

```json
[
  "defineNuxtPlugin",
  "defineNuxtRouteMiddleware"
]
```

#### `objectDefinitions`

##### `defineNuxtComponent`

- **Type**: `array`
- **Default**

```json
[
  "asyncData",
  "setup"
]
```

##### `defineNuxtPlugin`

- **Type**: `array`
- **Default**

```json
[
  "setup"
]
```

##### `definePageMeta`

- **Type**: `array`
- **Default**

```json
[
  "middleware",
  "validate"
]
```

### `keyedComposables`

Các hàm để inject khóa cho.

Miễn là số lượng đối số được truyền cho hàm nhỏ hơn `argumentLength`, một chuỗi magic bổ sung sẽ được inject có thể được sử dụng để deduplicate requests giữa server và client. Bạn sẽ cần thực hiện các bước để xử lý khóa bổ sung này.
Khóa sẽ duy nhất dựa trên vị trí của hàm được gọi trong tệp.

- **Type**: `array`
- **Default**

```json
[
  {
    "name": "callOnce",
    "argumentLength": 3
  },
  {
    "name": "defineNuxtComponent",
    "argumentLength": 2
  },
  {
    "name": "useState",
    "argumentLength": 2
  },
  {
    "name": "useFetch",
    "argumentLength": 3
  },
  {
    "name": "useAsyncData",
    "argumentLength": 3
  },
  {
    "name": "useLazyAsyncData",
    "argumentLength": 3
  },
  {
    "name": "useLazyFetch",
    "argumentLength": 3
  }
]
```

### `treeShake`

Tree shake code từ các build cụ thể.

#### `composables`

Tree shake composables từ server hoặc client builds.

**Example**:

```js
treeShake: { client: { myPackage: ['useServerOnlyComposable'] } }
```

##### `client`

- **Type**: `object`
- **Default**

```json
{
  "vue": [
    "onRenderTracked",
    "onRenderTriggered",
    "onServerPrefetch"
  ],
  "#app": [
    "definePayloadReducer",
    "definePageMeta",
    "onPrehydrate"
  ]
}
```

##### `server`

- **Type**: `object`
- **Default**

```json
{
  "vue": [
    "onMounted",
    "onUpdated",
    "onUnmounted",
    "onBeforeMount",
    "onBeforeUpdate",
    "onBeforeUnmount",
    "onRenderTracked",
    "onRenderTriggered",
    "onActivated",
    "onDeactivated"
  ],
  "#app": [
    "definePayloadReviver",
    "definePageMeta"
  ]
}
```

## pages

Có sử dụng tích hợp vue-router trong Nuxt 3 hay không. Nếu bạn không cung cấp giá trị, nó sẽ được bật nếu bạn có thư mục `pages/` trong thư mục nguồn của bạn.

Ngoài ra, bạn có thể cung cấp pattern glob hoặc mảng các pattern để scan chỉ các tệp nhất định cho pages.

**Example**:

```js
pages: {
  pattern: ['**\/*\/*.vue', '!**\/*.spec.*'],
}
```

## plugins

Một mảng các plugin ứng dụng nuxt.

Mỗi plugin có thể là một string (có thể là đường dẫn tuyệt đối hoặc tương đối đến tệp). Nếu nó kết thúc bằng `.client` hoặc `.server` thì nó sẽ tự động được tải chỉ trong ngữ cảnh phù hợp.
Nó cũng có thể là một đối tượng với khóa `src` và `mode`.

- **Type**: `array`

::callout
**Note**: Plugins cũng được auto-registered từ thư mục `~/plugins`
và các plugin này không cần được liệt kê trong `nuxt.config` trừ khi bạn
cần tùy chỉnh thứ tự của chúng. Tất cả plugins được deduplicated theo src path của chúng.
::

**See**: [`plugins/` directory documentation](https://nuxt.com/docs/guide/directory-structure/plugins){rel="nofollow"}

**Example**:

```js
plugins: [
  '~/plugins/foo.client.js', // only in client side
  '~/plugins/bar.server.js', // only in server side
  '~/plugins/baz.js', // both client & server
  { src: '~/plugins/both-sides.js' },
  { src: '~/plugins/client-only.js', mode: 'client' }, // only on client side
  { src: '~/plugins/server-only.js', mode: 'server' } // only on server side
]
```

## postcss

### `order`

Một chiến lược để ordering PostCSS plugins.

- **Type**: `function`

### `plugins`

Tùy chọn để cấu hình PostCSS plugins.

**See**: [PostCSS docs](https://postcss.org/){rel="nofollow"}

#### `autoprefixer`

Plugin để parse CSS và thêm vendor prefixes vào CSS rules.

**See**: [`autoprefixer`](https://github.com/postcss/autoprefixer){rel="nofollow"}

#### `cssnano`

- **Type**: `object`

**See**: [`cssnano` configuration options](https://cssnano.github.io/cssnano/docs/config-file/#configuration-options){rel="nofollow"}

## rootDir

Định nghĩa thư mục root của ứng dụng của bạn.

Thuộc tính này có thể bị overwrite (ví dụ, chạy `nuxt ./my-app/` sẽ đặt `rootDir` thành đường dẫn tuyệt đối của `./my-app/` từ thư mục làm việc hiện tại.
Nó thường không cần cấu hình tùy chọn này.

- **Type**: `string`
- **Default:** `"/<rootDir>"`

## routeRules

Tùy chọn route global áp dụng cho các server routes khớp.

**Experimental**: Đây là tính năng thử nghiệm và API có thể thay đổi trong tương lai.

**See**: [Nitro route rules documentation](https://nitro.build/config#routerules){rel="nofollow"}

## router

### `options`

Tùy chọn router bổ sung được truyền đến `vue-router`. Ngoài các tùy chọn cho `vue-router`, Nuxt cung cấp các tùy chọn bổ sung để tùy chỉnh router (xem dưới).

::callout
**Note**: Chỉ các tùy chọn JSON serializable nên được truyền bởi Nuxt config.
Để kiểm soát nhiều hơn, bạn có thể sử dụng tệp `router.options.ts`.
::

**See**: [Vue Router documentation](https://router.vuejs.org/api/interfaces/routeroptions.html){rel="nofollow"}.

#### `hashMode`

Bạn có thể bật hash history trong chế độ SPA. Trong chế độ này, router sử dụng ký tự hash (#) trước URL thực tế được truyền nội bộ. Khi được bật, **URL không bao giờ được gửi đến server** và **SSR không được hỗ trợ**.

- **Type**: `boolean`
- **Default:** `false`

**Default**: false

#### `scrollBehaviorType`

Tùy chỉnh hành vi scroll cho hash links.

- **Type**: `string`
- **Default:** `"auto"`

**Default**: 'auto'

## runtimeConfig

Runtime config cho phép truyền config động và biến môi trường đến ngữ cảnh ứng dụng Nuxt.

Giá trị của đối tượng này có thể truy cập từ server chỉ sử dụng `useRuntimeConfig`.
Nó chủ yếu nên chứa cấu hình *private* không được expose trên frontend. Điều này có thể bao gồm tham chiếu đến các token bí mật API của bạn.
Bất kỳ thứ gì dưới `public` và `app` sẽ được expose trên frontend cũng.
Giá trị được tự động thay thế bởi env variables khớp tại runtime, ví dụ đặt biến môi trường `NUXT_API_KEY=my-api-key NUXT_PUBLIC_BASE_URL=/foo/` sẽ overwrite hai giá trị trong ví dụ dưới.

- **Type**: `object`
- **Default**

```json
{
  "public": {},
  "app": {
    "buildId": "4a2e2d30-418f-41df-8e58-ed5df06de7fd",
    "baseURL": "/",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  }
}
```

**Example**:

```js
export default {
  runtimeConfig: {
    apiKey: '', // Default to an empty string, automatically set at runtime using process.env.NUXT_API_KEY
    public: {
       baseURL: '' // Exposed to the frontend as well.
    }
  }
}
```

## serverDir

Định nghĩa thư mục server của ứng dụng Nuxt của bạn, nơi các routes, middleware và plugins của Nitro được giữ.

Nếu đường dẫn tương đối được chỉ định, nó sẽ tương đối với `rootDir` của bạn.

- **Type**: `string`
- **Default:** `"/<srcDir>/server"`

## serverHandlers

Nitro server handlers.

Mỗi handler chấp nhận các tùy chọn sau:

- handler: Đường dẫn đến tệp định nghĩa handler. - route: Route mà handler có sẵn dưới đó. Điều này theo quy ước của [rou3](https://github.com/unjs/rou3){rel="nofollow"}. - method: HTTP method của requests nên được xử lý. - middleware: Chỉ định có phải là middleware handler hay không. - lazy: Chỉ định có sử dụng lazy loading để import handler hay không.
- **Type**: `array`

**See**: [`server/` directory documentation](https://nuxt.com/docs/guide/directory-structure/server){rel="nofollow"}

::callout
**Note**: Tệp từ `server/api`, `server/middleware` và `server/routes` sẽ được tự động đăng ký bởi Nuxt.
::

**Example**:

```js
serverHandlers: [
  { route: '/path/foo/**:name', handler: '~/server/foohandler.ts' }
]
```

## sourcemap

Cấu hình có và như thế nào sourcemaps được tạo cho server và/hoặc client bundles.

Nếu đặt thành một boolean duy nhất, giá trị đó áp dụng cho cả server và client. Ngoài ra, tùy chọn `'hidden'` cũng có sẵn cho cả server và client.
Tùy chọn có sẵn cho cả client và server: - `true`: Tạo sourcemaps và bao gồm tham chiếu nguồn trong bundle cuối. - `false`: Không tạo sourcemaps nào. - `'hidden'`: Tạo sourcemaps nhưng không bao gồm tham chiếu trong bundle cuối.

- **Type**: `object`
- **Default**

```json
{
  "server": true,
  "client": false
}
```

## spaLoadingTemplate

Boolean hoặc đường dẫn đến tệp HTML với nội dung của nó sẽ được chèn vào bất kỳ trang HTML nào được render với `ssr: false`.

- Nếu nó không được đặt, nó sẽ sử dụng tệp `~/spa-loading-template.html` trong một trong các layers của bạn, nếu tồn tại. - Nếu nó là false, không có chỉ báo tải SPA nào sẽ được tải. - Nếu true, Nuxt sẽ tìm tệp `~/spa-loading-template.html` trong một trong các layers của bạn, hoặc một
  hình ảnh Nuxt mặc định sẽ được sử dụng.
  Một số nguồn tốt cho spinners là [SpinKit](https://github.com/tobiasahlin/SpinKit){rel="nofollow"} hoặc [SVG Spinners](https://icones.js.org/collection/svg-spinners){rel="nofollow"}.
- **Default:** `null`

**Example**: \~/spa-loading-template.html

```html
<!-- https://github.com/barelyhuman/snips/blob/dev/pages/css-loader.md -->
<div class="loader"></div>
<style>
.loader {
  display: block;
  position: fixed;
  z-index: 1031;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 18px;
  height: 18px;
  box-sizing: border-box;
  border: solid 2px transparent;
  border-top-color: #000;
  border-left-color: #000;
  border-bottom-color: #efefef;
  border-right-color: #efefef;
  border-radius: 50%;
  -webkit-animation: loader 400ms linear infinite;
  animation: loader 400ms linear infinite;
}

@-webkit-keyframes loader {
  0% {
    -webkit-transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    -webkit-transform: translate(-50%, -50%) rotate(360deg);
  }
}
@keyframes loader {
  0% {
    transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}
</style>
```

## srcDir

Định nghĩa thư mục nguồn của ứng dụng Nuxt của bạn.

Nếu đường dẫn tương đối được chỉ định, nó sẽ tương đối với `rootDir`.

- **Type**: `string`
- **Default:** `"app"` (Nuxt 4), `"."` (Nuxt 3 with `compatibilityMode: 3`)

**Example**:

```js
export default {
  srcDir: 'app/'
}
```

Điều này mong đợi cấu trúc thư mục sau:

```bash
-| app/
---| assets/
---| components/
---| layouts/
---| middleware/
---| pages/
---| plugins/
---| app.config.ts
---| app.vue
---| error.vue
-| server/
-| public/
-| modules/
-| nuxt.config.js
-| package.json
```

## ssr

Có bật render HTML hay không - hoặc động (trong chế độ server) hoặc tại thời điểm generate. Nếu đặt thành `false` các trang được generate sẽ không có nội dung.

- **Type**: `boolean`
- **Default:** `true`

## telemetry

Tắt thủ công nuxt telemetry.

**See**: [Nuxt Telemetry](https://github.com/nuxt/telemetry){rel="nofollow"} để biết thêm thông tin.

## test

Ứng dụng của bạn có đang được unit tested hay không.

- **Type**: `boolean`
- **Default:** `false`

## theme

Mở rộng dự án từ nguồn local hoặc remote.

Giá trị nên là string trỏ đến thư mục nguồn hoặc đường dẫn cấu hình tương đối với cấu hình hiện tại.
Bạn có thể sử dụng `github:`, `gitlab:`, `bitbucket:` hoặc `https://` để mở rộng từ git repository remote.

- **Type**: `string`

## typescript

Cấu hình cho tích hợp TypeScript của Nuxt.

### `builder`

Loại builder types nào để bao gồm cho dự án của bạn.

Theo mặc định Nuxt suy luận điều này dựa trên tùy chọn `builder` của bạn (mặc định là 'vite') nhưng bạn có thể tắt builder environment types (với `false`) để xử lý hoàn toàn tự mình, hoặc chọn tùy chọn 'shared'.
Tùy chọn 'shared' được khuyên dùng cho tác giả module, những người sẽ muốn hỗ trợ nhiều builders có thể.

- **Default:** `null`

### `hoist`

Modules để tạo deep aliases cho trong `compilerOptions.paths`. Điều này chưa hỗ trợ subpaths. Nó có thể cần thiết khi sử dụng Nuxt trong pnpm monorepo với `shamefully-hoist=false`.

- **Type**: `array`
- **Default**

```json
[
  "nitropack/types",
  "nitropack/runtime",
  "nitropack",
  "defu",
  "h3",
  "consola",
  "ofetch",
  "@unhead/vue",
  "@nuxt/devtools",
  "vue",
  "@vue/runtime-core",
  "@vue/compiler-sfc",
  "vue-router",
  "vue-router/auto-routes",
  "unplugin-vue-router/client",
  "@nuxt/schema",
  "nuxt"
]
```

### `includeWorkspace`

Bao gồm parent workspace trong dự án Nuxt. Hữu ích chủ yếu cho themes và tác giả module.

- **Type**: `boolean`
- **Default:** `false`

### `shim`

Tạo shim `*.vue`.

Chúng tôi khuyến nghị thay vào đó để [official Vue extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar){rel="nofollow"} tạo types chính xác cho các thành phần của bạn.
Lưu ý rằng bạn có thể muốn đặt thành `true` nếu bạn đang sử dụng các thư viện khác, chẳng hạn như ESLint, không thể hiểu type của tệp `.vue`.

- **Type**: `boolean`
- **Default:** `false`

### `strict`

TypeScript đi kèm với một số checks để cung cấp cho bạn an toàn và phân tích chương trình của bạn nhiều hơn. Một khi bạn đã chuyển đổi codebase của mình sang TypeScript, bạn có thể bắt đầu bật các checks này để an toàn lớn hơn. [Đọc Thêm](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks){rel="nofollow"}

- **Type**: `boolean`
- **Default:** `true`

### `tsConfig`

Bạn có thể mở rộng các cấu hình TypeScript được tạo (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, v.v.) sử dụng tùy chọn này.

### `typeCheck`

Bật type checking thời gian build.

Nếu đặt thành true, điều này sẽ type check trong development. Bạn có thể hạn chế thành build-time type checking bằng cách đặt thành `build`. Yêu cầu cài đặt `typescript` và `vue-tsc` như dev dependencies.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt TypeScript docs](https://nuxt.com/docs/guide/concepts/typescript){rel="nofollow"}

## unhead

Một đối tượng cho phép chúng ta cấu hình module `unhead` của Nuxt.

### `legacy`

Bật chế độ tương thích legacy cho module `unhead`. Điều này áp dụng các thay đổi sau: - Tắt sắp xếp Capo.js - Thêm `DeprecationsPlugin`: hỗ trợ `hid`, `vmid`, `children`, `body` - Thêm `PromisesPlugin`: hỗ trợ promises làm input

- **Type**: `boolean`
- **Default:** `false`

**See**: [`unhead` migration documentation](https://unhead.unjs.io/docs/typescript/head/guides/get-started/migration){rel="nofollow"}

**Example**:

```ts
export default defineNuxtConfig({
 unhead: {
  legacy: true
})
```

### `renderSSRHeadOptions`

Một đối tượng sẽ được truyền đến `renderSSRHead` để tùy chỉnh output.

- **Type**: `object`
- **Default**

```json
{
  "omitLineBreaks": false
}
```

**Example**:

```ts
export default defineNuxtConfig({
 unhead: {
  renderSSRHeadOptions: {
   omitLineBreaks: true
  }
})
```

## vite

Cấu hình sẽ được truyền trực tiếp đến Vite.

**See**: [Vite configuration docs](https://vite.dev/config){rel="nofollow"} để biết thêm thông tin.
Lưu ý rằng không phải tất cả tùy chọn vite đều được hỗ trợ trong Nuxt.

### `build`

#### `assetsDir`

- **Type**: `string`
- **Default:** `"_nuxt/"`

#### `emptyOutDir`

- **Type**: `boolean`
- **Default:** `false`

### `cacheDir`

- **Type**: `string`
- **Default:** `"/<rootDir>/node_modules/.cache/vite"`

### `clearScreen`

- **Type**: `boolean`
- **Default:** `true`

### `define`

- **Type**: `object`
- **Default**

```json
{
  "__VUE_PROD_HYDRATION_MISMATCH_DETAILS__": false,
  "process.dev": false,
  "import.meta.dev": false,
  "process.test": false,
  "import.meta.test": false
}
```

### `esbuild`

- **Type**: `object`
- **Default**

```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

### `mode`

- **Type**: `string`
- **Default:** `"production"`

### `optimizeDeps`

#### `esbuildOptions`

- **Type**: `object`
- **Default**

```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

#### `exclude`

- **Type**: `array`
- **Default**

```json
[
  "vue-demi"
]
```

### `publicDir`

### `resolve`

#### `extensions`

- **Type**: `array`
- **Default**

```json
[
  ".mjs",
  ".js",
  ".ts",
  ".jsx",
  ".tsx",
  ".json",
  ".vue"
]
```

### `root`

- **Type**: `string`
- **Default:** `"/<srcDir>"`

### `server`

#### `fs`

##### `allow`

- **Type**: `array`
- **Default**

```json
[
  "/<rootDir>/.nuxt",
  "/<srcDir>",
  "/<rootDir>",
  "/<workspaceDir>"
]
```

### `vue`

#### `features`

##### `propsDestructure`

- **Type**: `boolean`
- **Default:** `true`

#### `isProduction`

- **Type**: `boolean`
- **Default:** `true`

#### `script`

##### `hoistStatic`

#### `template`

##### `compilerOptions`

- **Type**: `object`

##### `transformAssetUrls`

- **Type**: `object`
- **Default**

```json
{
  "video": [
    "src",
    "poster"
  ],
  "source": [
    "src"
  ],
  "img": [
    "src"
  ],
  "image": [
    "xlink:href",
    "href"
  ],
  "use": [
    "xlink:href",
    "href"
  ]
}
```

### `vueJsx`

- **Type**: `object`
- **Default**

```json
{
  "isCustomElement": {
    "$schema": {
      "title": "",
      "description": "",
      "tags": []
    }
  }
}
```

## vue

Cấu hình Vue.js

### `compilerOptions`

Tùy chọn cho Vue compiler sẽ được truyền tại build time.

**See**: [Vue documentation](https://vuejs.org/api/application.html#app-config-compileroptions){rel="nofollow"}

### `config`

Có thể truyền cấu hình Vue app globally. Chỉ các tùy chọn serializable có thể được đặt trong `nuxt.config` của bạn. Tất cả các tùy chọn khác nên được đặt tại runtime trong Nuxt plugin..

**See**: [Vue app config documentation](https://vuejs.org/api/application.html#app-config){rel="nofollow"}

### `propsDestructure`

Bật reactive destructure cho `defineProps`

- **Type**: `boolean`
- **Default:** `true`

### `runtimeCompiler`

Bao gồm Vue compiler trong runtime bundle.

- **Type**: `boolean`
- **Default:** `false`

### `transformAssetUrls`

#### `image`

- **Type**: `array`
- **Default**

```json
[
  "xlink:href",
  "href"
]
```

#### `img`

- **Type**: `array`
- **Default**

```json
[
  "src"
]
```

#### `source`

- **Type**: `array`
- **Default**

```json
[
  "src"
]
```

#### `use`

- **Type**: `array`
- **Default**

```json
[
  "xlink:href",
  "href"
]
```

#### `video`

- **Type**: `array`
- **Default**

```json
[
  "src",
  "poster"
]
```

## watch

Thuộc tính watch cho phép bạn định nghĩa patterns sẽ restart Nuxt dev server khi changed.

Nó là một mảng của strings hoặc regular expressions. Strings nên là absolute paths hoặc relative đến `srcDir` (và `srcDir` của bất kỳ layers nào). Regular expressions sẽ được matched với path relative đến project `srcDir` (và `srcDir` của bất kỳ layers nào).

- **Type**: `array`

## watchers

Thuộc tính watchers cho phép bạn overwrite cấu hình watchers trong `nuxt.config` của bạn.

### `chokidar`

Tùy chọn để truyền trực tiếp đến `chokidar`.

**See**: [chokidar](https://github.com/paulmillr/chokidar#api){rel="nofollow"}

#### `ignoreInitial`

- **Type**: `boolean`
- **Default:** `true`

#### `ignorePermissionErrors`

- **Type**: `boolean`
- **Default:** `true`

### `rewatchOnRawEvents`

Một mảng của event types, khi nhận được, sẽ khiến watcher restart.

### `webpack`

`watchOptions` để truyền trực tiếp đến webpack.

**See**: [webpack@4 watch options](https://v4.webpack.js.org/configuration/watch/#watchoptions){rel="nofollow"}.

#### `aggregateTimeout`

- **Type**: `number`
- **Default:** `1000`

## webpack

### `aggressiveCodeRemoval`

Hard-replaces `typeof process`, `typeof window` và `typeof document` để tree-shake bundle.

- **Type**: `boolean`
- **Default:** `false`

### `analyze`

Nuxt sử dụng `webpack-bundle-analyzer` để visualize bundles của bạn và cách tối ưu hóa chúng.

Đặt thành `true` để bật bundle analysis, hoặc truyền một đối tượng với tùy chọn: [for webpack](https://github.com/webpack-contrib/webpack-bundle-analyzer#options-for-plugin){rel="nofollow"} hoặc [for vite](https://github.com/btd/rollup-plugin-visualizer#options){rel="nofollow"}.

- **Type**: `object`
- **Default**

```json
{
  "template": "treemap",
  "projectRoot": "/<rootDir>",
  "filename": "/<rootDir>/.nuxt/analyze/{name}.html"
}
```

**Example**:

```js
analyze: {
  analyzerMode: 'static'
}
```

### `cssSourceMap`

Bật hỗ trợ CSS source map (mặc định là `true` trong development).

- **Type**: `boolean`
- **Default:** `false`

### `devMiddleware`

Xem [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware){rel="nofollow"} để biết tùy chọn có sẵn.

#### `stats`

- **Type**: `string`
- **Default:** `"none"`

### `experiments`

Cấu hình [webpack experiments](https://webpack.js.org/configuration/experiments/){rel="nofollow"}

### `extractCSS`

Bật Common CSS Extraction.

Sử dụng [mini-css-extract-plugin](https://github.com/webpack-contrib/mini-css-extract-plugin){rel="nofollow"} dưới hood, CSS của bạn sẽ được trích xuất vào các tệp riêng biệt, thường là một mỗi component. Điều này cho phép caching CSS và JavaScript của bạn riêng biệt.

- **Type**: `boolean`
- **Default:** `true`

**Example**:

```js
export default {
  webpack: {
    extractCSS: true,
    // or
    extractCSS: {
      ignoreOrder: true
    }
  }
}
```

Nếu bạn muốn trích xuất tất cả CSS của bạn vào một tệp duy nhất, có một workaround cho điều này.
Tuy nhiên, lưu ý rằng nó không được khuyến nghị để trích xuất mọi thứ vào một tệp duy nhất.
Trích xuất vào nhiều CSS files tốt hơn cho caching và preload isolation. Nó
cũng có thể cải thiện hiệu suất trang bằng cách downloading và resolving chỉ những resources
được cần.

**Example**:

```js
export default {
  webpack: {
    extractCSS: true,
    optimization: {
      splitChunks: {
        cacheGroups: {
          styles: {
            name: 'styles',
            test: /\.(css|vue)$/,
            chunks: 'all',
            enforce: true
          }
        }
      }
    }
  }
}
```

### `filenames`

Tùy chỉnh tên tệp bundle.

Để hiểu một chút nhiều hơn về việc sử dụng manifests, hãy xem [webpack documentation](https://webpack.js.org/guides/code-splitting/){rel="nofollow"}.

::callout
**Note**: Cẩn thận khi sử dụng filenames không dựa trên hash trong production
vì hầu hết browsers sẽ cache asset và không phát hiện changes trên first load.
::

Ví dụ này thay đổi fancy chunk names thành numerical ids:

**Example**:

```js
filenames: {
  chunk: ({ isDev }) => (isDev ? '[name].js' : '[id].[contenthash].js')
}
```

#### `app`

- **Type**: `function`

#### `chunk`

- **Type**: `function`

#### `css`

- **Type**: `function`

#### `font`

- **Type**: `function`

#### `img`

- **Type**: `function`

#### `video`

- **Type**: `function`

### `friendlyErrors`

Đặt thành `false` để tắt overlay được cung cấp bởi [FriendlyErrorsWebpackPlugin](https://github.com/nuxt/friendly-errors-webpack-plugin){rel="nofollow"}.

- **Type**: `boolean`
- **Default:** `true`

### `hotMiddleware`

Xem [webpack-hot-middleware](https://github.com/webpack-contrib/webpack-hot-middleware){rel="nofollow"} để biết tùy chọn có sẵn.

### `loaders`

Tùy chỉnh tùy chọn của Nuxt's integrated webpack loaders.

#### `css`

Xem [css-loader](https://github.com/webpack-contrib/css-loader){rel="nofollow"} để biết tùy chọn có sẵn.

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `importLoaders`

- **Type**: `number`
- **Default:** `0`

##### `url`

###### `filter`

- **Type**: `function`

#### `cssModules`

Xem [css-loader](https://github.com/webpack-contrib/css-loader){rel="nofollow"} để biết tùy chọn có sẵn.

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `importLoaders`

- **Type**: `number`
- **Default:** `0`

##### `modules`

###### `localIdentName`

- **Type**: `string`
- **Default:** `"[local]_[hash:base64:5]"`

##### `url`

###### `filter`

- **Type**: `function`

#### `esbuild`

- **Type**: `object`
- **Default**

```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

**See**: [esbuild loader](https://github.com/esbuild-kit/esbuild-loader){rel="nofollow"}

#### `file`

**See**: [`file-loader` Options](https://github.com/webpack-contrib/file-loader#options){rel="nofollow"}

**Default**:

```ts
{ esModule: false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `fontUrl`

**See**: [`file-loader` Options](https://github.com/webpack-contrib/file-loader#options){rel="nofollow"}

**Default**:

```ts
{ esModule: false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `imgUrl`

**See**: [`file-loader` Options](https://github.com/webpack-contrib/file-loader#options){rel="nofollow"}

**Default**:

```ts
{ esModule: false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `less`

- **Default**

```json
{
  "sourceMap": false
}
```

**See**: [`less-loader` Options](https://github.com/webpack-contrib/less-loader#options){rel="nofollow"}

#### `pugPlain`

**See**: [`pug` options](https://pugjs.org/api/reference.html#options){rel="nofollow"}

#### `sass`

**See**: [`sass-loader` Options](https://github.com/webpack-contrib/sass-loader#options){rel="nofollow"}

**Default**:

```ts
{
  sassOptions: {
    indentedSyntax: true
  }
}
```

##### `sassOptions`

###### `indentedSyntax`

- **Type**: `boolean`
- **Default:** `true`

#### `scss`

- **Default**

```json
{
  "sourceMap": false
}
```

**See**: [`sass-loader` Options](https://github.com/webpack-contrib/sass-loader#options){rel="nofollow"}

#### `stylus`

- **Default**

```json
{
  "sourceMap": false
}
```

**See**: [`stylus-loader` Options](https://github.com/webpack-contrib/stylus-loader#options){rel="nofollow"}

#### `vue`

Xem [vue-loader](https://github.com/vuejs/vue-loader){rel="nofollow"} để biết tùy chọn có sẵn.

##### `compilerOptions`

- **Type**: `object`

##### `propsDestructure`

- **Type**: `boolean`
- **Default:** `true`

##### `transformAssetUrls`

- **Type**: `object`
- **Default**

```json
{
  "video": [
    "src",
    "poster"
  ],
  "source": [
    "src"
  ],
  "img": [
    "src"
  ],
  "image": [
    "xlink:href",
    "href"
  ],
  "use": [
    "xlink:href",
    "href"
  ]
}
```

#### `vueStyle`

- **Default**

```json
{
  "sourceMap": false
}
```

### `optimization`

Cấu hình [webpack optimization](https://webpack.js.org/configuration/optimization/){rel="nofollow"}.

#### `minimize`

Đặt minimize thành `false` để tắt tất cả minimizers. (Nó bị tắt trong development theo mặc định).

- **Type**: `boolean`
- **Default:** `true`

#### `minimizer`

Bạn có thể đặt minimizer thành một mảng plugins tùy chỉnh.

#### `runtimeChunk`

- **Type**: `string`
- **Default:** `"single"`

#### `splitChunks`

##### `automaticNameDelimiter`

- **Type**: `string`
- **Default:** `"/"`

##### `cacheGroups`

##### `chunks`

- **Type**: `string`
- **Default:** `"all"`

### `optimizeCSS`

Tùy chọn plugin OptimizeCSSAssets.

Mặc định là true khi `extractCSS` được bật.

- **Type**: `boolean`
- **Default:** `false`

**See**: [css-minimizer-webpack-plugin documentation](https://github.com/webpack-contrib/css-minimizer-webpack-plugin){rel="nofollow"}.

### `plugins`

Thêm webpack plugins.

- **Type**: `array`

**Example**:

```js
import webpack from 'webpack'
import { version } from './package.json'
// ...
plugins: [
  new webpack.DefinePlugin({
    'process.VERSION': version
  })
]
```

### `postcss`

Tùy chỉnh PostCSS Loader. cùng tùy chọn như [`postcss-loader` options](https://github.com/webpack-contrib/postcss-loader#options){rel="nofollow"}

#### `postcssOptions`

##### `plugins`

- **Type**: `object`
- **Default**

```json
{
  "autoprefixer": {},
  "cssnano": {}
}
```

### `profile`

Bật profiler trong webpackbar.

Nó thường được bật bởi CLI argument `--profile`.

- **Type**: `boolean`
- **Default:** `false`

**See**: [webpackbar](https://github.com/unjs/webpackbar#profile){rel="nofollow"}.

### `serverURLPolyfill`

Thư viện polyfill để load để cung cấp URL và URLSearchParams.

Mặc định là `'url'` ([see package](https://www.npmjs.com/package/url){rel="nofollow"}).

- **Type**: `string`
- **Default:** `"url"`

### `warningIgnoreFilters`

Filters để ẩn build warnings.

- **Type**: `array`

## workspaceDir

Định nghĩa thư mục workspace của ứng dụng của bạn.

Thường được sử dụng khi trong monorepo setup. Nuxt sẽ cố gắng detect thư mục workspace của bạn tự động, nhưng bạn có thể override nó ở đây.
Nó thường không cần cấu hình tùy chọn này.

- **Type**: `string`
- **Default:** `"/<workspaceDir>"`


# Nuxt API Reference

::card-group
  :::card
  ---
  icon: i-lucide-box
  title: Components
  to: https://nuxt.com/docs/api/components/client-only
  ---
  Explore Nuxt built-in components for pages, layouts, head, and more.
  :::

  :::card
  ---
  icon: i-lucide-arrow-left-right
  title: Composables
  to: https://nuxt.com/docs/api/composables/use-app-config
  ---
  Discover Nuxt composable functions for data-fetching, head management and more.
  :::

  :::card
  ---
  icon: i-lucide-square-function
  title: Utils
  to: https://nuxt.com/docs/api/utils/dollarfetch
  ---
  Learn about Nuxt utility functions for navigation, error handling and more.
  :::

  :::card
  ---
  icon: i-lucide-square-terminal
  title: Commands
  to: https://nuxt.com/docs/api/commands/add
  ---
  List of Nuxt CLI commands to init, analyze, build, and preview your application.
  :::

  :::card
  ---
  icon: i-lucide-package
  title: Nuxt Kit
  to: https://nuxt.com/docs/api/kit/modules
  ---
  Understand Nuxt Kit utilities to create modules and control Nuxt.
  :::

  :::card
  ---
  icon: i-lucide-brain
  title: Advanced
  to: https://nuxt.com/docs/api/advanced/hooks
  ---
  Go deep in Nuxt internals with Nuxt lifecycle hooks.
  :::

  :::card
  ---
  icon: i-lucide-cog
  title: Nuxt Configuration
  to: https://nuxt.com/docs/api/nuxt-config
  ---
  Explore all Nuxt configuration options to customize your application.
  :::
::


# Getting Help

Vào một thời điểm nào đó, bạn có thể gặp phải một vấn đề cần được giúp đỡ.

Nhưng đừng lo lắng! Chúng tôi là một cộng đồng thân thiện của các nhà phát triển và chúng tôi rất muốn giúp đỡ.

::card-group
  :::card
  ---
  icon: i-simple-icons-discord
  target: _blank
  title: Discord
  to: https://go.nuxt.com/discord
  ---
  Nhận trợ giúp thời gian thực, trao đổi với nhóm cốt lõi và cộng đồng, và cập nhật tin tức Nuxt mới nhất.
  :::

  :::card
  ---
  icon: i-simple-icons-nuxt
  target: _blank
  title: Nuxters
  to: https://nuxters.nuxt.com
  ---
  Kết nối với những người đam mê Nuxt khác.
  :::
::

## "I can't figure out how to (...)."

Bạn đã đọc qua các tài liệu này và nghĩ rằng nó nên khả thi, nhưng không rõ cách thực hiện. Điều tốt nhất là [mở một Thảo luận GitHub](https://github.com/nuxt/nuxt/discussions){rel="nofollow"}.

Vui lòng đừng cảm thấy xấu hổ khi đặt một câu hỏi mà bạn nghĩ là dễ - chúng tôi đều đã trải qua điều đó! ❤️

Mọi người bạn gặp sẽ giúp đỡ vì họ quan tâm, không phải vì họ được trả tiền để làm vậy. Điều tử tế nhất là làm cho họ dễ dàng giúp bạn. Dưới đây là một số ý tưởng:

- *Giải thích mục tiêu của bạn, không chỉ vấn đề bạn đang đối mặt.* "Tôi cần đảm bảo các đầu vào biểu mẫu của tôi có thể truy cập, vì vậy tôi đang cố gắng làm cho các id khớp giữa máy chủ và máy khách."
- *Đảm bảo bạn đã đọc tài liệu trước và sử dụng công cụ tìm kiếm yêu thích của bạn*. Hãy cho mọi người biết bằng cách nói điều gì đó như "Tôi đã Google cho 'nuxt script setup' nhưng tôi không thể tìm thấy ví dụ mã ở đâu cả."
- *Giải thích những gì bạn đã thử.* Kể cho mọi người về loại giải pháp bạn đã thử nghiệm, và tại sao. Thường thì điều này có thể làm cho lời khuyên của mọi người phù hợp hơn với tình huống của bạn.
- *Chia sẻ mã của bạn.* Mọi người có lẽ sẽ không thể giúp nếu họ chỉ thấy thông báo lỗi hoặc ảnh chụp màn hình - nhưng tất cả điều đó thay đổi nếu bạn chia sẻ mã của bạn ở định dạng sao chép/dán - ưu tiên dưới dạng tái tạo tối thiểu như CodeSandbox.

Và cuối cùng, chỉ cần đặt câu hỏi! Không cần [yêu cầu phép để đặt câu hỏi](https://dontasktoask.com){rel="nofollow"} hoặc [chờ ai đó trả lời lời chào của bạn](https://www.nohello.com){rel="nofollow"}. Nếu bạn làm vậy, bạn có thể không nhận được phản hồi vì mọi người đang chờ toàn bộ câu hỏi trước khi tham gia.

## "Could there be a bug?"

Một cái gì đó không hoạt động theo cách mà tài liệu nói rằng nó nên. Bạn không chắc liệu đó có phải là lỗi hay không. Bạn đã tìm kiếm qua [các vấn đề mở](https://github.com/nuxt/nuxt/issues){rel="nofollow"} và [thảo luận](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} nhưng bạn không thể tìm thấy gì. (nếu có vấn đề đã đóng, vui lòng tạo một vấn đề mới)

Chúng tôi khuyên bạn nên xem [cách báo cáo lỗi](https://nuxt.com/docs/community/reporting-bugs). Nuxt vẫn đang trong quá trình phát triển tích cực, và mọi vấn đề giúp làm cho nó tốt hơn.

## "I need professional help"

Nếu cộng đồng không thể cung cấp sự giúp đỡ bạn cần trong khung thời gian bạn có, NuxtLabs cung cấp hỗ trợ chuyên nghiệp với [Nuxt Experts](https://nuxt.com/enterprise/support){rel="nofollow"}.

Mục tiêu của Nuxt Expert là cung cấp hỗ trợ cho hệ sinh thái Vue, đồng thời tạo cơ hội tự do cho những người đóng góp cho các giải pháp mã nguồn mở, từ đó giúp duy trì tính bền vững của hệ sinh thái.

Các chuyên gia Nuxt là những người đóng góp được chọn của Vue, Nuxt và Vite cung cấp hỗ trợ và dịch vụ tư vấn chuyên nghiệp.


# Reporting Bugs

Dù chúng tôi cố gắng hết sức, chúng tôi sẽ không bao giờ loại bỏ hoàn toàn lỗi.

Ngay cả khi bạn không thể sửa mã cơ bản, việc báo cáo lỗi tốt có thể cho phép ai đó có chút quen thuộc hơn với cơ sở mã phát hiện một mẫu hoặc thực hiện sửa chữa nhanh.

Dưới đây là một vài bước chính.

## Có Phải Là Lỗi Thật Không?

Hãy xem xét liệu bạn đang tìm kiếm sự giúp đỡ với một cái gì đó, hay bạn nghĩ có lỗi với chính Nuxt. Nếu là trường hợp trước, chúng tôi rất muốn giúp bạn - nhưng cách tốt nhất để làm điều đó là thông qua [yêu cầu giúp đỡ](https://nuxt.com/docs/community/getting-help) thay vì báo cáo lỗi.

## Tìm Kiếm Các Vấn Đề

Tìm kiếm qua [các vấn đề mở](https://github.com/nuxt/nuxt/issues){rel="nofollow"} và [thảo luận](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} trước. Nếu bạn tìm thấy bất kỳ thứ gì dường như là lỗi tương tự, tốt hơn là bình luận trên luồng hiện có hơn là tạo bản sao.

## Tạo Một Tái Tạo Tối Thiểu

Điều quan trọng là có thể tái tạo lỗi một cách đáng tin cậy - theo cách tối thiểu và tách biệt với phần còn lại của dự án của bạn. Điều này thu hẹp những gì có thể gây ra vấn đề và làm cho nó có thể cho ai đó không chỉ tìm ra nguyên nhân, mà còn kiểm tra giải pháp tiềm năng.

Bắt đầu với hộp cát Nuxt và thêm **số lượng mã tối thiểu** cần thiết để tái tạo lỗi bạn đang gặp phải.

::note
Nếu vấn đề của bạn liên quan đến Vue hoặc Vite, vui lòng thử tái tạo nó trước với Vue SSR starter.
::

**Nuxt**:

::card-group
  :::card
  ---
  icon: i-simple-icons-stackblitz
  target: _blank
  title: Nuxt on StackBlitz
  to: https://nuxt.new/s/v3
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-codesandbox
  target: _blank
  title: Nuxt on CodeSandbox
  to: https://nuxt.new/c/v3
  ---
  :::
::

**Vue**:

::card-group
  :::card
  ---
  icon: i-simple-icons-stackblitz
  target: _blank
  title: Vue SSR on StackBlitz
  to: https://stackblitz.com/github/nuxt-contrib/vue3-ssr-starter/tree/main?terminal=dev
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-codesandbox
  target: _blank
  title: Vue SSR on CodeSandbox
  to: https://codesandbox.io/s/github/nuxt-contrib/vue3-ssr-starter/main
  ---
  :::

  :::card
  ---
  icon: i-simple-icons-github
  target: _blank
  title: Vue SSR Template on GitHub
  to: https://github.com/nuxt-contrib/vue3-ssr-starter/generate
  ---
  :::
::

Một khi bạn đã tái tạo vấn đề, hãy loại bỏ càng nhiều mã từ tái tạo của bạn càng tốt (trong khi vẫn tái tạo lỗi). Thời gian dành để làm cho tái tạo càng tối thiểu càng tốt sẽ tạo ra sự khác biệt lớn cho bất kỳ ai đặt ra để sửa vấn đề.

## Tìm Ra Nguyên Nhân Có Thể Là Gì

Với dự án Nuxt, có rất nhiều bộ phận chuyển động - từ [các module Nuxt](https://nuxt.com/modules) đến [các thư viện JavaScript khác](https://www.npmjs.com){rel="nofollow"}. Hãy thử báo cáo lỗi ở nơi phù hợp và cụ thể nhất. Điều đó có thể là module Nuxt gây ra vấn đề, hoặc thư viện upstream mà Nuxt phụ thuộc vào.


# Contribution

Có nhiều cách khác nhau mà bạn có thể đóng góp cho hệ sinh thái Nuxt.

## Ecosystem

Hệ sinh thái Nuxt bao gồm nhiều dự án và tổ chức khác nhau:

- [nuxt/](https://github.com/nuxt){rel="nofollow"} - kho lưu trữ cốt lõi cho chính framework Nuxt. [**nuxt/nuxt**](https://github.com/nuxt/nuxt){rel="nofollow"} chứa framework Nuxt (cả phiên bản 2 và 3).
- [nuxt-modules/](https://github.com/nuxt-modules){rel="nofollow"} - các module và thư viện được đóng góp và duy trì bởi cộng đồng. Có một [quy trình để di chuyển một module](https://nuxt.com/docs/guide/going-further/modules/#joining-nuxt-modules-and-nuxtjs) sang `nuxt-modules`. Mặc dù các module này có người duy trì riêng, chúng không phụ thuộc vào một người duy nhất.
- [unjs/](https://github.com/unjs){rel="nofollow"} - nhiều thư viện này được sử dụng trong toàn bộ hệ sinh thái Nuxt. Chúng được thiết kế như các thư viện phổ quát, không phụ thuộc vào framework hoặc môi trường. Chúng tôi chào đón đóng góp và sử dụng bởi các framework và dự án khác.

## How To Contribute

### Triage Issues and Help Out in Discussions

Kiểm tra các vấn đề và thảo luận cho dự án bạn muốn giúp đỡ. Ví dụ, đây là [bảng vấn đề](https://github.com/nuxt/nuxt/issues){rel="nofollow"} và [thảo luận](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} cho Nuxt. Giúp đỡ người dùng khác, chia sẻ giải pháp thay thế, tạo bản sao, hoặc thậm chí đào sâu vào một lỗi một chút và chia sẻ phát hiện của bạn sẽ tạo ra sự khác biệt lớn.

### Creating an Issue

Cảm ơn bạn đã dành thời gian tạo một vấn đề! ❤️

- **Báo cáo lỗi**: Kiểm tra [hướng dẫn của chúng tôi](https://nuxt.com/docs/community/reporting-bugs) để biết một số việc cần làm trước khi mở một vấn đề.
- **Yêu cầu tính năng**: Kiểm tra xem có vấn đề hoặc thảo luận hiện có nào bao phủ phạm vi của tính năng bạn đang nghĩ đến không. Nếu tính năng đó dành cho một phần khác của hệ sinh thái Nuxt (như một module), hãy cân nhắc nêu yêu cầu tính năng ở đó trước. Nếu tính năng bạn nghĩ đến là chung hoặc API không hoàn toàn rõ ràng, hãy cân nhắc mở một thảo luận trong phần **Ý tưởng** để thảo luận với cộng đồng trước.

Chúng tôi sẽ cố gắng hết sức để tuân theo [sơ đồ quyết định vấn đề nội bộ của chúng tôi](https://mermaid.live/view#pako\:eNqFlE1v2zAMhv8K4UuToslhx2Bo0TZt12Edhm7YMCAXWqJtorLk6qOpkfS_j7KdfpyWQ-BQr8mHL6nsCuU0FauiMm6rGvQRfq03FuRzvvvTYIQHthpcBT_ugQNwPHuZjheLxf4i1VDx8x4udrf5EBCOQvSsYg4ffS79KS9pmX9QALTgyid2KYB7Ih-4bmKWbDk2YB0E1gRUVaRi-FDmmjAmT3u4nB3DmoNKIUA1BsGSohA49jnVMQhHbDh_EZQUImyxh-gAtfaiG-KWSJ-N8nt6YtpCdgEeE5rXPOdav5YwWJIJU7zrvNADV9C7JBIyIC07Wxupkx3LFQ5vCkguRno5f9fP2qnUko0Y2dk9rGdvHAa9IIhVGlCp5FFNPN-ce4DKeXBd53xMliOLp9IZtyORQVsnrGm-WJzejtUu5fFqdr5FGQ3bLslYvGthjZbJTLpReZG5_lLYw7XQ_CbPVT92ws9gnEJj-v84dk-PiaXnmF1XGAaPsOsMKywNvYmG80ZohV8k4wDR9_N3KN_dHm5mh1lnkM5FsYzRfNiTvJoT5gnQsl6uxjqXLhkNQ9syHJ0UZZ8ERUIlNShr6N8gZDEliR-ow7QZa0fhY4LoHLRo-8N7ZxPwjRj5ZZYXpvOSNs9v3Jjs8NXB4ets92xan3zydXZHvj64lKMayh4-gZC1bjASW2ipLeWuzIuToiXfImu5rbucclMIc0ubYiWPGv3DptjYF9Fhiu5nb1Wxij7RSZE6jZHWjLXHtlhVaIJESXN0_m68_sO_wMs_oO9gyg){rel="nofollow"} khi trả lời các vấn đề.

### Send a Pull Request

Chúng tôi luôn chào đón các pull request! ❤️

#### Before You Start

Trước khi sửa một lỗi, chúng tôi khuyên bạn nên kiểm tra xem **có vấn đề nào mô tả nó không**, vì có thể đó là vấn đề tài liệu hoặc có một số ngữ cảnh hữu ích để biết.

Nếu bạn đang làm việc trên một tính năng, thì chúng tôi yêu cầu bạn **mở vấn đề yêu cầu tính năng trước** để thảo luận với người duy trì xem tính năng đó có được mong muốn không - và thiết kế của những tính năng đó. Điều này giúp tiết kiệm thời gian cho cả người duy trì và người đóng góp và có nghĩa là các tính năng có thể được phát hành nhanh hơn. Vấn đề **nên được xác nhận** bởi một thành viên nhóm framework trước khi xây dựng tính năng trong một pull request.

Đối với sửa lỗi đánh máy, bạn nên gộp nhiều sửa lỗi đánh máy vào một pull request để duy trì lịch sử commit sạch hơn.

Đối với những thay đổi lớn hơn đối với chính Nuxt, chúng tôi khuyên bạn nên [tạo một module Nuxt](https://nuxt.com/#create-a-module) trước và triển khai tính năng ở đó. Điều này cho phép proof-of-concept nhanh. Sau đó, bạn có thể [tạo một RFC](https://nuxt.com/#make-an-rfc) dưới dạng thảo luận. Khi người dùng áp dụng nó và bạn thu thập phản hồi, nó có thể được tinh chỉnh và thêm vào lõi Nuxt hoặc tiếp tục như một module độc lập.

#### Commit Conventions

Chúng tôi sử dụng [Conventional Commits](https://www.conventionalcommits.org){rel="nofollow"} cho thông điệp commit, điều này [cho phép tạo changelog tự động](https://github.com/unjs/changelogen){rel="nofollow"} dựa trên các commit. Vui lòng đọc hướng dẫn kỹ nếu bạn chưa quen với nó.

Lưu ý rằng `fix:` và `feat:` dành cho **thay đổi mã thực tế** (có thể ảnh hưởng đến logic). Đối với thay đổi đánh máy hoặc tài liệu, hãy sử dụng `docs:` hoặc `chore:` thay thế:

- ~~`fix: typo`~~ -> `docs: fix typo`

Nếu bạn đang làm việc trong một dự án có monorepo, như `nuxt/nuxt`, hãy đảm bảo chỉ định phạm vi chính của commit của bạn trong ngoặc đơn. Ví dụ: `feat(kit): add 'addMagicStuff' utility`.

#### Making the Pull Request

Nếu bạn không biết cách gửi pull request, chúng tôi khuyên bạn nên đọc [hướng dẫn](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request){rel="nofollow"}.

Khi gửi pull request, hãy đảm bảo tiêu đề PR của bạn cũng tuân theo [Quy ước Commit](https://nuxt.com/#commit-conventions).

Nếu PR của bạn sửa hoặc giải quyết các vấn đề hiện có, hãy đảm bảo đề cập đến chúng trong mô tả PR.

Bạn có thể có nhiều commit trong một PR duy nhất; bạn không cần rebase hoặc force push cho các thay đổi của mình vì chúng tôi sẽ sử dụng `Squash and Merge` để gộp các commit thành một commit khi hợp nhất.

Chúng tôi không thêm bất kỳ commit hooks nào để cho phép commit nhanh. Nhưng trước khi bạn tạo pull request, bạn nên đảm bảo rằng bất kỳ script lint/test nào đang chạy thành công.

Nói chung, vui lòng cũng đảm bảo rằng không có thay đổi *không liên quan* trong PR. Ví dụ, nếu trình chỉnh sửa của bạn đã thực hiện bất kỳ thay đổi nào về khoảng trắng hoặc định dạng ở nơi khác trong tệp bạn đã chỉnh sửa, hãy hoàn nguyên những thay đổi đó để rõ ràng hơn những gì PR của bạn thay đổi. Và vui lòng tránh bao gồm nhiều tính năng hoặc sửa lỗi không liên quan trong một PR duy nhất. Nếu có thể tách biệt chúng, thì tốt hơn là có nhiều PR để xem xét và hợp nhất riêng biệt. Nói chung, một PR nên làm *một việc duy nhất*.

#### Once You've Made a Pull Request

Khi bạn đã tạo pull request, chúng tôi sẽ cố gắng hết sức để xem xét nó kịp thời.

Nếu chúng tôi chỉ định nó cho một người duy trì, thì điều đó có nghĩa là người đó sẽ đặc biệt chú ý xem xét nó và triển khai bất kỳ thay đổi nào có thể được yêu cầu.

Nếu chúng tôi yêu cầu thay đổi trên PR, vui lòng bỏ qua văn bản màu đỏ! Nó không có nghĩa là chúng tôi nghĩ đó là PR xấu - đó chỉ là cách dễ dàng để cho biết trạng thái của danh sách các pull request tại một thời điểm.

Nếu chúng tôi đánh dấu PR là 'pending', điều đó có nghĩa là chúng tôi có thể có một nhiệm vụ khác để làm trong việc xem xét PR - đó là ghi chú nội bộ cho chính mình, và không nhất thiết phản ánh liệu PR có phải là ý tưởng tốt hay không. Chúng tôi sẽ cố gắng giải thích qua bình luận lý do cho trạng thái pending.

Chúng tôi sẽ cố gắng hết sức để tuân theo [sơ đồ quyết định PR của chúng tôi](https://mermaid.live/view#pako\:eNp9VE1v2kAQ_SsjXzBSEqlALlaUisSh0ACK2l4qcVm8Y9hi7672Iwly-O-ZtYPt5FAOCHbee_PmzdpVlCmOURLlhXrJ9sw4-JNuJNBnWs1UQafIQVjrERyWumAOv58-AJeXt29_0b7BXbWwwL0uRPa1vlZvcB_fF8oiMMmB2QM4BXkt3UoON7Lh3LWaDz2SVkK6QGt7DHvw0CKt5sxCKaQoWQEGtVHcZ04oGdw04LTVngW_LHOeFcURGGz97mw6PSv-iJdsi0UCA4nI7SfNwc3W3JZit3eQ1SZFDlKB15yswQ2MgbOjbYeatY3n8bcr-IWlekYYaJRcyB04I9gOB1CEfkF5dAVTzmFAtnqn4-bUYAiMMmHZgWhNPRhgus5mW2BATxq0NkIZ4Y4NbNjzE2ZchBzcHmGLe_ZMSKCcyRXyLrVFa_5n_PBK2xKy3kk9eOjULUdltk6C8kI-7NFDr8f4EVGDoqlp-wa4sJm3ltIMIuZ_mTQXJyTSkQZtunPqsKxShV9GKdkBYe1fHXjpbcjlvONlO9Kqx_M7YHmOmav_luxfE5zKwVs09hM5DLSupgYDlr5flDkwo7ykixKG-xDsUly1LZ-uY32dgDc7lG7YqwbNp0msJwmIUivjWFtfd-xRrEcJ7Omydz37qFplHOtxEp4GskI2qB5dRCWakglOz3oV8JuITJa4iRL6yZk5bKKNPBGOead-H2UWJc54vIiaW53SPgwrz4fIhVNm1bw76lfI6R2_MW21){rel="nofollow"} khi trả lời và xem xét các pull request.

### AI-Assisted Contributions

Chúng tôi chào đón việc sử dụng có suy nghĩ các công cụ AI khi đóng góp cho Nuxt, nhưng yêu cầu tất cả người đóng góp tuân theo [hai nguyên tắc cốt lõi](https://roe.dev/blog/using-ai-in-open-source){rel="nofollow"}.

#### Never let an LLM speak for you

- Tất cả bình luận, vấn đề và mô tả pull request nên được viết bằng giọng điệu của riêng bạn
- Chúng tôi coi trọng giao tiếp rõ ràng của con người hơn ngữ pháp hoặc chính tả hoàn hảo
- Tránh sao chép-dán các tóm tắt được tạo bởi AI không phản ánh sự hiểu biết của riêng bạn

#### Never let an LLM think for you

- Hãy thoải mái sử dụng công cụ AI để tạo mã hoặc khám phá ý tưởng
- Chỉ gửi đóng góp mà bạn hiểu đầy đủ và có thể giải thích
- Đóng góp nên phản ánh lý luận và giải quyết vấn đề của riêng bạn

Mục tiêu của chúng tôi là đảm bảo chất lượng và duy trì niềm vui hợp tác và giao tiếp với những người thực sự. Nếu bạn có ý tưởng để cải thiện chính sách của chúng tôi về AI trong cộng đồng Nuxt, chúng tôi rất muốn nghe chúng! ❤️

### Create a Module

Nếu bạn đã xây dựng điều gì đó với Nuxt mà thật tuyệt, tại sao không [trích xuất nó thành một module](https://nuxt.com/docs/guide/going-further/modules), để có thể chia sẻ với người khác? Chúng tôi có [nhiều module tuyệt vời đã có](https://nuxt.com/modules), nhưng luôn có chỗ cho nhiều hơn.

Nếu bạn cần giúp đỡ trong khi xây dựng nó, hãy thoải mái [kiểm tra với chúng tôi](https://nuxt.com/docs/community/getting-help).

### Make an RFC

Chúng tôi đặc biệt khuyên bạn nên [tạo một module](https://nuxt.com/#create-a-module) trước để thử nghiệm các tính năng mới lớn và giành được sự áp dụng của cộng đồng.

Nếu bạn đã làm điều này rồi, hoặc không phù hợp để tạo một module mới, thì vui lòng bắt đầu bằng cách tạo một thảo luận mới. Hãy đảm bảo nó giải thích suy nghĩ của bạn rõ ràng nhất có thể. Bao gồm ví dụ mã hoặc chữ ký hàm cho các API mới. Tham chiếu các vấn đề hiện có hoặc điểm đau với ví dụ.

Nếu chúng tôi nghĩ điều này nên là một RFC, chúng tôi sẽ thay đổi danh mục thành RFC và phát sóng rộng hơn để nhận phản hồi.

Một RFC sau đó sẽ trải qua các giai đoạn sau:

- `rfc: active` - hiện đang mở để nhận bình luận
- `rfc: approved` - được phê duyệt bởi nhóm Nuxt
- `rfc: ready to implement` - một vấn đề đã được tạo và chỉ định để triển khai
- `rfc: shipped` - đã triển khai
- `rfc: archived` - không được phê duyệt, nhưng lưu trữ để tham khảo trong tương lai

### Conventions Across Ecosystem

Các quy ước sau đây là *bắt buộc* trong tổ chức `nuxt/` và được khuyến nghị cho các người duy trì khác trong hệ sinh thái.

#### Module Conventions

Các module nên tuân theo [mẫu module Nuxt](https://github.com/nuxt/starter/tree/module){rel="nofollow"}. Xem [hướng dẫn module](https://nuxt.com/docs/guide/going-further/modules) để biết thêm thông tin.

#### Use Core `unjs/` Libraries

Chúng tôi khuyên bạn nên sử dụng các thư viện sau đây được sử dụng trong toàn bộ hệ sinh thái:

- [pathe](https://github.com/unjs/pathe){rel="nofollow"} - tiện ích đường dẫn phổ quát (thay thế cho node `path`)
- [ufo](https://github.com/unjs/ufo){rel="nofollow"} - tiện ích phân tích và nối URL
- [unbuild](https://github.com/unjs/unbuild){rel="nofollow"} - hệ thống xây dựng được hỗ trợ bởi rollup
- ... kiểm tra phần còn lại của tổ chức [unjs/](https://github.com/unjs){rel="nofollow"} để biết nhiều hơn!

#### Use ESM Syntax and Default to `type: module`

Hầu hết hệ sinh thái Nuxt có thể tiêu thụ ESM trực tiếp. Nói chung, chúng tôi ủng hộ việc tránh sử dụng mã cụ thể CJS, chẳng hạn như `__dirname` và câu lệnh `require`. Bạn có thể [đọc thêm về ESM](https://nuxt.com/docs/guide/concepts/esm).

#### What's Corepack

[Corepack](https://nodejs.org/api/corepack.html){rel="nofollow"} đảm bảo bạn đang sử dụng phiên bản chính xác cho trình quản lý gói khi bạn chạy các lệnh tương ứng. Các dự án có thể có trường `packageManager` trong `package.json` của họ.

Dưới các dự án có cấu hình như hiển thị bên dưới, Corepack sẽ cài đặt `v7.5.0` của `pnpm` (nếu bạn chưa có) và sử dụng nó để chạy lệnh của bạn.

```jsonc [package.json]
{
  "packageManager": "pnpm@7.5.0"
}
```

#### Use ESLint

Chúng tôi sử dụng [ESLint](https://eslint.org){rel="nofollow"} cho cả linting và định dạng với [`@nuxt/eslint`](https://github.com/nuxt/eslint){rel="nofollow"}.

##### IDE Setup

Chúng tôi khuyên bạn nên sử dụng [VS Code](https://code.visualstudio.com){rel="nofollow"} cùng với [phần mở rộng ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint){rel="nofollow"}. Nếu bạn muốn, bạn có thể bật tự động sửa và định dạng khi bạn lưu mã bạn đang chỉnh sửa:

```json [settings.json]
{
  "editor.codeActionsOnSave": {
    "source.fixAll": "never",
    "source.fixAll.eslint": "explicit"
  }
}
```

#### No Prettier

Vì ESLint đã được cấu hình để định dạng mã, không cần sao chép chức năng với Prettier. Để định dạng mã, bạn có thể chạy `yarn lint --fix`, `pnpm lint --fix`, hoặc `bun run lint --fix` hoặc tham khảo phần [ESLint](https://nuxt.com/#use-eslint) để thiết lập IDE.

Nếu bạn có Prettier được cài đặt trong trình chỉnh sửa của mình, chúng tôi khuyên bạn nên tắt nó khi làm việc trên dự án để tránh xung đột.

#### Package Manager

Chúng tôi khuyên bạn nên sử dụng `pnpm` làm trình quản lý gói cho các module, thư viện và ứng dụng.

Điều quan trọng là kích hoạt Corepack để đảm bảo bạn đang ở trên cùng phiên bản của trình quản lý gói như dự án. Corepack được tích hợp sẵn trong các phiên bản node mới để tích hợp trình quản lý gói liền mạch.

Để kích hoạt nó, chạy

```bash [Terminal]
corepack enable
```

Bạn chỉ cần làm điều này một lần, sau khi Node.js được cài đặt trên máy tính của bạn.

## Documentation Style Guide

Tài liệu là một phần thiết yếu của Nuxt. Chúng tôi hướng tới việc trở thành một framework trực quan - và một phần lớn của điều đó là đảm bảo rằng cả trải nghiệm nhà phát triển và tài liệu đều hoàn hảo trên toàn bộ hệ sinh thái. 👌

Dưới đây là một số mẹo có thể giúp cải thiện tài liệu của bạn:

- Tránh các từ chủ quan như *đơn giản*, *chỉ*, &#x2A;rõ ràng...* khi có thể. :br Hãy nhớ rằng độc giả của bạn có thể có nền tảng và kinh nghiệm khác nhau. Do đó, những từ này không truyền tải ý nghĩa và có thể gây hại. :caution[Đơn giản hãy đảm bảo hàm trả về một promise.]{icon="i-lucide-circle-x"}:tip[Hãy đảm bảo hàm trả về một [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise){rel="nofollow"}.]{icon="i-lucide-circle-check"}
- Ưu tiên [giọng chủ động](https://developers.google.com/tech-writing/one/active-voice){rel="nofollow"}. :caution[Một lỗi sẽ được ném ra bởi Nuxt.]{icon="i-lucide-circle-x"}:tip[Nuxt sẽ ném ra một lỗi.]{icon="i-lucide-circle-check"}

::read-more
---
to: https://nuxt.com/docs/community/framework-contribution#documentation-guide
---
Tìm hiểu cách đóng góp cho tài liệu.
::


# Framework

Khi bạn đã đọc [hướng dẫn đóng góp chung](https://nuxt.com/docs/community/contribution), đây là một số điểm cụ thể để làm về đóng góp cho kho lưu trữ [`nuxt/nuxt`](https://github.com/nuxt/nuxt){rel="nofollow"}.

## Monorepo Guide

- `packages/kit`: Bộ công cụ để tạo Nuxt Modules, được xuất bản dưới dạng [`@nuxt/kit`](https://npmjs.com/package/@nuxt/kit){rel="nofollow"}.
- `packages/nuxt`: Lõi của Nuxt, được xuất bản dưới dạng [`nuxt`](https://npmjs.com/package/nuxt){rel="nofollow"}.
- `packages/schema`: Các typedef và mặc định đa phiên bản của Nuxt, được xuất bản dưới dạng [`@nuxt/schema`](https://npmjs.com/package/@nuxt/schema){rel="nofollow"}.
- `packages/rspack`: Bộ đóng gói [Rspack](https://rspack.dev){rel="nofollow"} cho Nuxt, được xuất bản dưới dạng [`@nuxt/rspack-builder`](https://npmjs.com/package/@nuxt/rspack-builder){rel="nofollow"}.
- `packages/vite`: Bộ đóng gói [Vite](https://vite.dev){rel="nofollow"} cho Nuxt, được xuất bản dưới dạng [`@nuxt/vite-builder`](https://npmjs.com/package/@nuxt/vite-builder){rel="nofollow"}.
- `packages/webpack`: Bộ đóng gói [webpack](https://webpack.js.org){rel="nofollow"} cho Nuxt, được xuất bản dưới dạng [`@nuxt/webpack-builder`](https://npmjs.com/package/@nuxt/webpack-builder){rel="nofollow"}.

## Setup

Để đóng góp cho Nuxt, bạn cần thiết lập môi trường cục bộ.

1. [Fork](https://help.github.com/articles/fork-a-repo){rel="nofollow"} kho lưu trữ [`nuxt/nuxt`](https://github.com/nuxt/nuxt){rel="nofollow"} vào tài khoản GitHub của riêng bạn và sau đó [clone](https://help.github.com/articles/cloning-a-repository){rel="nofollow"} nó vào thiết bị cục bộ của bạn.
2. Đảm bảo sử dụng [Node.js](https://nodejs.org/en){rel="nofollow"} mới nhất (20.x)
3. Kích hoạt [Corepack](https://github.com/nodejs/corepack){rel="nofollow"} để có `pnpm` và `yarn`
   ```bash [Terminal]
   corepack enable
   ```
4. Chạy `pnpm install --frozen-lockfile` để Cài đặt các phụ thuộc với pnpm:

   ```bash [Terminal]
   pnpm install --frozen-lockfile
   ```
   :note[Nếu bạn đang thêm một phụ thuộc, vui lòng sử dụng `pnpm add`. :br
   Tệp `pnpm-lock.yaml` là nguồn chân lý cho tất cả các phụ thuộc Nuxt.]
5. Kích hoạt hệ thống phát triển thụ động

   ```bash [Terminal]
   pnpm dev:prepare
   ```
6. Kiểm tra một nhánh nơi bạn có thể làm việc và commit các thay đổi của mình:

   ```bash [Terminal]
   git checkout -b my-new-branch
   ```

Sau đó, kiểm tra các thay đổi của bạn với [playground](https://nuxt.com/#playground) và [kiểm tra](https://nuxt.com/#testing) các thay đổi của bạn trước khi gửi pull request.

### Playground

Trong khi làm việc trên pull request, bạn có thể muốn kiểm tra xem các thay đổi của bạn có hoạt động chính xác không.

Bạn có thể sửa đổi ứng dụng ví dụ trong `playground/`, và chạy:

```bash [Terminal]
pnpm dev
```

::important
Vui lòng đảm bảo không commit nó vào nhánh của bạn, nhưng nó có thể hữu ích để thêm một số mã ví dụ vào mô tả PR của bạn. Điều này có thể giúp người xem xét và người dùng Nuxt khác hiểu sâu về tính năng bạn đã xây dựng.
::

### Testing

Mọi tính năng mới nên có một bài kiểm tra đơn vị tương ứng (nếu có thể). Thư mục `test/` trong kho lưu trữ này hiện đang trong quá trình phát triển, nhưng hãy cố gắng hết sức để tạo một bài kiểm tra mới theo ví dụ của những gì đã có.

Trước khi tạo PR hoặc đánh dấu là sẵn sàng để xem xét, hãy đảm bảo tất cả các bài kiểm tra đều pass bằng cách chạy:

```bash [Terminal]
pnpm test
```

### Linting

Bạn có thể đã nhận thấy rằng chúng tôi sử dụng ESLint để thực thi tiêu chuẩn mã hóa.

Trước khi commit các thay đổi của bạn, để xác minh rằng kiểu mã là chính xác, chạy:

```bash [Terminal]
pnpm lint
```

::note
Bạn có thể sử dụng `pnpm lint --fix` để sửa hầu hết các thay đổi kiểu. :br
Nếu vẫn còn lỗi, bạn phải sửa chúng theo cách thủ công.
::

### Documentation

Nếu bạn đang thêm một tính năng mới hoặc tái cấu trúc hoặc thay đổi hành vi của Nuxt theo bất kỳ cách nào khác, bạn có thể muốn ghi lại các thay đổi. Vui lòng bao gồm bất kỳ thay đổi nào đối với tài liệu trong cùng PR. Bạn không cần viết tài liệu ngay từ commit đầu tiên (nhưng vui lòng làm như vậy ngay khi pull request của bạn trưởng thành đủ).

::important
Hãy đảm bảo thực hiện thay đổi theo [Hướng dẫn Kiểu Tài liệu](https://nuxt.com/docs/community/contribution#documentation-style-guide).
::

### Final Checklist

Khi gửi PR của bạn, có một mẫu đơn giản mà bạn phải điền. Vui lòng đánh dấu tất cả "câu trả lời" phù hợp trong danh sách kiểm tra.

## Documentation Guide

Nếu bạn phát hiện một khu vực mà chúng ta có thể cải thiện tài liệu hoặc thông báo lỗi, vui lòng mở PR - ngay cả khi chỉ để sửa lỗi đánh máy!

::important
Hãy đảm bảo thực hiện thay đổi theo [Hướng dẫn Kiểu Tài liệu](https://nuxt.com/docs/community/contribution#documentation-style-guide).
::

### Quick Edits

Nếu bạn phát hiện lỗi đánh máy hoặc muốn diễn đạt lại một câu, bạn có thể nhấp vào liên kết **Chỉnh sửa trang này** nằm ở bên phải trong phần **Cộng đồng**.

Thực hiện thay đổi trực tiếp trong giao diện GitHub và mở Pull Request.

### Longer Edits

Nội dung tài liệu nằm bên trong thư mục `docs/` của kho lưu trữ [nuxt/nuxt](https://github.com/nuxt/nuxt){rel="nofollow"} và được viết bằng markdown.

::note
Để xem trước tài liệu cục bộ, hãy làm theo các bước trên kho lưu trữ [nuxt/nuxt.com](https://github.com/nuxt/nuxt.com){rel="nofollow"}.
::

::note
Chúng tôi khuyên bạn nên cài đặt [phần mở rộng MDC](https://marketplace.visualstudio.com/items?itemName=Nuxt.mdc){rel="nofollow"} cho VS Code.
::

### Linting Docs

Tài liệu được lint bằng [MarkdownLint](https://github.com/DavidAnson/markdownlint){rel="nofollow"} và [case police](https://github.com/antfu/case-police){rel="nofollow"} để giữ cho tài liệu gắn kết.

```bash [Terminal]
pnpm lint:docs
```

::note
Bạn cũng có thể chạy `pnpm lint:docs:fix` để đánh dấu và giải quyết bất kỳ vấn đề lint nào.
::

### Open a PR

Vui lòng đảm bảo tiêu đề PR của bạn tuân theo các hướng dẫn [conventional commits](https://www.conventionalcommits.org){rel="nofollow"}.

```bash [Example of PR title]
docs: update the section about the nuxt.config.ts file
```


# Roadmap

::read-more{to="https://nuxt.com/blog"}
Xem blog của chúng tôi để biết các thông báo mới nhất về framework và hệ sinh thái.
::

## Status Reports

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/issues/13653
---
Tiến độ Tài liệu
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/nuxt/discussions/16119
---
Tối ưu hóa Kết xuất: Hôm nay và Ngày mai
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt/image/discussions/563
---
Nuxt Image: Hiệu suất và Trạng thái
::

## Roadmap

Trong roadmap bên dưới là một số tính năng chúng tôi đang lên kế hoạch hoặc làm việc tại thời điểm này.

::tip
Kiểm tra [Thảo luận](https://github.com/nuxt/nuxt/discussions){rel="nofollow"} và [RFC](https://github.com/nuxt/nuxt/discussions/categories/rfcs){rel="nofollow"} để biết thêm các tính năng sắp tới và ý tưởng.
::

| Milestone    | Expected date | Notes                                                                                                                                                                        | Description                                                                                                                                                 |
| ------------ | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SEO & PWA    | 2025          | [nuxt/nuxt#18395](https://github.com/nuxt/nuxt/discussions/18395){rel="nofollow"}                                                                                            | Di chuyển từ [nuxt-community/pwa-module](https://github.com/nuxt-community/pwa-module){rel="nofollow"} để có tiện ích SEO tích hợp và hỗ trợ service worker |
| Assets       | 2025          | [nuxt/nuxt#22012](https://github.com/nuxt/nuxt/discussions/22012){rel="nofollow"}                                                                                            | Cho phép nhà phát triển và module xử lý tải tài sản bên thứ ba.                                                                                             |
| Translations | -             | [nuxt/translations#4](https://github.com/nuxt/translations/discussions/4){rel="nofollow"} ([request access](https://github.com/nuxt/nuxt/discussions/16054){rel="nofollow"}) | Một dự án hợp tác cho quá trình dịch ổn định cho tài liệu Nuxt. Hiện đang chờ ý tưởng và hỗ trợ công cụ tài liệu (content v2 với nguồn từ xa).              |

## Core Modules Roadmap

Ngoài framework Nuxt, còn có các module quan trọng cho hệ sinh thái. Trạng thái của chúng sẽ được cập nhật bên dưới.

| Module                                              | Status      | Nuxt Support | Repository                                                      | Description                                                                                                                                                         |
| --------------------------------------------------- | ----------- | ------------ | --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Scripts](https://scripts.nuxt.com){rel="nofollow"} | Public Beta | 3.x, 4.x     | [nuxt/scripts](https://github.com/nuxt/scripts){rel="nofollow"} | Quản lý script bên thứ ba dễ dàng.                                                                                                                                  |
| Auth Utils                                          | Planned     | 4.x, 5.x     | `nuxt/auth-utils` to be announced                               | Kho lưu trữ tạm thời [atinux/nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils){rel="nofollow"} có sẵn trong khi chờ tích hợp chính thức vào Nuxt qua RFC. |
| A11y                                                | Planned     | 4.x, 5.x     | `nuxt/a11y` to be announced                                     | Gợi ý và tiện ích khả năng truy cập [nuxt/nuxt#23255](https://github.com/nuxt/nuxt/issues/23255){rel="nofollow"}                                                    |
| Hints                                               | Planned     | 4.x, 5.x     | `nuxt/hints` to be announced                                    | Hướng dẫn và gợi ý để nâng cao thực hành phát triển.                                                                                                                |

## Release Cycle

Kể từ tháng 1 năm 2023, chúng tôi đã áp dụng chu kỳ phát hành nhất quán cho Nuxt, tuân theo [semver](https://semver.org){rel="nofollow"}. Chúng tôi hướng tới việc phát hành framework chính mỗi năm, với kỳ vọng phát hành patch mỗi tuần hoặc lâu hơn và phát hành nhỏ mỗi tháng hoặc lâu hơn. Chúng không bao giờ chứa các thay đổi phá vỡ ngoại trừ trong các tùy chọn được đánh dấu rõ ràng là `experimental`.

Chúng tôi đang lên kế hoạch một biến thể nhỏ từ kế hoạch này cho Nuxt 4 và Nuxt 5. Nuxt 4 sẽ là bản phát hành tập trung vào ổn định chứa tất cả các tính năng `compatibilityVersion: 4`, và sẽ được theo sau ngay bởi Nuxt 5 bao gồm nâng cấp lên Nitro v3 và các thay đổi bổ sung.

Cách tiếp cận này tách các thay đổi phá vỡ thành các giai đoạn có thể quản lý, cho phép kiểm tra hệ sinh thái tốt hơn và di chuyển mượt mà hơn.

### Ongoing Support for Nuxt

Chúng tôi cam kết hỗ trợ mỗi phiên bản chính của Nuxt trong tối thiểu sáu tháng sau khi phát hành phiên bản chính tiếp theo, và cung cấp đường dẫn nâng cấp cho người dùng hiện tại tại thời điểm đó.

### Current Packages

Phiên bản hoạt động hiện tại của [Nuxt](https://nuxt.com){rel="nofollow"} là **v4** có sẵn dưới dạng `nuxt` trên npm với thẻ `latest`.

Nuxt 3 sẽ tiếp tục nhận các bản cập nhật bảo trì (cả sửa lỗi và backports của các tính năng từ Nuxt 4) cho đến cuối tháng 1 năm 2026.

Mỗi phiên bản hoạt động có các bản phát hành nightly riêng được tạo tự động. Để biết thêm về việc kích hoạt kênh phát hành nightly của Nuxt, xem [tài liệu kênh phát hành nightly](https://nuxt.com/docs/guide/going-further/nightly-release-channel).

| Release               |                                                                                                                                        | Initial release     | End Of Life                | Docs                                                    |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------------- | ------------------------------------------------------- |
| **5.x** (scheduled)   |                                                                                                                                        | Q4 2025 (estimated) | TBA                        |                                                         |
| **4.x** (stable)      | [![Nuxt latest version](https://flat.badgen.net/npm/v/nuxt?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2025-07-16          | 6 months after 5.x release | [nuxt.com](https://nuxt.com/docs/4.x)                   |
| **3.x** (maintenance) | [![Nuxt 3.x version](https://flat.badgen.net/npm/v/nuxt/3x?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2022-11-16          | 2026-01-31                 | [nuxt.com](https://nuxt.com/docs/3.x)                   |
| **2.x** (unsupported) | [![Nuxt 2.x version](https://flat.badgen.net/npm/v/nuxt/2x?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2018-09-21          | 2024-06-30                 | [v2.nuxt.com](https://v2.nuxt.com/docs){rel="nofollow"} |
| **1.x** (unsupported) | [![Nuxt 1.x version](https://flat.badgen.net/npm/v/nuxt/1x?label=){.not-prose}](https://www.npmjs.com/package/nuxt?activeTab=versions) | 2018-01-08          | 2019-09-21                 |                                                         |

### Support Status

| Status      | Description                                                              |
| ----------- | ------------------------------------------------------------------------ |
| Unsupported | Phiên bản này không được duy trì nữa và sẽ không nhận các bản vá bảo mật |
| Maintenance | Phiên bản này sẽ chỉ nhận các bản vá bảo mật                             |
| Stable      | Phiên bản này đang được phát triển và sẽ nhận các bản vá bảo mật         |
| Development | Phiên bản này có thể không ổn định                                       |
| Scheduled   | Phiên bản này chưa tồn tại nhưng đã được lên kế hoạch                    |


# Releases

::card-group
  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/nuxt
  to: https://github.com/nuxt/nuxt/releases
  ---
  Các bản phát hành framework Nuxt.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/cli
  to: https://github.com/nuxt/cli/releases
  ---
  Các bản phát hành Nuxt CLI (`@nuxt/cli`).
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/content
  to: https://github.com/nuxt/content/releases
  ---
  Các bản phát hành Nuxt Content.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/devtools
  to: https://github.com/nuxt/devtools/releases
  ---
  Các bản phát hành Nuxt DevTools.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/fonts
  to: https://github.com/nuxt/fonts/releases
  ---
  Các bản phát hành Nuxt Fonts.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/image
  to: https://github.com/nuxt/image/releases
  ---
  Các bản phát hành Nuxt Image.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/scripts
  to: https://github.com/nuxt/scripts/releases
  ---
  Các bản phát hành Nuxt Scripts.
  :::

  :::card
  ---
  ui:
    icon:
      base: text-black dark:text-white
  icon: i-simple-icons-github
  target: _blank
  title: nuxt/ui
  to: https://github.com/nuxt/ui/releases
  ---
  Các bản phát hành Nuxt UI.
  :::
::

::read-more
---
icon: i-simple-icons-github
target: _blank
to: https://github.com/nuxt
---
Khám phá tổ chức `nuxt` trên GitHub
::


# Overview

::note
Nếu bạn đang bắt đầu một dự án Nuxt 3 mới, vui lòng bỏ qua phần này và chuyển đến [Cài đặt Nuxt 3](https://nuxt.com/docs/getting-started/introduction).
::

::warning
Nuxt Bridge cung cấp các tính năng giống hệt với Nuxt 3 ([docs](https://nuxt.com/docs/guide/concepts/auto-imports)) nhưng có một số hạn chế, đáng chú ý là các composables [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) không khả dụng. Vui lòng đọc phần còn lại của trang này để biết chi tiết.
::

Bridge là một lớp tương thích chuyển tiếp cho phép bạn trải nghiệm nhiều tính năng mới của Nuxt 3 bằng cách chỉ cần cài đặt và kích hoạt một module Nuxt.

Sử dụng Nuxt Bridge, bạn có thể đảm bảo dự án của mình (gần như) sẵn sàng cho Nuxt 3 và bạn có thể dần dần tiến hành chuyển đổi sang Nuxt 3.

## First Step

### Upgrade Nuxt 2

Đảm bảo máy chủ phát triển của bạn (`nuxt dev`) không đang chạy, xóa bất kỳ tệp khóa gói nào (`package-lock.json` và `yarn.lock`), và cài đặt phiên bản Nuxt 2 mới nhất:

```diff [package.json]
- "nuxt": "^2.16.3"
+ "nuxt": "^2.17.3"
```

Sau đó, cài đặt lại các phụ thuộc của bạn:

::code-group{sync="pm"}
```bash [npm]
npm install
```

```bash [yarn]
yarn install
```

```bash [pnpm]
pnpm install
```

```bash [bun]
bun install
```
::

::note
Sau khi cài đặt hoàn tất, hãy đảm bảo cả bản dựng phát triển và sản xuất đều hoạt động như mong đợi trước khi tiếp tục.
::

### Install Nuxt Bridge

Cài đặt `@nuxt/bridge` và `nuxi` làm phụ thuộc phát triển:

::code-group{sync="pm"}
```bash [npm]
npm install -D @nuxt/bridge nuxi
```

```bash [yarn]
yarn add --dev @nuxt/bridge nuxi
```

```bash [pnpm]
pnpm add -D @nuxt/bridge nuxi
```

```bash [bun]
bun add -D @nuxt/bridge nuxi
```
::

### Update `nuxt.config`

Vui lòng đảm bảo tránh bất kỳ cú pháp CommonJS nào như `module.exports`, `require` hoặc `require.resolve` trong tệp cấu hình của bạn. Nó sẽ sớm bị loại bỏ và không được hỗ trợ.

Bạn có thể sử dụng `import` tĩnh, `import()` động và `export default` thay thế. Sử dụng TypeScript bằng cách đổi tên thành [`nuxt.config.ts`](https://nuxt.com/docs/guide/directory-structure/nuxt-config) cũng có thể và được khuyến nghị.

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: false
})
```

### Update Commands

Lệnh `nuxt` bây giờ nên được thay đổi thành lệnh `nuxt2`.

```diff
{
  "scripts": {
-   "dev": "nuxt",
+   "dev": "nuxt2",
-   "build": "nuxt build",
+   "build": "nuxt2 build",
-   "start": "nuxt start",
+   "start": "nuxt2 start"
  }
}
```

Hãy thử chạy `nuxt2` một lần ở đây. Bạn sẽ thấy ứng dụng hoạt động như trước.

(Nếu 'bridge' được đặt thành false, ứng dụng của bạn sẽ hoạt động mà không có thay đổi như trước.)

## Upgrade Steps

Với Nuxt Bridge, việc di chuyển sang Nuxt 3 có thể tiến hành từng bước.
`Upgrade Steps` bên dưới không cần phải thực hiện tất cả cùng một lúc.

- [TypeScript](https://nuxt.com/docs/bridge/typescript)
- [Migrate Legacy Composition API](https://nuxt.com/docs/bridge/bridge-composition-api)
- [Plugins and Middleware](https://nuxt.com/docs/bridge/plugins-and-middleware)
- [Migrate New Composition API](https://nuxt.com/docs/bridge/nuxt3-compatible-api)
- [Meta Tags](https://nuxt.com/docs/bridge/meta)
- [Runtime Config](https://nuxt.com/docs/bridge/runtime-config)
- [Nitro](https://nuxt.com/docs/bridge/nitro)
- [Vite](https://nuxt.com/docs/bridge/vite)

## Migrate from CommonJS to ESM

Nuxt 3 hỗ trợ TypeScript và ECMAScript Modules một cách tự nhiên. Vui lòng kiểm tra [Native ES Modules](https://nuxt.com/docs/guide/concepts/esm) để biết thêm thông tin và nâng cấp.


# Configuration

## Feature Flags

Bạn có thể tùy chọn tắt một số tính năng từ bridge hoặc chọn tham gia các tính năng ít ổn định hơn. Trong các tình huống bình thường, luôn luôn tốt nhất là giữ nguyên mặc định!

Bạn có thể kiểm tra [bridge/src/module.ts](https://github.com/nuxt/bridge/blob/main/packages/bridge/src/module.ts){rel="nofollow"} để biết các mặc định mới nhất.

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'
export default defineNuxtConfig({
  bridge: {

    // -- Tính năng chọn tham gia --

    // Sử dụng Vite làm bundler thay vì webpack 4
    // vite: true,

    // Kích hoạt useHead tương thích với Nuxt 3
    // meta: true,

    // Kích hoạt macro definePageMeta
    // macros: {
    //   pageMeta: true
    // },

    // Kích hoạt transpiling TypeScript với esbuild
    // typescript: {
    //   esbuild: true
    // },

    // -- Tính năng mặc định --

    // Sử dụng máy chủ legacy thay vì Nitro
    // nitro: false,

    // Tắt giao diện `nuxtApp` tương thích với Nuxt 3
    // app: false,

    // Tắt hỗ trợ Composition API
    // capi: false,

    // ... hoặc chỉ tắt hỗ trợ Composition API legacy
    // capi: {
    //   legacy: false
    // },

    // Không transpile modules
    // transpile: false,

    // Tắt hỗ trợ <script setup>
    // scriptSetup: false,

    // Tắt auto importing composables
    // imports: false,

    // Không cảnh báo về không tương thích module
    // constraints: false
  },

  vite: {
    // Config for Vite
  }
})
```

## Migration of each option

### router.base

```diff
export default defineNuxtConfig({
- router: {
-   base: '/my-app/'
- }
+ app: {
+   baseURL: '/my-app/'
+ }
})
```

### build.publicPath

```diff
export default defineNuxtConfig({
- build: {
-   publicPath: 'https://my-cdn.net'
- }
+ app: {
+   cdnURL: 'https://my-cdn.net'
+ }
})
```


# TypeScript

## Remove Modules

- Xóa `@nuxt/typescript-build`: Bridge kích hoạt cùng chức năng
- Xóa `@nuxt/typescript-runtime` và `nuxt-ts`: Nuxt 2 có hỗ trợ runtime tích hợp

### Set `bridge.typescript`

```ts
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    typescript: true,
    nitro: false // If migration to Nitro is complete, set to true
  }
})
```

## Update `tsconfig.json`

Nếu bạn đang sử dụng TypeScript, bạn có thể chỉnh sửa `tsconfig.json` của mình để hưởng lợi từ các loại Nuxt được tạo tự động:

```diff [tsconfig.json]
{
+ "extends": "./.nuxt/tsconfig.json",
  "compilerOptions": {
    ...
  }
}
```

::note
Vì `.nuxt/tsconfig.json` được tạo và không được kiểm tra vào kiểm soát phiên bản, bạn sẽ cần tạo tệp đó trước khi chạy các bài kiểm tra của mình. Thêm `nuxi prepare` làm bước trước các bài kiểm tra của bạn, nếu không bạn sẽ thấy `TS5083: Cannot read file '~/.nuxt/tsconfig.json'`

Đối với các dự án Nuxt hiện đại, chúng tôi khuyến nghị sử dụng [TypeScript project references](https://nuxt.com/docs/guide/directory-structure/tsconfig) thay vì mở rộng trực tiếp `.nuxt/tsconfig.json`.
::

::note
Hãy nhớ rằng tất cả các tùy chọn được mở rộng từ `./.nuxt/tsconfig.json` sẽ bị ghi đè bởi các tùy chọn được định nghĩa trong `tsconfig.json` của bạn.
Ghi đè các tùy chọn như `"compilerOptions.paths"` bằng cấu hình của riêng bạn sẽ dẫn đến TypeScript không tính đến các độ phân giải module từ `./.nuxt/tsconfig.json`. Điều này có thể dẫn đến các độ phân giải module như `#imports` không được nhận dạng.

Trong trường hợp bạn cần mở rộng thêm các tùy chọn được cung cấp bởi `./.nuxt/tsconfig.json`, bạn có thể sử dụng thuộc tính `alias` trong `nuxt.config` của mình. `nuxi` sẽ chọn chúng và mở rộng `./.nuxt/tsconfig.json` tương ứng.
::


# Legacy Composition API

Nuxt Bridge cung cấp quyền truy cập vào cú pháp Composition API. Nó được thiết kế đặc biệt để phù hợp với Nuxt 3. Vì vậy, có một vài bước bổ sung để thực hiện khi kích hoạt Nuxt Bridge, nếu bạn đã sử dụng Composition API trước đó.

## Remove Modules

- Xóa `@vue/composition-api` khỏi các phụ thuộc của bạn.
- Xóa `@nuxtjs/composition-api` khỏi các phụ thuộc của bạn (và khỏi các module trong `nuxt.config`).

## Using `@vue/composition-api`

Nếu bạn đã sử dụng chỉ `@vue/composition-api` và không phải `@nuxtjs/composition-api`, thì mọi thứ rất đơn giản.

1. Đầu tiên, xóa plugin nơi bạn đang đăng ký Composition API theo cách thủ công. Nuxt Bridge sẽ xử lý điều này cho bạn.
   ```diff
   - import Vue from 'vue'
   - import VueCompositionApi from '@vue/composition-api'
   -
   - Vue.use(VueCompositionApi)
   ```
2. Nếu không, không có gì bạn cần làm. Tuy nhiên, nếu bạn muốn, bạn có thể xóa các import rõ ràng của mình từ `@vue/composition-api` và dựa vào Nuxt Bridge tự động import chúng cho bạn.

## Migrating from `@nuxtjs/composition-api`

Nuxt Bridge triển khai Composition API hơi khác so với `@nuxtjs/composition-api` và cung cấp các composables khác nhau (được thiết kế để phù hợp với các composables mà Nuxt 3 cung cấp).

Vì một số composables đã bị xóa và chưa có thay thế, điều này sẽ là một quá trình hơi phức tạp hơn.

### Remove `@nuxtjs/composition-api/module` from your buildModules

Bạn không cần phải cập nhật ngay lập tức các import của mình - Nuxt Bridge sẽ tự động cung cấp một 'shim' cho hầu hết các import bạn hiện có, để cho bạn thời gian di chuyển sang các composables mới, tương thích với Nuxt 3, với các ngoại lệ sau:

- `withContext` đã bị xóa. Xem [bên dưới](https://nuxt.com/docs/bridge/nuxt3-compatible-api#usecontext-and-withcontext).
- `useStatic` đã bị xóa. Không có thay thế hiện tại. Hãy thoải mái nêu ra một cuộc thảo luận nếu bạn có trường hợp sử dụng cho điều này.
- `reqRef` và `reqSsrRef`, vốn đã bị loại bỏ, giờ đã bị xóa hoàn toàn. Làm theo hướng dẫn bên dưới về [ssrRef](https://nuxt.com/docs/bridge/nuxt3-compatible-api#ssrref-and-shallowssrref) để thay thế điều này.

### Set `bridge.capi`

```ts
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    capi: true,
    nitro: false // If migration to Nitro is complete, set to true
  }
})
```

Đối với mỗi composable khác bạn đang sử dụng từ `@nuxtjs/composition-api`, hãy làm theo các bước bên dưới.

### useFetch

`$fetchState` và `$fetch` đã bị xóa.

```diff
const {
- $fetch,
- $fetchState,
+ fetch,
+ fetchState,
} = useFetch(() => { posts.value = await $fetch('/api/posts') })
```

### `defineNuxtMiddleware`

Đây là một hàm stub trợ giúp loại mà giờ đã bị xóa.

Xóa wrapper `defineNuxtMiddleware`:

```diff
- import { defineNuxtMiddleware } from '@nuxtjs/composition-api`
- export default defineNuxtMiddleware((ctx) => {})
+ export default (ctx) => {}
```

Để hỗ trợ typescript, bạn có thể sử dụng `@nuxt/types`:

```ts
import type { Middleware } from '@nuxt/types'

export default <Middleware> function (ctx) { }
```

### `defineNuxtPlugin`

Đây là một hàm stub trợ giúp loại mà giờ đã bị xóa.

Bạn cũng có thể tiếp tục sử dụng các plugin kiểu Nuxt 2, bằng cách xóa hàm (như với [defineNuxtMiddleware](https://nuxt.com/#definenuxtmiddleware)).

Xóa wrapper `defineNuxtPlugin`:

```diff
- import { defineNuxtPlugin } from '@nuxtjs/composition-api'
- export default defineNuxtPlugin((ctx, inject) => {})
+ export default (ctx, inject) => {}
```

Để hỗ trợ typescript, bạn có thể sử dụng `@nuxt/types`:

```ts
import type { Plugin } from '@nuxt/types'

export default <Plugin> function (ctx, inject) {}
```

::warning
Mặc dù ví dụ này hợp lệ, Nuxt 3 giới thiệu một hàm defineNuxtPlugin mới có chữ ký hơi khác.
::

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/plugins#creating-plugins
---
::

### `useRouter` and `useRoute`

Nuxt Bridge cung cấp các thay thế trực tiếp cho các composables này qua [`useRouter`](https://nuxt.com/docs/api/composables/use-router) và `useRoute`.

Sự khác biệt chính duy nhất là [`useRoute`](https://nuxt.com/docs/api/composables/use-route) không còn trả về một thuộc tính computed.

```diff
- import { useRouter, useRoute } from '@nuxtjs/composition-api'

  const router = useRouter()
  const route = useRoute()

- console.log(route.value.path)
+ console.log(route.path)
```


# Plugins and Middleware

## New Plugins Format

Bây giờ bạn có thể di chuyển sang API plugin của Nuxt 3, có định dạng hơi khác so với Nuxt 2.

Các plugin bây giờ chỉ nhận một đối số (`nuxtApp`). Bạn có thể tìm hiểu thêm trong [tài liệu](https://nuxt.com/docs/guide/directory-structure/plugins).

```js [plugins/hello.ts]
export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.provide('injected', () => 'my injected function')
  // now available on `nuxtApp.$injected`
})
```

::note
Nếu bạn muốn sử dụng các composables Nuxt mới (như [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) hoặc `useRuntimeConfig`) trong các plugin của mình, bạn sẽ cần sử dụng helper `defineNuxtPlugin` cho những plugin đó.
::

::warning
Mặc dù một giao diện tương thích được cung cấp qua `nuxtApp.vueApp`, bạn nên tránh đăng ký plugin, directive, mixin hoặc component theo cách này mà không thêm logic của riêng bạn để đảm bảo chúng không được cài đặt nhiều hơn một lần, hoặc điều này có thể gây rò rỉ bộ nhớ.
::

## New Middleware Format

Bây giờ bạn có thể di chuyển sang API middleware của Nuxt 3, có định dạng hơi khác so với Nuxt 2.

Middleware bây giờ chỉ nhận hai đối số (`to`, `from`). Bạn có thể tìm hiểu thêm trong [tài liệu](https://nuxt.com/docs/guide/directory-structure/middleware).

```ts twoslash
export default defineNuxtRouteMiddleware((to) => {
  if (to.path !== '/') {
    return navigateTo('/')
  }
})
```

::important
Việc sử dụng `defineNuxtRouteMiddleware` không được hỗ trợ bên ngoài thư mục middleware.
::

## definePageMeta

Bạn cũng có thể sử dụng [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) trong Nuxt Bridge.

Bạn có thể được kích hoạt với tùy chọn `macros.pageMeta` trong tệp cấu hình của mình

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    macros: {
      pageMeta: true
    }
  }
})
```

::note
Nhưng chỉ cho `middleware` và `layout`.
::


# New Composition API

Bằng cách di chuyển từ `@nuxtjs/composition-api` sang API tương thích với Nuxt 3, sẽ có ít việc viết lại hơn khi di chuyển sang Nuxt 3.

## `ssrRef` and `shallowSsrRef`

Hai hàm này đã được thay thế bằng một composable mới hoạt động rất giống nhau dưới hood: `useState`.

Sự khác biệt chính là bạn phải cung cấp một *key* cho trạng thái này (mà Nuxt đã tạo tự động cho `ssrRef` và `shallowSsrRef`), và nó chỉ có thể được gọi trong một plugin Nuxt 3 (được định nghĩa bởi `defineNuxtPlugin`) hoặc một instance component. (Nói cách khác, bạn không thể sử dụng [`useState`](https://nuxt.com/docs/api/composables/use-state) với ngữ cảnh global/ambient, vì nguy cơ trạng thái chia sẻ trên các yêu cầu.)

```diff
- import { ssrRef } from '@nuxtjs/composition-api'

- const ref1 = ssrRef('initialData')
- const ref2 = ssrRef(() => 'factory function')
+ const ref1 = useState('ref1-key', () => 'initialData')
+ const ref2 = useState('ref2-key', () => 'factory function')
  // accessing the state
  console.log(ref1.value)
```

Vì trạng thái được khóa, bạn có thể truy cập cùng trạng thái từ nhiều vị trí, miễn là bạn đang sử dụng cùng key.

Bạn có thể đọc thêm về cách sử dụng composable này trong [tài liệu Nuxt 3](https://nuxt.com/docs/api/composables/use-state).

## `ssrPromise`

Hàm này đã bị xóa, và bạn sẽ cần tìm một triển khai thay thế nếu bạn đã sử dụng nó. Nếu bạn có trường hợp sử dụng cho `ssrPromise`, vui lòng cho chúng tôi biết qua một cuộc thảo luận.

## `onGlobalSetup`

Hàm này đã bị xóa, nhưng các trường hợp sử dụng của nó có thể được đáp ứng bằng cách sử dụng [`useNuxtApp`](https://nuxt.com/docs/api/composables/use-nuxt-app) hoặc [`useState`](https://nuxt.com/docs/api/composables/use-state) trong `defineNuxtPlugin`. Bạn cũng có thể chạy bất kỳ mã tùy chỉnh nào trong hàm `setup()` của một layout.

```diff
- import { onGlobalSetup } from '@nuxtjs/composition-api'

- export default () => {
-   onGlobalSetup(() => {
+ export default defineNuxtPlugin((nuxtApp) => {
+   nuxtApp.hook('vue:setup', () => {
      // ...
    })
- }
+ })
```

## `useStore`

Để truy cập instance store Vuex, bạn có thể sử dụng `useNuxtApp().$store`.

```diff
- import { useStore } from '@nuxtjs/composition-api`
+ const { $store } = useNuxtApp()
```

## `useContext` and `withContext`

Bạn có thể truy cập các helper được inject bằng `useNuxtApp`.

```diff
- import { useContext } from '@nuxtjs/composition-api`
+ const { $axios } = useNuxtApp()
```

::note
`useNuxtApp()` cũng cung cấp một key gọi là `nuxt2Context` chứa tất cả các thuộc tính giống nhau bạn thường truy cập từ ngữ cảnh Nuxt 2, nhưng được khuyên *không* sử dụng trực tiếp, vì nó sẽ không tồn tại trong Nuxt 3. Thay vào đó, xem liệu có cách khác để truy cập những gì bạn cần không. (Nếu không, vui lòng nêu yêu cầu tính năng hoặc thảo luận.)
::

## `wrapProperty`

Hàm helper này không được cung cấp nữa nhưng bạn có thể thay thế nó bằng mã sau:

```js
const wrapProperty = (property, makeComputed = true) => () => {
  const vm = getCurrentInstance().proxy
  return makeComputed ? computed(() => vm[property]) : vm[property]
}
```

## `useAsync` and `useFetch`

Hai composables này có thể được thay thế bằng `useLazyAsyncData` và `useLazyFetch`, được ghi chép [trong tài liệu Nuxt 3](https://nuxt.com/docs/getting-started/data-fetching). Giống như các composables `@nuxtjs/composition-api` trước đó, các composables này không chặn điều hướng route ở phía client (do đó phần 'lazy' của tên).

::important
Lưu ý rằng API hoàn toàn khác, mặc dù tên nghe giống nhau. Quan trọng là, bạn không nên cố gắng thay đổi giá trị của các biến khác bên ngoài composable (như bạn có thể đã làm với `useFetch` trước đó).
::

::warning
`useLazyFetch` phải đã được cấu hình cho [Nitro](https://nuxt.com/docs/bridge/nitro).
::

Di chuyển sang các composables mới từ `useAsync`:

```diff
<script setup>
- import { useAsync } from '@nuxtjs/composition-api'
- const posts = useAsync(() => $fetch('/api/posts'))
+ const { data: posts } = useLazyAsyncData('posts', () => $fetch('/api/posts'))
+ // or, more simply!
+ const { data: posts } = useLazyFetch('/api/posts')
</script>
```

Di chuyển sang các composables mới từ `useFetch`:

```diff
<script setup>
- import { useFetch } from '@nuxtjs/composition-api'
- const posts = ref([])
- const { fetch } = useFetch(() => { posts.value = await $fetch('/api/posts') })
+ const { data: posts, refresh } = useLazyAsyncData('posts', () => $fetch('/api/posts'))
+ // or, more simply!
+ const { data: posts, refresh } = useLazyFetch('/api/posts')
  function updatePosts() {
-   return fetch()
+   return refresh()
  }
</script>
```

### `useMeta`

Để tương tác với `vue-meta`, bạn có thể sử dụng `useNuxt2Meta`, sẽ hoạt động trong Nuxt Bridge (nhưng không phải Nuxt 3) và sẽ cho phép bạn thao tác các thẻ meta của mình theo cách tương thích với `vue-meta`.

```diff
<script setup>
- import { useMeta } from '@nuxtjs/composition-api'
  useNuxt2Meta({
    title: 'My Nuxt App',
  })
</script>
```

Bạn cũng có thể truyền vào các giá trị computed hoặc refs, và các giá trị meta sẽ được cập nhật một cách reactive:

```ts
<script setup>
const title = ref('my title')
useNuxt2Meta({
  title,
})
title.value = 'new title'
</script>
```

::note
Cẩn thận không sử dụng cả `useNuxt2Meta()` và Options API `head()` trong cùng một component, vì hành vi có thể không thể dự đoán.
::

Nuxt Bridge cũng cung cấp một triển khai meta tương thích với Nuxt 3 có thể được truy cập với composable [`useHead`](https://nuxt.com/docs/api/composables/use-head).

```diff
<script setup>
- import { useMeta } from '@nuxtjs/composition-api'
  useHead({
    title: 'My Nuxt App',
  })
</script>
```

Bạn cũng sẽ cần kích hoạt nó rõ ràng trong `nuxt.config` của mình:

```js
import { defineNuxtConfig } from '@nuxt/bridge'
export default defineNuxtConfig({
  bridge: {
    meta: true
  }
})
```

Composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) này sử dụng `@unhead/vue` dưới hood (thay vì `vue-meta`) để thao tác `<head>` của bạn. Theo đó, được khuyến nghị không sử dụng cả các thuộc tính `head()` Nuxt 2 native cũng như [`useHead`](https://nuxt.com/docs/api/composables/use-head), vì chúng có thể xung đột.

Để biết thêm thông tin về cách sử dụng composable này, xem [tài liệu Nuxt 3](https://nuxt.com/docs/getting-started/seo-meta).

### Explicit Imports

Nuxt expose mọi auto-import với alias `#imports` có thể được sử dụng để làm import rõ ràng nếu cần:

```vue
<script setup lang="ts">
import { ref, computed } from '#imports'

const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Disabling Auto-imports

Nếu bạn muốn tắt auto-importing composables và utilities, bạn có thể đặt `imports.autoImport` thành `false` trong tệp `nuxt.config`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    autoImport: false
  }
})
```

Điều này sẽ tắt auto-imports hoàn toàn nhưng vẫn có thể sử dụng [explicit imports](https://nuxt.com/#explicit-imports) từ `#imports`.


# Meta Tags

Nếu bạn cần truy cập trạng thái component với `head`, bạn nên di chuyển sang sử dụng [`useHead`](https://nuxt.com/docs/api/composables/use-head).

Nếu bạn cần sử dụng Options API, có một phương thức `head()` bạn có thể sử dụng khi bạn sử dụng `defineNuxtComponent`.

## Migration

### Set `bridge.meta`

```js
import { defineNuxtConfig } from '@nuxt/bridge'
export default defineNuxtConfig({
  bridge: {
    meta: true,
    nitro: false // If migration to Nitro is complete, set to true
  }
})
```

### Update head properties

Trong `nuxt.config` của bạn, đổi tên `head` thành `meta`. (Lưu ý rằng các object không còn có key `hid` để loại bỏ trùng lặp.)

::code-group
```ts [Nuxt 2]
export default {
  head: {
    titleTemplate: '%s - Nuxt',
    meta: [
      { charset: 'utf-8' },
      { name: 'viewport', content: 'width=device-width, initial-scale=1' },
      { hid: 'description', name: 'description', content: 'Meta description' }
    ]
  }
}
```

```ts [Nuxt 3]
export default defineNuxtConfig({
  app: {
    head: {
      titleTemplate: '%s - Nuxt',
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { name: 'description', content: 'Meta description' }
      ]
    }
  }
})
```
::

## `useHead` Composables

Nuxt Bridge cung cấp một API meta Nuxt 3 mới có thể được truy cập với một composable mới [`useHead`](https://nuxt.com/docs/api/composables/use-head).

```vue
<script setup lang="ts">
useHead({
  title: 'My Nuxt App',
})
</script>
```

::tip
Composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) này sử dụng `@unhead/vue` dưới hood (thay vì `vue-meta`) để thao tác `<head>` của bạn.
::

::warning
Chúng tôi khuyến nghị không sử dụng các thuộc tính `head()` Nuxt 2 native ngoài [`useHead`](https://nuxt.com/docs/api/composables/use-head), vì chúng có thể xung đột.
::

Để biết thêm thông tin về cách sử dụng composable này, xem [tài liệu](https://nuxt.com/docs/getting-started/seo-meta).

## Options API

```vue
<script>
// if using options API `head` method you must use `defineNuxtComponent`
export default defineNuxtComponent({
  head (nuxtApp) {
    // `head` receives the nuxt app but cannot access the component instance
    return {
      meta: [{
        name: 'description',
        content: 'This is my page description.'
      }]
    }
  }
})
</script>
```

::warning
Thay đổi có thể gây lỗi: `head` nhận nuxt app nhưng không thể truy cập instance component. Nếu mã trong `head` của bạn cố gắng truy cập object data qua `this` hoặc `this.$data`, bạn sẽ cần di chuyển sang composable `useHead`.
::

## Title Template

Nếu bạn muốn sử dụng một hàm (để kiểm soát đầy đủ), thì điều này không thể được đặt trong nuxt.config của bạn, và được khuyến nghị thay vào đó đặt nó trong thư mục `/layouts` của bạn.

```vue [layouts/default.vue]
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} - Site Title` : 'Site Title';
  }
})
</script>
```


# Runtime Config

::warning
Khi sử dụng tùy chọn `runtimeConfig`, [nitro](https://nuxt.com/docs/bridge/nitro) phải đã được cấu hình.
::

## Update Runtime Config

Nuxt 3 tiếp cận runtime config khác với Nuxt 2, sử dụng một tùy chọn `runtimeConfig` kết hợp mới.

Đầu tiên, bạn sẽ cần kết hợp các thuộc tính `publicRuntimeConfig` và `privateRuntimeConfig` của mình thành một cái mới gọi là `runtimeConfig`, với config public trong một key gọi là `public`.

```diff
// nuxt.config.js
- privateRuntimeConfig: {
-   apiKey: process.env.NUXT_API_KEY || 'super-secret-key'
- },
- publicRuntimeConfig: {
-   websiteURL: 'https://public-data.com'
- }
+ runtimeConfig: {
+   apiKey: process.env.NUXT_API_KEY || 'super-secret-key',
+   public: {
+     websiteURL: 'https://public-data.com'
+   }
+ }
```

Điều này cũng có nghĩa là khi bạn cần truy cập public runtime config, nó nằm sau một thuộc tính gọi là `public`. Nếu bạn sử dụng public runtime config, bạn sẽ cần cập nhật mã của mình.

```diff
// MyWidget.vue
- <div>Website: {{ $config.websiteURL }}</div>
+ <div>Website: {{ $config.public.websiteURL }}</div>
```


# Nitro

## Remove Modules

- Xóa `@nuxt/nitro`: Bridge inject cùng chức năng

## Update Config

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    nitro: true
  }
})
```

## Update Your Scripts

Bạn cũng sẽ cần cập nhật các script trong `package.json` của mình để phản ánh thực tế rằng Nuxt bây giờ sẽ tạo ra một máy chủ Nitro làm đầu ra build.

### Install Nuxi

Cài đặt `nuxi` làm phụ thuộc phát triển:

::code-group{sync="pm"}
```bash [npm]
npm install -D nuxi
```

```bash [yarn]
yarn add --dev nuxi
```

```bash [pnpm]
pnpm add -D nuxi
```

```bash [bun]
bun add -D nuxi
```
::

### Nuxi

Nuxt 3 giới thiệu lệnh CLI Nuxt mới [`nuxi`](https://nuxt.com/docs/api/commands/add). Cập nhật các script của bạn như sau để tận dụng hỗ trợ tốt hơn từ Nuxt Bridge:

```diff
{
  "scripts": {
-   "dev": "nuxt",
+   "dev": "nuxi dev",
-   "build": "nuxt build",
+   "build": "nuxi build",
-   "start": "nuxt start",
+   "start": "nuxi preview"
  }
}
```

::tip
Nếu `nitro: false`, sử dụng lệnh `nuxt2`.
::

### Static Target

Nếu bạn đã đặt `target: 'static'` trong `nuxt.config` của mình thì bạn cần đảm bảo cập nhật script build của mình thành `nuxi generate`.

```json [package.json]
{
  "scripts": {
    "build": "nuxi generate"
  }
}
```

### Server Target

Đối với tất cả các tình huống khác, bạn có thể sử dụng lệnh `nuxi build`.

```json [package.json]
{
  "scripts": {
    "build": "nuxi build",
    "start": "nuxi preview"
  }
}
```

## Exclude Built Nitro Folder From Git

Thêm thư mục `.output` vào tệp `.gitignore`.

## Ensure Everything Goes Well

✔️ Hãy thử với `nuxi dev` và `nuxi build` (hoặc `nuxi generate`) để xem liệu mọi thứ có diễn ra tốt không.


# Vite

::warning
Khi sử dụng `vite`, [nitro](https://nuxt.com/docs/bridge/nitro) phải đã được cấu hình.
::

## Remove Modules

- Xóa `nuxt-vite`: Bridge kích hoạt cùng chức năng

## Update Config

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    vite: true,
    nitro: true
  }
})
```

## Configuration

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  vite: {
    // Config for Vite
  }
})
```


# Overview

Có những thay đổi đáng kể khi di chuyển ứng dụng Nuxt 2 sang Nuxt 3, mặc dù bạn có thể mong đợi quá trình di chuyển trở nên đơn giản hơn khi chúng tôi tiến tới phiên bản ổn định.

::note
Hướng dẫn di chuyển này đang được tiến hành để phù hợp với sự phát triển của Nuxt 3.
::

Một số thay đổi đáng kể này bao gồm:

1. Chuyển từ Vue 2 sang Vue 3, bao gồm mặc định sử dụng Composition API và script setup.
2. Chuyển từ webpack 4 và Babel sang Vite hoặc webpack 5 và esbuild.
3. Chuyển từ phụ thuộc runtime Nuxt sang máy chủ độc lập tối thiểu được biên dịch với nitropack.

::tip
Nếu bạn cần duy trì Nuxt 2, nhưng muốn hưởng lợi từ các tính năng của Nuxt 3 trong Nuxt 2, bạn có thể thay thế kiểm tra [cách bắt đầu với Bridge](https://nuxt.com/docs/bridge/overview).
::

## Next Steps

- Tìm hiểu về sự khác biệt trong [cấu hình](https://nuxt.com/docs/migration/configuration)


# Build Tooling

Chúng tôi sử dụng các build tools sau theo mặc định:

- [Vite](https://vite.dev){rel="nofollow"} or [webpack](https://webpack.js.org){rel="nofollow"}
- [Rollup](https://rollupjs.org){rel="nofollow"}
- [PostCSS](https://postcss.org){rel="nofollow"}
- [esbuild](https://esbuild.github.io){rel="nofollow"}

Vì lý do này, hầu hết cấu hình `build` trước đây của bạn trong `nuxt.config` sẽ hiện bị bỏ qua, bao gồm bất kỳ cấu hình babel tùy chỉnh nào.

Nếu bạn cần cấu hình bất kỳ build tools nào của Nuxt, bạn có thể làm vậy trong `nuxt.config` của bạn, sử dụng các keys top-level mới `vite`, `webpack` và `postcss`.

Ngoài ra, Nuxt đi kèm với hỗ trợ TypeScript.

::read-more{to="https://nuxt.com/docs/guide/concepts/typescript"}
::

## Steps

1. Xóa `@nuxt/typescript-build` và `@nuxt/typescript-runtime` khỏi dependencies và modules của bạn.
2. Xóa bất kỳ babel dependencies không sử dụng nào khỏi project của bạn.
3. Xóa bất kỳ core-js dependencies rõ ràng nào.
4. Di chuyển `require` sang `import`.


# Server

Trong một ứng dụng Nuxt 3 đã build, không có runtime Nuxt dependency. Điều đó có nghĩa là site của bạn sẽ rất performant, và ultra-slim. Nhưng nó cũng có nghĩa là bạn không thể hook vào runtime Nuxt server hooks nữa.

::read-more{to="https://nuxt.com/docs/guide/concepts/server-engine"}
::

## Steps

1. Xóa key `render` trong `nuxt.config` của bạn.
2. Bất kỳ tệp nào trong `~/server/api` và `~/server/middleware` sẽ được đăng ký tự động; bạn có thể xóa chúng khỏi mảng `serverMiddleware` của bạn.
3. Cập nhật bất kỳ items nào khác trong mảng `serverMiddleware` của bạn để trỏ đến tệp hoặc npm packages trực tiếp, thay vì sử dụng inline functions.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/server"}
::

::read-more
---
to: https://nuxt.com/docs/guide/going-further/hooks#server-hooks-runtime
---
::


# Configuration

## `nuxt.config`

Điểm khởi đầu cho ứng dụng Nuxt của bạn vẫn là tệp `nuxt.config` của bạn.

::note
Cấu hình Nuxt sẽ được tải bằng cách sử dụng [`unjs/jiti`](https://github.com/unjs/jiti){rel="nofollow"} và [`unjs/c12`](https://github.com/unjs/c12){rel="nofollow"}.
::

### Migration

1. Bạn nên di chuyển sang hàm `defineNuxtConfig` mới để cung cấp schema cấu hình được nhập. :code-group[```ts \[Nuxt 2\]
   export default {
     // ...
   }
   ``````ts \[Nuxt 3\]
   export default defineNuxtConfig({
     // ...
   })
   ```]
2. Nếu bạn đang sử dụng `router.extendRoutes` bạn có thể di chuyển sang hook `pages:extend` mới: :code-group[```ts \[Nuxt 2\]
   export default {
     router: {
       extendRoutes (routes) {
         //
       }
     }
   }
   ``````ts \[Nuxt 3\]
   export default defineNuxtConfig({
     hooks: {
       'pages:extend' (routes) {
         //
       }
     }
   })
   ```]
3. Nếu bạn đang sử dụng `router.routeNameSplitter` bạn có thể đạt được kết quả tương tự bằng cách cập nhật logic tạo tên route trong hook `pages:extend` mới: :code-group[```ts \[Nuxt 2\]
   export default {
     router: {
       routeNameSplitter: '/'
     }
   }
   ``````ts \[Nuxt 3\]
   import { createResolver } from '@nuxt/kit'

   export default defineNuxtConfig({
     hooks: {
       'pages:extend' (routes) {
         const routeNameSplitter = '/'
         const root = createResolver(import.meta.url).resolve('./pages')

         function updateName(routes) {
           if (!routes) return

           for (const route of routes) {
             const relativePath = route.file.substring(root.length + 1)
             route.name = relativePath.slice(0, -4).replace(/\/index$/, '').replace(/\//g, routeNameSplitter)

             updateName(route.children)
           }
         }
         updateName(routes)
       },
     },
   })
   ```]

#### ESM Syntax

Nuxt 3 là một framework gốc ESM. Mặc dù [`unjs/jiti`](https://github.com/unjs/jiti){rel="nofollow"} cung cấp khả năng tương thích bán phần khi tải tệp `nuxt.config`, tránh bất kỳ việc sử dụng `require` và `module.exports` nào trong tệp này.

1. Thay đổi `module.exports` thành `export default`
2. Thay đổi `const lib = require('lib')` thành `import lib from 'lib'`

#### Async Configuration

Để làm cho hành vi tải Nuxt trở nên dự đoán hơn, cú pháp cấu hình async đã bị deprecated. Cân nhắc sử dụng hooks Nuxt cho các hoạt động async.

#### Dotenv

Nuxt có hỗ trợ tích hợp để tải tệp `.env`. Tránh nhập trực tiếp từ `nuxt.config`.

## Modules

Nuxt và Nuxt Modules hiện chỉ là build-time-only.

### Migration

1. Di chuyển tất cả `buildModules` của bạn vào `modules`.
2. Kiểm tra khả năng tương thích Nuxt 3 của các modules.
3. Nếu bạn có bất kỳ module cục bộ nào trỏ đến một thư mục, bạn nên cập nhật điều này để trỏ đến tệp entry:

```diff
  export default defineNuxtConfig({
    modules: [
-     '~/modules/my-module'
+     '~/modules/my-module/index'
    ]
  })
```

::tip
Nếu bạn là tác giả module, bạn có thể kiểm tra [thông tin thêm về khả năng tương thích module](https://nuxt.com/docs/migration/module-authors) và [hướng dẫn tác giả module của chúng tôi](https://nuxt.com/docs/guide/going-further/modules).
::

## Directory Changes

Thư mục `static/` (để lưu trữ tài sản tĩnh) đã được đổi tên thành `public/`. Bạn có thể đổi tên thư mục `static` của mình thành `public`, hoặc giữ tên bằng cách thiết lập `dir.public` trong `nuxt.config` của bạn.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/public"}
::

## TypeScript

Sẽ dễ dàng hơn nhiều để di chuyển ứng dụng của bạn nếu bạn sử dụng tích hợp TypeScript của Nuxt. Điều này không có nghĩa là bạn cần viết ứng dụng của mình bằng TypeScript, chỉ là Nuxt sẽ cung cấp gợi ý kiểu tự động cho trình soạn thảo của bạn.

Bạn có thể đọc thêm về hỗ trợ TypeScript của Nuxt [trong tài liệu](https://nuxt.com/docs/guide/concepts/typescript).

::note
Nuxt có thể kiểm tra kiểu ứng dụng của bạn bằng cách sử dụng [`vue-tsc`](https://github.com/vuejs/language-tools/tree/master/packages/tsc){rel="nofollow"} với lệnh `nuxt typecheck`.
::

### Migration

1. Tạo một `tsconfig.json` với nội dung sau:
   ```json
   {
     "files": [],
     "references": [
       {
         "path": "./.nuxt/tsconfig.app.json"
       },
       {
         "path": "./.nuxt/tsconfig.server.json"
       },
       {
         "path": "./.nuxt/tsconfig.shared.json"
       },
       {
         "path": "./.nuxt/tsconfig.node.json"
       }
     ]
   }
   ```
2. Chạy `npx nuxt prepare` để tạo các tệp tsconfig.
3. Cài đặt Volar theo hướng dẫn trong [tài liệu](https://nuxt.com/docs/getting-started/introduction#prerequisites).

## Vue Changes

Có một số thay đổi đối với những gì được khuyến nghị là best practice Vue, cũng như một số breaking changes giữa Vue 2 và 3.

Bạn nên đọc [hướng dẫn di chuyển Vue 3](https://v3-migration.vuejs.org){rel="nofollow"} và đặc biệt là [danh sách breaking changes](https://v3-migration.vuejs.org/breaking-changes){rel="nofollow"}.

Hiện tại không thể sử dụng [build di chuyển Vue 3](https://v3-migration.vuejs.org/migration-build.html){rel="nofollow"} với Nuxt 3.

## Vuex

Nuxt không còn cung cấp tích hợp Vuex. Thay vào đó, khuyến nghị chính thức của Vue là sử dụng `pinia`, có hỗ trợ tích hợp Nuxt thông qua một [module Nuxt](https://pinia.vuejs.org/ssr/nuxt.html){rel="nofollow"}. [Tìm hiểu thêm về pinia tại đây](https://pinia.vuejs.org){rel="nofollow"}.

Một cách đơn giản để cung cấp quản lý trạng thái toàn cục với pinia sẽ là:

Cài đặt module [`@pinia/nuxt`](https://nuxt.com/modules/pinia):

```bash [Terminal]
yarn add pinia @pinia/nuxt
```

Kích hoạt module trong cấu hình nuxt của bạn:

```ts [nuxt.config.ts]
import { defineNuxtConfig } from 'nuxt/config';

export default defineNuxtConfig({
  modules: ['@pinia/nuxt']
})
```

Tạo một thư mục `store` tại root của ứng dụng của bạn:

```ts [store/index.ts]
import { defineStore } from 'pinia'

export const useMainStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  actions: {
    increment() {
      // `this` là instance store
      this.counter++
    },
  },
})
```

Tạo một tệp plugin để toàn cầu hóa store của bạn:

```ts [plugins/pinia.ts]
import { useMainStore } from '~/store'

export default defineNuxtPlugin(({ $pinia }) => {
  return {
    provide: {
      store: useMainStore($pinia)
    }
  }
})
```

Nếu bạn muốn giữ Vuex, bạn có thể di chuyển thủ công sang Vuex 4 theo [những bước này](https://vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html){rel="nofollow"}.

Sau khi hoàn thành, bạn sẽ cần thêm plugin sau vào ứng dụng Nuxt của bạn:

```ts [plugins/vuex.ts]
import store from '~/store'

export default defineNuxtPlugin(nuxtApp => {
  nuxtApp.vueApp.use(store);
})
```

Đối với các ứng dụng lớn hơn, việc cập nhật Vuex có thể đòi hỏi rất nhiều công việc. Nếu việc cập nhật Vuex vẫn tạo ra trở ngại, bạn có thể sử dụng module cộng đồng: [nuxt3-vuex-module](https://github.com/vedmant/nuxt3-vuex#nuxt3-vuex-module){rel="nofollow"}, sẽ hoạt động ngay lập tức.


# Modules

## Module Compatibility

Nuxt 3 có một lớp tương thích ngược cơ bản cho các modules Nuxt 2 sử dụng auto wrappers `@nuxt/kit`. Nhưng thường có các bước để làm cho modules tương thích với Nuxt 3 và đôi khi, sử dụng Nuxt Bridge là cần thiết cho cross-version compatibility.

Chúng tôi đã chuẩn bị một [Hướng dẫn Dành riêng](https://nuxt.com/docs/guide/going-further/modules) cho việc authoring modules sẵn sàng Nuxt 3 sử dụng `@nuxt/kit`. Hiện tại best migration path là làm theo nó và rewrite modules của bạn. Phần còn lại của hướng dẫn này bao gồm các bước chuẩn bị nếu bạn muốn tránh một full rewrite nhưng vẫn làm cho modules tương thích với Nuxt 3.

::tip{icon="i-lucide-puzzle" to="https://nuxt.com/modules"}
Khám phá các modules tương thích Nuxt 3.
::

### Plugin Compatibility

Plugins Nuxt 3 **không** hoàn toàn tương thích ngược với Nuxt 2.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

### Vue Compatibility

Plugins hoặc components sử dụng Composition API cần hỗ trợ Vue 2 hoặc Vue 3 độc quyền.

Bằng cách sử dụng [vue-demi](https://github.com/vueuse/vue-demi){rel="nofollow"} chúng nên tương thích với cả Nuxt 2 và 3.

## Module Migration

Khi users Nuxt 3 thêm module của bạn, bạn sẽ không có quyền truy cập vào module container (`this.*`) vì vậy bạn sẽ cần sử dụng utilities từ `@nuxt/kit` để truy cập chức năng container.

### Test with `@nuxt/bridge`

Di chuyển sang `@nuxt/bridge` là bước đầu tiên và quan trọng nhất để hỗ trợ Nuxt 3.

Nếu bạn có một fixture hoặc example trong module của bạn, thêm package `@nuxt/bridge` vào config của nó (xem [example](https://nuxt.com/docs/bridge/overview#update-nuxtconfig))

### Migrate from CommonJS to ESM

Nuxt 3 natively supports TypeScript và ECMAScript Modules. Vui lòng kiểm tra [Native ES Modules](https://nuxt.com/docs/guide/concepts/esm) để biết thêm info và upgrading.

### Ensure Plugins Default Export

Nếu bạn inject một Nuxt plugin không có `export default` (như global Vue plugins), đảm bảo bạn thêm `export default () => { }` vào cuối của nó.

::code-group
```js [Before]
// ~/plugins/vuelidate.js
import Vue from 'vue'
import Vuelidate from 'vuelidate'

Vue.use(Vuelidate)
```

```js [After]
// ~/plugins/vuelidate.js
import Vue from 'vue'
import Vuelidate from 'vuelidate'

Vue.use(Vuelidate)

export default () => { }
```
::

### Avoid Runtime Modules

Với Nuxt 3, Nuxt hiện là build-time-only dependency, có nghĩa là modules không nên cố gắng hook vào Nuxt runtime.

Module của bạn nên hoạt động ngay cả khi nó chỉ được thêm vào [`buildModules`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig) (thay vì `modules`). Ví dụ:

- Tránh cập nhật `process.env` trong một Nuxt module và đọc bởi một Nuxt plugin; sử dụng [`runtimeConfig`](https://nuxt.com/docs/api/nuxt-config#runtimeconfig) thay thế.
- (\*) Tránh phụ thuộc vào runtime hooks như `vue-renderer:*` cho production
- (\*) Tránh thêm `serverMiddleware` bằng cách import chúng bên trong module. Thay vào đó, thêm chúng bằng cách tham chiếu một file path để chúng độc lập với context của module.

(\*) Trừ khi nó chỉ dành cho mục đích `nuxt dev` và được bảo vệ với `if (nuxt.options.dev) { }`.

::tip
Tiếp tục đọc về modules Nuxt 3 trong [Hướng dẫn Tác giả Modules](https://nuxt.com/docs/guide/going-further/modules).
::

### Use TypeScript (Optional)

Mặc dù không cần thiết, hầu hết ecosystem Nuxt đang chuyển sang sử dụng TypeScript, vì vậy nó được khuyến nghị cao để cân nhắc migration.

::tip
Bạn có thể bắt đầu migration bằng cách đổi tên tệp `.js` thành `.ts`. TypeScript được thiết kế để progressive!
::

::tip
Bạn có thể sử dụng syntax TypeScript cho modules và plugins Nuxt 2 và 3 mà không cần dependencies extra.
::


# Auto Imports

::note
Trong phần còn lại của tài liệu di chuyển, bạn sẽ nhận thấy rằng các tiện ích Nuxt và Vue chính không có import rõ ràng. Điều này không phải là lỗi đánh máy; Nuxt sẽ tự động import chúng cho bạn, và bạn sẽ nhận được gợi ý kiểu đầy đủ nếu bạn đã làm theo [các hướng dẫn](https://nuxt.com/docs/migration/configuration#typescript) để sử dụng hỗ trợ TypeScript của Nuxt.
::

[Đọc thêm về auto imports](https://nuxt.com/docs/guide/concepts/auto-imports)

## Migration

1. Nếu bạn đã sử dụng `@nuxt/components` trong Nuxt 2, bạn có thể xóa `components: true` trong `nuxt.config` của bạn. Nếu bạn có thiết lập phức tạp hơn, thì lưu ý rằng các tùy chọn component đã thay đổi một chút. Xem [tài liệu components](https://nuxt.com/docs/guide/directory-structure/components) để biết thêm thông tin.

::tip
Bạn có thể xem `.nuxt/types/components.d.ts` và `.nuxt/types/imports.d.ts` để xem cách Nuxt đã giải quyết auto-imports của components và composables của bạn.
::


# Meta Tags

Nuxt 3 cung cấp một số cách khác nhau để quản lý meta tags của bạn:

1. Thông qua `nuxt.config` của bạn.
2. Thông qua composable [`useHead`](https://nuxt.com/docs/api/composables/use-head) [composable](https://nuxt.com/docs/getting-started/seo-meta)
3. Thông qua [global meta components](https://nuxt.com/docs/getting-started/seo-meta)

Bạn có thể tùy chỉnh `title`, `titleTemplate`, `base`, `script`, `noscript`, `style`, `meta`, `link`, `htmlAttrs` và `bodyAttrs`.

::tip
Nuxt hiện đang sử dụng [`Unhead`](https://github.com/unjs/unhead){rel="nofollow"} để quản lý meta tags của bạn, nhưng implementation details có thể thay đổi.
::

::read-more{to="https://nuxt.com/docs/getting-started/seo-meta"}
::

## Migration

1. Trong `nuxt.config` của bạn, đổi tên `head` thành `meta`. Cân nhắc di chuyển cấu hình meta chia sẻ này vào `app.vue` của bạn thay thế. (Lưu ý rằng objects không còn có key `hid` để deduplication.)
2. Nếu bạn cần truy cập trạng thái component với `head`, bạn nên di chuyển sang sử dụng [`useHead`](https://nuxt.com/docs/api/composables/use-head) . Bạn cũng có thể cân nhắc sử dụng built-in meta-components.
3. Nếu bạn cần sử dụng Options API, có một method `head()` bạn có thể sử dụng khi bạn sử dụng `defineNuxtComponent`.

### useHead

::code-group
```vue [Nuxt 2]
<script>
export default {
  data: () => ({
    title: 'My App',
    description: 'My App Description'
  })
  head () {
    return {
      title: this.title,
      meta: [{
        hid: 'description',
        name: 'description',
        content: this.description
      }]
    }
  }
}
</script>
```

```vue [Nuxt 3]
<script setup lang="ts">
const title = ref('My App')
const description = ref('My App Description')

// This will be reactive when you change title/description above
useHead({
  title,
  meta: [{
    name: 'description',
    content: description
  }]
})
</script>
```
::

### Meta-components

Nuxt 3 cũng cung cấp meta components mà bạn có thể sử dụng để đạt được cùng tác vụ. Mặc dù các components này trông giống như HTML tags, chúng được cung cấp bởi Nuxt và có chức năng tương tự.

::code-group
```vue [Nuxt 2]
<script>
 export default {
   head () {
     return {
       title: 'My App',
       meta: [{
         hid: 'description',
         name: 'description',
         content: 'My App Description'
       }]
     }
   }
 }
</script>
```

```vue [Nuxt 3]
<template>
  <div>
    <Head>
      <Title>My App</Title>
      <Meta name="description" content="My app description"/>
    </Head>
    <!-- -->
  </div>
</template>
```
::

::important
1. Hãy đảm bảo sử dụng chữ cái viết hoa cho tên component này để phân biệt với native HTML elements (`<Title>` chứ không phải `<title>`).
2. Bạn có thể đặt các components này ở bất kỳ đâu trong template của bạn cho trang của bạn.
::

### Options API

```vue [Nuxt 3 (Options API)]
<script>
// if using options API `head` method you must use `defineNuxtComponent`
export default defineNuxtComponent({
  head (nuxtApp) {
    // `head` receives the nuxt app but cannot access the component instance
    return {
      meta: [{
        name: 'description',
        content: 'This is my page description.'
      }]
    }
  }
})
</script>
```


# Plugins and Middleware

## Plugins

Plugins hiện có định dạng khác, và chỉ nhận một đối số (`nuxtApp`).

::code-group
```js [Nuxt 2]
export default (ctx, inject) => {
  inject('injected', () => 'my injected function')
})
```

```ts [Nuxt 3]
export default defineNuxtPlugin(nuxtApp => {
  // now available on `nuxtApp.$injected`
  nuxtApp.provide('injected', () => 'my injected function')

  // You can alternatively use this format, which comes with automatic type support
  return {
    provide: {
      injected: () => 'my injected function'
    }
  }
})
```
::

::read-more{to="https://nuxt.com/docs/guide/directory-structure/plugins"}
::

::read-more{to="https://nuxt.com/docs/api/composables/use-nuxt-app"}
Đọc thêm về định dạng của `nuxtApp`.
::

### Migration

1. Di chuyển plugins của bạn sang sử dụng helper function `defineNuxtPlugin`.
2. Xóa bất kỳ entries nào trong mảng plugins của `nuxt.config` nằm trong thư mục `plugins/` của bạn. Tất cả các tệp ở cấp cao nhất (và bất kỳ tệp index nào trong bất kỳ thư mục con nào) sẽ được đăng ký tự động. Thay vì thiết lập `mode` thành `client` hoặc `server`, bạn có thể chỉ ra điều này trong tên tệp. Ví dụ, `~/plugins/my-plugin.client.ts` sẽ chỉ được tải trên client-side.

## Route Middleware

Route middleware có định dạng khác.

::code-group
```js [Nuxt 2]
export default function ({ store, redirect }) {
  // If the user is not authenticated
  if (!store.state.authenticated) {
    return redirect('/login')
  }
}
```

```ts [Nuxt 3]
export default defineNuxtRouteMiddleware((to, from) => {
  const auth = useState('auth')
  if (!auth.value.authenticated) {
    return navigateTo('/login')
  }
})
```
::

Tương tự như Nuxt 2, route middleware được đặt trong thư mục `~/middleware` của bạn được đăng ký tự động. Bạn có thể chỉ định nó theo tên trong một component. Tuy nhiên, điều này được thực hiện với `definePageMeta` chứ không phải là một component option.

`navigateTo` là một trong số các route helper functions.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/middleware"}
::

### Migration

1. Di chuyển route middleware của bạn sang sử dụng helper function `defineNuxtRouteMiddleware`.
2. Bất kỳ global middleware nào (như trong `nuxt.config` của bạn) có thể được đặt trong thư mục `~/middleware` với phần mở rộng `.global`, ví dụ `~/middleware/auth.global.ts`.


# Pages and Layouts

## `app.vue`

Nuxt 3 cung cấp một điểm nhập tập trung cho ứng dụng của bạn qua `~/app.vue`.

::note
Nếu bạn không có tệp `app.vue` trong thư mục nguồn của bạn, Nuxt sẽ sử dụng phiên bản mặc định của riêng nó.
::

Tệp này là một nơi tuyệt vời để đặt bất kỳ code tùy chỉnh nào cần chạy một lần khi ứng dụng của bạn khởi động, cũng như bất kỳ components nào có mặt trên mọi trang của ứng dụng của bạn. Ví dụ, nếu bạn chỉ có một layout, bạn có thể di chuyển điều này sang `app.vue` thay thế.

::read-more{to="https://nuxt.com/docs/guide/directory-structure/app"}
::

::link-example{to="https://nuxt.com/docs/examples/hello-world"}
::

### Migration

Cân nhắc tạo một tệp `app.vue` và bao gồm bất kỳ logic nào cần chạy một lần ở cấp cao nhất của ứng dụng của bạn. Bạn có thể kiểm tra [một ví dụ tại đây](https://nuxt.com/docs/guide/directory-structure/app).

## Layouts

Nếu bạn đang sử dụng layouts trong ứng dụng của mình cho nhiều trang, chỉ có một thay đổi nhỏ cần thiết.

Trong Nuxt 2, component `<Nuxt>` được sử dụng trong một layout để render trang hiện tại. Trong Nuxt 3, layouts sử dụng slots thay thế, vì vậy bạn sẽ phải thay thế component đó bằng `<slot />`. Điều này cũng cho phép các use cases nâng cao với named và scoped slots. [Đọc thêm về layouts](https://nuxt.com/docs/guide/directory-structure/layouts).

Bạn cũng sẽ cần thay đổi cách bạn định nghĩa layout được sử dụng bởi một trang bằng cách sử dụng compiler macro `definePageMeta`. Layouts sẽ được kebab-cased. Vì vậy `layouts/customLayout.vue` trở thành `custom-layout` khi được tham chiếu trong trang của bạn.

### Migration

1. Thay thế `<Nuxt />` bằng `<slot />`
   ```diff [layouts/custom.vue]
     <template>
       <div id="app-layout">
         <main>
   -       <Nuxt />
   +       <slot />
         </main>
       </div>
     </template>
   ```
2. Sử dụng [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta) để chọn layout được sử dụng bởi trang của bạn.
   ```diff [pages/index.vue]
   + <script setup>
   + definePageMeta({
   +   layout: 'custom'
   + })
   - <script>
   - export default {
   -   layout: 'custom'
   - }
     </script>
   ```
3. Di chuyển `~/layouts/_error.vue` sang `~/error.vue`. Xem [tài liệu xử lý lỗi](https://nuxt.com/docs/getting-started/error-handling). Nếu bạn muốn đảm bảo rằng trang này sử dụng một layout, bạn có thể sử dụng [`<NuxtLayout>`](https://nuxt.com/docs/guide/directory-structure/layouts) trực tiếp trong `error.vue`:
   ```vue [error.vue]
   <template>
     <div>
       <NuxtLayout name="default">
         <!-- -->
       </NuxtLayout>
     </div>
   </template>
   ```

## Pages

Nuxt 3 đi kèm với tích hợp `vue-router` tùy chọn được kích hoạt bởi sự tồn tại của thư mục [`pages/`](https://nuxt.com/docs/guide/directory-structure/pages) trong thư mục nguồn của bạn. Nếu bạn chỉ có một trang duy nhất, bạn có thể cân nhắc di chuyển nó sang `app.vue` thay thế để có build nhẹ hơn.

### Dynamic Routes

Định dạng để định nghĩa dynamic routes trong Nuxt 3 hơi khác so với Nuxt 2, vì vậy bạn có thể cần đổi tên một số tệp trong `pages/`.

1. Nơi bạn trước đây sử dụng `_id` để định nghĩa một dynamic route parameter bạn hiện sử dụng `[id]`.
2. Nơi bạn trước đây sử dụng `_.vue` để định nghĩa một catch-all route, bạn hiện sử dụng `[...slug].vue`.

### Nested Routes

Trong Nuxt 2, bạn sẽ định nghĩa bất kỳ nested routes nào (với parent và child components) bằng cách sử dụng `<Nuxt>` và `<NuxtChild>`. Trong Nuxt 3, những cái này đã được thay thế bằng một component `<NuxtPage>` duy nhất.

### Page Keys and Keep-alive Props

Nếu bạn đã truyền một custom page key hoặc keep-alive props cho `<Nuxt>`, bạn sẽ hiện sử dụng `definePageMeta` để thiết lập các tùy chọn này.

::read-more
---
to: https://nuxt.com/docs/guide/directory-structure/pages#special-metadata
---
::

### Page and Layout Transitions

Nếu bạn đã định nghĩa transitions cho page hoặc layout của bạn trực tiếp trong component options của bạn, bạn sẽ hiện cần sử dụng `definePageMeta` để thiết lập transition. Vì Vue 3, [-enter và -leave CSS classes đã được đổi tên](https://v3-migration.vuejs.org/breaking-changes/transition.html){rel="nofollow"}. Prop `style` từ `<Nuxt>` không còn áp dụng cho transition khi được sử dụng trên `<slot>`, vì vậy di chuyển các styles sang class `-active` của bạn.

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

### Migration

1. Đổi tên bất kỳ pages nào với dynamic parameters để khớp với định dạng mới.
2. Cập nhật `<Nuxt>` và `<NuxtChild>` thành `<NuxtPage>`.
3. Nếu bạn đang sử dụng Composition API, bạn cũng có thể di chuyển `this.$route` và `this.$router` sang sử dụng [`useRoute`](https://nuxt.com/docs/api/composables/use-route) và [`useRouter`](https://nuxt.com/docs/api/composables/use-router) composables.

#### Example: Dynamic Routes

::code-group
```text [Nuxt 2]
- URL: /users
- Page: /pages/users/index.vue

- URL: /users/some-user-name
- Page: /pages/users/_user.vue
- Usage: params.user

- URL: /users/some-user-name/edit
- Page: /pages/users/_user/edit.vue
- Usage: params.user

- URL: /users/anything-else
- Page: /pages/users/_.vue
- Usage: params.pathMatch
```

```text [Nuxt 3]
- URL: /users
- Page: /pages/users/index.vue

- URL: /users/some-user-name
- Page: /pages/users/[user].vue
- Usage: params.user

- URL: /users/some-user-name/edit
- Page: /pages/users/[user]/edit.vue
- Usage: params.user

- URL: /users/anything-else
- Page: /pages/users/[...slug].vue
- Usage: params.slug
```
::

#### Example: Nested Routes and `definePageMeta`

::code-group
```vue [Nuxt 2]
<template>
  <div>
    <NuxtChild keep-alive :keep-alive-props="{ exclude: ['modal'] }" :nuxt-child-key="$route.slug" />
  </div>
</template>

<script>
export default {
  transition: 'page' // or { name: 'page' }
}
</script>
```

```vue [Nuxt 3]
<template>
  <div>
    <NuxtPage />
  </div>
</template>

<script setup lang="ts">
// This compiler macro works in both <script> and <script setup>
definePageMeta({
  // you can also pass a string or a computed property
  key: route => route.slug,
  transition: {
    name: 'page',
  },
  keepalive: {
    exclude: ['modal']
  },
})
</script>
```
::

## `<NuxtLink>` Component

Hầu hết syntax và chức năng giống nhau cho global [NuxtLink](https://nuxt.com/docs/api/components/nuxt-link) component. Nếu bạn đã sử dụng shortcut `<NLink>` format, bạn nên cập nhật điều này để sử dụng `<NuxtLink>`.

`<NuxtLink>` hiện là một drop-in replacement cho tất cả links, ngay cả external ones. Bạn có thể đọc thêm về nó, và cách mở rộng nó để cung cấp component link tùy chỉnh của riêng bạn.

::read-more{to="https://nuxt.com/docs/api/components/nuxt-link"}
::

## Programmatic Navigation

Khi di chuyển từ Nuxt 2 sang Nuxt 3, bạn sẽ phải cập nhật cách bạn điều hướng users của mình theo chương trình. Trong Nuxt 2, bạn có quyền truy cập vào underlying Vue Router với `this.$router`. Trong Nuxt 3, bạn có thể sử dụng utility method `navigateTo()` cho phép bạn truyền một route và parameters cho Vue Router.

::warning
Hãy đảm bảo luôn `await` trên [`navigateTo`](https://nuxt.com/docs/api/utils/navigate-to) hoặc chain kết quả của nó từ functions.
::

::code-group
```vue [Nuxt 2]
<script>
export default {
  methods: {
    navigate(){
      this.$router.push({
        path: '/search',
        query: {
          name: 'first name',
          type: '1'
        }
      })
    }
  }
}
</script>
```

```vue [Nuxt 3]
<script setup lang="ts">
function navigate(){
  return navigateTo({
    path: '/search',
    query: {
      name: 'first name',
      type: '1'
    }
  })
}
</script>
```
::


# Component Options

## `asyncData` and `fetch`

Nuxt 3 cung cấp các tùy chọn mới để [fetching data từ một API](https://nuxt.com/docs/getting-started/data-fetching).

### Isomorphic Fetch

Trong Nuxt 2 bạn có thể sử dụng `@nuxtjs/axios` hoặc `@nuxt/http` để fetch data của bạn - hoặc chỉ global `fetch` polyfilled.

Trong Nuxt 3 bạn có thể sử dụng một method `fetch` globally available có cùng API như [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch){rel="nofollow"} hoặc method `$fetch` sử dụng [unjs/ofetch](https://github.com/unjs/ofetch){rel="nofollow"}. Nó có một số lợi ích bao gồm:

1. Nó sẽ 'thông minh' thực hiện [direct API calls](https://nuxt.com/docs/guide/concepts/server-engine#direct-api-calls) nếu đang chạy trên server, hoặc thực hiện client-side call tới API của bạn nếu đang chạy trên client. (Nó cũng có thể xử lý calling third-party APIs.)
2. Plus, nó đi kèm với convenience features bao gồm tự động parsing responses và stringifying data.

Bạn có thể đọc thêm [về direct API calls](https://nuxt.com/docs/guide/concepts/server-engine#direct-api-calls) hoặc [fetching data](https://nuxt.com/docs/getting-started/data-fetching).

### Composables

Nuxt 3 cung cấp composables mới cho fetching data: [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) và `useFetch`. Mỗi cái có variants 'lazy' (`useLazyAsyncData` và `useLazyFetch`), không block client-side navigation.

Trong Nuxt 2, bạn sẽ fetch data của bạn trong component bằng syntax tương tự như:

```ts
export default {
  async asyncData({ params, $http }) {
    const post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
    return { post }
  },
  // or alternatively
  fetch () {
    this.post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
  }
}
```

Trong methods và templates của bạn, bạn có thể sử dụng biến `post` tương tự như bất kỳ piece of data nào khác được cung cấp bởi component của bạn.

Với Nuxt 3, bạn có thể thực hiện data fetching này bằng composables trong method `setup()` hoặc tag `<script setup>` của bạn:

```vue
<script setup lang="ts">
// Define params wherever, through `defineProps()`, `useRoute()`, etc.
const { data: post, refresh } = await useAsyncData('post', () => $fetch(`https://api.nuxtjs.dev/posts/${params.id}`) )
// Or instead - useFetch is a convenience wrapper around useAsyncData when you're just performing a simple fetch
const { data: post, refresh } = await useFetch(`https://api.nuxtjs.dev/posts/${params.id}`)
</script>
```

Bạn có thể sử dụng `post` bên trong template Nuxt 3 của bạn, hoặc gọi `refresh` để cập nhật data.

::note
Mặc dù tên, [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) không phải là direct replacement của hook `fetch()`. Thay vào đó, [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) thay thế cả hai hooks và có thể tùy chỉnh hơn; nó có thể làm nhiều hơn chỉ fetching data từ một endpoint. [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) là convenience wrapper xung quanh [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) để chỉ fetching data từ một endpoint.
::

### Migration

1. Thay thế hook `asyncData` với [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) hoặc [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) trong page/component của bạn.
2. Thay thế hook `fetch` với [`useAsyncData`](https://nuxt.com/docs/api/composables/use-async-data) hoặc [`useFetch`](https://nuxt.com/docs/api/composables/use-fetch) trong component của bạn.

## `head`

::read-more{to="https://nuxt.com/docs/migration/meta"}
::

## `key`

Bạn có thể định nghĩa một key trong compiler macro [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta).

```diff [pages/index.vue]
- <script>
- export default {
-   key: 'index'
-   // or a method
-   // key: route => route.fullPath
- }
+ <script setup>
+ definePageMeta({
+   key: 'index'
+   // or a method
+   // key: route => route.fullPath
+ })
</script>
```

## `layout`

::read-more{to="https://nuxt.com/docs/migration/pages-and-layouts"}
::

## `loading`

Tính năng này chưa được hỗ trợ trong Nuxt 3.

## `middleware`

::read-more{to="https://nuxt.com/docs/migration/plugins-and-middleware"}
::

## `scrollToTop`

Tính năng này chưa được hỗ trợ trong Nuxt 3. Nếu bạn muốn overwrite default scroll behavior của `vue-router`, bạn có thể làm vậy trong `~/router.options.ts` (xem [docs](https://nuxt.com/docs/guide/recipes/custom-routing#router-options)) để biết thêm info.
Tương tự như `key`, chỉ định nó trong compiler macro [`definePageMeta`](https://nuxt.com/docs/api/utils/define-page-meta).

```diff [pages/index.vue]
- <script>
- export default {
-   scrollToTop: false
- }
+ <script setup>
+ definePageMeta({
+   scrollToTop: false
+ })
</script>
```

## `transition`

::read-more{to="https://nuxt.com/docs/getting-started/transitions"}
::

## `validate`

Hook validate trong Nuxt 3 chỉ chấp nhận một argument, `route`. Cũng như trong Nuxt 2, bạn có thể return một boolean value. Nếu return false và không match khác có thể được tìm thấy, điều này sẽ có nghĩa là 404. Bạn cũng có thể return trực tiếp một object với `statusCode`/`statusMessage` để respond ngay lập tức với một error (không match khác sẽ được kiểm tra).

```diff [pages/users/[id\\].vue]
- <script>
- export default {
-   async validate({ params }) {
-     return /^\d+$/.test(params.id)
-   }
- }
+ <script setup>
+ definePageMeta({
+   validate: async (route) => {
+     const nuxtApp = useNuxtApp()
+     return /^\d+$/.test(route.params.id)
-   }
+ })
  </script>
```

## `watchQuery`

Điều này không được hỗ trợ trong Nuxt 3. Thay vào đó, bạn có thể trực tiếp sử dụng một watcher để trigger refetching data.

```vue [pages/users/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data, refresh } = await useFetch('/api/user')
watch(() => route.query, () => refresh())
</script>
```


# Runtime Config

Nếu bạn muốn tham chiếu environment variables trong ứng dụng Nuxt 3 của bạn, bạn sẽ cần sử dụng runtime config.

Khi tham chiếu các biến này trong components của bạn, bạn sẽ phải sử dụng composable [`useRuntimeConfig`](https://nuxt.com/docs/api/composables/use-runtime-config) trong method setup của bạn (hoặc Nuxt plugin).

Trong phần `server/` của ứng dụng của bạn, bạn có thể sử dụng [`useRuntimeConfig`](https://nuxt.com/docs/api/composables/use-runtime-config) mà không cần import.

::read-more{to="https://nuxt.com/docs/guide/going-further/runtime-config"}
::

## Migration

1. Thêm bất kỳ environment variables nào bạn sử dụng trong ứng dụng của bạn vào property `runtimeConfig` của tệp `nuxt.config`.
2. Di chuyển `process.env` sang [`useRuntimeConfig`](https://nuxt.com/docs/api/composables/use-runtime-config) trong suốt phần Vue của ứng dụng của bạn.

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // Private config that is only available on the server
    apiSecret: '123',
    // Config within public will be also exposed to the client
    public: {
      apiBase: '/api'
    }
  }
})
```

```vue [pages/index.vue]
<script setup lang="ts">
const config = useRuntimeConfig()

// instead of process.env you will now access config.public.apiBase
console.log(config.public.apiBase)
</script>
```

```ts [server/api/hello.ts]
export default defineEventhandler((event) => {
  const config = useRuntimeConfig(event)
  // In server, you can now access config.apiSecret, in addition to config.public
  console.log(config.apiSecret)
  console.log(config.public.apiBase)
})
```

```ini [.env]
# Runtime config values are automatically replaced by matching environment variables at runtime
NUXT_API_SECRET=api_secret_token
NUXT_PUBLIC_API_BASE=https://nuxtjs.org
```
::


# Nuxt Content v3

Welcome to Nuxt Content v3, a major upgrade that brings enhanced performance and innovative features to your Nuxt projects. This latest iteration of our Git-based CMS is optimized for modern application development.

## What's New?

### Content Collections

Collections organize related items within your project, helping you manage large datasets more efficiently. Key benefits include:

- **Structured Data**: Configure database architecture and define collections in [`content.config.ts`](https://nuxt.com/docs/collections/define#defining-collections)
- **Type-safe Queries**: Direct TypeScript integration across all utilities
- **Automatic Validation**: Ensure data consistency across frontmatter fields and data files (json, yml...)
- **Advanced Query Builder**: Filter, sort, and paginate your collections with ease
- **Studio Integration**: Enhanced form generation and optimal editing experience through [Studio](https://nuxt.com/studio)

Learn more about [Content Collections](https://nuxt.com/docs/collections/define).

### Improved Performance

A significant challenge in v2 was the large bundle size needed for storing files, particularly affecting serverless deployments.

V3 addresses this by transitioning to SQL-based storage in production. This switch requires zero configuration, supporting development mode, static generation, server hosting, serverless and edge deployments.

::prose-note
The new database system enhances the way your data files are stored and structured, ensuring better performance and scalability. This update is entirely behind the scenes and does not affect the file types you can use in Content (`yml`, `json`, and `markdown` ).
::

Benefits include:

- **Optimized Queries**: SQL storage enables ultra-fast data retrieval
- **Universal Compatibility**: Our adapter-based system integrates SQL databases across all deployment modes ([server](https://nuxt.com/docs/deploy/server), [serverless](https://nuxt.com/docs/deploy/serverless) and [static](https://nuxt.com/docs/deploy/static)). We welcome community contributions for additional adapters.

### TypeScript Integration

The new collections system provides automatic TypeScript types for all your data. Every utility and API is strongly typed based on your collection definitions, ensuring robust type safety throughout development.

### Nuxt Studio Integration :badge[Soon]{color="neutral"}

[Nuxt Studio](https://nuxt.com/docs/studio/setup) and v3 are designed to complement each other perfectly.. The [studio module](https://github.com/nuxtlabs/studio-module){rel="nofollow"} is now integrated directly into Nuxt Content, creating an ideal environment where developers can focus on code while team members manage content through an intuitive interface.

---

We're excited for you to explore these new capabilities. Dive into our documentation to learn more about integrating the module and implementing best practices in your next project.

## Content V2 Migration

Learn how to migrate from Content v2 to v3 in the [migration guide](https://nuxt.com/docs/getting-started/migration).


# Installation

### Install the Package

Choose your preferred package manager to install Nuxt Content v3:

::code-group
```bash [pnpm]
pnpm add @nuxt/content
```

```bash [yarn]
yarn add @nuxt/content
```

```bash [npm]
npm install @nuxt/content
```

```bash [bun]
bun add @nuxt/content
```
::

### Register the Module

Add the Nuxt Content module to your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content']
})
```

### Automatic Setup

When starting a new Nuxt project with the `create-nuxt` CLI, you can simply select `@nuxt/content` from the interactive module selector. This will automatically install and register the module for you.

::code-group
```bash [npm]
npm create nuxt <project-name>
```

```bash [yarn]
yarn create nuxt <project-name>
```

```bash [pnpm]
pnpm create nuxt <project-name>
```

```bash [bun]
bun create nuxt <project-name>
```

```bash [deno]
deno -A npm:create-nuxt@latest <project-name>
```
::

::note{color="warning"}
When you run your project in Node.js, Nuxt Content will ask you about the database connector to use.
You can choose to install `better-sqlite3` or `sqlite3` package.

:br

If you don't want to install any package, you can use native SQLite from Node.js\@v22.5.0 or newer.
Checkout [`experimental.nativeSqlite` configuration](https://nuxt.com/docs/getting-started/configuration#experimentalnativesqlite-deprecated-use-sqliteconnector).
::

### Create your First Collection

Create a `content.config.ts` file in your project root directory:

```ts [content.config.ts]
import { defineContentConfig, defineCollection } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    content: defineCollection({
      type: 'page',
      source: '**/*.md'
    })
  }
})
```

This configuration creates a default `content` collection that processes all Markdown files located in the `content` folder of your project. You can customize the collection settings based on your needs.

::tip
The `type: page` means there is a 1-to-1 relationship between content files and pages on your site.
::

::note{to="https://nuxt.com/docs/collections/define"}
Learn more in our **Collections guide**.
::

### Create your First Markdown Page

Create a `content/index.md` file in your project root directory:

```md [content/index.md]
# My First Page

Here is some content.
```

Read more about writing [Markdown pages](https://nuxt.com/docs/files/markdown).

### Display your Page

Create a `pages/index.vue` file and display the page content:

```vue [pages/index.vue]
<script setup lang="ts">
const { data: home } = await useAsyncData(() => queryCollection('content').path('/').first())

useSeoMeta({
  title: home.value?.title,
  description: home.value?.description
})
</script>

<template>
  <ContentRenderer v-if="home" :value="home" />
  <div v-else>Home not found</div>
</template>
```

::note{icon="i-lucide-info"}
If you are installing Nuxt Content in a new Nuxt project and you didn't have `pages` directory, you also need to update the `app.vue` file to allow rendering the pages by adding the `NuxtPage` component. (If you already have some pages in your project, you are good to go.)

```vue [app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```
::

::tip{icon="i-lucide-rocket"}
That's it! You've now created your first Nuxt Content page.
::


# Configuration

To configure the content module and customize its behavior, you can use the `content` property in your `nuxt.config`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    // Options
  }
})
```

::note{to="https://github.com/nuxt-modules/mdc#configurations"}
In addition to configuring via `content.markdown`, you can use Markdown Components (MDC) to customize the rendering of Markdown elements with `mdc` property.
::

## `build`

Nuxt Content read and parse all the available contents at build time. This option gives you control over parsing contents.

### `markdown`

Configure markdown parser.

#### `toc`

::code-group
```ts [Default]
toc: {
  depth: 2,
  searchDepth: 2
}
```

```ts [Signature]
type Toc = {
  depth: number
  searchDepth: number
}
```
::

Control behavior of Table of Contents generation.

Value:

- `depth`: Maximum heading depth to include in the table of contents.
- `searchDepth`: Maximum depth of nested tags to search for heading.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        toc: {
          depth: 3, // include h3 headings
        }
      }
    }
  }
})
```

#### `remarkPlugins`

::code-group
```ts [Default]
remarkPlugins: {}
```

```ts [Signature]
type RemarkPlugins = Record<string, false | MarkdownPlugin>
```
::

A list of [remark](https://github.com/remarkjs/remark){rel="nofollow"} plugins to use.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        // Object syntax can be used to override default options
        remarkPlugins: {
          // Override remark-emoji options
          'remark-emoji': {
            options: {
              emoticon: true
            }
          },
          // Disable remark-gfm
          'remark-gfm': false,
          // Add remark-oembed
          'remark-oembed': {
            // Options
          }
        },
      }
    }
  }
})
```

#### `rehypePlugins`

::code-group
```ts [Default]
rehypePlugins: {}
```

```ts [Signature]
type RehypePlugins = object
```
::

A list of [rehype](https://github.com/remarkjs/remark-rehype){rel="nofollow"} plugins to use.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        // Object syntax can be used to override default options
        rehypePlugins: {
          'rehype-figure': {

          }
        },
      }
    }
  }
})
```

#### `highlight`

::code-group
```ts [Default]
highlight: false
```

```ts [Signature]
type Highlight = false | object
```
::

Nuxt Content uses [Shiki](https://github.com/shikijs/shiki){rel="nofollow"} to provide syntax highlighting for [`ProsePre`](https://nuxt.com/docs/components/prose#prosepre) and [`ProseCode`](https://nuxt.com/docs/components/prose#prosecode).

| Option  | Type                                         | Description                                                                                                                      |
| ------- | -------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `theme` | `ShikiTheme` or `Record<string, ShikiTheme>` | The [color theme](https://github.com/shikijs/shiki/blob/main/docs/themes.md){rel="nofollow"} to use.                             |
| `langs` | `ShikiLang[]`                                | The [loaded languages](https://github.com/shikijs/shiki/blob/main/docs/languages.md){rel="nofollow"} available for highlighting. |

- `highlight.theme`

Theme can be specified by a single string but also supports an object with multiple themes.

This option is compatible with [Color Mode module](https://color-mode.nuxtjs.org/){rel="nofollow"}.

If you are using multiple themes, it's recommended to always have a `default` theme specified.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          // Theme used in all color schemes.
          theme: 'github-light',
          // OR
          theme: {
            // Default theme (same as single string)
            default: 'github-light',
            // Theme used if `html.dark`
            dark: 'github-dark',
            // Theme used if `html.sepia`
            sepia: 'monokai'
          }
        }
      }
    }
  }
})
```

- `highlight.langs`

By default, the module loads a couple of languages for syntax highlighting:

```ts [Default]
['json', 'js', 'ts', 'html', 'css', 'vue', 'shell', 'mdc', 'md', 'yaml']
```

If you plan to use code samples of other languages, you need to define the language in these options.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          langs: [
            'c',
            'cpp',
            'java'
          ]
        }
      }
    }
  }
})
```

If you wish to add highlighting for an unsupported language, you can do so by loading the grammar file for the language.

```ts [nuxt.config.ts]
import { readFileSync } from 'node:fs'

export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          langs: [
            // Read more about Shiki languages: https://shiki.style/guide/load-lang
            JSON.parse(
              readFileSync('./shiki/languages/gdscript.tmLanguage.json', 'utf-8'),
            ),
          ]
        }
      }
    }
  }
})
```

Read more about adding languages in the [Shiki documentation](https://github.com/shikijs/shiki/blob/main/docs/languages.md#adding-grammar){rel="nofollow"}.

### `pathMeta`

Content module uses files path to generate the slug, default title and content order, you can customize this behavior with `pathMeta` option.

#### `pathMeta.forceLeadingSlash`

If set to `true`, the path will be prefixed with a leading slash. Default value is `true`.

#### `pathMeta.slugifyOptions`

Content module uses [slugify](https://github.com/simov/slugify){rel="nofollow"} to generate the slug, you can customize the behavior of slugify with this option.

Checkout [slugify options](https://github.com/simov/slugify#options){rel="nofollow"} for more information.

### `transformers`

Nuxt Content has specific transformers for each content type to parse the raw content and prepare it for querying and rendering. Using this option you can define custom transformers to support new content types or improve functionalities of supported content types.

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~/transformers/title-suffix',
      ],
    },
  },
})
```

```ts [~/transformers/title-suffix.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'title-suffix',
  extensions: ['.md'],
  transform(file) {
    return {
      ...file,
      title: file.title + ' (suffix)',
    }
  },
})
```
::

Read more about transformers in the [Transformers](https://nuxt.com/docs/advanced/transformers) documentation.

## `database`

By default Nuxt Content uses a local SQLite database to store and query content. If you like to use another database or you plan to deploy on Cloudflare Workers, you can modify this option.

Here is the list of supported database adapters:

### `SQLite`

If you want to change the default database location and move it to elsewhere you can use `sqlite` adapter to do so. This is the default value to the `database` option. Depending on your runtime-environment different sqlite adapters will be used (Node: better-sqlite-3, Bun: bun\:sqlite).

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'sqlite',
      filename: 'SQLITE_DB_LOCATION'
    }
  }
})
```

### `D1`

If you plan to deploy your application to Cloudflare workers, you need to use the `d1` database adapter. Create a `d1` binding in the Cloudflare dashboard and fill in the `bindingName` field.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'd1',
      bindingName: 'CF_BINDING_NAME'
    }
  }
})
```

### `Postgres`

If you plan to deploy your application using PostgreSQL database you need to use the `postgres` database adapter.

First, make sure to install the `pg` package:

```bash [Terminal]
npx npm i pg
```

Then, configure the `postgres` adapter in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'postgres',
      url: process.env.POSTGRES_URL,
      /* Other options for `pg` */
    }
  }
})
```

### `LibSQL`

If you plan to deploy your application using a LibSQL database you need to use the `libsql` database adapter.

First, make sure to install the `@libsql/client` package:

```bash [Terminal]
npx npm i @libsql/client
```

Then, configure the `libsql` adapter in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'libsql',
      url: process.env.TURSO_DATABASE_URL,
      authToken: process.env.TURSO_AUTH_TOKEN,
    }
  }
})
```

::note
The most popular LibSQL hosting services is [Turso](https://turso.tech/){rel="nofollow"}.
::

## `renderer`

Configure content renderer.

### `anchorLinks`

::code-group
```ts [Default]
{ h2: true, h3: true, h4: true }
```

```ts [Signature]
type AnchorLinks = boolean | Record<'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6', boolean>
```
::

Control anchor link generation, by default it generates anchor links for `h2`, `h3` and `h4` heading

Value:

- `false`: will disable link generation.
- `true`: will enable link generation for all headings.

### `alias`

::code-group
```ts [Default]
alias: {}
```

```ts [Signature]
type Alias = Record<string, string>
```
::

Aliases will be used to replace markdown components and render custom components instead of default ones.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    renderer: {
      alias: {
        p: 'MyCustomParagraph'
      }
    }
  }
})
```

## `watch`

```ts [Default]
watch: {
  enabled: true,
  port: 4000,
  showURL: false
}
```

Configure content hot reload in development.

Value:

- `enabled`: Enable/Disable hot reload.
- `port`: Select the port used for the WebSocket server.
- `showURL`: Toggle URL display in dev server boot message.

Nuxt Content uses [listhen](https://github.com/unjs/listhen){rel="nofollow"} to provide a local development server. Check out the [listhen documentation](https://github.com/unjs/listhen#options){rel="nofollow"} for more information.

::callout
The watcher is a development feature and will not be included in production.
::

::code-group
```ts [Enabled]
export default defineNuxtConfig({
  content: {
    watch: {
      port: 4000,
      showURL: true
    }
  }
})
```

```ts [Disabled]
export default defineNuxtConfig({
  content: {
    watch: {
      enabled: false
    }
  }
})
```
::

## `preview`

Enable `Preview API`

::prose-note
This is needed to enable live preview on [Nuxt Studio](https://nuxt.com/studio).
::

Value:

- `dev`: Enable in development mode
- `api`: Activate the preview mode and set the `API` to be linked with.

```ts [Enable Studio]
preview: {
  api: 'https://api.nuxt.studio',
}
```

## `experimental`

Experimental features that are not yet stable.

### `experimental.sqliteConnector`

SQLite connectors have limitations in different environments. Some work in serverless environments, while others do not. Nuxt Content supports three different SQLite connectors to cover all environments:

- `better-sqlite3`: Works in all Node environments, GitHub CI, Vercel CI and production, Cloudflare CI pipelines, etc. (Does **not** work in WebContainers and StackBlitz)
- `sqlite3`: Works in Node environments, GitHub CI, and StackBlitz. (Does **not** work in Vercel or Cloudflare)
- `native`: As of Node.js v22.5.0, the `node:sqlite` module is available natively in Node.js. This connector works in all Node environments with Node.js version 22.5.0 or newer.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    experimental: { sqliteConnector: 'native' },
  },
});
```

### `experimental.nativeSqlite` (deprecated, use `sqliteConnector`)

As of Node.js v22.5.0, the `node:sqlite` module is available natively in Node.js.
This allows Nuxt Content to use SQLite as a database without the need for an external package.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    experimental: { nativeSqlite: true },
  },
});
```

::prose-note
This feature is only available in Node.js v22.5.0 and above. Enabling this feature in older version will not do anything.
::


# Migration

Nuxt Content v3 has been rebuilt from the ground up, resulting in a new library with enhanced capabilities. While we've redesigned concepts and components in a similar way as Content v2, breaking changes are inevitable.

Don't worry, you don't need to modify your content files. We made sure that Content v3 handles content in the same way as Content v2.

## Changes

### Vue utils

- `queryContent()` API is replaced with new `queryCollection()`

::prose-tip
The new API is backed by SQL and content queries happens within a specific collection.
::

- `fetchContentNavigation()` API is replaced with new `queryCollectionNavigation()`
- Surroundings now has its own separate API `queryCollectionItemSurroundings()`
- Document driven mode is dropped: `Markdown` files will not convert to Nuxt pages automatically, you need to create pages, [check this section to see how](https://nuxt.com/docs/components/content-renderer#example-usage).
- `useContent()` composable is removed
- `searchContent()` is dropped in favor of the new `queryCollectionSearchSections` API
- Full text search can easily be done using the `queryCollectionSearchSections` API, [check this section to see how](https://nuxt.com/docs/advanced/fulltext-search)

### Components

- All content should be rendered using `<ContentRenderer>` component. `<ContentDoc>`, `<ContentList>`, `<ContentNavigation>` and `<ContentQuery>` components are dropped in v3.
- `<ContentSlot>` and `<MDCSlot>` components are not supported in v3. Instead components can simply use Vue's native `<slot>` component

::prose-note
`<ContentSlot>` and `<MDCSlot>` was initially pro to manipulate content before rendering and removing wrapping paragraphs from slot content. This unwrapping behavior is now supported via `mdc-unwrap` attribute in `<slot>` component. Example: `<slot mdc-unwrap="p" />`
::

- Components created under the `components/content` directory are no longer automatically registered as global components. If you use [dynamic rendering](https://vuejs.org/guide/essentials/component-basics.html#dynamic-components){rel="nofollow"} to render these components outside markdown files, you must manually register them in your Nuxt app. Check out the [Nuxt - Custom Components Directories](https://nuxt.com/docs/guide/directory-structure/components#custom-directories){rel="nofollow"} documentation for more information on how to do so.

### Types

- `import type { NavItem } from '@nuxt/content/dist/runtime/types'` is replaced with `import type { ContentNavigationItem } from '@nuxt/content'`

### General

- `_dir.yml` files are renamed to `.navigation.yml`
- There is no source option in module options, instead you can define [multiple sources](https://nuxt.com/docs/collections/sources) for your collections in `content.config.ts`.
- Document `._path` is now renamed to `.path`, likewise all internal fields with `_` prefix are removed or renamed.
- `useContentHelpers()` is removed
- Module does not ignore dot files by default, you can ignore them by adding `ignore: ['**/.*']` in `exclude` options of your collection source.
- Due to SQL limitations, sort order now uses alphabetical order instead for numerical order. Check out the [Ordering Files](https://nuxt.com/docs/collections/types#ordering-files) section for more information.
- Module options have changed from v2. Check out [configuration page](https://nuxt.com/docs/getting-started/configuration) for details.

### Nuxt Studio integration

- The [studio module](https://nuxt.studio){rel="nofollow"} has been deprecated and a new generic `Preview API` has been implemented directly into Nuxt Content, you can remove the `@nuxthq/studio` package from your dependencies and from the `nuxt.config.ts` modules. Instead we just need to enable the preview mode in the Nuxt configuration file by binding the Studio API.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  },
})
```

- In order to keep the [app config file](https://nuxt.com/docs/studio/config) updatable from Studio we just need to update the helper import of the `nuxt.schema.ts` file from `@nuxthq/studio/theme` to `@nuxt/content/preview`.

## Implement Document Driven mode in v3

Implementing document driven mode in Content v3 is quite easy. All you need is to create a catch-all page in Nuxt and fetch contents based on route path.

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('content').path(route.path).first()
})
</script>

<template>
  <div>
    <header><!-- ... --></header>

    <ContentRenderer v-if="page" :value="page" />

    <footer><!-- ... --></footer>
  </div>
</template>
```

## Converting `queryContent` to `queryCollections`

As we mentioned above, `queryContent` is dropped in favor of new collection based `queryCollection`. There are two main differences between these two:

1. `queryCollection` is building a query for an SQL database.
2. `queryCollection` does the search only inside the specified collection. You should know the collection's name (key on config).

```ts [Find content with path]
// Content v2
const v2Query = await queryContent(route.path).findOne()
// Content v3 - don't forget to create `content` collection in `content.config.ts`
const v3Query = await queryCollection('content').path(route.path).first()
```

```ts [Find contents with custom filter]
// Content v2
const v2Query = await queryContent()
  .where({ path: /^\/hello\/.*/ })
  .find()
// Content v3 - don't forget to create `content` collection in `content.config.ts`
const v3Query = await queryCollection('content')
  .where('path', 'LIKE', '/hello%')
  .first()
```

::prose-note{to="https://nuxt.com/docs/collections/define"}
Check the dedicated section for more info about collections
::

## Convert `queryContent().findSurround()`

Surround now has its own separate API.

```ts
const targetPath = '/docs'

// Content v2
const v2Surround = await queryContent(targetPath)
  .only(['title', 'description', 'navigation'])
  .findSurround(withoutTrailingSlash(route.path))

// Content v3 - don't forget to create `content` collection in `content.config.ts`
const v3Surround = await queryCollectionItemSurroundings(
  'content',
  targetPath,
  {
    fields: ['title', 'description', 'navigation']
  }
)
```

::prose-note
Check the dedicated section for more information about the
::

## Consolidate `ProsePre`, `ProseCode`, and `ProseCodeInline` components

Many `ProsePre` components are thin wrappers around the `ProseCode` component. We've consolidated these three components into two components. There is now no difference between `ProsePre` and multi-line code blocks.

1. MDC will now map and parse single backticks `` ` `` as `ProseCode` instead of `ProseCodeInline`.
2. MDC will now map and parse block code starting with three backticks` ``` ` as `ProsePre` component.

**Suggested Changes:**

1. Your current `ProseCode` logic should be moved to `ProsePre`
2. Rename your `ProseCodeInline` components to `ProseCode`

## `_dir.yml` files are renamed to `.navigation.yml`

In Content v3, we renamed `_dir.yml` to `.navigation.yml`. The new name better reflects the purpose of these files. :br
Module uses these files to gather information about directories for generating navigation.

Note that in order to make these files available for Module, youe should define your collection's source in
a way that includes these files. For example `source: '**'` and `source: '**/*.{md|yml}` will include these files
in collection, but `source: '**/*.md'` will not include them.

## Ignore dot files

By default, Content v3 does not ignore dot files. If you want to ignore them, you can add `ignore: ['**/.*']` in the `exclude` option of your collection source.

```ts
defineCollection({
  source: {
    include: '**',
    exclude: ['**/.*']
  }
})
```

Note that the above pattern will also exclude `.navigation.yml` file from collection. If you use `.navigation.yml` and want to keep them
you can use `**/.(!(navigation.yml))` pattern to exclude all dot files except `.navigation.yml`.

```ts
defineCollection({
  source: {
    include: '**',
    exclude: ['**/.!(navigation.yml)']
  }
})
```


# Define Content Collections

The Nuxt Content module automatically parses any content files within the `content/` directory located at the root of your Nuxt application. This setup allows you to freely structure the folder to suit your project's needs.

For better organization, consider using Content Collections, which let you categorize and manage content more effectively. These collections are defined in a `content.config.ts` file.

::warning
If no `content.config.ts` file is present, all files within the content folder are parsed and imported by default. However, once a config file is added, only files matching the specified path patterns defined in collections will be imported.
::

## What are Content Collections?

Content Collections organize related items within your Nuxt Content project. They provide a structured way to manage your content, making it easier to query, display, and maintain your site's data.

Key features include:

- **Logical Grouping**: Group similar content together, such as blog posts, product pages, or documentation articles
- **Shared Configuration**: Apply common settings and validations across all items within a collection
- **Improved Querying**: Fetch and filter related content items efficiently
- **Automatic Type Inference**: Get type safety and autocompletion in your development environment
- **Flexible Structure**: Organize collections by content type, category, or any other logical grouping that suits your needs

## Defining Collections

Create a `content.config.ts` file in your project's root directory. This special file configures your collections database, utility types, and content handling.

Here's a basic example:

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      // Specify the type of content in this collection
      type: 'page',
      // Load every file inside the `content` directory
      source: '**',
    })
  }
})
```

::warning
Currently, a document is designed to be present in only one collection at a time. If a file is referenced in multiple collections, live reload will not work correctly. To avoid this, it is recommended to use the `exclude` attribute to explicitly exclude a document from other collections using appropriate regex patterns.

This topic is still under discussion in this issue: [nuxt/content#2966](https://github.com/nuxt/content/issues/2966){rel="nofollow"}.
::

### Collection Schema

Schemas enforce data consistency within a collection and serve as the source of truth for TypeScript types.

On top of the built-in fields, you can define a schema by adding the `schema` property to your collection by using a [`zod`](https://zod.dev){rel="nofollow"} schema:

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      // Define custom schema for docs collection
      schema: z.object({
        tags: z.array(z.string()),
        image: z.string(),
        date: z.date()
      })
    })
  }
})
```

::note
`@nuxt/content` exposes a `z` object that contains a set of Zod schemas for common data types. Check [Zod’s README](https://github.com/colinhacks/zod){rel="nofollow"} for complete documentation on how Zod works and what features are available.
::

::tip
You can define as many collections as you want to organize different types of content.
::

## Querying Collections

Use the [`queryCollection`](https://nuxt.com/docs/utils/query-collection) util to fetch one or all items from a collection:

```vue [pages/blog.vue]
<script setup lang="ts">
const { data: posts } = await useAsyncData('blog', () => queryCollection('blog').all())
</script>

<template>
  <div>
    <h1>Blog</h1>
    <ul>
      <li v-for="post in posts" :key="post.id">
        <NuxtLink :to="post.path">{{ post.title }}</NuxtLink>
      </li>
    </ul>
  </div>
</template>
```

::note{to="https://nuxt.com/docs/utils/query-collection"}
Learn more about the available query options in our `queryCollections` API documentation.
::

## defineCollection()

The `defineCollection` function defines a collection in your content configuration. Here's its TypeScript signature:

```ts
function defineCollection(collection: Collection): DefinedCollection

type Collection = {
  // Determines how content is processed
  type: 'page' | 'data'
  // Specifies content location
  source?: string | CollectionSource
  // Zod schema for content validation and typing
  schema?: ZodObject<T>
}
```

::note{to="https://nuxt.com/docs/collections/types"}
Learn more about collection types.
::

```ts
type CollectionSource = {
  // Glob pattern for content matching
  include: string
  // .path prefix (only applies to 'page' type)
  prefix?: string
  // Glob patterns to exclude content
  exclude?: string[]
  // Root directory for content matching
  cwd?: string
  // Remote git repository URL (e.g., https://github.com/nuxt/content)
  repository?: string
  // Authentication token for private repositories (e.g., GitHub personal access token)
  authToken?: string
}
```

::note{to="https://nuxt.com/docs/collections/sources"}
Learn more about collection sources.
::

The function returns the defined collection object.


# Collection Types

In Nuxt Content, you can specify a type for each collection, depending on the intended purpose of the collection files. Collections can be defined as either **page** or **data** types.

For both types, built-in fields are generated. Every collection includes these default fields:

- `id`: Unique content identifier
- `stem`: File path without extension (used for sorting and location)
- `extension`: File extension
- `meta`: Custom fields not defined in the collection schema

## Page type

```ts
defineCollection({
  source: '**/*.md',
  type: 'page'
})
```

::tip
Use the **page** type if there is a 1-to-1 relationship between content files and pages on your site.
::

### Path generation

Nuxt Content will automatically generate a path for each file in the collection, making it easy to create URL mappings.

Here are examples of generated paths based on file structure:

|                                  |                       |
| -------------------------------- | --------------------- |
|                                  |                       |
| File                             | Path                  |
| `content/index.md`               | `/`                   |
| `content/about.md`               | `/about`              |
| `content/blog/index.md`          | `/blog`               |
| `content/blog/hello.md`          | `/blog/hello`         |
| `content/1.guide/2.installation` | `/guide/installation` |

::note
You can use the helper [`queryCollection('COLLECTION').path('PATH')`](https://nuxt.com/docs/utils/query-collection) to retrieve content by a specific path.
::

### Schema Overrides

When you use the **page** type, Nuxt Content generates several standard fields that are commonly used for web pages. These fields provide structure and are **automatically** applied to the collection’s schema:

- `path`: Generated route path
- `title`: Page title
- `description`: Page description
- `seo`: SEO metadata (to be used with Nuxt's `useSeoMeta` composable)
- `body`: Page content parsed as AST
- `navigation`: Page navigation configuration (for [queryCollectionNavigation](https://nuxt.com/docs/utils/query-collection-navigation))

Here is the corresponding schema applied:

```ts
  path: z.string(),
  title: z.string(),
  description: z.string(),
  seo: z.intersection(
    z.object({
      title: z.string().optional(),
      description: z.string().optional(),
      meta: z.array(z.record(z.string(), z.any())).optional(),
      link: z.array(z.record(z.string(), z.any())).optional(),
    }),
    z.record(z.string(), z.any()),
  ).optional().default({}),
  body: z.object({
    type: z.string(),
    children: z.any(),
    toc: z.any(),
  }),
  navigation: z.union([
    z.boolean(),
    z.object({
      title: z.string(),
      description: z.string(),
      icon: z.string(),
    }),
  ]).default(true),
```

::note
You can override any of these fields by defining them in the collection’s schema.
::

## Data type

```ts
defineCollection({
  source: 'authors/**.yml',
  type: 'data'
})
```

The data type is useful for content that doesn't directly correspond to a webpage but instead represents structured data you might want to query and display within your application.

With data collections, you have complete control over the schema, allowing you to define custom structures.

::note
There's no strict relationship between collection type and file extension. For instance, a **page** collection can use [Markdown](https://nuxt.com/docs/files/markdown) or [YAML](https://nuxt.com/docs/files/yaml) or [JSON](https://nuxt.com/docs/files/json) files, and **data** collections can use any of these formats as well.
::

## Ordering Files

For both types, you may want to control the display order in lists. Use numeric prefixes in file and directory names to specify an order. Nuxt Content will use these numbers when ordering content lists.

::note
Nuxt Content uses alphabetical order for sorting, so if you want to use numerical order, you need to prefix single digit numbers with `0`. For example, without the `0` prefix, `10.foo.md` would come before `2.bar.md`.
::

```text [Directory structure]
content/
  1.frameworks/
    1.vue.md
    2.nuxt.md
    ...
  2.examples/
    01.nuxthub.md
    02.vercel.md
    03.netlify.md
    04.heroku.md
    ...
    10.cloudflare.md
    index.md
```

::warning
Separate number from file name using `.` character. Using any other separator will not work.
::


# Collection Sources

Nuxt Content provides several ways to import content files into your collection. You can configure the source by using the `source` property within `defineCollection`:

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      source: '**',
      type: 'page'
    })
  }
})
```

## `source`

The `source` property can be defined as either a string (following a glob pattern) or an object, allowing more detailed source configuration for your target directory and files within the content folder.

**Example:**

- `source: '**'` includes all files within the content directory and its subdirectories.
- `source: '**/*.md'`includes all `Markdown` files within the content directory and its subdirectories.
- `source: 'docs/**/*.yml'` includes all `YML` files within the `content/docs` and its subdirectories.
- `source: '**/*.{json,yml}'` includes `JSON` or `YML` file within the content directory and all its subdirectories.
- `source: '*.json'` includes only `JSON` files located directly within the content directory, excluding any subdirectories.

### `include` (required)

Glob pattern of your target repository and files in the content folder.

### `exclude`

Glob patterns to exclude content from the import.

### `prefix`

This configuration only applied for **page** type with 1-to-1 relationship between content files and pages on your site.

It represents the path prefix (base URL) of the corresponding page on the website.

::prose-warning
The `prefix` must start by a leading `/`.
::

By default, module extracts the static prefix of `source`(or `source.include`) and uses it as a prefix for content paths. For example, if you define `/en/**` source, module will auto-fill the `prefix` with `/en`. You can manually provide a prefix to override this behavior. The prefix can be removed by setting `prefix: '/'` in the collection source.

```ts
defineCollection({
  type: "page",
  source: {
    include: "en/**",
    exclude: ["en/index.md"],
    prefix: '/'
  }
})
```

### `cwd`

Root directory for content matching.

**Example:**

If you want to include files from a folder outside the content directory, set the absolute path of that folder to the `cwd` property.

```ts
source: {
  cwd: path.resolve('packages/my-pkg/docs'),
  include: '**/*.md',
}
```

### `repository`

External source representing a remote git repository URL (e.g., <https://github.com/nuxt/content>{rel="nofollow"}).

When defining an external source you must also define the `include` option.
`include` pattern is essential for the module to know which files to use for the collection.

```js
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: {
        repository: 'https://github.com/nuxt/content',
        include: 'docs/content/**',
      },
    })
  }
})
```

### `authToken`

Authentication token for private repositories (e.g., GitHub personal access token).

::warning{icon="i-lucide-shield-alert"}
Never commit authentication tokens or credentials directly in your code. Use environment variables or other secure methods to provide these values at runtime.
::

### `authBasic`

Basic authentication for private repositories (e.g., Bitbucket username and password).

```ts
defineCollection({
  type: 'page',
  source: {
    repository: 'https://bitbucket.org/username/repo',
    authBasic: {
      username: 'username',
      password: 'password',
    },
  },
})
```


# Schema Validators

Nuxt Content supports defining collection schemas with multiple validators. Out of the box, this includes popular libraries like **Zod v3 / v4** and **Valibot** (examples below). The system is extensible and can support other validators via JSON Schema adapters. Schemas enforce data consistency and drive generated types and Studio forms.

## Using Zod v3

### Install

```bash
pnpm add -D zod zod-to-json-schema
# or
npm i -D zod zod-to-json-schema
```

Prefer importing `z` directly from `zod`.

```ts [content.config.ts]
import { defineContentConfig, defineCollection, property } from '@nuxt/content'
import { z } from 'zod' // or 'zod/v3' if your setup exposes this subpath

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        title: z.string(),
        description: z.string().optional(),
        date: z.date(),
        draft: z.boolean().default(false),
        tags: z.array(z.string()).optional(),
        image: z.object({
          src: property(z.string()).editor({ input: 'media' }),
          alt: z.string()
        })
      })
    })
  }
})
```

::note
Dates are serialised as ISO strings under the hood (JSON Schema `format: date-time`).
::

::warning
The `z` re-export from `@nuxt/content` is deprecated and will be removed in a future release. Import `z` from `zod` (or `zod/v3`) instead.
::

## Using Zod v4

Zod v4 provides a native JSON Schema export. No `zod-to-json-schema` dependency is required.

### Install

```bash
pnpm add -D zod
# or
npm i -D zod
```

```ts [content.config.ts]
import { defineContentConfig, defineCollection, property } from '@nuxt/content'
import { z } from 'zod/v4'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: 'docs/**/*.md',
      schema: z.object({
        title: z.string(),
        description: z.string().optional(),
        updatedAt: z.date(),
        draft: z.boolean().optional(),
        tags: z.array(z.string()).optional(),
        hero: z.object({
          image: property(z.string()).editor({ input: 'media' }),
          caption: z.string().optional()
        })
      })
    })
  }
})
```

## Using Valibot

Use Valibot primitives to define your schema.

### Install

```bash
pnpm add -D valibot @valibot/to-json-schema
# or
npm i -D valibot @valibot/to-json-schema
```

```ts [content.config.ts]
import { defineContentConfig, defineCollection, property } from '@nuxt/content'
import { object, string, boolean, array, date, optional } from 'valibot'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: 'docs/**/*.md',
      schema: object({
        title: string(),
        description: optional(string()),
        updatedAt: date(),
        draft: optional(boolean()),
        tags: optional(array(string())),
        hero: object({
          image: property(string()).editor({ input: 'media' }),
          caption: optional(string())
        })
      })
    })
  }
})
```

## Choosing a validator

- **Zod v3**: battle-tested, rich ecosystem; great DX with re-exported `z`.
- **Valibot**: lightweight and fast; bring your own importer from `valibot`.

Only install and use the validator you need. Nuxt Content auto-detects supported validators that are installed.

## Support for other validators

Nuxt Content converts your collection schema to JSON Schema Draft-07 internally. If your preferred validator can be transformed to Draft-07 (or has a compatible adapter), it can be supported. Currently, Zod (v3 and v4) and Valibot are auto-detected. If you’d like first-class support for another validator, consider opening an issue or PR in the [Nuxt Content repository](https://github.com/nuxt/content){rel="nofollow"}.

## Editor metadata (optional)

You can enrich fields for Studio via `property(...).editor({ ... })` with both validators. See the Studio docs for mapping details.

::tip{to="https://nuxt.com/docs/studio/content"}
Learn how editor metadata maps to form inputs in Studio.
::


# Inherit Schema from a Vue Component

You can reuse a Vue component's props as part of your collection schema. This helps keep your content model aligned with your UI, reduces duplication, and prevents drift.

## How it works

Nuxt Content provides a `property()` helper that augments your validator and adds the following utility:

- **inherit(path)**: replace the current object schema with the props JSON Schema inferred from a Vue component at `path`

Under the hood, Nuxt Content reads the component's props (via `nuxt-component-meta`) and converts them to JSON Schema, then merges them into your collection schema.

## Example

```ts [content.config.ts]
import { defineContentConfig, defineCollection, z, property } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    pages: defineCollection({
      type: 'page',
      source: '**/*.md',
      schema: z.object({
        // Reuse props from a local component
        hero: property(z.object({})).inherit('app/components/HeroSection.vue'),

        // Reuse props from a dependency (path is resolved like an import)
        button: property(z.object({})).inherit('@nuxt/ui/components/Button.vue')
      })
    })
  }
})
```

## Notes

- The argument to `inherit()` is resolved like a module path. You can pass a relative path from project root or a package path.
- `inherit()` expects to be used on an object field (e.g., `property(z.object({}))`).
- Nested usage is supported: you can place inherited objects inside other objects and arrays; Nuxt Content recursively replaces `$content.inherit` markers.
- If the component cannot be resolved, the schema falls back to the original object definition.

::tip
Pair `inherit()` with `editor(...)` for better Studio forms if you need custom inputs on top of the component's props.
::


# Markdown

## Usage

### Define a Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        date: z.string()
      })
    })
  }
})
```

::note{to="https://nuxt.com/docs/collections/types#page-type"}
Learn more about the `page` collection type.
::

### Create `.md` files

Create blog posts in `content/blog/` directory.

::code-group
```md [foo.md]
---
date: 2020-11-11
---

# Foo

This is Foo blog post.
```

```md [bar.md]
---
date: 2024-12-12
---
Hello
I am bar. Nice to meet you.
```
::

### Query Markdown Files

Now we can query blog posts:

```ts
// Get the foo post
const fooPost = await queryCollection('blog').path('/blog/foo').first()

// Find all posts
const allPosts = await queryCollection('blog').order('date', 'DESC').all()
```

### Display Markdown

To display the content of a markdown file, you can use the [`<ContentRenderer>`](https://nuxt.com/docs/components/content-renderer) component.

```vue [blog/[slug\\].vue]
<script setup>
const slug = useRoute().params.slug
const { data: post } = await useAsyncData(`blog-${slug}`, () => {
  return queryCollection('blog').path(`/blog/${slug}`).first()
})
</script>

<template>
  <!-- Render the blog post as Prose & Vue components -->
  <ContentRenderer :value="post" />
</template>
```

::note
Read more about the [`<ContentRenderer>`](https://nuxt.com/docs/components/content-renderer) component and [`Prose Components`](https://nuxt.com/docs/components/prose).
::

## Frontmatter

Frontmatter is a convention of Markdown-based CMS to provide meta-data to pages, like description or title. In Nuxt Content, the frontmatter uses the YAML syntax with `key: value` pairs.

These data are available when rendering the content and can store any information that you would need.

### Syntax

You can declare a frontmatter block at the top of the Markdown files in the `content/` directory with the `---` identifier.

```md [content/index.md]
---
title: 'Title of the page'
description: 'meta description of the page'
---

<!-- Content of the page -->
```

```ts [example.ts]
const home = await queryCollection('content').path('/').first()

console.log(home.title)
// => 'Title of the page'
console.log(home.description)
// => 'meta description of the page'
console.log(home.body)
// => AST object of the page content
```

### Native parameters

|               |           |                          |                                                                                                                                        |
| ------------- | --------- | ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| Key           | Type      | Default                  | Description                                                                                                                            |
| `title`       | `string`  | First `<h1>` of the page | Title of the page, will also be injected in metas                                                                                      |
| `description` | `string`  | First `<p>` of the page  | Description of the page, will be shown below the title and injected into the metas                                                     |
| `navigation`  | `boolean` | `true`                   | Define if the page is included in [`queryCollectionNavigation`](https://nuxt.com/docs/utils/query-collection-navigation) return value. |

::warning
Additional parameters that you have defined in your frontmatter block need to be defined in your schema (see the date parameter in the example at top of this page) to be able to use them for querying.
::

## MDC Syntax

We created the MDC syntax to supercharge Markdown and give you the ability to integrate Vue components with slots and props inside your Markdown.

::callout
---
icon: i-simple-icons-visualstudiocode
to: https://marketplace.visualstudio.com/items?itemName=Nuxt.mdc
---
Install the **MDC VS Code extension** to get proper syntax highlighting for the MDC syntax.
::

### Vue Components

You can use any Vue component in your Markdown files.

We have a special syntax to make it easier to use components in your Markdown files.

```mdc [content/index.md]
::component-name
Default slot content
::
```

::warning
Components that are used in Markdown has to be marked as `global` in your Nuxt app if you don't use the `components/content/` directory, visit [Nuxt 3 docs](https://nuxt.com/docs/guide/directory-structure/components){rel="nofollow"} to learn more about it.
::

#### Block Components

Block components are components that accept Markdown content or another component as a slot.

The component must contain at least one `<slot />` component to accept formatted text.

In a markdown file, use the component with the `::` identifier.

::code-group
```mdc [index.md]
::card
The content of the card
::
```

```html [Card.vue]
<!-- components/content/Card.vue -->
<template>
  <div class="p-2 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <slot />
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-card
    The content of the card
    ::::
  :::
::

#### Slots

A component's slots can accept content or another components.

- **Default slot** renders the top-level content inside the block component or with `#default`
- **Named slots** use the `#` identifier to render the corresponding content.

::code-group
```mdc [index.md]
::hero
My Page Title

#description
This will be rendered inside the `description` slot.
::
```

```html [Hero.vue]
<template>
  <section>
    <h1 class="text-4xl">
      <slot mdc-unwrap="p" />
    </h1>
    <slot name="description" />
  </section>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-hero
    My Page Title
    
    #description
    This will be rendered inside the `description` slot.
    ::::
  :::
::

::note
Read more about the [`<slot />`](https://nuxt.com/docs/components/slot) component.
::

::tip
You can use Markdown inside your components slots:

  :::code-group
  ```mdc [index.md]
  ::my-title
  A [rich text](/) will be **rendered** by the component.
  ::
  ```
  
  ```html [MyTitle.vue]
  <template>
    <h1 class="text-4xl">
      <slot mdc-unwrap="p" />
    </h1>
  </template>
  ```
  
    ::::code-preview{icon="i-lucide-eye" label="Preview"}
      :::::example-title
      A [rich text](https://nuxt.com) will be **rendered** by the component.
      :::::
    ::::
  :::
::

#### Props

There are two ways to pass props to components using MDC.

##### **Inline method**

The `{}` identifier passes props to components in a terse way by using a `key=value` syntax.

::code-group
```mdc [index.md]
::alert{type="warning"}
The **alert** component.
::
```

```vue [Alert.vue]
<script setup>
const props = defineProps({ type: { type: String } })

const alertClass = computed(() => {
  return {
    warning: 'bg-orange-100 border-orange-200 dark:bg-orange-900 dark:border-orange-800',
    info: 'bg-blue-100 border-blue-200 dark:bg-blue-900 dark:border-blue-800',
    success: 'bg-green-100 border-green-200 dark:bg-green-900 dark:border-green-800',
  }[props.type]
})
</script>

<template>
  <div
    class="text-black p-2 border dark:text-white rounded"
    :class="alertClass"
  >
    <slot mdc-unwrap="p" />
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-alert{type="warning"}
    The **alert** component.
    ::::
  :::
::

Multiple props can be separated with a space:

```mdc
::alert{type="warning" icon="exclamation-circle"}
Oops! An error occurred
::
```

The `v-bind` shorthand `:` can be also be used to bind a prop to a value in the frontmatter.

```mdc
---
type: "warning"
---

::alert{:type="type"}
Your warning
::
```

If you want to pass arrays or objects as props to components you can pass them as JSON string and prefix the prop key with a colon to automatically decode the JSON string. Note that in this case you should use single quotes for the value string so you can use double quotes to pass a valid JSON string:

::code-group
```mdc [array.md]
::dropdown{:items='["Nuxt", "Vue", "React"]'}
::
```

```mdc [number-array.md]
::dropdown{:items='[1,2,3.5]'}
::
```

```mdc [object.md]
::chart{:options='{"responsive": true, "scales": {"y": {"beginAtZero": true}}}'}
::
```
::

##### **YAML method**

The YAML method uses the `---` identifier to declare one prop per line, that can be useful for readability.

::code-group
```mdc [index.md]
::icon-card
---
icon: IconNuxt
description: Harness the full power of Nuxt and the Nuxt ecosystem.
title: Nuxt Architecture.
---
::
```

```html [IconCard.vue]
<script setup>
defineProps({
  title: {
    type: String,
    default: 'Default title'
  },
  description: {
    type: String,
    default: 'Default description'
  },
  icon: {
    type: String,
    default: 'IconMarkdown'
  }
})
</script>

<template>
  <div class="p-6 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <component :is="icon" class="w-20 h-20" />
    <h2 class="text-3xl font-semibold mb-2">
      {{ title }}
    </h2>
    <p>{{ description }}</p>
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-icon-card
    ---
    description: Harness the full power of Nuxt and the Nuxt ecosystem.
    icon: i-simple-icons-nuxtdotjs
    title: Nuxt Architecture.
    ---
    ::::
  :::
::

### Attributes

Attributes are useful for highlighting and modifying part of paragraph. The syntax is nearly similar to inline components and markdown links syntax.

Possible values are all named attributes, classes with the notation `.class-name` and an ID with `#id-name`.

::code-group
```mdc [index.md]
Hello [World]{style="color: green;" .custom-class #custom-id}!
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  Hello [World]{#custom-id .custom-class style="color: green;"} !
  :::
::

In addition to mdc components and `span`, attribute syntax will work on images, links, inline `code`, \**bold*\* and \_italic\_ text.

::code-group
```md [index.md]
Attributes work on:

- [link](#attributes){style="background-color: green;"}, `code`{style="color: cyan;"},
- _italic_{style="background-color: yellow; color:black;"} and **bold**{style="background-color: lightgreen;"} texts.
```

  :::code-preview{prose label="Preview" prose=""}
  Attributes work on:
  
  - [link](https://nuxt.com/#attributes){style="background-color: green;"}, `code`,
  - *italic* and **bold** texts.
  :::
::

### Binding Data

You can bind data within your Markdown document using the `{{ $doc.variable || 'defaultValue' }}` syntax. These values can be defined in the YAML frontmatter at the top of the document, within each MDC component, or injected using the `data` prop of the `<ContentRenderer>` component.

#### Define in YAML

```mdc
---
title: 'Title of the page'
description: 'meta description of the page'
customVariable: 'Custom Value'
---

# The Title is {{ $doc.title }} and customVariable is {{ $doc.customVariable || 'defaultValue' }}

```

#### Define in external with `<ContentRenderer>`

```html [test.vue]
<template>
  <div>
    <ContentRenderer :value="data" :data="mdcVars"/>
    <button type="button" v-on:click="mdcVars.name = 'Hugo'">Change name</button>
  </div>
</template>

<script setup lang="ts">
const { data } = await useAsyncData(() => queryCollection('content').path('/test').first());
const mdcVars = ref({ name: 'Maxime'});
</script>
```

```mdc [test.md]
# Hello {{ $doc.name || 'World' }}

```

## Prose Components

In Nuxt Content, the prose represents HTML tags generated by the Markdown syntax, such as heading levels and links.

For each HTML tag, a Vue component is used, allowing you to override them if needed, for example `<p>` becomes `<ProseP>`.

If you want to customize a Prose component, here are the recommended steps:

- Check out the original [component sources](https://github.com/nuxt-modules/mdc/blob/main/src/runtime/components/prose){rel="nofollow"}.
- Use the exact same props.
- In your `components/content/` directory, give it the same name.
- Make it yours 🚀.

::note{to="https://nuxt.com/docs/components/prose"}
Read the complete Prose reference in the Prose Components section.
::

## Code Highlighting

Nuxt Content uses [Shiki](https://github.com/shikijs/shiki){rel="nofollow"}, which colors tokens with VSCode themes.

Code highlighting works both on [`ProsePre`](https://nuxt.com/docs/components/prose#prosepre) and [`ProseCode`](https://nuxt.com/docs/components/prose#prosecodeinline).

Each line of a code block gets its line number in the `line` attribute so lines can be labeled or individually styled.

::callout
[Read the API reference to configure or entirely disable syntax highlighting.](https://nuxt.com/docs/getting-started/configuration)
::

## Images

You can add images to your `public` directory:

```bash [Directory structure]
content/
  index.md
public/
  image.png
nuxt.config.ts
package.json
```

And then use them in your markdown files in the `content` directory as such:

```md [content/index.md]
![my image](/image.png)
```

## Excerpt

Content excerpt or summary can be extracted from the content using `<!--more-->` as a divider.

```md [content/index.md]
---
title: Introduction
---

Learn how to use `@nuxt/content`.

<!--more-->

Full amount of content beyond the more divider.
```

Description property will contain the excerpt content unless defined within the frontmatter props.

If there is no `<!--more-->` divider in the text then excerpt is undefined.

::tip
You should define the `excerpt` field in the collection schema if you want to use the excerpt feature.

```ts [content.config.ts]
const content = defineCollection({
  type: 'page',
  source: '**',
  schema: z.object({
    excerpt: z.object({
      type: z.string(),
      children: z.any(),
    }),
  }),
})
```

Read more about the [collection schema](https://nuxt.com/docs/collections/define#collection-schema).
::

Example variables will be injected into the document:

```json
{
  "excerpt": Object
  "body": Object
  // ... other keys
}
```


# YAML

## Define Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.yml',
      schema: z.object({
        name: z.string(),
        avatar: z.string(),
        url: z.string()
      })
    })
  }
})

```

## Create `.yml` files

Create authors files in `content/authors/` directory.

::code-group
```yaml [farnabaz.yml]
name: Ahad Birang
avatar: https://avatars.githubusercontent.com/u/2047945?v=4
url: https://github.com/farnabaz
```

```yaml [larbish.yml]
name: Baptiste Leproux
avatar: https://avatars.githubusercontent.com/u/7290030?v=4
url: https://github.com/larbish
```
::

## Query Data

Now we can query authors:

```vue
<script lang="ts" setup>
// Find a single author
const { data: author } = await useAsyncData('larbish', () => {
  return queryCollection('authors')
    .where('stem', '=', 'larbish')
    .first()
})

// Get all authors
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'DESC')
    .all()
})
</script>
```


# JSON

## Define Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.json',
      schema: z.object({
        name: z.string(),
        avatar: z.string(),
        url: z.string()
      })
    })
  }
})

```

## Create `.json` files

Create authors files in `content/authors/` directory.

::code-group
```json [farnabaz.json]
{
  "name": "Ahad Birang",
  "avatar": "https://avatars.githubusercontent.com/u/2047945?v=4",
  "url": "https://github.com/farnabaz"
}
```

```json [larbish.json]
{
  "name": "Baptiste Leproux",
  "avatar": "https://avatars.githubusercontent.com/u/7290030?v=4",
  "url": "https://github.com/larbish"
}
```
::

::warning
Each file in `data` collection should contain only one object, therefore having top level array in a JSON file will cause invalid result in query time.
::

## Query Data

Now we can query authors:

```vue
<script lang="ts" setup>
// Find a single author
const { data: author } = await useAsyncData('larbish', () => {
  return queryCollection('authors')
    .where('stem', '=', 'larbish')
    .first()
})

// Get all authors
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'DESC')
    .all()
})
</script>
```


# CSV

## Define Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.csv',
      schema: z.object({
        name: z.string(),
        email: z.string(),
        avatar: z.string()
      })
    })
  }
})

```

## Create `.csv` files

Create author files in `content/authors/` directory.

::code-group
```csv [users.csv]
id,name,email
1,John Doe,john@example.com
2,Jane Smith,jane@example.com
3,Alice Johnson,alice@example.com
```

```csv [team.csv]
name,role,avatar
John Doe,Developer,https://avatars.githubusercontent.com/u/1?v=4
Jane Smith,Designer,https://avatars.githubusercontent.com/u/2?v=4
```
::

::warning
Each CSV file should have a header row that defines the column names, which will be used as object keys when parsed.
::

## Query Data

Now we can query authors:

```vue
<script lang="ts" setup>
// Find a single author
const { data: author } = await useAsyncData('john-doe', () => {
  return queryCollection('authors')
    .where('name', '=', 'John Doe')
    .first()
})

// Get all authors
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'ASC')
    .all()
})
</script>

<template>
  <ul>
    <li v-for="author in authors" :key="author.id">
      {{ author.name }} ({{ author.email }})
    </li>
  </ul>
</template>
```

## Configuration

You can configure how CSV files are parsed in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      csv: {
        // Convert CSV data to JSON objects
        json: true,
        // Specify custom delimiter (default is ',')
        delimiter: ','
      }
    }
  }
})
```

With `json: true` in the configuration, each row will be converted to a JavaScript object with the header row used as keys:

```json
[
  {
    "id": "1",
    "name": "John Doe",
    "email": "john@example.com"
  },
  {
    "id": "2",
    "name": "Jane Smith",
    "email": "jane@example.com"
  }
]
```

## Custom Delimiters

If your CSV files use a different delimiter, you can specify it in the configuration:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      csv: {
        delimiter: ';' // Use semicolon as delimiter
      }
    }
  }
})
```

This would parse CSV files like:

```csv [semicolon-data.csv]
id;name;email
1;John Doe;john@example.com
2;Jane Smith;jane@example.com
```

::note
The CSV parser can be disabled by setting `csv: false` in the configuration if you don't need CSV support.
::


# queryCollection

## Usage

Use the auto-imported `queryCollection` to find contents inside a collection. Here we assume that you have defined `docs` collection inside `content.config.ts`.

If you have not defined any collection, check [How to define a collection](https://nuxt.com/docs/collections/define#defining-collections).

```vue [pages/[...slug\\].vue]
<script>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>
```

::tip
The `queryCollection` utility is available in both Vue and Nitro. Checkout [Server Usage](https://nuxt.com/#server-usage) for more details on how to use it on the server side.
::

## API

### Type

```ts
function queryCollection<T extends keyof Collections>(collection: T): CollectionQueryBuilder<Collections[T]>

interface CollectionQueryBuilder<T> {
  where(field: keyof T | string, operator: SQLOperator, value?: unknown): CollectionQueryBuilder<T>
  andWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  orWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  order(field: keyof T, direction: 'ASC' | 'DESC'): CollectionQueryBuilder<T>
  // ... other methods
}
```

### `queryCollection(collection: CollectionName)`

Create a query builder to search in the specific collection.

- Parameter:

  - `collection`: The key of defined collection in `content.config.ts`

### `path(path: string)`

Search for contents that have specific `path`. (`path` is an special field in `page` collections which generates based on fs path and can be use as route to render the content)

- Parameter:

  - `path`: The path string to match.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
```

### `select(...fields: keyof Collection)`

Select specific fields from the collection to be returned in the query result.

- Parameters:

  - `...fields`: A list of field names to select from the collection.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .select('path', 'title', 'description')
    .first()
})
```

### `where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)`

Add a condition to the query to filter results based on a specific field.

- Parameters:

  - `field`: The field to filter on
  - `operator`: The SQL operator to use for comparison. Possible values include:

    - `'='`: Equal to
    - `'>'`: Greater than
    - `'<'`: Less than
    - `'<>'`: Not equal to
    - `'IN'`: In a list of values
    - `'BETWEEN'`: Between two values
    - `'NOT BETWEEN'`: Not between two values
    - `'IS NULL'`: Is null
    - `'IS NOT NULL'`: Is not null
    - `'LIKE'`: Matches a pattern
    - `'NOT LIKE'`: Does not match a pattern
  - `value`: The value to compare against. The type depends on the operator used.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    .where('category', '=', 'news')
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE date < '2024-04-04' AND category = 'news'
```

### `andWhere(groupFactory: QueryGroupFunction<Collection>)`

Add an AND condition group to the query. This allows for more complex query conditions.

- Parameter:

  - `groupFactory`: A function that receives a query builder and can add multiple conditions that will be grouped together with AND

```ts
const { data } = await useAsyncData('recent-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .andWhere(query => query.where('date', '>', '2024-01-01').where('category', '=', 'news'))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (date > '2024-01-01' AND category = 'news')
```

### `orWhere(groupFactory: QueryGroupFunction<Collection>)`

Add an OR condition group to the query. This allows for alternative conditions.

- Parameter:

  - `groupFactory`: A function that receives a query builder and can add multiple conditions that will be grouped together with OR

```ts
const { data } = await useAsyncData('featured-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .orWhere(query => query.where('featured', '=', true).where('priority', '>', 5))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (featured = true OR priority > 5)
```

### `order(field: keyof Collection, direction: 'ASC' | 'DESC')`

Order the query results based on a specific field.

- Parameters:

  - `field`: The field to order by.
  - `direction`: The direction of ordering, either 'ASC' for ascending or 'DESC' for descending.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .all()
})
```

### `limit(limit: number)`

Limit the number of results returned by the query.

- Parameter:

  - `limit`: The maximum number of results to return.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .limit(10)
    .all()
})
```

### `skip(skip: number)`

Skip a specified number of results in the query.

- Parameter:

  - `skip`: The number of results to skip.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // Skip first 5 items
    .skip(5)
    .all()
})
```

### `all()`

Execute the query and return all matching results.

- Returns: A Promise that resolves to an array of all matching documents.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').all()
})
```

### `first()`

Execute the query and return the first matching result.

- Returns: A Promise that resolves to the first matching document, or `null` if no documents match.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').first()
})
```

### `count()`

Count the number of matched collection entries based on the query.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // Count matches
    .count()
})

// Returns
5 // number of matches
```

You can also use `count()` with other methods defined above such as `where()` in order to apply additional conditions within the collection query.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    // Count matches
    .count()
})

// Returns
3 // number of matches for the provided query
```

## Examples

Here is a complete example of how to fetch a list of documents in the `docs` collections.

```vue [index.vue]
<script setup lang="ts">
const { data: docs } = await useAsyncData('documents-list', () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .select('title', 'path', 'description')
    .all()
})
</script>

<template>
  <NuxtLink v-for="doc in docs" :key="doc.path" :to="doc.path">
    <h2>{{ doc.title }}</h2>
    <p>{{ doc.description }}</p>
  </NuxtLink>
</template>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollection` function.

```ts [server/api/[slug\\].ts]
export default eventHandler(async (event) => {
  const { slug } = getRouterParams(event)
  const page = await queryCollection(event, 'docs').path(slug).first()
  return page
})
```

::note
Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# queryCollectionNavigation

## Usage

Use the auto-imported `queryCollectionNavigation` to generate a navigation tree for a specific collection. This is particularly useful for creating dynamic navigation menus or sidebars based on your content structure.

The function returns a chainable promise that allows you to add additional query conditions:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

::tip
The `queryCollectionNavigation` utility is available in both Vue and Nitro. Checkout [Server Usage](https://nuxt.com/#server-usage) for more details on how to use it on the server side.
::

### Navigation metadata with `.navigation.yml`

You can add metadata to a directory using a `.navigation.yml` file.

```yml [.navigation.yml]
title: Getting Started
icon: i-lucide-square-play
```

## Type

```ts
function queryCollectionNavigation<T extends keyof PageCollections>(
  collection: T,
  fields?: Array<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## API

### `queryCollectionNavigation(collection: CollectionName, extraField: keyof Collection)`

Generate a navigation tree for the specified collection.

- Parameters:

  - `collection`: The key of the defined collection in `content.config.ts`.
  - `extraFields`: (Optional) An array of additional fields to include in the navigation items. (By default `title` and `path` are included in the navigation items.)
- Returns: A chainable promise that resolves to a navigation tree structure. The promise includes methods for adding query conditions:

  - `where(field, operator, value)`: Add a WHERE condition
  - `andWhere(groupFactory)`: Add a grouped AND condition
  - `orWhere(groupFactory)`: Add a grouped OR condition
  - `order(field, direction)`: Add an ORDER BY clause

The navigation tree is generated based on the directory structure and ordering happens based on files [ordering](https://nuxt.com/docs/collections/types#ordering-files)

## Examples

Basic usage without additional query conditions:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">{{ item.title }}</NuxtLink>
      </li>
    </ul>
  </nav>
</template>
```

Example with additional query conditions and extra fields:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs', ['description', 'badge'])
    .where('draft', '=', false)
    .where('partial', '=', false)
    .order('title', 'ASC')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">
          {{ item.title }}
          <span v-if="item.badge" class="badge">{{ item.badge }}</span>
        </NuxtLink>
        <p v-if="item.description">{{ item.description }}</p>
      </li>
    </ul>
  </nav>
</template>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollectionNavigation` function.

```ts [server/api/navigation.ts]
export default eventHandler(async (event) => {
  const navigation = await queryCollectionNavigation(event, 'docs')
  return navigation
})
```

::note
Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::

---

## Extra utilities to work with navigation

Content module provides some extra utilities to simplify common use cases like building breadcrumb navigation.

### `findPageHeadline(navigation, path, options?)`

Returns the headline (name of the parent folder) for a given path within a navigation tree. Useful for displaying section titles or contextual navigation headers.

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The current page path.
- `options` (optional):

  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageHeadline } from '@nuxt/content/utils'

const headline = findPageHeadline(navigation, '/docs/guide/getting-started')
// headline is a string that contains the name of the parent folder
```

### `findPageBreadcrumb(navigation, path, options?)`

Returns the breadcrumb trail (array of navigation items) for a given path within a navigation tree. Useful for building breadcrumb navigation components.

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The current page path.
- `options` (optional):

  - `current`: Include the current page in the breadcrumb.
  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageBreadcrumb } from '@nuxt/content/utils'

const breadcrumb = findPageBreadcrumb(navigation, '/docs/guide/getting-started')
// breadcrumb is an array of navigation items leading to the current page
```

### `findPageChildren(navigation, path, options?)`

Finds and returns the direct children of a given path in the navigation tree.

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The parent path to find children for.
- `options` (optional):

  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageChildren } from '@nuxt/content/utils'

const children = findPageChildren(navigation, '/docs/guide')
// children is an array of navigation items under '/docs/guide'
```

### `findPageSiblings(navigation, path, options?)`

Returns the sibling navigation items for a given path (i.e., other items with the same parent).

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The current page path.
- `options` (optional):

  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageSiblings } from '@nuxt/content/utils'

const siblings = findPageSiblings(navigation, '/docs/guide/getting-started')
// siblings is an array of navigation items that share the same parent as the current page
```


# queryCollectionItemSurroundings

## Usage

Use the auto-imported `queryCollectionItemSurroundings` to find the previous and next items relative to a specific content item in a collection. This is particularly useful for creating navigation between related content pages.

The function returns a chainable promise that allows you to add additional query conditions:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

::tip
The `queryCollectionItemSurroundings` utility is available in both Vue and Nitro. Checkout [Server Usage](https://nuxt.com/#server-usage) for more details on how to use it on the server side.
::

## Type

```ts
function queryCollectionItemSurroundings<T extends keyof PageCollections>(
  collection: T,
  path: string,
  opts?: SurroundOptions<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## API

### `queryCollectionItemSurroundings(collection: CollectionName, path: string, opts?: SurroundOptions)`

Find the surrounding items (previous and next) for a specific content item in a collection.

- Parameters:

  - `collection`: The key of the defined collection in `content.config.ts`.
  - `path`: The path of the current content item.
  - `opts`: (Optional) An object with the following properties:

    - `before`: (Optional) The number of items to fetch before the current item. Default is 1.
    - `after`: (Optional) The number of items to fetch after the current item. Default is 1.
    - `fields`: (Optional) An array of additional fields to include in the surrounding items.
- Returns: A chainable promise that resolves to an array containing the surrounding items. The promise includes methods for adding query conditions:

  - `where(field, operator, value)`: Add a WHERE condition
  - `andWhere(groupFactory)`: Add a grouped AND condition
  - `orWhere(groupFactory)`: Add a grouped OR condition
  - `order(field, direction)`: Add an ORDER BY clause

The final result will be an array with the following structure:

- `[previousItem, nextItem]` if using default options
- `[...previousItems, ...nextItems]` if using custom `before` and `after` values

Each item in the array is of type `ContentNavigationItem` or `null` if there is no item in that position.

## Examples

Basic usage without additional query conditions:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
})
</script>

<template>
  <div class="flex justify-between">
    <NuxtLink v-if="data?.[0]" :to="data[0].path">
      ← {{ data[0].title }}
    </NuxtLink>
    <NuxtLink v-if="data?.[1]" :to="data[1].path">
      {{ data[1].title }} →
    </NuxtLink>
  </div>
</template>
```

Example with additional query conditions:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo', {
    before: 1,
    after: 1,
    fields: ['badge', 'description']
  })
    .where('_draft', '=', false)
    .where('_partial', '=', false)
    .order('date', 'DESC')
})
</script>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollectionItemSurroundings` function.

```ts [server/api/surroundings.ts]
export default eventHandler(async (event) => {
  const surroundings = await queryCollectionItemSurroundings(event, 'docs', '/foo')
  return surroundings
})
```

::note
Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# queryCollectionSearchSections

## Usage

Use the auto-imported `queryCollectionSearchSections` to generate searchable sections from a specific collection. This is particularly useful for creating advanced search functionality or content discovery features in your application.

```vue [app.vue]
<script>
const { data: sections } = await useAsyncData('search-sections', () => {
  return queryCollectionSearchSections('docs')
})
</script>
```

::tip
The `queryCollectionSearchSections` utility is available in both Vue and Nitro. Checkout [Server Usage](https://nuxt.com/#server-usage) for more details on how to use it on the server side.
::

## Type

```ts
function queryCollectionSearchSections(collection: keyof Collections, opts?: { ignoredTags: string[] }): ChainablePromise<T, Section[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## API

### `queryCollectionSearchSections(collection: CollectionName, options?: SearchSectionsOptions)`

Generate searchable sections from the specified collection.

- Parameters:

  - `collection`: The key of the defined collection in `content.config.ts`.
  - `options`: (Optional) An object with the following properties:

    - `ignoredTags`: An array of tag names to ignore when generating sections. Default is an empty array.
- Returns: A Promise that resolves to an array of searchable sections. Each section is an object with the following properties:

  - `id`: A unique identifier for the section.
  - `title`: The title of the section (usually the heading text).
  - `titles`: An array of parent section titles, representing the hierarchy.
  - `content`: The textual content of the section.
  - `level`: The heading level (1-6) of the section, where 1 is the highest level.

## Example

Here's an example of how to use `queryCollectionSearchSections` to create searchable sections from the 'docs' collection:

```vue [pages/[...slug\\].vue]
<script>
const { data: surround } = await useAsyncData('foo-surround', () => {
  return queryCollectionSearchSections('docs', {
    ignoredTags: ['code']
  })
})
</script>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollectionSearchSections` function.

```ts [server/api/search-sections.ts]
export default eventHandler(async (event) => {
  const sections = await queryCollectionSearchSections(event, 'docs')
  return sections
})
```

::note
Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# ContentRenderer

The `<ContentRenderer>` component renders a document coming from a query with [`queryCollection()`](https://nuxt.com/docs/utils/query-collection).

::note
This component **only works** with `Markdown` files.
::

## Props

| Prop         | Default     | Type                  | Description                                                                                                                           |
| ------------ | ----------- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `value`      | `{}`        | `ParsedContent`       | The document to render.                                                                                                               |
| `tag`        | `'div'`     | `string`              | The tag to use for the renderer element if it is used.                                                                                |
| `excerpt`    | `false`     | `boolean`             | Whether to render the excerpt only without the rest of the content.                                                                   |
| `components` | `{}`        | `object`              | The map of custom components to use for rendering. This prop will pass to the markdown renderer and will not affect other file types. |
| `data`       | `{}`        | `object` (required)   | A map of variables to inject into the markdown content for later use in binding variables.                                            |
| `prose`      | `undefined` | `boolean`             | Whether or not to render Prose components instead of HTML tags.                                                                       |
| `class`      | `undefined` | `string` or `object`  | Root tag to use for rendering.                                                                                                        |
| `unwrap`     | `false`     | `boolean` or `string` | Tags to unwrap separated by spaces. Example: `'ul li'`.                                                                               |

## Example Usage

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
</template>
```

## Handling Missing Pages

If the queried content is **missing**, you can display a **custom fallback message**.

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <template v-if="page">
    <ContentRenderer :value="page" />
  </template>
  <template v-else>
    <div class="empty-page">
      <h1>Page Not Found</h1>
      <p>Oops! The content you're looking for doesn't exist.</p>
      <NuxtLink to="/">Go back home</NuxtLink>
    </div>
  </template>
</template>
```

## Handling Empty Pages

If the queried content is **empty**, you can display a **custom fallback message**.


# Slot

When you write contents and paragraphs inside a component with the MDC syntax, you can use Vue's `<slot>` component to render the content.

## Usage

If you don't want to modify the rendered content, simply use Vue's `<slot>` component.

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot />
  </div>
</template>
```

Now let's use it in Markdown:

```mdc [content/index.md]
::callout
This is a callout.
::
```

The rendered HTML will be:

```html
<div class="callout">
  <p>This is a callout.</p>
</div>
```

This usage would be similar to using the native `<slot>` component.

### Unwrapping

The `mdc-unwrap` prop allows you to remove one or multiple wrapping elements from the rendered content. This is useful when you want to extract the content nested in native Markdown syntax. Each specified tag will get removed from AST.

Let's unwrap the `<p>` element from the previous example:

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot mdc-unwrap="p" />
  </div>
</template>
```

Now the rendered HTML will be:

```html
<div class="callout">
  This is a callout.
</div>
```

### Named Slots

The `name` prop allows you to bind a slot by its name. This is useful when you want to render a slot that is not the default one.

Let's improve our `Callout` component to have a `title` slot:

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <h2 v-if="$slots.title">
      <slot name="title" mdc-unwrap="p" />
    </h2>
    <slot />
  </div>
</template>
```

Now let's use it in Markdown:

```mdc [content/index.md]
::callout
#title
Please be careful!
#default
Using MDC & Vue components is addictive.
::
```

This will result into:

```html
<div class="callout">
  <h2>Please be careful!</h2>
  <p>Using MDC & Vue components is addictive.</p>
</div>
```

When not using the `title` slot, the `h2` element will not be rendered.

## Props

- `mdc-unwrap`: Whether to unwrap the content or not. This is useful when you want to extract the content nested in native Markdown syntax. Each specified tag will get removed from AST.

  - **Type:** `boolean` or `string`
  - **Default:** `false`
  - **Example:** `'p'` or `'ul li'`


# Prose Components

Prose components are replacements for HTML typography tags. Prose components provide a simple way to customize content UI.

To overwrite a prose component, create a component with the same name in your project `components/content/` directory (ex: `components/content/ProseA.vue`).

::note
Prose components are originally part of [`@nuxtjs/mdc`](https://github.com/nuxt-modules/mdc){rel="nofollow"}.
::

## `ProseA`

::code-group
```md [Code]
[Link](/docs/components/prose)
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  [Link](https://nuxt.com/docs/components/prose)
  :::
::

## `ProseBlockquote`

::code-group
```md [Code]
> Block quote
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  > Block quote
  :::
::

## `ProsePre`

::code-group
````md [Code]
  ```js [file.js]{2} meta-info=val
  export default () => {
    console.log('Code block')
  }
  ```
````

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ```js [file.js]
  export default () => {
    console.log('Code block')
  }
  ```
  :::
::

Component properties will be:

```json
{
  code: "export default () => {\n    console.log('Code block')\n}"
  language: "js"
  filename: "file.js"
  highlights: [2]
  meta: "meta-info=val"
}
```

Check out the [highlight options](https://nuxt.com/docs/getting-started/configuration#highlight) for more about the syntax highlighting.

::callout{type="warning"}
If you want to use `]` in the filename, you need to escape it with 2 backslashes: `\\]`. This is necessary since JS will automatically escape the backslash in a string so `\]` will be resolved as `]` breaking our regex.
::

## `ProseCode`

::code-group
```md [Code]
`code`

`const code: string = 'highlighted code inline'`{lang="ts"}
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  `code`
  
  `const code: string = 'highlighted code inline'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}
  :::
::

## `ProseH1`

::code-group
```md [Code]
# H1 Heading
```

  :::code-preview{.pt-4 label="Preview"}
  # H1 Heading
  :::
::

## `ProseH2`

::code-group
```md [Code]
## H2 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ## H2 Heading
  :::
::

## `ProseH3`

::code-group
```md [Code]
### H3 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ### H3 Heading
  :::
::

## `ProseH4`

::code-group
```md [Code]
#### H4 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  #### H4 Heading
  :::
::

## `ProseH5`

::code-group
```md [Code]
##### H5 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ##### H5 Heading
  :::
::

## `ProseH6`

::code-group
```md [Code]
###### H6 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ###### H6 Heading
  :::
::

## `ProseHr`

::code-group
```md [Code]
Divider under.

---

Divider above.
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  Divider under.
  
  ---
  
  Divider above.
  :::
::

## `ProseImg`

::code-group
```md [Code]
![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)
  :::
::

## `ProseUl`

::code-group
```md [Code]
- Just
- An
- Unordered
- List
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  - Just
  - An
  - Unordered
  - List
  :::
::

## `ProseLi`

::code-group
```md [Code]
- List element
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  - List element
  :::
::

## `ProseOl`

::code-group
```md [Code]
1. Foo
2. Bar
3. Baz
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  1. Foo
  2. Bar
  3. Baz
  :::
::

## `ProseP`

::code-group
```md [Code]
Just a paragraph.
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  Just a paragraph.
  :::
::

## `ProseStrong`

::code-group
```md [Code]
**Just a strong paragraph.**
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  **Just a strong paragraph.**
  :::
::

## `ProseEm`

::code-group
```md [Code]
_Just an italic paragraph._
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  *Just an italic paragraph.*
  :::
::

## `ProseTable`

::code-group
```md [Code]
| Key | Type      | Description |
| --- | --------- | ----------- |
| 1   | Wonderful | Table       |
| 2   | Wonderful | Data        |
| 3   | Wonderful | Website     |
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  | Key | Type      | Description |
  | --- | --------- | ----------- |
  | 1   | Wonderful | Table       |
  | 2   | Wonderful | Data        |
  | 3   | Wonderful | Website     |
  :::
::

## `ProseTbody`

Included in **ProseTable** example.

## `ProseTd`

Included in **ProseTable** example.

## `ProseTh`

Included in **ProseTable** example.

## `ProseThead`

Included in **ProseTable** example.

## `ProseTr`

Included in **ProseTable** example.

::callout
---
icon: i-simple-icons-github
to: https://github.com/nuxt-modules/mdc/tree/main/src/runtime/components/prose
---
Checkout the source code for these components on GitHub.
::


# Server Hosting

## What is Node.js preset?

Node preset is the default preset for Nuxt, when building your project, Nuxt will output a Node.js server that you can run with `node .output/server/index.mjs`.

## Environment requirement

If you are using the default `better-sqlite3` module to operate the sqlite database,
then you have to deploy to an OS with Glibc version higher than 2.29, eg. Debian 11, Ubuntu 20.04.

::note
You can use `ldd --version` to check the Glibc version. Checkout [issue #3248](https://github.com/nuxt/content/issues/3248){rel="nofollow"} for more details.
::

## Building with Node.js preset

Build project with Nuxt build command:

```bash [Terminal]
nuxi build
```

When running `nuxi build` with the Node server preset, the result will be an entry point that launches a ready-to-run Node server.

```bash [Terminal]
$ node .output/server/index.mjs
Listening on http://localhost:3000
```

::note
The SQLite database will be loaded on the server side when booting the server as well as in the browser for client-side navigation or actions.
::


# Static Hosting

## What is Static Hosting?

Static hosting is a type of hosting where your website is built and served as static files (HTML, CSS, JS) that can be served by any static file server.

Nuxt Content can be deployed to static hosting using Nuxt prerendering.

## Building with SSG

To build your app with static site generation, run the following command:

```bash
npx nuxi generate
```

::tip{icon="i-lucide-check"}
This command will create a `dist/` directory with your static site. You can upload it to any static hosting service.
::

Nuxt will automatically pre-render all pages using an internal crawler, you can customize it's behavior with the `nitro.prerender` options.

::note{to="https://nuxt.com/docs/getting-started/prerendering"}
Learn more about pre-rendering in Nuxt.
::

## What about the Database?

Nuxt Content will load the database in the browser using [WASM SQLite](https://nuxt.com/docs/advanced/database#wasm-sqlite-in-browser), this way, the content queries happening on client-side navigation or actions will run in the browser.


# Serverless Hosting

## What is Serverless Hosting?

Serverless hosting lets you run code and applications without managing servers directly - you just upload your code and the cloud provider automatically handles all the infrastructure, scaling, and maintenance while charging you only for the actual compute resources you use.

**In serverless environments, each user request triggers a fresh instance of your Nuxt server, meaning it starts from scratch every time.** This "stateless" nature means you can't store data in server memory or use file-based databases like SQLite. That's why we need to use external database services (like D1, Turso, or PostgreSQL) that persist data independently of your server instances.

## Deploy with Serverless

The module have built-in support for couple of famous serverless platforms. You can deploy your project to them with ease. Checkout the guides for each platform:

- [NuxtHub](https://nuxt.com/docs/deploy/nuxthub)
- [Cloudflare Pages](https://nuxt.com/docs/deploy/cloudflare-pages)
- [Vercel](https://nuxt.com/docs/deploy/vercel)

If you like to deploy to other platforms, you can follow below steps to deploy your project.

### 1. Select a database service

Before deploying your project, you need to select a database service:

::code-group
```ts [PostgreSQL]
// 1. Create a PostgreSQL database
// 2. And add the `POSTGRES_URL` to the env variables
export default defineNuxtConfig({
  content: {
    database: {
      type: 'postgres',
      url: process.env.POSTGRES_URL
    }
  }
})
```

```ts [Cloudflare D1]
// 1. Create a D1 database in your CF account
// 2. Link it to your project with the same binding name
export default defineNuxtConfig({
  content: {
    database: {
      type: 'd1',
      bindingName: '<YOUR_BINDING_NAME>'
    }
  }
})
```

```ts [LibSQL]
// 1. Create a LibSQL database on Turso.tech
// 2. And add the `TURSO_DATABASE_URL` and `TURSO_AUTH_TOKEN` env variables
export default defineNuxtConfig({
  modules: ['@nuxt/content'],
  content: {
    database: {
      type: 'libsql',
      url: process.env.TURSO_DATABASE_URL,
      authToken: process.env.TURSO_AUTH_TOKEN,
    }
  }
})
```

```ts [NuxtHub]
// Install the NuxtHub module (see hub.nuxt.com)
export default defineNuxtConfig({
  modules: ['@nuxt/content', '@nuxthub/core'],
  content: {
    database: {
      type: 'd1',
      binding: 'DB'
    }
  },
  hub: {
    database: true
  }
})
```
::

### 2. Deploy your project

Nuxt Content uses Nuxt deployment presets to adjust the build process for different hosting platforms.

Various serverless platform are supported with zero configuration:

- [Cloudflare](https://nuxt.com/deploy/cloudflare){rel="nofollow"}
- [NuxtHub](https://nuxt.com/deploy/nuxthub){rel="nofollow"}
- [Vercel](https://nuxt.com/deploy/vercel){rel="nofollow"}
- [Netlify](https://nuxt.com/deploy/netlify){rel="nofollow"}

All you need to do is to set the build command to:

```bash [Terminal]
nuxi build
```

The generated output will be compatible with the selected platform.

::note
The linked database will be loaded on the server side when booting the server. In the browser, a [WASM SQLite](https://nuxt.com/docs/advanced/database#wasm-sqlite-in-browser) database will be loaded for client-side navigation and actions.
::

::tip
If you wish to deploy to AWS Lambda or Azure Static Web Apps, you need to make sure your sqlite file is in `/tmp` since this is the only writeable folder

```ts
export default defineNuxtConfig({
  modules: ['@nuxt/content'],
  content: {
    database: {
      type: 'sqlite',
      filename: '/tmp/contents.sqlite'
    }
  }
})
```
::

### 3. Optimize with pre-rendering

As each request trigger a fresh instance of your Nuxt server, the performance of your serverless application will be impacted if you don't pre-render some pages.

To optimize your serverless application, you can pre-render your pages using the `routeRules` option:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true }
  }
})
```

::tip{to="https://hub.nuxt.com/docs/recipes/pre-rendering"}
We recommend to checkout **NuxtHub's Pre-rendering guide** to learn more about the different strategies to optimize your serverless application, it applies to all serverless platforms.
::


# NuxtHub

::card
Quick Setup

1. Install the `@nuxthub/core` module `nuxi module add hub`
2. Use `npx nuxthub deploy` to deploy your content to NuxtHub
::

---

Nuxt Content module has a built-in integration with [NuxtHub](https://hub.nuxt.com){rel="nofollow"} to deploy your content.

To enable NuxtHub integration, you need to install the `@nuxthub/core` module and register it in your `nuxt.config.ts`. More efficiently, you can use `nuxi module` command to do both at once.

```bash
npx nuxi module add hub
```

That's it 🎉

Now you can use the `npx nuxthub deploy` command to deploy your content to NuxtHub.

```bash
npx nuxthub deploy
```

::note
Nuxt Content module automatically enables NuxtHub database. And update database configuration to use Cloudflare D1 with `DB` binding name. (This is default configuration for NuxtHub database.)

:br

You can override the database configuration by providing your own database configuration in `nuxt.config.ts`.
::

Checkout the [NuxtHub documentation](https://hub.nuxt.com/docs/getting-started/deploy){rel="nofollow"} for more information.


# Cloudflare Pages

::card
Quick Setup

1. Use `nuxi build --preset=cloudflare_pages` to build your app
2. Create D1 database and connect to your project in Cloudflare Dashboard under `DB` binding name
3. Deploy/Redeploy your app
::

---

Nuxt Content module has a built-in integration with [Cloudflare Pages](https://pages.cloudflare.com){rel="nofollow"} to deploy your content.

Module will automatically detects the build target and prepare the necessary configuration for Cloudflare Pages.

You can either use `--preset=cloudflare_pages` option on `nuxi build` command or use `nuxt.config.ts` to configure the preset.

```ts
export default defineNuxtConfig({
  nitro: {
    preset: 'cloudflare_pages',
  },
});
```

The module requires a D1 database to be connected to the app in order to work. By default it will use the `DB` binding name. You can override the database configuration by providing your own database configuration in `nuxt.config.ts`.

After creating a new Cloudflare Pages project, you need to create a new D1 database and connect it to the project. Make sure to use the same binding name as the module is using. (default is `DB`)

That's it 🎉

Checkout:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/cloudflare){rel="nofollow"}
- [Cloudflare D1 documentation](https://developers.cloudflare.com/d1/){rel="nofollow"}
- [Cloudflare Pages documentation](https://developers.cloudflare.com/pages/){rel="nofollow"}


# Cloudflare Workers

::card
Quick Setup

1. Use `cloudflare_module` preset and compatibility date of `2024-09-19` or later.
2. Create a D1 database and connect it to your project in the Cloudflare Dashboard under the `DB` binding name, and configure the database configuration in the `nuxt.config.ts` file.
3. Build and deploy your app
::

---

The Nuxt Content module has a built-in integration with [Cloudflare Workers](https://workers.cloudflare.com){rel="nofollow"} to deploy your content.

The module will automatically detect the build target and prepare the necessary configuration for Cloudflare Workers.

All you need to do is create a Cloudflare D1 database and connect it to your project. After creating a D1 database, you should
define the database configuration in the `nuxt.config.ts` file with the `nitro.cloudflare.wrangler.d1_databases` option.

By default, the module will use the `DB` binding name. You can override the database configuration by providing your own database configuration in `nuxt.config.ts`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  compatibilityDate: "2025-05-15",
  nitro: {
    preset: 'cloudflare_module',
    cloudflare: {
      deployConfig: true,
      wrangler: {
        d1_databases: [
          {
            binding: 'DB',
            database_name: 'database-name',
            database_id: '*********-***-****-****-*********'
          }
        ]
      },
    },
  }
})
```

::note
If you want to use a different binding name, you can override the database configuration by providing your own database configuration in `nuxt.config.ts`. Check out [Database Configuration](https://nuxt.com/docs/getting-started/configuration#d1)
::

::note
To deploy a Nuxt project to Cloudflare Workers, you need to use a compatibility date of `2024-09-19` or later.
::

Build your project with the `nuxi build` command, and you can deploy the project with the `wrangler deploy` command.

```bash
npx wrangler deploy
```

That's it! 🎉

Check out:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/cloudflare){rel="nofollow"}
- [Cloudflare D1 documentation](https://developers.cloudflare.com/d1/){rel="nofollow"}
- [Cloudflare Workers documentation](https://developers.cloudflare.com/workers/){rel="nofollow"}


# Vercel

::card
Quick Setup

- Execute `npx vercel deploy` command or go to Vercel dashboard and create a new project using git repository.
::

---

Nuxt Content projects can be deployed to Vercel with zero configuration. The module will automatically detect a Vercel environment and will prepare the necessary configuration for deployment.

All you need to do is to execute `npx vercel deploy` command or go to Vercel dashboard and create a new project using git repository.

That's it 🎉

::note
By default module will use SQlite database in Vercel located at `/tmp` directory. You can override the database configuration by providing your own database configuration.

:br

There are a couple of database providers that are supported by Vercel. You can use any of them by providing the correct connection string in `nuxt.config.ts`.
::

Checkout:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/vercel){rel="nofollow"}
- [Vercel documentation](https://vercel.com/docs/deployments/deployment-methods){rel="nofollow"}


# Netlify

::card
Quick Setup

- Go go Netlify dashboard and create a new project using git repository.
- Go to `Site Configuration` under `Dependency management` and change Node Version to `20.x` or higher.
- Go to `deploys` and retry last deployment.
::

---

Nuxt Content projects can be deployed to Netlify with zero configuration. The module will automatically detects Netlify environment and prepare the necessary configuration for Netlify.

All you need to do is to go to Netlify dashboard and create a new project using git repository.

::note
By default Netlify uses Node.js 18.x which is not supported by the module. You need to change the Node.js version in `Site Configuration` under `Dependency management`.
::

That's it 🎉

Checkout:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/netlify){rel="nofollow"}
- [Netlify documentation](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/){rel="nofollow"}


# AWS Amplify

::card
Quick Setup

- Install `sqlite3` package in your project.
- Go to AWS Amplify dashboard and create a new project using git repository and deploy the app.
::

---

Nuxt Content projects can be deployed to AWS Amplify with zero configuration.
The module will automatically detect an AWS Amplify environment and will prepare the necessary configuration for deployment.

All you need to do is to install `sqlite3` package in your project and go to AWS Amplify dashboard and create a new project using git repository.

That's it 🎉

::note
By default module will use SQlite database located at `/tmp` directory. You can override the database configuration by providing your own database configuration.
::

Checkout:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/aws-amplify){rel="nofollow"}


# Docker

Docker is a popular containerization platform that allows you to package your application with all its dependencies into a single container. This makes it easy to deploy your Content app on any platform that supports Docker.

## With Node.js image

Using Docker's Node.js image, you can deploy your Content app. All you need is to create a Dockerfile and build the image. Here is an example Dockerfile:

```docker [Dockerfile]
# Build Stage 1

FROM node:22-alpine AS build
WORKDIR /app

RUN corepack enable

# Copy package.json and your lockfile, here we add pnpm-lock.yaml for illustration
COPY package.json pnpm-lock.yaml .npmrc ./

# Install dependencies
RUN pnpm i

# Copy the entire project
COPY . ./

# Build the project
RUN pnpm run build

# Build Stage 2

FROM node:22-alpine
WORKDIR /app

# Only `.output` folder is needed from the build stage
COPY --from=build /app/.output/ ./

# Change the port and host
ENV PORT=80
ENV HOST=0.0.0.0

EXPOSE 80

CMD ["node", "/app/server/index.mjs"]
```

## With Bun image

If you like to use Bun, you can use the official Bun image. Here is an example Dockerfile:

```docker [Dockerfile]
# use the official Bun image
# see all versions at https://hub.docker.com/r/oven/bun/tags
FROM oven/bun:1 AS build
WORKDIR /app

COPY package.json bun.lockb ./

# use ignore-scripts to avoid builting node modules like better-sqlite3
RUN bun install --frozen-lockfile --ignore-scripts

# Copy the entire project
COPY . .

RUN bun --bun run build

# copy production dependencies and source code into final image
FROM oven/bun:1 AS production
WORKDIR /app

# Only `.output` folder is needed from the build stage
COPY --from=build /app/.output /app

# run the app
EXPOSE 3000/tcp
ENTRYPOINT [ "bun", "--bun", "run", "/app/server/index.mjs" ]
```


# I18n module

Nuxt Content integrates with [`@nuxtjs/i18n`](https://i18n.nuxtjs.org/){rel="nofollow"} to create multi-language websites. When both modules are configured together, you can organize content by language and automatically serve the correct content based on the user's locale.

## Setup

::prose-steps
### Install the required module

```bash [terminal]
npm install @nuxtjs/i18n
```

### Configure your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content', '@nuxtjs/i18n'],
  i18n: {
    locales: [
      { code: 'en', name: 'English', language: 'en-US', dir: 'ltr' },
      { code: 'fr', name: 'French', language: 'fr-FR' },
      { code: 'fa', name: 'Farsi', language: 'fa-IR', dir: 'rtl' },
    ],
    strategy: 'prefix_except_default',
    defaultLocale: 'en',
  }
})
```

### Define collections for each language

Create separate collections for each language in your `content.config.ts`:

```ts [content.config.ts]
const commonSchema = ...;

export default defineContentConfig({
  collections: {
    // English content collection
    content_en: defineCollection({
      type: 'page',
      source: {
        include: 'en/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
    // French content collection
    content_fr: defineCollection({
      type: 'page',
      source: {
        include: 'fr/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
    // Farsi content collection
    content_fa: defineCollection({
      type: 'page',
      source: {
        include: 'fa/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
  },
})
```

### Create dynamic pages

Create a catch-all page that fetches content based on the current locale:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
import { withLeadingSlash } from 'ufo'
import type { Collections } from '@nuxt/content'

const route = useRoute()
const { locale } = useI18n()
const slug = computed(() => withLeadingSlash(String(route.params.slug)))

const { data: page } = await useAsyncData('page-' + slug.value, async () => {
  // Build collection name based on current locale
  const collection = ('content_' + locale.value) as keyof Collections
  const content = await queryCollection(collection).path(slug.value).first()

  // Optional: fallback to default locale if content is missing
  if (!content && locale.value !== 'en') {
    return await queryCollection('content_en').path(slug.value).first()
  }

  return content
}, {
  watch: [locale], // Refetch when locale changes
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
  <div v-else>
    <h1>Page not found</h1>
    <p>This page doesn't exist in {{ locale }} language.</p>
  </div>
</template>
```
::

That's it! 🚀 Your multi-language content site is ready.

## Content Structure

Organize your content files in language-specific folders to match your collections:

```text
content/
  en/
    index.md
    about.md
    blog/
      post-1.md
  fr/
    index.md
    about.md
    blog/
      post-1.md
  fa/
    index.md
    about.md
```

Each language folder should contain the same structure to ensure content parity across locales.

## Fallback Strategy

You can implement a fallback strategy to show content from the default locale when content is missing in the current locale:

```ts [pages/[...slug\\].vue]
const { data: page } = await useAsyncData('page-' + slug.value, async () => {
  const collection = ('content_' + locale.value) as keyof Collections
  let content = await queryCollection(collection).path(slug.value).first()

  // Fallback to default locale if content is missing
  if (!content && locale.value !== 'en') {
    content = await queryCollection('content_en').path(slug.value).first()
  }

  return content
})
```

::prose-warning
Make sure to handle missing content gracefully and provide clear feedback to users when content is not available in their preferred language.
::

## Complete Examples

You can see a complete working example:

- **Source**: <https://github.com/nuxt/content/tree/main/examples/i18n>{rel="nofollow"}
- **Live Demo**: <https://content3-i18n.nuxt.dev/>{rel="nofollow"}


# LLMs module

The Nuxt Content module integrates [`nuxt-llms`](https://github.com/nuxtlabs/nuxt-llms){rel="nofollow"} to prepare your content for Large Language Models (LLMs). When `nuxt-llms` is detected, Content module automatically extends the LLMs module and inject collections of type [page](https://content.nuxt.com/docs/collections/types#page-type){rel="nofollow"} to the LLMs module.🚀

## Setup

::prose-steps
### Install the required module

```bash [terminal]
npm install nuxt-llms
```

### Configure your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content', 'nuxt-llms'],
  llms: {
    domain: 'https://your-site.com',
    title: 'Your Site Name',
    description: 'A brief description of your site',
  },
})
```
::

That's it 🚀 `/llms.txt` file is automatically generated and pre-rendered.

## Sections

When generating content, you can create custom sections to process your content into LLM-friendly formats.

You can create custom sections to the `llms.sections` array and define the `contentCollection` and `contentFilters` option for each section.

::prose-warning
If there is no section defined in the `contentCollection` option, the module will only add [page](https://content.nuxt.com/docs/collections/types#page-type){rel="nofollow"} collections to the LLMs module.
::

### `contentCollection`

This option specifies which content collection to use as source.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  llms: {
    sections: [
      {
        title: 'Documentation',
        description: 'Technical documentation and guides',
        contentCollection: 'docs',
       },
    ],
  },
})
```

### `contentFilters`

This options defines filters to select specific content within the collection.

You precisely control which content is included. Each filter consists of:

- `field`: The content property to check
- `operator`: Comparison operator (`=`, `<>`, `>`, `<`, `LIKE`, `IN`, `NOT IN`, `IS NULL`, `IS NOT NULL`, etc.)
- `value`: The value to compare against

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  llms: {
    sections: [
      {
        title: 'Documentation',
        description: 'Technical documentation and guides',
        contentCollection: 'docs',
        contentFilters: [
            // Only include markdown files
            { field: 'extension', operator: '=', value: 'md' },
            // Only include published content
            { field: 'draft', operator: '<>', value: true },
            // Filter by directory
            { field: 'path', operator: 'LIKE', value: '/guide%' },
        ]
      },
    ],
  },
})
```

::tip{to="https://github.com/nuxtlabs/nuxt-llms"}
Checkout the nuxt-llms documentation for more information about the module.
::


# Full-Text Search

Content module exposes a handy utility [`queryCollectionSearchSections`](https://nuxt.com/docs/utils/query-collection-search-sections) to break down content files into searchable sections. This is useful for implementing full-text search in your website. You can use the result of this utility in combination with [Nuxt UI Content Search](https://ui.nuxt.com/pro/components/content-search){rel="nofollow"} or other search libraries like [Fuse.js](https://fusejs.io/){rel="nofollow"}, [minisearch](https://lucaong.github.io/minisearch){rel="nofollow"}, etc.

## Nuxt UI Pro

Nuxt UI Pro provides a ready to use component for full-text search. You can use it by passing the result of `queryCollectionSearchSections` to the `files` prop of the component.

Read more about [Nuxt UI Content Search](https://ui.nuxt.com/pro/components/content-search){rel="nofollow"}.

::code-group
```vue [UContentSearchExample.vue]
<script setup lang="ts">
const { data: navigation } = await useAsyncData('navigation', () => queryCollectionNavigation('docs'))
const { data: files } = await useAsyncData('search', () => queryCollectionSearchSections('docs'))

const searchTerm = ref('')
</script>

<template>
  <UContentSearch
    v-model:search-term="searchTerm"
    :files="files"
    :navigation="navigation"
    :fuse="{ resultLimit: 42 }"
  />
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-fulltext-content-search
    ::::
  :::
::

## MiniSearch example

Read more about [minisearch](https://lucaong.github.io/minisearch){rel="nofollow"}.

::code-group
```vue [MiniSearchExample.vue]
<script setup lang="ts">
import MiniSearch from 'minisearch'

const query = ref('')
const { data } = await useAsyncData('search', () => queryCollectionSearchSections('docs'))

const miniSearch = new MiniSearch({
  fields: ['title', 'content'],
  storeFields: ['title', 'content'],
  searchOptions: {
    prefix: true,
    fuzzy: 0.2,
  },
})

// Add data to the MiniSearch instance
miniSearch.addAll(toValue(data.value))
const result = computed(() => miniSearch.search(toValue(query)))
</script>

<template>
  <UContainer class="p-4">
    <UCard>
      <UInput v-model="query" placeholder="Search..." />
      <ul>
        <li v-for="link of result" :key="link.id" class="mt-2">
          <NuxtLink :to="link.id">{{ link.title }}</NuxtLink>
          <p class="text-gray-500 text-xs">{{ link.content }}</p>
        </li>
      </ul>
    </UCard>
  </UContainer>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-fulltext-mini-search
    ::::
  :::
::

## Fuse.js example

Read more about [Fuse.js](https://fusejs.io){rel="nofollow"}.

::code-group
```vue [FusejsExample.vue]
<script setup lang="ts">
import Fuse from 'fuse.js'

const query = ref('')
const { data } = await useAsyncData('search-data', () => queryCollectionSearchSections('docs'))

const fuse = new Fuse(data.value, {
  keys: ['title', 'description']
})

const result = computed(() => fuse.search(toValue(query)).slice(0, 10))
</script>

<template>
  <UContainer class="p-4">
    <UCard>
      <UInput v-model="query" placeholder="Search..." class="w-full" />
      <ul>
        <li v-for="link of result" :key="link.item.id" class="mt-2">
          <UButton variant="ghost" class="w-full" :to="link.item.id">
            {{ link.item.title }}
            <span class="text-gray-500 text-xs">
              {{ link.item.content?.slice(0, 100) }}...
            </span>
          </UButton>
        </li>
      </ul>
    </UCard>
  </UContainer>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-fulltext-fusejs
    ::::
  :::
::


# Raw Content

There were lots of requests in Content version 2 about accessing contents raw data in production. In Content version 3 it is possible to ship contents raw data to production.

In order to ship raw contents to production you need to define `rawbody` field in your collection's schema. That's it.

Nuxt Content will detect this magical field in your schema and fill it with the raw content.

```ts [content.config.ts]

import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      source: '**',
      type: 'page',
      schema: z.object({
        rawbody: z.string()
      })
    })
  }
})
```

And you can use `queryCollection()` to fetch the raw content.

```vue [pages/index.vue]
<script setup lang="ts">
const route = useRoute()
const { data } = useAsyncData('page-' + route.path, () => queryCollection('docs').path(route.path).first())
</script>

<template>
  <pre>{{ data.rawbody }}</pre>
</template>
```

In case you don't want to ship raw content of a specific file you can add `rawbody: ''` to frontmatter of that file. The auto filled value of `rawbody` is acting like default value and when you define `rawbody` in the frontmatter it will overwritten.

```md [content.md]
---
title: My page
rawbody: ''
---

```

::callout
It is important to fill frontmatter fields with a same type of data that is defined in collection schema. In this case `rawbody` is a string, and you should consider passing empty string. Do not use `boolean` or other type of values.
::


# Database

In Content v3, we have introduced a robust storage layer based on SQLite, which offers a powerful and efficient method for managing content. This marks a significant enhancement over the previous file-based storage system, which was constrained by performance and scalability limitations.

> In Content v2, the system read and parsed content during the Nitro runtime, creating a cache file for each content file to store the parsed data. This method introduced considerable overhead to the website's runtime.
>
> - The I/O time in production was substantial, as the module had to load all cache files to search through the content.
> - Additionally, the lack of optimization and compression for the content resulted in a large bundle size, particularly problematic in edge environments.

Content management in Content v3 involves three key steps, which are designed to streamline the process and enhance performance.

## Generating Database Dump

For each collection in your project, the module reads the content from the defined source and parses it into an Abstract Syntax Tree (AST). It creates a specific table for each collection based on its schema. The parsed content is then inserted into the corresponding table, ensuring that the data structure aligns with the defined schema for optimal querying. Everything is then saved in a dump file.

## Restoring Dump on Cold Start

During runtime, when the application executes the first query to retrieve content, the module reads the generated dump from the previous step and restores it into the target database. This process is fast and optimized for each deployment mode and platform.

The module employs a special integrity check mechanism to ensure that the database is updated with the latest content. This same integrity check also prevents duplicate imports, maintaining the integrity and accuracy of the data stored.

## WASM SQLite in Browser

For client-side navigation, the module utilizes a similar approach. When the application executes the first query for content, it downloads the generated dump from the server and initializes a local SQLite database within the browser. From that point onward, all queries are executed locally without needing to call the server, significantly improving the responsiveness of the application and providing a seamless user experience.

This architecture not only enhances performance but also allows for offline capabilities, enabling users to access content even without an active internet connection. The combination of server-side and client-side processing ensures that Nuxt Content v3 is both powerful and flexible, catering to a wide range of use cases and environments.


# Tools

Nuxt Content uses an &#x2A;*SQLite database (`contents.sqlite`)** to store and query content efficiently. If you're running into **missing content, slow queries, or database issues**, debugging your SQLite database can help!

::callout
---
icon: i-simple-icons-visualstudiocode
to: https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite
---
A simple way to inspect it? **Use the SQLite VS Code extension!**
::

## Install SQLite VS Code Extension

1. Open **Visual Studio Code**.
2. Go to the **Extensions** panel (`Ctrl+Shift+X` / `Cmd+Shift+X` on Mac).
3. Search for &#x2A;*"SQLite"** (by `alexcvzz`) and install it.
4. Open your Nuxt Content database (`.data/content/contents.sqlite`).

::tip{icon="i-lucide-lightbulb"}
If you don't see `contents.sqlite`, start your Nuxt app first:

```bash [Terminal]
npx nuxi dev
```
::

## Locate Your SQLite Database

Nuxt Content stores its database here:

```bash
.data/content/contents.sqlite
```

::note{to="https://nuxt.com/docs/getting-started/prerendering"}
This file is automatically generated when you start your Nuxt app. No need to create it manually!
::

## Open & Explore the Database

1. **Right-click** on `contents.sqlite` in VS Code.
2. Select &#x2A;*"Open Database"**.
3. Expand the **Database Explorer** panel to view tables & data.

![SQLite Explorer in VS Code](https://github.com/user-attachments/assets/c9f22c4c-7a95-43e8-ab03-aa76f2e49c8e)

## Fixing Common Issues

### Content Not Showing?

1. **Check if the database exists** (`.data/content/contents.sqlite`).
2. **Run a cleanup & restart Nuxt**:

   ```bash [Terminal]
   npx nuxi cleanup && npx nuxi dev
   ```
3. **Check if content is inside the database** (run an SQL query).

### Manually Reset the Database

If things seem **really broken**, try resetting it:

1. **Delete the database file**:

   ```bash [Terminal]
   rm -rf .data/content/contents.sqlite
   ```
2. **Run cleanup** to remove old caches:

   ```bash [Terminal]
   npx nuxi cleanup
   ```
3. **Restart Nuxt** to generate a fresh database:

   ```bash [Terminal]
   npx nuxi dev
   ```

::note{icon="i-lucide-triangle-alert"}
Cleaning up will remove cached data. Don't worry—it regenerates automatically!
::

## More Debugging Tools

If VS Code isn’t enough, check out:

- 🖥️ [**DB Browser for SQLite**](https://sqlitebrowser.org/){rel="nofollow"} – A visual tool for inspecting & modifying the database.
- 🛠️ **SQLite Command Line** – Use `sqlite3 contents.sqlite` to run SQL queries from your terminal.


# Hooks

## `content:file:beforeParse`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}

This hook is called before the content is parsed.

It can be used to modify the raw content from a `file` before it is transformed
or modify the transform options.

```ts
export default defineNuxtConfig({
  hooks: {
    'content:file:beforeParse'(ctx) {
      // ...
    }
  }
})
```

## `content:file:afterParse`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}

This hook is called after the content is parsed and before it is saved to the database.

```ts
export default defineNuxtConfig({
  hooks: {
    'content:file:afterParse'(ctx) {
      // ...
    }
  }
})
```

## Example Usage

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // ...
  hooks: {
    'content:file:beforeParse'(ctx) {
      const { file } = ctx;

      if (file.id.endsWith(".md")) {
        file.body = file.body.replace(/react/gi, "Vue");
      }
    },
    'content:file:afterParse'(ctx) {
      const { file, content } = ctx;

      const wordsPerMinute = 180;
      const text = typeof file.body === 'string' ? file.body : '';
      const wordCount = text.split(/\s+/).length;

      content.readingTime = Math.ceil(wordCount / wordsPerMinute);
    }
  }
})
```

::note{icon="i-lucide-info"}
In the `content:file:afterParse` hook, we added a custom property to our content object. To be able to access that property within our pages using [`queryCollection()`](https://nuxt.com/docs/utils/query-collection), we first need to define it in our content schema.

```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    content: defineCollection({
      type: 'page',
      source: '**/*.md',
      schema: z.object({
        readingTime: z.number().optional()
      })
    })
  }
});
```
::


# Custom Source

By default, Nuxt Content provides some built-in sources like local files source and remote Github source. However this is not enough for some cases, for example, you want to fetch data from a remote API. In this case, you can define a custom source to fetch data and use it in your collections.

Using `defineCollectionSource`, you can define a custom source.

```ts
import { defineCollectionSource } from '@nuxt/content'

const hackernewsSource = defineCollectionSource({
  getKeys: () => {
    return fetch('https://hacker-news.firebaseio.com/v0/topstories.json')
      .then(res => res.json())
      .then(data => data.map((key: string) => `${key}.json`))
  },
  getItem: (key: string) => {
    const id = key.split('.')[0]
    return fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)
      .then(res => res.json())
  },
})
```

Then you can use this source in your collections.

```ts [content.config.ts]
import { defineContentConfig, defineCollectionSource, defineCollection, z } from '@nuxt/content'

const hackernewsSource = defineCollectionSource({
  getKeys: () => {
    return fetch('https://hacker-news.firebaseio.com/v0/topstories.json')
      .then(res => res.json())
      .then(data => data.map((key: string) => `${key}.json`))
  },
  getItem: (key: string) => {
    const id = key.split('.')[0]
    return fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)
      .then(res => res.json())
  },
})

const hackernews = defineCollection({
  type: 'data',
  source: hackernewsSource,
  schema: z.object({
    title: z.string(),
    date: z.date(),
    type: z.string(),
    score: z.number(),
    url: z.string(),
    by: z.string(),
  }),
})

export default defineContentConfig({
  collections: {
    hackernews,
  },
})
```


# Transformers

Transformers in Nuxt Content allow you to programmatically parse, modify, or analyze your content files as they are processed. They are especially useful for:

- Adding or modifying fields (e.g., appending to the title, generating slugs)
- Extracting metadata (e.g., listing used components)
- Enriching content with computed data
- Supporting new content types

## Defining a Transformer

You can define a transformer using the `defineTransformer` helper from `@nuxt/content`:

```ts [~~/transformers/title-suffix.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'title-suffix',
  extensions: ['.md'], // File extensions to apply this transformer to
  transform(file) {
    // Modify the file object as needed
    return {
      ...file,
      title: file.title + ' (suffix)',
    }
  },
})
```

### Transformer Options

- `name` (string): A unique name for your transformer.
- `extensions` (string [] ): File extensions this transformer should apply to (e.g., `['.md']`).
- `transform` (function): The function that receives the file object and returns the modified file.

## Registering Transformers

Transformers are registered in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~~/transformers/title-suffix',
        '~~/transformers/my-custom-transformer',
      ],
    },
  },
})
```

## Example: Adding Metadata

Transformers can add a `__metadata` field to the file. This field is not stored in the database but can be used for runtime logic.

```ts [~~/transformers/component-metadata.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'component-metadata',
  extensions: ['.md'],
  transform(file) {
    // Example: Detect if a custom component is used
    const usesMyComponent = file.body?.includes('<MyCustomComponent>')
    return {
      ...file,
      __metadata: {
        components: usesMyComponent ? ['MyCustomComponent'] : [],
      },
    }
  },
})
```

**Note:** The `__metadata` field is only available at runtime and is not persisted in the content database.

## API Reference

```ts
interface Transformer {
  name: string
  extensions: string[]
  transform: (file: ContentFile) => ContentFile
}
```

- `ContentFile` is the object representing the parsed content file, including frontmatter, body, and other fields.

## Supporting New File Formats with Transformers

Transformers are not limited to modifying existing content—they can also be used to add support for new file formats in Nuxt Content. By defining a transformer with a custom `parse` method, you can instruct Nuxt Content how to read and process files with new extensions, such as YAML.

### Example: YAML File Support

Suppose you want to support `.yml` and `.yaml` files in your content directory. You can create a transformer that parses YAML frontmatter and body, and registers it for those extensions:

```ts [~~/transformers/yaml.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'Yaml',
  extensions: ['.yml', '.yaml'],
  parse: (file) => {
    const { id, body } = file
    
    // parse the body with your favorite yaml parser
    const parsed = parseYaml(body)

    return {
      ...parsed,
      id,
    }
  },
})
```

Register your YAML transformer in your Nuxt config just like any other transformer:

```ts
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~~/transformers/yaml',
        // ...other transformers
      ],
    },
  },
})
```

This approach allows you to extend Nuxt Content to handle any custom file format you need.


# Setup Nuxt Studio

Studio is an intuitive CMS interface to edit your Nuxt Content websites.

It takes advantage of the `Preview API` included in Nuxt Content to propose the best editing experience for your content files. Editors can benefit from a user-friendly interface to edit their `Markdown`, `YAML` or `JSON` files.

Developers can customize the editing experience and provide tools to the editor who can focus on content without requiring any technical expertise.

:video{autoplay controls loop poster="/home/videos/HomeNotionLikePoster.webp" src="https://res.cloudinary.com/nuxt/video/upload/v1733494722/contentv3final_rc8bvu.mp4"}

## Authentication

The Studio admin is located on [nuxt.studio](https://nuxt.studio){rel="nofollow"}. From there you can either login with GitHub or with Google. Both methods give you the same editing rights but since Studio is [synchronized with GitHub](https://nuxt.com/docs/studio/github), the repository import must be handled by a GitHub user.

::warning
Google authentication is adapted for non technical users. Google users have to join a team with existing projects to edit them.
::

## Connect your Nuxt Content Repository

Once you are logged in the admin, you have the possibility to import your Nuxt Content repository from the interface.

::tip
Two options are available, you can either import an existing repository or use one of our [templates](https://nuxt.com/templates).
::

The only requirement is to host your repository on GitHub. From the interface, connect to our [GitHub app](https://nuxt.com/docs/studio/github), you'll be then able to link a GitHub repository to your Studio project.

Once the project is created, you can start editing your files with the Studio editors and publish your changes.

## **Enable the Full Editing Experience**

To unlock the complete range of features in Studio, make sure your project URL is properly configured in the deployment section.

**This will enable all Studio features including:**

- **Live preview of your website:** instantly see changes reflected on your site as you work.
- **Dynamic form generation:** Automatically generate forms to edit your files based on your Nuxt Content [collections](https://nuxt.com/docs/collections/define).
- **Enhanced markdown editors:** enjoy an improved editing experience, including the ability to list and integrate [Vue components](https://nuxt.com/docs/studio/content#vue-components) that you’ve exposed.
- **Automatic app configuration:** generate [application configurations](https://nuxt.com/docs/studio/config) based on the schema you’ve defined.

::tip
We are proposing a GitHub Pages deployment. By using it, we will handle all the requirements for you. However, if you want to use the deployment platform of your choice, please follow the simple guideline below.
::

To be able to set your URL in Studio, you just need to set the `Preview API` in the content configuration of your `nuxt.config.ts` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  }
})
```

Once deployed, you can ensure the `Preview API` has been activated by navigating to the `/__preview.json` page on your site. This metadata page is automatically generated by the Content module and must be accessible to connect your URL in the self-hosted section of Studio.

### Troubleshooting

The `__preview.json` file is generated but you encounter a `Forbidden error: invalid property check` when setting your URL in the self-hosted section, follow these steps:

::prose-steps{level="4"}
#### Ensure the `gitInfo` field is set and accurate in the `__preview.json` file

```json [https://your-website.com/__preview.json]
"gitInfo": {
  "name": "content",
  "owner": "nuxt",
  "url": "https://github.com/nuxt/content"
},
```

  :::warning
  This information should be populated automatically in most cases. We support most popular providers (NuxtHub, Vercel, Netlify, etc.), but if you're using a non supported provider or a custom one, it may not be fetched correctly.
  :::

#### Override `gitInfo` in your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio',
      gitInfo: {
        name: 'Your repository name',
        owner: 'Your repository owner/organization',
        url: 'Your GitHub repository URL'
      }
    }
  }
})
```

#### Ensure these fields are correctly set in `__preview.json`

The `Forbidden error` should be resolved and you should be able to set your URL on Nuxt Studio. If not, please contact us on the [Discord server](https://discord.gg/sBXDm6e8SP){rel="nofollow"}.
::


# Real time synchronization between Studio and GitHub

::tip
This section explains the syncronization behaviour between Studio and GitHub. This process is handled directly from the platform and does not require any external action. This page purpose is purely informational.
::

## Overview

Nuxt Studio integrates with the [GitHub](https://github.com){rel="nofollow"} API, enabling smooth synchronization between Studio and your GitHub repositories. This first-class integration is made possible through the utilization of [GitHub Apps](https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps#about-github-apps){rel="nofollow"}.

## Installation

During Studio project creation, you'll need to install the [Nuxt Studio GitHub App](https://github.com/apps/nuxt-studio){rel="nofollow"} in your personal account or in the organizations you manage. Installing a GitHub App requires either organization ownership or admin permissions in a repository. If you lack the necessary permissions, the repository owner will need to approve the request.

You can access the installation page from anywhere on the app by clicking on [Install with GitHub](https://github.com/apps/nuxt-studio/installations/new){rel="nofollow"}.

### Permissions

During the installation of our GitHub app, you will be prompted to grant certain permissions:

- Read access to `actions`, `metadata`, `members`, and `plan`
- Read and write access to `secrets`, `administration`, `contents`, `pages`, `pull requests` and `workflows`

We need read access to `actions` to send a notification when a workflow run fails on a pull request or on the repository default branch. `metadata` is mandatory to fetch repository data, `members` to import your organization members and repository collaborators and `plan` is used to propose features based on your GitHub account plan.

Nuxt Studio acts on your behalf to create repositories, branches, pull requests, and perform commits and merges. We also offer one-click deployment to GitHub Pages with instant preview of workflows and environment variables secrets management. To accomplish this, we need read and write access to `administration`, `contents`, `pages`, `pull requests`, `workflows` and `secrets`.

### Repositories Installations

When installing our GitHub app, you will be prompted to select all repositories or a subset of them. This selection can be changed at any time by going to the [GitHub app settings](https://github.com/apps/nuxt-studio/installations/new){rel="nofollow"}.

By clicking on `Install`, Nuxt Studio will install each repository you have selected, enabling you to perform all the actions listed above.

## Uninstall

All the data imported from GitHub is directly associated with your GitHub app installation. If you uninstall the GitHub app, all the associated data will be deleted.

If you delete your GitHub repository, the associated Nuxt Studio project will be automatically removed. However, if this project was subscribed to a Team plan, the subscription will not be canceled automatically. You will need to manually end the subscription via [Lemon Squeezy]() or [contact us](https://nuxt.com/team@nuxt.studio) for assistance.


# Edit your content

Nuxt Studio offers a versatile workspace for both developers and content writers, giving them the freedom to choose between our differents editors:

- [Notion-like editor](https://nuxt.com/#notion-like-editor-markdown-files) for `Markdown` files
- [Form editor](https://nuxt.com/#form-editor) for `YAML` and `JSON` files
- [Code editor](https://nuxt.com/#code-editor) for any kind of files (for technical users only)

::tip
You can choose your favorite editor from the settings page of your project.
::

Each editor serves its own purpose. Some users are used to code edition, while others prefer a non-technical, visual approach. At the end, **code syntax is the final output** for both editors.

## Notion-like editor (`Markdown` files)

![edit your website with a visual interface](https://nuxt.com/docs/studio/visual-markdown-editor.webp)

This editor is heavily inspired by Notion, well known for its intuitive design and flexibility. Much like a standard text editor, this editor is designed to be familiar and easy to use. However, it stands out with its additional features that improve the writing experience.

::tip{to="https://nuxt.com/blog/visual-editor"}
You want to know how we've built this editor and how it works under the hood? Check this blog post.
::

### Frontmatter

[Frontmatter](https://nuxt.com/docs/files/markdown#frontmatter) is a convention of Markdown-based CMS to provide meta-data to pages, like description or title or any other data you would like to store as `key: value` pair.

Based on the user [collection and schema](https://nuxt.com/docs/collections/define) provided, a form is generated to edit this metadata from the editor.

:video{autoplay controls loop poster="/home/videos/HomeNotionLikePoster.webp" src="https://res.cloudinary.com/nuxt/video/upload/v1739982761/frontmatterform_yjafgt.mp4"}

::prose-note{to="https://nuxt.com/#form-editor-yaml-and-json-files"}
Check this section to learn more about form generation based on schema.
::

### Toolbar

Highlight your text to reveal the toolbar, giving you access to all the standard text editing features (title formatting, Bold, Italic, Strike-through, code, link, class, bullet list, numerated list...).

### Medias

Users can simply drag and drop images directly into the editor. An upload modal will open to let you choose the destination folder.

By typing `/` and searching for `Image` or `Video`, they can quickly insert a media. A modal will open to let them choose the media they want to insert from the media gallery (aka the`public` folder of the Nuxt application).

From the media modal, you can set the [alt attribute](https://www.w3schools.com/tags/att_img_alt.asp){rel="nofollow"} for SEO and accessibility purpose.

### Vue Components

One of this editor standout features is its ability to integrate and customize any complex `Vue` component directly within the editor.

#### Create and integrate your own component

A developer can create any kind of visually complex components and editors will be able to use them and focus on the content. An editor can also play with the component properties, styles, and behaviour to fit its specific requirements as long as the developer made it customisable.

::steps{level="4"}
#### Create your component

You can create Vue components and integrate them into Markdown. They just need to be located in the `/components/content` folder to be available.

```vue [components/content/HomeFeature.vue]
<template>
  <div class="flex items-start gap-3">
    <div class="flex items-center justify-center border rounded-lg p-1.5">
      <UIcon :name="icon" />
    </div>
    <div class="flex flex-col">
      <h3 class="font-semibold">
        <slot name="title" />
      </h3>
      <span>
        <slot name="description" />
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
defineProps({
  icon: {
    type: String,
    default: 'i-ph-cursor-click',
  },
})
</script>
```

#### Integrate these components easily within any Markdown file using [MDC syntax](https://nuxt.com/docs/files/markdown#mdc-syntax)

```mdc [content/index.md]
::home-feature
  ---
  icon: i-mdi-vuejs
  ---
  #title
  Embedded Vue components
  #description
  Edit slots and props inside the Notion-like editor.
::
```

#### Edit them with our Studio editors

The visual editor simplifies the component edition, allowing you to integrate and edit them directly in the visual editor. Non technical users can play with **slots** and **props** without any technical knowledge.

:video{autoplay controls loop src="https://res.cloudinary.com/nuxt/video/upload/v1744126742/studio/finalpropscomps_usfabp.mp4"}

All components in the `/components/content` folder are available in the editor. Studio users can type `/` anywhere while editing to access the list of available components.

  :::tip{to="https://nuxt.com/docs/studio/debug"}
  Take a look at this section to validate your
  
  `Vue`
  
  component integration in the editor in local development.
  :::
::

#### Integrate built-in components from external libraries

By default, you can integrate any component inside a Markdown file and it should work and be editable from Studio but external components **won't be displayed in the components list in Studio and can't be integrated manually by a Studio editor**.

To list this component inside Studio and fetch all its metadata, you need to set it as global in your Nuxt config file.

Here is an example to integrate Button and Icon components from the [Nuxt UI](https://ui.nuxt.com){rel="nofollow"} library:

```ts
export default defineNuxtConfig({
  hooks: {
    'components:extend': (components) => {
      const globals = components.filter(c => ['UButton', 'UIcon'].includes(c.pascalName))

      globals.forEach(c => c.global = true)
    }
  },
})
```

## Form editor

![YAML and JSON edition with auto generated form](https://nuxt.com/blog/frontmatters.png)

This editor is used whether you’re editing the [frontmatter]() of a `Markdown` file or a `JSON` / `YAML` file.

It eliminates the need to interact directly with complex file syntax. Instead, a form is automatically generated based on the provided user [collection schema](https://nuxt.com/docs/collections/define).

### **Defining your form with** `zod` Schema

::prose-note{to="https://nuxt.com/docs/collections/define"}
Learn more about schema collection definition in the dedicated section.
::

Once the `schema` property has been defined in your collection, this will automatically generate the corresponding form on Studio interface.

::prose-code-group
```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    posts: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        draft: z.boolean().default(false),
        category: z.enum(['Alps', 'Himalaya', 'Pyrenees']).optional(),
        date: z.date(),
        image: z.object({
          src: z.string().editor({ input: 'media' }),
          alt: z.string(),
        }),
        slug: z.string().editor({ hidden: true }),
        icon: z.string().optional().editor({ input: 'icon' }),
        authors: z.array(z.object({
          slug: z.string(),
          username: z.string(),
          name: z.string(),
          to: z.string(),
          avatar: z.object({
            src: z.string(),
            alt: z.string(),
          }),
        })),
      }),
    }),
  },
})    
```

  :::code-preview{icon="i-lucide-eye" label="Generated Form"}
  ![Form preview](https://nuxt.com/docs/studio/preview-schema.png)
  :::
::

### **Native Inputs Mapping**

Primitive Zod types are automatically mapped to appropriate form inputs in:

- **String** → Text input
- **Date** → Date picker
- **Number** → Number input (counter)
- **Boolean** → Toggle switch
- **Enum** → Select dropdown
- **Arrays of strings** → List of badge inputs
- **Arrays of objects** → Accordion of items with embedded form

:video{autoplay controls loop poster="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.jpg" src="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.mp4"}

### Custom Inputs Mapping

Studio goes beyond primitive types. You can customise form fields using the `editor` method, which extends Zod types with metadata to empower editor interface.

This allows you to define custom inputs or hide fields.

#### Usage

```ts [content.config.ts]
// Icon
icon: z.string().editor({ input: 'icon', iconLibraries: ['lucide', 'simple-icons'] })

// Media
image: z.string().editor({ input: 'media' })
```

#### Options

##### `input: 'media' | 'icon'`

You can set the editor input type. Currently `icon` and `media` are available.

##### `iconLibraries: Array<string>`

Specifies which [Iconify](https://icones.js.org/){rel="nofollow"} libraries to display. Use this option to filter and limit the available icon sets.

`hidden: Boolean`

This option can be set to avoid the display of a field in the Studio editor.

::prose-tip
Studio inputs are fully extensible. We can create as many input as we want based on our users needs.
::

## Code editor

![Edit directly your raw content with our code editor](https://nuxt.com/docs/studio/code-editor.webp)

Even though the two previous editors are dedicated to a specific file extension (`md` or `yaml`/`json`). The code editor can be used with any kind of file.

It provides full control over your content, allowing you to write raw content directly:

- [MDC](https://nuxt.com/docs/files/markdown) syntax for `Markdown` files
- [JSON](https://nuxt.com/docs/files/json) or [YAML](https://nuxt.com/docs/files/yaml) syntax

When your file is saved with the code editor, the content is stored exactly as you've written it, preserving all specific syntax and formatting. This editor is ideal for users comfortable with code syntax (`Markdown`, `YAML` or `JSON`) who want precise control over structure of their content.


# Manage and integrate Medias in Nuxt Content Studio CMS

## Browse your medias

All medias located in the `/public` directory are available in the **Media** tab of the Studio platform.

![Media gallery on Studio](https://nuxt.com/docs/studio/editors-medias.webp)

It's an intuitive interface for non technical users to manage their `/public` directory.

Users can easily browse folders, upload new media at any level, and drag and drop media into other folders, making medias organization straightforward.

The interface is designed to be intuitive for non-technical users. It can be viewed as a user friendly IDE.

## Use it in the Notion-like editor

Users can simply drag and drop images directly into the editor. An upload modal will open to let you choose the destination folder.

By typing `/` and searching for `Image`, they can quickly insert a media. A modal will open to let them choose the media they want to insert.

From the media modal, you can set the [alt attribute](https://www.w3schools.com/tags/att_img_alt.asp){rel="nofollow"} for SEO and accessibility purpose.


# Tailor application configuration edition

When entering the **Config** tab of the editor, you can browse configurations to customize your website. These configurations represent the settings defined in your `app.config.ts` file.

## `app.config.ts`

The [`app.config.ts`](https://nuxt.com/docs/guide/directory-structure/app-config){rel="nofollow"} file is a configuration file introduced in Nuxt 3. It's a TypeScript file that allows you to configure various aspects of your application settings. Developers can easily turn any website into a configurable experience using this file.

## Customize edition

::prose-note
Ensure you have at least an empty config file in your app.

```ts [app.config.ts]
export default defineAppConfig({})
```
::

To create a customized editing experience for your `app.config.ts` in Studio, you need to create a `nuxt.schema.ts` file in your project. This schema serves as a representation of your `app.config.ts`.

### Helpers

::prose-note
Those helpers are provided by the Nuxt Content `Preview API`.
::

- The `group` method allows you to customize parent objects.
- The `field` method allows you to customize inputs (aka leaf).

```ts [nuxt.schema.ts]
import { field, group } from '@nuxt/content/preview'

export default defineNuxtSchema({
  appConfig: {
    parent: group({
      title: 'Parent title',
      description: 'Parent description.',
      icon: 'i-icon-to-display',
      fields: {
        leaf: field({
          type: 'Type of component used to edit your field',
          title: 'Field title',
          description: 'Field Description',
          icon: 'i-icon-to-display',
          default: 'default value'
        })
      }
    })
  }
})
```

::tip
It is not mandatory to include all your app config keys; only those you wish to showcase on the Studio interface need to be added.
::

#### Input Types

The `type` in the `field()` method's first parameter can accept various values:

- string
- number
- boolean
- array
- object
- icon
- media

Based on these values, the Studio UI will adapt to display the appropriate input type. For instance, an icon picker is displayed for `icon` type or the media library is displayed for `media` type.

Text can be displayed as a select instead on a classical input if you provide a `required` key in the `field()` method:

```ts [nuxt.schema.ts]
import { field, group } from '@nuxt/content/preview'

export default defineNuxtSchema({
  appConfig: {
    parent: group({
      title: 'UI',
      description: 'UI configuration',
      icon: 'i-ph-palette-fill',
      fields: {
        primary: field({
          type: 'string',
          title: 'Primary',
          description: 'Primary color of your UI.',
          icon: 'i-ph-palette',
          default: 'sky',
          required: ['sky', 'mint', 'rose', 'amber']
        })
      }
    })
  }
})
```

### Edit on Studio

Once your schema is deployed. Any user can access the **Data** section and play with the generated form.

Any update in the form will be directly applied to the `app.config.ts` file. You can review those changes on the review page.

::code-group
  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ![app config UI on Studio](https://nuxt.com/docs/studio/home-data-studio-dark.webp)
  :::

```ts [nuxt.schema.ts]
export default defineNuxtSchema({
  ui: group({
    title: 'UI',
    description: 'UI Customization.',
    icon: 'i-mdi-palette-outline',
    fields: {
      primary: field({
        type: 'string',
        title: 'Primary',
        description: 'Primary color of your UI.',
        icon: 'i-mdi-palette-outline',
        required: ['sky', 'mint', 'rose', 'amber', 'violet', 'emerald', 'fuchsia', '...']
      }),
      gray: field({ ... }),
      icons: group({
        title: 'Icons',
        description: 'Manage icons used in UI Pro.',
        icon: 'i-mdi-application-settings-outline',
        fields: {
          search: field({ ...}),
          dark: field({ ... }),
          light: field({ ... }),
          external: field({ ...}),
          chevron: field({ ... }),
          hash: field({ ... })
        }
      })
    }
  })
})
```
::

::tip{to="https://nuxt.com/docs/studio/debug"}
Take a look at this section to validate your schema in local development.
::

::tip{to="https://github.com/nuxt-ui-pro/docs/blob/main/nuxt.schema.ts"}
For a practical example, take a look at the schema we've developed for the UI Pro Docs starter.
::


# Local Debug

## Purpose

The goal of this section is to explain how to validate your customization in local before publishing on production.

It can help if:

- You want to create a `nuxt.schema.ts` file and [generate the appropriate interface](https://nuxt.com/docs/studio/config) on Studio.
- You want to integrate [custom Vue components](https://nuxt.com/docs/studio/content) and ensure edition is working as expected in the editor.

## Tutorial

::steps
### Import your project on Studio

### Clone your repository on local

### Enable Nuxt Content preview in development

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      // force module initialization on dev env
      dev: true
    }
  }
})
```

### Launch your app using your dev command with `--tunnel` to expose it to the internet

```bash [Terminal]
npx nuxt dev --tunnel
```

![local tunnel expose](https://nuxt.com/docs/studio/dev-tunnel.png)

### Ensure the metadata file has been generated

`__preview.json` file should accessible from `https://your-localtunnel-url/__preview.json`

### Copy the tunnel URL and copy it in the self-hosting section of the deployment tab on Studio platform
::

::tip
That's it! You should now be able to access Studio UI and confirm that your config interface has been successfully generated and your Vue components are available with their props and slots in the editor.
::

::warning
Any modification of your `nuxt.config.ts` file or any changes in a Vue file require a restart of the Nuxt dev server. Once the server has restarted you can synchronize the Studio interface by calling the `Sync meta` action from command menu `` `` . A refresh of the Studio app should also apply the update.
::


# Nuxt Content v3

Kiểm tra tiếng Việt
Chào mừng bạn đến với Nuxt Content v3, một bản nâng cấp lớn mang lại hiệu suất nâng cao và các tính năng sáng tạo cho các dự án Nuxt của bạn. Phiên bản mới nhất này của CMS dựa trên Git của chúng tôi được tối ưu hóa cho việc phát triển ứng dụng hiện đại.

## What's New?

### Content Collections

Bộ sưu tập tổ chức các mục liên quan trong dự án của bạn, giúp bạn quản lý các tập dữ liệu lớn hiệu quả hơn. Các lợi ích chính bao gồm:

- **Dữ liệu có cấu trúc**: Cấu hình kiến trúc cơ sở dữ liệu và định nghĩa bộ sưu tập trong [`content.config.ts`](https://nuxt.com/docs/collections/define#defining-collections)
- **Truy vấn an toàn kiểu**: Tích hợp TypeScript trực tiếp trên tất cả các tiện ích
- **Xác thực tự động**: Đảm bảo tính nhất quán dữ liệu trên các trường frontmatter và tệp dữ liệu (json, yml...)
- **Trình tạo truy vấn nâng cao**: Lọc, sắp xếp và phân trang bộ sưu tập của bạn một cách dễ dàng
- **Tích hợp Studio**: Tạo biểu mẫu nâng cao và trải nghiệm chỉnh sửa tối ưu thông qua [Studio](https://nuxt.com/studio)

Tìm hiểu thêm về [Content Collections](https://nuxt.com/docs/collections/define).

### Improved Performance

Một thách thức đáng kể trong v2 là kích thước gói lớn cần thiết để lưu trữ tệp, đặc biệt ảnh hưởng đến việc triển khai serverless.

V3 giải quyết vấn đề này bằng cách chuyển sang lưu trữ dựa trên SQL trong sản xuất. Chuyển đổi này không yêu cầu cấu hình, hỗ trợ chế độ phát triển, tạo tĩnh, lưu trữ máy chủ, triển khai serverless và edge.

::prose-note
Hệ thống cơ sở dữ liệu mới nâng cao cách lưu trữ và cấu trúc tệp dữ liệu của bạn, đảm bảo hiệu suất và khả năng mở rộng tốt hơn. Cập nhật này hoàn toàn diễn ra ở hậu trường và không ảnh hưởng đến các loại tệp bạn có thể sử dụng trong Content (`yml`, `json`, và `markdown` ).
::

Lợi ích bao gồm:

- **Truy vấn được tối ưu hóa**: Lưu trữ SQL cho phép truy xuất dữ liệu siêu nhanh
- **Tương thích phổ quát**: Hệ thống dựa trên adapter của chúng tôi tích hợp cơ sở dữ liệu SQL trên tất cả các chế độ triển khai ([server](https://nuxt.com/docs/deploy/server), [serverless](https://nuxt.com/docs/deploy/serverless) và [static](https://nuxt.com/docs/deploy/static)). Chúng tôi hoan nghênh đóng góp từ cộng đồng cho các adapter bổ sung.

### TypeScript Integration

Hệ thống bộ sưu tập mới cung cấp các kiểu TypeScript tự động cho tất cả dữ liệu của bạn. Mọi tiện ích và API đều được gõ mạnh dựa trên định nghĩa bộ sưu tập của bạn, đảm bảo an toàn kiểu mạnh mẽ trong suốt quá trình phát triển.

### Nuxt Studio Integration :badge[Soon]{color="neutral"}

[Nuxt Studio](https://nuxt.com/docs/studio/setup) và v3 được thiết kế để bổ sung cho nhau một cách hoàn hảo. [Mô-đun studio](https://github.com/nuxtlabs/studio-module){rel="nofollow"} giờ đây được tích hợp trực tiếp vào Nuxt Content, tạo ra một môi trường lý tưởng nơi các nhà phát triển có thể tập trung vào mã trong khi các thành viên nhóm quản lý nội dung thông qua giao diện trực quan.

---

Chúng tôi rất hào hứng để bạn khám phá các khả năng mới này. Hãy đi sâu vào tài liệu của chúng tôi để tìm hiểu thêm về việc tích hợp mô-đun và triển khai các phương pháp tốt nhất trong dự án tiếp theo của bạn.

## Content V2 Migration

Tìm hiểu cách di chuyển từ Content v2 sang v3 trong [hướng dẫn di chuyển](https://nuxt.com/docs/getting-started/migration).


# Installation

### Install the Package

Chọn trình quản lý gói ưa thích của bạn để cài đặt Nuxt Content v3:

::code-group
```bash [pnpm]
pnpm add @nuxt/content
```

```bash [yarn]
yarn add @nuxt/content
```

```bash [npm]
npm install @nuxt/content
```

```bash [bun]
bun add @nuxt/content
```
::

### Register the Module

Thêm mô-đun Nuxt Content vào `nuxt.config.ts` của bạn:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content']
})
```

### Automatic Setup

Khi bắt đầu một dự án Nuxt mới với CLI `create-nuxt`, bạn có thể đơn giản chọn `@nuxt/content` từ bộ chọn mô-đun tương tác. Điều này sẽ tự động cài đặt và đăng ký mô-đun cho bạn.

::code-group
```bash [npm]
npm create nuxt <project-name>
```

```bash [yarn]
yarn create nuxt <project-name>
```

```bash [pnpm]
pnpm create nuxt <project-name>
```

```bash [bun]
bun create nuxt <project-name>
```

```bash [deno]
deno -A npm:create-nuxt@latest <project-name>
```
::

::note{color="warning"}
Khi bạn chạy dự án của mình trong Node.js, Nuxt Content sẽ hỏi bạn về trình kết nối cơ sở dữ liệu để sử dụng.
Bạn có thể chọn cài đặt gói `better-sqlite3` hoặc `sqlite3`.

:br

Nếu bạn không muốn cài đặt bất kỳ gói nào, bạn có thể sử dụng SQLite gốc từ Node.js\@v22.5.0 hoặc mới hơn.
Kiểm tra [cấu hình `experimental.nativeSqlite`](https://nuxt.com/docs/getting-started/configuration#experimentalnativesqlite).
::

### Create your First Collection

Tạo tệp `content.config.ts` trong thư mục gốc dự án của bạn:

```ts [content.config.ts]
import { defineContentConfig, defineCollection } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    content: defineCollection({
      type: 'page',
      source: '**/*.md'
    })
  }
})
```

Cấu hình này tạo ra một bộ sưu tập `content` mặc định xử lý tất cả tệp Markdown nằm trong thư mục `content` của dự án của bạn. Bạn có thể tùy chỉnh cài đặt bộ sưu tập dựa trên nhu cầu của mình.

::tip
Loại `type: page` có nghĩa là có mối quan hệ 1-1 giữa tệp nội dung và các trang trên trang web của bạn.
::

::note{to="https://nuxt.com/docs/collections/define"}
Tìm hiểu thêm trong **hướng dẫn Bộ sưu tập** của chúng tôi.
::

### Create your First Markdown Page

Tạo tệp `content/index.md` trong thư mục gốc dự án của bạn:

```md [content/index.md]
# My First Page

Here is some content.
```

Đọc thêm về viết [trang Markdown](https://nuxt.com/docs/files/markdown).

### Display your Page

Tạo tệp `pages/index.vue` và hiển thị nội dung trang:

```vue [pages/index.vue]
<script setup lang="ts">
const { data: home } = await useAsyncData(() => queryCollection('content').path('/').first())

useSeoMeta({
  title: home.value?.title,
  description: home.value?.description
})
</script>

<template>
  <ContentRenderer v-if="home" :value="home" />
  <div v-else>Home not found</div>
</template>
```

::note{icon="i-lucide-info"}
Nếu bạn đang cài đặt Nuxt Content trong một dự án Nuxt mới và bạn không có thư mục `pages`, bạn cũng cần cập nhật tệp `app.vue` để cho phép hiển thị các trang bằng cách thêm thành phần `NuxtPage`. (Nếu bạn đã có một số trang trong dự án của mình, bạn đã sẵn sàng.)

```vue [app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```
::

::tip{icon="i-lucide-rocket"}
Đó là nó! Bạn đã tạo trang Nuxt Content đầu tiên của mình.
::


# Configuration

Để cấu hình mô-đun nội dung và tùy chỉnh hành vi của nó, bạn có thể sử dụng thuộc tính `content` trong `nuxt.config` của bạn:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    // Options
  }
})
```

::note{to="https://github.com/nuxt-modules/mdc#configurations"}
Ngoài việc cấu hình qua `content.markdown`, bạn có thể sử dụng Markdown Components (MDC) để tùy chỉnh việc hiển thị các phần tử Markdown với thuộc tính `mdc`.
::

## `build`

Nuxt Content đọc và phân tích tất cả nội dung có sẵn tại thời điểm xây dựng. Tùy chọn này cho bạn quyền kiểm soát việc phân tích nội dung.

### `markdown`

Cấu hình trình phân tích markdown.

#### `toc`

::code-group
```ts [Default]
toc: {
  depth: 2,
  searchDepth: 2
}
```

```ts [Signature]
type Toc = {
  depth: number
  searchDepth: number
}
```
::

Kiểm soát hành vi tạo Mục lục.

Giá trị:

- `depth`: Độ sâu tiêu đề tối đa để bao gồm trong mục lục.
- `searchDepth`: Độ sâu tối đa của các thẻ lồng nhau để tìm tiêu đề.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        toc: {
          depth: 3, // include h3 headings
        }
      }
    }
  }
})
```

#### `remarkPlugins`

::code-group
```ts [Default]
remarkPlugins: {}
```

```ts [Signature]
type RemarkPlugins = Record<string, false | MarkdownPlugin>
```
::

Danh sách các plugin [remark](https://github.com/remarkjs/remark){rel="nofollow"} để sử dụng.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        // Object syntax can be used to override default options
        remarkPlugins: {
          // Override remark-emoji options
          'remark-emoji': {
            options: {
              emoticon: true
            }
          },
          // Disable remark-gfm
          'remark-gfm': false,
          // Add remark-oembed
          'remark-oembed': {
            // Options
          }
        },
      }
    }
  }
})
```

#### `rehypePlugins`

::code-group
```ts [Default]
rehypePlugins: {}
```

```ts [Signature]
type RehypePlugins = object
```
::

Danh sách các plugin [rehype](https://github.com/remarkjs/remark-rehype){rel="nofollow"} để sử dụng.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        // Object syntax can be used to override default options
        rehypePlugins: {
          'rehype-figure': {

          }
        },
      }
    }
  }
})
```

#### `highlight`

::code-group
```ts [Default]
highlight: false
```

```ts [Signature]
type Highlight = false | object
```
::

Nuxt Content sử dụng [Shiki](https://github.com/shikijs/shiki){rel="nofollow"} để cung cấp tô sáng cú pháp cho [`ProsePre`](https://nuxt.com/docs/components/prose#prosepre) và [`ProseCode`](https://nuxt.com/docs/components/prose#prosecode).

| Tùy chọn | Loại                                           | Mô tả                                                                                                                  |
| -------- | ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| `theme`  | `ShikiTheme` hoặc `Record<string, ShikiTheme>` | [Chủ đề màu](https://github.com/shikijs/shiki/blob/main/docs/themes.md){rel="nofollow"} để sử dụng.                    |
| `langs`  | `ShikiLang[]`                                  | Các [ngôn ngữ đã tải](https://github.com/shikijs/shiki/blob/main/docs/languages.md){rel="nofollow"} có sẵn để tô sáng. |

- `highlight.theme`

Chủ đề có thể được chỉ định bằng một chuỗi đơn nhưng cũng hỗ trợ một đối tượng với nhiều chủ đề.

Tùy chọn này tương thích với [mô-đun Color Mode](https://color-mode.nuxtjs.org/){rel="nofollow"}.

Nếu bạn đang sử dụng nhiều chủ đề, bạn nên luôn có một chủ đề `default` được chỉ định.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          // Theme used in all color schemes.
          theme: 'github-light',
          // OR
          theme: {
            // Default theme (same as single string)
            default: 'github-light',
            // Theme used if `html.dark`
            dark: 'github-dark',
            // Theme used if `html.sepia`
            sepia: 'monokai'
          }
        }
      }
    }
  }
})
```

- `highlight.langs`

Theo mặc định, mô-đun tải một số ngôn ngữ để tô sáng cú pháp:

```ts [Default]
['json', 'js', 'ts', 'html', 'css', 'vue', 'shell', 'mdc', 'md', 'yaml']
```

Nếu bạn dự định sử dụng mẫu mã của các ngôn ngữ khác, bạn cần định nghĩa ngôn ngữ trong các tùy chọn này.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          langs: [
            'c',
            'cpp',
            'java'
          ]
        }
      }
    }
  }
})
```

Nếu bạn muốn thêm tô sáng cho một ngôn ngữ không được hỗ trợ, bạn có thể làm như vậy bằng cách tải tệp ngữ pháp cho ngôn ngữ đó.

```ts [nuxt.config.ts]
import { readFileSync } from 'node:fs'

export default defineNuxtConfig({
  content: {
    build: {
      markdown: {
        highlight: {
          langs: [
            // Read more about Shiki languages: https://shiki.style/guide/load-lang
            JSON.parse(
              readFileSync('./shiki/languages/gdscript.tmLanguage.json', 'utf-8'),
            ),
          ]
        }
      }
    }
  }
})
```

Đọc thêm về việc thêm ngôn ngữ trong [tài liệu Shiki](https://github.com/shikijs/shiki/blob/main/docs/languages.md#adding-grammar){rel="nofollow"}.

### `pathMeta`

Mô-đun nội dung sử dụng đường dẫn tệp để tạo slug, tiêu đề mặc định và thứ tự nội dung, bạn có thể tùy chỉnh hành vi này với tùy chọn `pathMeta`.

#### `pathMeta.forceLeadingSlash`

Nếu đặt thành `true`, đường dẫn sẽ được thêm tiền tố với dấu gạch chéo dẫn đầu. Giá trị mặc định là `true`.

#### `pathMeta.slugifyOptions`

Mô-đun nội dung sử dụng [slugify](https://github.com/simov/slugify){rel="nofollow"} để tạo slug, bạn có thể tùy chỉnh hành vi của slugify với tùy chọn này.

Kiểm tra [tùy chọn slugify](https://github.com/simov/slugify#options){rel="nofollow"} để biết thêm thông tin.

### `transformers`

Nuxt Content có các trình biến đổi cụ thể cho từng loại nội dung để phân tích nội dung thô và chuẩn bị cho truy vấn và hiển thị. Sử dụng tùy chọn này, bạn có thể định nghĩa các trình biến đổi tùy chỉnh để hỗ trợ các loại nội dung mới hoặc cải thiện chức năng của các loại được hỗ trợ.

::code-group
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~/transformers/title-suffix',
      ],
    },
  },
})
```

```ts [~/transformers/title-suffix.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'title-suffix',
  extensions: ['.md'],
  transform(file) {
    return {
      ...file,
      title: file.title + ' (suffix)',
    }
  },
})
```
::

Đọc thêm về trình biến đổi trong tài liệu [Transformers](https://nuxt.com/docs/advanced/transformers).

## `database`

Theo mặc định, Nuxt Content sử dụng cơ sở dữ liệu SQLite cục bộ để lưu trữ và truy vấn nội dung. Nếu bạn muốn sử dụng cơ sở dữ liệu khác hoặc bạn dự định triển khai trên Cloudflare Workers, bạn có thể sửa đổi tùy chọn này.

Đây là danh sách các adapter cơ sở dữ liệu được hỗ trợ:

### `SQLite`

Nếu bạn muốn thay đổi vị trí cơ sở dữ liệu mặc định và di chuyển đến nơi khác, bạn có thể sử dụng adapter `sqlite` để làm như vậy. Đây là giá trị mặc định cho tùy chọn `database`. Tùy thuộc vào môi trường thời gian chạy, các adapter sqlite khác nhau sẽ được sử dụng (Node: better-sqlite-3, Bun: bun\:sqlite).

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'sqlite',
      filename: 'SQLITE_DB_LOCATION'
    }
  }
})
```

### `D1`

Nếu bạn dự định triển khai ứng dụng của mình lên Cloudflare workers, bạn cần sử dụng adapter cơ sở dữ liệu `d1`. Tạo một ràng buộc `d1` trong bảng điều khiển Cloudflare và điền vào trường `bindingName`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'd1',
      bindingName: 'CF_BINDING_NAME'
    }
  }
})
```

### `Postgres`

Nếu bạn dự định triển khai ứng dụng của mình bằng cơ sở dữ liệu PostgreSQL, bạn cần sử dụng adapter cơ sở dữ liệu `postgres`.

Đầu tiên, đảm bảo cài đặt gói `pg`:

```bash [Terminal]
npx npm i pg
```

Sau đó, cấu hình adapter `postgres` trong `nuxt.config.ts` của bạn:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'postgres',
      url: process.env.POSTGRES_URL,
      /* Other options for `pg` */
    }
  }
})
```

### `LibSQL`

Nếu bạn dự định triển khai ứng dụng của mình bằng cơ sở dữ liệu LibSQL, bạn cần sử dụng adapter cơ sở dữ liệu `libsql`.

Đầu tiên, đảm bảo cài đặt gói `@libsql/client`:

```bash [Terminal]
npx npm i @libsql/client
```

Sau đó, cấu hình adapter `libsql` trong `nuxt.config.ts` của bạn:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    database: {
      type: 'libsql',
      url: process.env.TURSO_DATABASE_URL,
      authToken: process.env.TURSO_AUTH_TOKEN,
    }
  }
})
```

::note
Dịch vụ lưu trữ LibSQL phổ biến nhất là [Turso](https://turso.tech/){rel="nofollow"}.
::

## `renderer`

Cấu hình trình hiển thị nội dung.

### `anchorLinks`

::code-group
```ts [Default]
{ h2: true, h3: true, h4: true }
```

```ts [Signature]
type AnchorLinks = boolean | Record<'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6', boolean>
```
::

Kiểm soát tạo liên kết neo, theo mặc định nó tạo liên kết neo cho tiêu đề `h2`, `h3` và `h4`

Giá trị:

- `false`: sẽ tắt tạo liên kết.
- `true`: sẽ bật tạo liên kết cho tất cả tiêu đề.

### `alias`

::code-group
```ts [Default]
alias: {}
```

```ts [Signature]
type Alias = Record<string, string>
```
::

Bí danh sẽ được sử dụng để thay thế các thành phần markdown và hiển thị các thành phần tùy chỉnh thay vì các thành phần mặc định.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    renderer: {
      alias: {
        p: 'MyCustomParagraph'
      }
    }
  }
})
```

## `watch`

```ts [Default]
watch: {
  enabled: true,
  port: 4000,
  showURL: false
}
```

Cấu hình tải lại nóng nội dung trong quá trình phát triển.

Giá trị:

- `enabled`: Bật/Tắt tải lại nóng.
- `port`: Chọn cổng được sử dụng cho máy chủ WebSocket.
- `showURL`: Chuyển đổi hiển thị URL trong thông báo khởi động máy chủ dev.

Nuxt Content sử dụng [listhen](https://github.com/unjs/listhen){rel="nofollow"} để cung cấp máy chủ phát triển cục bộ. Kiểm tra [tài liệu listhen](https://github.com/unjs/listhen#options){rel="nofollow"} để biết thêm thông tin.

::callout
Trình theo dõi là một tính năng phát triển và sẽ không được bao gồm trong sản xuất.
::

::code-group
```ts [Enabled]
export default defineNuxtConfig({
  content: {
    watch: {
      port: 4000,
      showURL: true
    }
  }
})
```

```ts [Disabled]
export default defineNuxtConfig({
  content: {
    watch: {
      enabled: false
    }
  }
})
```
::

## `preview`

Bật `Preview API`

::prose-note
Điều này cần thiết để bật xem trước trực tiếp trên [Nuxt Studio](https://nuxt.com/studio).
::

Giá trị:

- `dev`: Bật trong chế độ phát triển
- `api`: Kích hoạt chế độ xem trước và đặt `API` để liên kết với.

```ts [Enable Studio]
preview: {
  api: 'https://api.nuxt.studio',
}
```

## `experimental`

Các tính năng thử nghiệm chưa ổn định.

### `experimental.sqliteConnector`

Các trình kết nối SQLite có hạn chế trong các môi trường khác nhau. Một số hoạt động trong môi trường serverless, trong khi những cái khác thì không. Nuxt Content hỗ trợ ba trình kết nối SQLite khác nhau để bao phủ tất cả môi trường:

- `better-sqlite3`: Hoạt động trong tất cả môi trường Node, GitHub CI, Vercel CI và sản xuất, đường ống CI Cloudflare, v.v. (Không hoạt động trong WebContainers và StackBlitz)
- `sqlite3`: Hoạt động trong môi trường Node, GitHub CI và StackBlitz. (Không hoạt động trong Vercel hoặc Cloudflare)
- `native`: Kể từ Node.js v22.5.0, mô-đun `node:sqlite` có sẵn nguyên bản trong Node.js. Trình kết nối này hoạt động trong tất cả môi trường Node với phiên bản Node.js 22.5.0 hoặc mới hơn.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    experimental: { sqliteConnector: 'native' },
  },
});
```

### `experimental.nativeSqlite` (deprecated, use `sqliteConnector`)

Kể từ Node.js v22.5.0, mô-đun `node:sqlite` có sẵn nguyên bản trong Node.js.
Điều này cho phép Nuxt Content sử dụng SQLite làm cơ sở dữ liệu mà không cần gói bên ngoài.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    experimental: { nativeSqlite: true },
  },
});
```

::prose-note
Tính năng này chỉ có sẵn trong Node.js v22.5.0 trở lên. Bật tính năng này trong phiên bản cũ hơn sẽ không làm gì.
::


# Migration

Nuxt Content v3 đã được xây dựng lại từ đầu, dẫn đến một thư viện mới với khả năng nâng cao. Mặc dù chúng tôi đã thiết kế lại các khái niệm và thành phần tương tự như Content v2, nhưng những thay đổi đột phá là không thể tránh khỏi.

Đừng lo lắng, bạn không cần sửa đổi các tệp nội dung của mình. Chúng tôi đảm bảo rằng Content v3 xử lý nội dung theo cùng cách như Content v2.

## Changes

### Vue utils

- `queryContent()` API được thay thế bằng `queryCollection()` mới

::prose-tip
API mới được hỗ trợ bởi SQL và các truy vấn nội dung xảy ra trong một bộ sưu tập cụ thể.
::

- `fetchContentNavigation()` API được thay thế bằng `queryCollectionNavigation()` mới
- Surroundings hiện có API riêng biệt `queryCollectionItemSurroundings()`
- Chế độ Document driven bị loại bỏ: Các tệp `Markdown` sẽ không chuyển đổi thành các trang Nuxt tự động, bạn cần tạo các trang, [check this section to see how](https://nuxt.com/docs/components/content-renderer#example-usage).
- Composable `useContent()` bị loại bỏ
- `searchContent()` bị loại bỏ để ủng hộ API `queryCollectionSearchSections` mới
- Tìm kiếm toàn văn có thể dễ dàng thực hiện bằng API `queryCollectionSearchSections`, [check this section to see how](https://nuxt.com/docs/advanced/fulltext-search)

### Components

- Tất cả nội dung nên được hiển thị bằng thành phần `<ContentRenderer>`. Các thành phần `<ContentDoc>`, `<ContentList>`, `<ContentNavigation>` và `<ContentQuery>` bị loại bỏ trong v3.
- Các thành phần `<ContentSlot>` và `<MDCSlot>` không được hỗ trợ trong v3. Thay vào đó, các thành phần có thể sử dụng thành phần `<slot>` gốc của Vue

::prose-note
`<ContentSlot>` và `<MDCSlot>` ban đầu được sử dụng để thao tác nội dung trước khi hiển thị và loại bỏ các đoạn văn bao bọc từ nội dung slot. Hành vi bỏ bọc này hiện được hỗ trợ qua thuộc tính `mdc-unwrap` trong thành phần `<slot>`. Ví dụ: `<slot mdc-unwrap="p" />`
::

- Các thành phần được tạo dưới thư mục `components/content` không còn được đăng ký tự động làm thành phần toàn cục. Nếu bạn sử dụng [dynamic rendering](https://vuejs.org/guide/essentials/component-basics.html#dynamic-components){rel="nofollow"} để hiển thị các thành phần này bên ngoài tệp markdown, bạn phải đăng ký chúng thủ công trong ứng dụng Nuxt. Kiểm tra tài liệu [Nuxt - Custom Components Directories](https://nuxt.com/docs/guide/directory-structure/components#custom-directories){rel="nofollow"} để biết thêm thông tin về cách thực hiện.

### Types

- `import type { NavItem } from '@nuxt/content/dist/runtime/types'` được thay thế bằng `import type { ContentNavigationItem } from '@nuxt/content'`

### General

- Các tệp `_dir.yml` được đổi tên thành `.navigation.yml`
- Không có tùy chọn nguồn trong tùy chọn module, thay vào đó bạn có thể định nghĩa [multiple sources](https://nuxt.com/docs/collections/sources) cho các bộ sưu tập của bạn trong `content.config.ts`.
- Tài liệu `._path` hiện được đổi tên thành `.path`, tương tự như vậy tất cả các trường nội bộ với tiền tố `_` bị loại bỏ hoặc đổi tên.
- `useContentHelpers()` bị loại bỏ
- Module không bỏ qua các tệp dot theo mặc định, bạn có thể bỏ qua chúng bằng cách thêm `ignore: ['**/.*']` trong tùy chọn `exclude` của nguồn bộ sưu tập.
- Do hạn chế SQL, thứ tự sắp xếp hiện sử dụng thứ tự bảng chữ cái thay vì thứ tự số. Kiểm tra phần [Ordering Files](https://nuxt.com/docs/collections/types#ordering-files) để biết thêm thông tin.
- Tùy chọn module đã thay đổi từ v2. Kiểm tra [configuration page](https://nuxt.com/docs/getting-started/configuration) để biết chi tiết.

### Nuxt Studio integration

- [studio module](https://nuxt.studio){rel="nofollow"} đã bị deprecated và một `Preview API` chung mới đã được triển khai trực tiếp vào Nuxt Content, bạn có thể loại bỏ gói `@nuxthq/studio` khỏi dependencies và khỏi modules của `nuxt.config.ts`. Thay vào đó, chúng ta chỉ cần kích hoạt chế độ preview trong tệp cấu hình Nuxt bằng cách ràng buộc API Studio.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  },
})
```

- Để giữ [app config file](https://nuxt.com/docs/studio/config) có thể cập nhật từ Studio, chúng ta chỉ cần cập nhật import helper của tệp `nuxt.schema.ts` từ `@nuxthq/studio/theme` thành `@nuxt/content/preview`.

## Implement Document Driven mode in v3

Triển khai chế độ Document driven trong Content v3 khá dễ dàng. Tất cả những gì bạn cần là tạo một trang catch-all trong Nuxt và lấy nội dung dựa trên đường dẫn route.

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('content').path(route.path).first()
})
</script>

<template>
  <div>
    <header><!-- ... --></header>

    <ContentRenderer v-if="page" :value="page" />

    <footer><!-- ... --></footer>
  </div>
</template>
```

## Converting `queryContent` to `queryCollections`

Như chúng tôi đã đề cập ở trên, `queryContent` bị loại bỏ để ủng hộ `queryCollection` dựa trên bộ sưu tập mới. Có hai sự khác biệt chính giữa hai cái này:

1. `queryCollection` đang xây dựng một truy vấn cho cơ sở dữ liệu SQL.
2. `queryCollection` chỉ thực hiện tìm kiếm bên trong bộ sưu tập được chỉ định. Bạn nên biết tên bộ sưu tập (khóa trên config).

```ts [Find content with path]
// Content v2
const v2Query = await queryContent(route.path).findOne()
// Content v3 - don't forget to create `content` collection in `content.config.ts`
const v3Query = await queryCollection('content').path(route.path).first()
```

```ts [Find contents with custom filter]
// Content v2
const v2Query = await queryContent()
  .where({ path: /^\/hello\/.*/ })
  .find()
// Content v3 - don't forget to create `content` collection in `content.config.ts`
const v3Query = await queryCollection('content')
  .where('path', 'LIKE', '/hello%')
  .first()
```

::prose-note{to="https://nuxt.com/docs/collections/define"}
Kiểm tra phần chuyên dụng để biết thêm thông tin về các bộ sưu tập
::

## Convert `queryContent().findSurround()`

Surround hiện có API riêng biệt.

```ts
const targetPath = '/docs'

// Content v2
const v2Surround = await queryContent(targetPath)
  .only(['title', 'description', 'navigation'])
  .findSurround(withoutTrailingSlash(route.path))

// Content v3 - don't forget to create `content` collection in `content.config.ts`
const v3Surround = await queryCollectionItemSurroundings(
  'content',
  targetPath,
  {
    fields: ['title', 'description', 'navigation']
  }
)
```

::prose-note
Kiểm tra phần chuyên dụng để biết thêm thông tin về
::

## Consolidate `ProsePre`, `ProseCode`, and `ProseCodeInline` components

Nhiều thành phần `ProsePre` là các wrapper mỏng xung quanh thành phần `ProseCode`. Chúng tôi đã hợp nhất ba thành phần này thành hai thành phần. Hiện không có sự khác biệt giữa `ProsePre` và các khối mã đa dòng.

1. MDC sẽ ánh xạ và phân tích cú pháp backticks đơn `` ` `` như `ProseCode` thay vì `ProseCodeInline`.
2. MDC sẽ ánh xạ và phân tích cú pháp khối mã bắt đầu bằng ba backticks ` ``` ` như thành phần `ProsePre`.

**Suggested Changes:**

1. Logic `ProseCode` hiện tại của bạn nên được chuyển sang `ProsePre`
2. Đổi tên các thành phần `ProseCodeInline` của bạn thành `ProseCode`

## `_dir.yml` files are renamed to `.navigation.yml`

Trong Content v3, chúng tôi đã đổi tên `_dir.yml` thành `.navigation.yml`. Tên mới phản ánh tốt hơn mục đích của các tệp này. :br
Module sử dụng các tệp này để thu thập thông tin về các thư mục để tạo điều hướng.

Lưu ý rằng để làm cho các tệp này có sẵn cho Module, bạn nên định nghĩa nguồn bộ sưu tập của mình theo cách bao gồm các tệp này. Ví dụ `source: '**'` và `source: '**/*.{md|yml}` sẽ bao gồm các tệp này trong bộ sưu tập, nhưng `source: '**/*.md'` sẽ không bao gồm chúng.

## Ignore dot files

Theo mặc định, Content v3 không bỏ qua các tệp dot. Nếu bạn muốn bỏ qua chúng, bạn có thể thêm `ignore: ['**/.*']` trong tùy chọn `exclude` của nguồn bộ sưu tập.

```ts
defineCollection({
  source: {
    include: '**',
    exclude: ['**/.*']
  }
})
```

Lưu ý rằng mẫu ở trên cũng sẽ loại trừ tệp `.navigation.yml` khỏi bộ sưu tập. Nếu bạn sử dụng `.navigation.yml` và muốn giữ chúng, bạn có thể sử dụng mẫu `**/.(!(navigation.yml))` để loại trừ tất cả tệp dot ngoại trừ `.navigation.yml`.

```ts
defineCollection({
  source: {
    include: '**',
    exclude: ['**/.!(navigation.yml)']
  }
})
```


# Define Content Collections

Module Nuxt Content tự động phân tích bất kỳ tệp nội dung nào trong thư mục `content/` nằm ở gốc của ứng dụng Nuxt của bạn. Thiết lập này cho phép bạn tự do cấu trúc thư mục để phù hợp với nhu cầu của dự án.

Để tổ chức tốt hơn, hãy cân nhắc sử dụng Content Collections, cho phép bạn phân loại và quản lý nội dung hiệu quả hơn. Các bộ sưu tập này được định nghĩa trong tệp `content.config.ts`.

::warning
Nếu không có tệp `content.config.ts`, tất cả tệp trong thư mục content sẽ được phân tích và nhập theo mặc định. Tuy nhiên, một khi tệp cấu hình được thêm vào, chỉ những tệp khớp với các mẫu đường dẫn được chỉ định trong bộ sưu tập mới được nhập.
::

## What are Content Collections?

Content Collections tổ chức các mục liên quan trong dự án Nuxt Content của bạn. Chúng cung cấp cách có cấu trúc để quản lý nội dung của bạn, giúp dễ dàng truy vấn, hiển thị và duy trì dữ liệu trang web của bạn.

Các tính năng chính bao gồm:

- **Nhóm logic**: Nhóm nội dung tương tự lại với nhau, chẳng hạn như bài đăng blog, trang sản phẩm hoặc bài viết tài liệu
- **Cấu hình chia sẻ**: Áp dụng cài đặt và xác thực chung trên tất cả mục trong bộ sưu tập
- **Truy vấn cải thiện**: Lấy và lọc các mục nội dung liên quan hiệu quả
- **Suy luận loại tự động**: Nhận an toàn loại và tự động hoàn thành trong môi trường phát triển của bạn
- **Cấu trúc linh hoạt**: Tổ chức bộ sưu tập theo loại nội dung, danh mục hoặc bất kỳ nhóm logic nào phù hợp với nhu cầu của bạn

## Defining Collections

Tạo tệp `content.config.ts` trong thư mục gốc của dự án. Tệp đặc biệt này cấu hình cơ sở dữ liệu bộ sưu tập, loại tiện ích và xử lý nội dung của bạn.

Đây là ví dụ cơ bản:

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      // Specify the type of content in this collection
      type: 'page',
      // Load every file inside the `content` directory
      source: '**',
    })
  }
})
```

::warning
Hiện tại, một tài liệu được thiết kế để có mặt trong chỉ một bộ sưu tập tại một thời điểm. Nếu một tệp được tham chiếu trong nhiều bộ sưu tập, tải lại trực tiếp sẽ không hoạt động chính xác. Để tránh điều này, bạn nên sử dụng thuộc tính `exclude` để loại trừ rõ ràng một tài liệu khỏi các bộ sưu tập khác bằng cách sử dụng các mẫu regex thích hợp.

Chủ đề này vẫn đang được thảo luận trong vấn đề này: [nuxt/content#2966](https://github.com/nuxt/content/issues/2966){rel="nofollow"}.
::

### Collection Schema

Schemas thực thi tính nhất quán dữ liệu trong bộ sưu tập và phục vụ như nguồn chân lý cho các loại TypeScript.

Ngoài các trường tích hợp, bạn có thể định nghĩa schema bằng cách thêm thuộc tính `schema` vào bộ sưu tập của bạn bằng cách sử dụng schema [`zod`](https://zod.dev){rel="nofollow"}:

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      // Define custom schema for docs collection
      schema: z.object({
        tags: z.array(z.string()),
        image: z.string(),
        date: z.date()
      })
    })
  }
})
```

::note
`@nuxt/content` hiển thị một đối tượng `z` chứa một tập hợp các schema Zod cho các loại dữ liệu phổ biến. Kiểm tra [README của Zod](https://github.com/colinhacks/zod){rel="nofollow"} để biết tài liệu hoàn chỉnh về cách Zod hoạt động và các tính năng có sẵn.
::

::tip
Bạn có thể định nghĩa bao nhiêu bộ sưu tập tùy ý để tổ chức các loại nội dung khác nhau.
::

## Querying Collections

Sử dụng tiện ích [`queryCollection`](https://nuxt.com/docs/utils/query-collection) để lấy một hoặc tất cả mục từ bộ sưu tập:

```vue [pages/blog.vue]
<script setup lang="ts">
const { data: posts } = await useAsyncData('blog', () => queryCollection('blog').all())
</script>

<template>
  <div>
    <h1>Blog</h1>
    <ul>
      <li v-for="post in posts" :key="post.id">
        <NuxtLink :to="post.path">{{ post.title }}</NuxtLink>
      </li>
    </ul>
  </div>
</template>
```

::note{to="https://nuxt.com/docs/utils/query-collection"}
Tìm hiểu thêm về các tùy chọn truy vấn có sẵn trong tài liệu API `queryCollections` của chúng tôi.
::

## defineCollection()

Hàm `defineCollection` định nghĩa một bộ sưu tập trong cấu hình nội dung của bạn. Đây là chữ ký TypeScript của nó:

```ts
function defineCollection(collection: Collection): DefinedCollection

type Collection = {
  // Determines how content is processed
  type: 'page' | 'data'
  // Specifies content location
  source?: string | CollectionSource
  // Zod schema for content validation and typing
  schema?: ZodObject<T>
}
```

::note{to="https://nuxt.com/docs/collections/types"}
Tìm hiểu thêm về các loại bộ sưu tập.
::

```ts
type CollectionSource = {
  // Glob pattern for content matching
  include: string
  // .path prefix (only applies to 'page' type)
  prefix?: string
  // Glob patterns to exclude content
  exclude?: string[]
  // Root directory for content matching
  cwd?: string
  // Remote git repository URL (e.g., https://github.com/nuxt/content)
  repository?: string
  // Authentication token for private repositories (e.g., GitHub personal access token)
  authToken?: string
}
```

::note{to="https://nuxt.com/docs/collections/sources"}
Tìm hiểu thêm về các nguồn bộ sưu tập.
::

Hàm trả về đối tượng bộ sưu tập đã định nghĩa.


# Collection Types

Trong Nuxt Content, bạn có thể chỉ định một loại cho mỗi bộ sưu tập, tùy thuộc vào mục đích dự định của các tệp bộ sưu tập. Bộ sưu tập có thể được định nghĩa là loại **page** hoặc **data**.

Đối với cả hai loại, các trường tích hợp được tạo. Mọi bộ sưu tập bao gồm các trường mặc định này:

- `id`: Mã định danh nội dung duy nhất
- `stem`: Đường dẫn tệp không có phần mở rộng (được sử dụng để sắp xếp và vị trí)
- `extension`: Phần mở rộng tệp
- `meta`: Các trường tùy chỉnh không được định nghĩa trong schema bộ sưu tập

## Page type

```ts
defineCollection({
  source: '**/*.md',
  type: 'page'
})
```

::tip
Sử dụng loại **page** nếu có mối quan hệ 1-đến-1 giữa các tệp nội dung và các trang trên trang web của bạn.
::

### Path generation

Nuxt Content sẽ tự động tạo một đường dẫn cho mỗi tệp trong bộ sưu tập, giúp dễ dàng tạo ánh xạ URL.

Đây là các ví dụ về đường dẫn được tạo dựa trên cấu trúc tệp:

|                                  |                       |
| -------------------------------- | --------------------- |
|                                  |                       |
| File                             | Path                  |
| `content/index.md`               | `/`                   |
| `content/about.md`               | `/about`              |
| `content/blog/index.md`          | `/blog`               |
| `content/blog/hello.md`          | `/blog/hello`         |
| `content/1.guide/2.installation` | `/guide/installation` |

::note
Bạn có thể sử dụng helper [`queryCollection('COLLECTION').path('PATH')`](https://nuxt.com/docs/utils/query-collection) để truy xuất nội dung theo một đường dẫn cụ thể.
::

### Schema Overrides

Khi bạn sử dụng loại **page**, Nuxt Content tạo ra một số trường tiêu chuẩn thường được sử dụng cho các trang web. Các trường này cung cấp cấu trúc và được **tự động** áp dụng cho schema của bộ sưu tập:

- `path`: Đường dẫn route được tạo
- `title`: Tiêu đề trang
- `description`: Mô tả trang
- `seo`: Metadata SEO (để sử dụng với composable `useSeoMeta` của Nuxt)
- `body`: Nội dung trang được phân tích như AST
- `navigation`: Cấu hình điều hướng trang (cho [queryCollectionNavigation](https://nuxt.com/docs/utils/query-collection-navigation))

Đây là schema tương ứng được áp dụng:

```ts
  path: z.string(),
  title: z.string(),
  description: z.string(),
  seo: z.intersection(
    z.object({
      title: z.string().optional(),
      description: z.string().optional(),
      meta: z.array(z.record(z.string(), z.any())).optional(),
      link: z.array(z.record(z.string(), z.any())).optional(),
    }),
    z.record(z.string(), z.any()),
  ).optional().default({}),
  body: z.object({
    type: z.string(),
    children: z.any(),
    toc: z.any(),
  }),
  navigation: z.union([
    z.boolean(),
    z.object({
      title: z.string(),
      description: z.string(),
      icon: z.string(),
    }),
  ]).default(true),
```

::note
Bạn có thể ghi đè bất kỳ trường nào trong số này bằng cách định nghĩa chúng trong schema của bộ sưu tập.
::

## Data type

```ts
defineCollection({
  source: 'authors/**.yml',
  type: 'data'
})
```

Loại data hữu ích cho nội dung không trực tiếp tương ứng với một trang web mà thay vào đó đại diện cho dữ liệu có cấu trúc bạn có thể muốn truy vấn và hiển thị trong ứng dụng của mình.

Với bộ sưu tập data, bạn có toàn quyền kiểm soát schema, cho phép bạn định nghĩa cấu trúc tùy chỉnh.

::note
Không có mối quan hệ chặt chẽ giữa loại bộ sưu tập và phần mở rộng tệp. Ví dụ, bộ sưu tập **page** có thể sử dụng tệp [Markdown](https://nuxt.com/docs/files/markdown) hoặc [YAML](https://nuxt.com/docs/files/yaml) hoặc [JSON](https://nuxt.com/docs/files/json), và bộ sưu tập **data** cũng có thể sử dụng bất kỳ định dạng nào trong số này.
::

## Ordering Files

Đối với cả hai loại, bạn có thể muốn kiểm soát thứ tự hiển thị trong danh sách. Sử dụng tiền tố số trong tên tệp và thư mục để chỉ định thứ tự. Nuxt Content sẽ sử dụng các số này khi sắp xếp danh sách nội dung.

::note
Nuxt Content sử dụng thứ tự bảng chữ cái để sắp xếp, vì vậy nếu bạn muốn sử dụng thứ tự số, bạn cần thêm tiền tố `0` cho các số có một chữ số. Ví dụ, không có tiền tố `0`, `10.foo.md` sẽ đến trước `2.bar.md`.
::

```text [Directory structure]
content/
  1.frameworks/
    1.vue.md
    2.nuxt.md
    ...
  2.examples/
    01.nuxthub.md
    02.vercel.md
    03.netlify.md
    04.heroku.md
    ...
    10.cloudflare.md
    index.md
```

::warning
Tách số khỏi tên tệp bằng ký tự `.`. Sử dụng bất kỳ dấu phân cách nào khác sẽ không hoạt động.
::


# Collection Sources

Nuxt Content cung cấp một số cách để nhập tệp nội dung vào bộ sưu tập của bạn. Bạn có thể cấu hình nguồn bằng cách sử dụng thuộc tính `source` trong `defineCollection`:

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      source: '**',
      type: 'page'
    })
  }
})
```

## `source`

Thuộc tính `source` có thể được định nghĩa là một chuỗi (theo mẫu glob) hoặc một đối tượng, cho phép cấu hình nguồn chi tiết hơn cho thư mục đích và tệp trong thư mục content.

**Ví dụ:**

- `source: '**'` bao gồm tất cả tệp trong thư mục content và các thư mục con của nó.
- `source: '**/*.md'` bao gồm tất cả tệp `Markdown` trong thư mục content và các thư mục con của nó.
- `source: 'docs/**/*.yml'` bao gồm tất cả tệp `YML` trong `content/docs` và các thư mục con của nó.
- `source: '**/*.{json,yml}'` bao gồm tệp `JSON` hoặc `YML` trong thư mục content và tất cả thư mục con của nó.
- `source: '*.json'` bao gồm chỉ tệp `JSON` nằm trực tiếp trong thư mục content, loại trừ bất kỳ thư mục con nào.

### `include` (bắt buộc)

Mẫu glob của kho lưu trữ đích và tệp trong thư mục content.

### `exclude`

Mẫu glob để loại trừ nội dung khỏi việc nhập.

### `prefix`

Cấu hình này chỉ áp dụng cho loại **page** với mối quan hệ 1-đến-1 giữa tệp nội dung và trang trên trang web của bạn.

Nó đại diện cho tiền tố đường dẫn (URL cơ sở) của trang tương ứng trên trang web.

::prose-warning
`prefix` phải bắt đầu bằng `/` dẫn đầu.
::

Theo mặc định, module trích xuất tiền tố tĩnh của `source` (hoặc `source.include`) và sử dụng nó làm tiền tố cho đường dẫn nội dung. Ví dụ, nếu bạn định nghĩa nguồn `/en/**`, module sẽ tự động điền `prefix` với `/en`. Bạn có thể cung cấp tiền tố thủ công để ghi đè hành vi này. Tiền tố có thể được loại bỏ bằng cách đặt `prefix: '/'` trong nguồn bộ sưu tập.

```ts
defineCollection({
  type: "page",
  source: {
    include: "en/**",
    exclude: ["en/index.md"],
    prefix: '/'
  }
})
```

### `cwd`

Thư mục gốc để khớp nội dung.

**Ví dụ:**

Nếu bạn muốn bao gồm tệp từ một thư mục bên ngoài thư mục content, đặt đường dẫn tuyệt đối của thư mục đó vào thuộc tính `cwd`.

```ts
source: {
  cwd: path.resolve('packages/my-pkg/docs'),
  include: '**/*.md',
}
```

### `repository`

Nguồn bên ngoài đại diện cho URL kho lưu trữ git từ xa (ví dụ: <https://github.com/nuxt/content>{rel="nofollow"}).

Khi định nghĩa nguồn bên ngoài, bạn cũng phải định nghĩa tùy chọn `include`.
Mẫu `include` là cần thiết để module biết tệp nào sẽ sử dụng cho bộ sưu tập.

```js
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: {
        repository: 'https://github.com/nuxt/content',
        include: 'docs/content/**',
      },
    })
  }
})
```

### `authToken`

Token xác thực cho kho lưu trữ riêng tư (ví dụ: GitHub personal access token).

::warning{icon="i-lucide-shield-alert"}
Không bao giờ commit token xác thực hoặc thông tin đăng nhập trực tiếp trong mã của bạn. Sử dụng biến môi trường hoặc các phương pháp bảo mật khác để cung cấp các giá trị này tại thời gian chạy.
::

### `authBasic`

Xác thực cơ bản cho kho lưu trữ riêng tư (ví dụ: tên người dùng và mật khẩu Bitbucket).

```ts
defineCollection({
  type: 'page',
  source: {
    repository: 'https://bitbucket.org/username/repo',
    authBasic: {
      username: 'username',
      password: 'password',
    },
  },
})
```


# Markdown

## Usage

### Define a Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        date: z.string()
      })
    })
  }
})
```

::note{to="https://nuxt.com/docs/collections/types#page-type"}
Tìm hiểu thêm về loại bộ sưu tập `page`.
::

### Create `.md` files

Tạo bài đăng blog trong thư mục `content/blog/`.

::code-group
```md [foo.md]
---
date: 2020-11-11
---

# Foo

This is Foo blog post.
```

```md [bar.md]
---
date: 2024-12-12
---
Hello
I am bar. Nice to meet you.
```
::

### Query Markdown Files

Bây giờ chúng ta có thể truy vấn bài đăng blog:

```ts
// Get the foo post
const fooPost = await queryCollection('blog').path('/blog/foo').first()

// Find all posts
const allPosts = await queryCollection('blog').order('date', 'DESC').all()
```

### Display Markdown

Để hiển thị nội dung của tệp markdown, bạn có thể sử dụng thành phần [`<ContentRenderer>`](https://nuxt.com/docs/components/content-renderer).

```vue [blog/[slug\\].vue]
<script setup>
const slug = useRoute().params.slug
const { data: post } = await useAsyncData(`blog-${slug}`, () => {
  return queryCollection('blog').path(`/blog/${slug}`).first()
})
</script>

<template>
  <!-- Render the blog post as Prose & Vue components -->
  <ContentRenderer :value="post" />
</template>
```

::note
Đọc thêm về thành phần [`<ContentRenderer>`](https://nuxt.com/docs/components/content-renderer) và [`Prose Components`](https://nuxt.com/docs/components/prose).
::

## Frontmatter

Frontmatter là quy ước của CMS dựa trên Markdown để cung cấp meta-data cho các trang, như mô tả hoặc tiêu đề. Trong Nuxt Content, frontmatter sử dụng cú pháp YAML với các cặp `key: value`.

Dữ liệu này có sẵn khi hiển thị nội dung và có thể lưu trữ bất kỳ thông tin nào bạn cần.

### Syntax

Bạn có thể khai báo khối frontmatter ở đầu tệp Markdown trong thư mục `content/` với mã định danh `---`.

```md [content/index.md]
---
title: 'Title of the page'
description: 'meta description of the page'
---

<!-- Content of the page -->
```

```ts [example.ts]
const home = await queryCollection('content').path('/').first()

console.log(home.title)
// => 'Title of the page'
console.log(home.description)
// => 'meta description of the page'
console.log(home.body)
// => AST object of the page content
```

### Native parameters

|               |           |                          |                                                                                                                                        |
| ------------- | --------- | ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| Key           | Type      | Default                  | Description                                                                                                                            |
| `title`       | `string`  | First `<h1>` of the page | Title of the page, will also be injected in metas                                                                                      |
| `description` | `string`  | First `<p>` of the page  | Description of the page, will be shown below the title and injected into the metas                                                     |
| `navigation`  | `boolean` | `true`                   | Define if the page is included in [`queryCollectionNavigation`](https://nuxt.com/docs/utils/query-collection-navigation) return value. |

::warning
Các tham số bổ sung mà bạn đã định nghĩa trong khối frontmatter cần được định nghĩa trong schema của bạn (xem tham số date trong ví dụ ở đầu trang này) để có thể sử dụng chúng cho truy vấn.
::

## MDC Syntax

Chúng tôi đã tạo cú pháp MDC để tăng cường Markdown và cho bạn khả năng tích hợp các thành phần Vue với các slot và props bên trong Markdown của bạn.

::callout
---
icon: i-simple-icons-visualstudiocode
to: https://marketplace.visualstudio.com/items?itemName=Nuxt.mdc
---
Cài đặt tiện ích mở rộng **MDC VS Code** để có đánh dấu cú pháp đúng cho cú pháp MDC.
::

### Vue Components

Bạn có thể sử dụng bất kỳ thành phần Vue nào trong tệp Markdown của mình.

Chúng tôi có cú pháp đặc biệt để làm cho việc sử dụng thành phần trong tệp Markdown dễ dàng hơn.

```mdc [content/index.md]
::component-name
Default slot content
::
```

::warning
Các thành phần được sử dụng trong Markdown phải được đánh dấu là `global` trong ứng dụng Nuxt của bạn nếu bạn không sử dụng thư mục `components/content/`, truy cập [tài liệu Nuxt 3](https://nuxt.com/docs/guide/directory-structure/components){rel="nofollow"} để tìm hiểu thêm về nó.
::

#### Block Components

Các thành phần khối là các thành phần chấp nhận nội dung Markdown hoặc một thành phần khác làm slot.

Thành phần phải chứa ít nhất một thành phần `<slot />` để chấp nhận văn bản được định dạng.

Trong tệp markdown, sử dụng thành phần với mã định danh `::`.

::code-group
```mdc [index.md]
::card
The content of the card
::
```

```html [Card.vue]
<!-- components/content/Card.vue -->
<template>
  <div class="p-2 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <slot />
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-card
    The content of the card
    ::::
  :::
::

#### Slots

Các slot của thành phần có thể chấp nhận nội dung hoặc các thành phần khác.

- **Default slot** hiển thị nội dung cấp cao nhất bên trong thành phần khối hoặc với `#default`
- **Named slots** sử dụng mã định danh `#` để hiển thị nội dung tương ứng.

::code-group
```mdc [index.md]
::hero
My Page Title

#description
This will be rendered inside the `description` slot.
::
```

```html [Hero.vue]
<template>
  <section>
    <h1 class="text-4xl">
      <slot mdc-unwrap="p" />
    </h1>
    <slot name="description" />
  </section>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-hero
    My Page Title
    
    #description
    This will be rendered inside the `description` slot.
    ::::
  :::
::

::note
Đọc thêm về thành phần [`<slot />`](https://nuxt.com/docs/components/slot).
::

::tip
Bạn có thể sử dụng Markdown bên trong các slot thành phần của mình:

  :::code-group
  ```mdc [index.md]
  ::my-title
  A [rich text](/) will be **rendered** by the component.
  ::
  ```
  
  ```html [MyTitle.vue]
  <template>
    <h1 class="text-4xl">
      <slot mdc-unwrap="p" />
    </h1>
  </template>
  ```
  
    ::::code-preview{icon="i-lucide-eye" label="Preview"}
      :::::example-title
      A [rich text](https://nuxt.com) will be **rendered** by the component.
      :::::
    ::::
  :::
::

#### Props

Có hai cách để truyền props cho các thành phần bằng MDC.

##### **Inline method**

Mã định danh `{}` truyền props cho các thành phần theo cách ngắn gọn bằng cách sử dụng cú pháp `key=value`.

::code-group
```mdc [index.md]
::alert{type="warning"}
The **alert** component.
::
```

```vue [Alert.vue]
<script setup>
const props = defineProps({ type: { type: String } })

const alertClass = computed(() => {
  return {
    warning: 'bg-orange-100 border-orange-200 dark:bg-orange-900 dark:border-orange-800',
    info: 'bg-blue-100 border-blue-200 dark:bg-blue-900 dark:border-blue-800',
    success: 'bg-green-100 border-green-200 dark:bg-green-900 dark:border-green-800',
  }[props.type]
})
</script>

<template>
  <div
    class="text-black p-2 border dark:text-white rounded"
    :class="alertClass"
  >
    <slot mdc-unwrap="p" />
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-alert{type="warning"}
    The **alert** component.
    ::::
  :::
::

Nhiều props có thể được phân tách bằng dấu cách:

```mdc
::alert{type="warning" icon="exclamation-circle"}
Oops! An error occurred
::
```

Shorthand `v-bind` `:` cũng có thể được sử dụng để ràng buộc một prop với một giá trị trong frontmatter.

```mdc
---
type: "warning"
---

::alert{:type="type"}
Your warning
::
```

Nếu bạn muốn truyền mảng hoặc đối tượng làm props cho các thành phần, bạn có thể truyền chúng dưới dạng chuỗi JSON và thêm tiền tố khóa prop bằng dấu hai chấm để tự động giải mã chuỗi JSON. Lưu ý rằng trong trường hợp này, bạn nên sử dụng dấu ngoặc đơn cho giá trị chuỗi để bạn có thể sử dụng dấu ngoặc kép để truyền chuỗi JSON hợp lệ:

::code-group
```mdc [array.md]
::dropdown{:items='["Nuxt", "Vue", "React"]'}
::
```

```mdc [number-array.md]
::dropdown{:items='[1,2,3.5]'}
::
```

```mdc [object.md]
::chart{:options='{"responsive": true, "scales": {"y": {"beginAtZero": true}}}'}
::
```
::

##### **YAML method**

Phương pháp YAML sử dụng mã định danh `---` để khai báo một prop mỗi dòng, có thể hữu ích cho khả năng đọc.

::code-group
```mdc [index.md]
::icon-card
---
icon: IconNuxt
description: Harness the full power of Nuxt and the Nuxt ecosystem.
title: Nuxt Architecture.
---
::
```

```html [IconCard.vue]
<script setup>
defineProps({
  title: {
    type: String,
    default: 'Default title'
  },
  description: {
    type: String,
    default: 'Default description'
  },
  icon: {
    type: String,
    default: 'IconMarkdown'
  }
})
</script>

<template>
  <div class="p-6 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <component :is="icon" class="w-20 h-20" />
    <h2 class="text-3xl font-semibold mb-2">
      {{ title }}
    </h2>
    <p>{{ description }}</p>
  </div>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-icon-card
    ---
    description: Harness the full power of Nuxt and the Nuxt ecosystem.
    icon: i-simple-icons-nuxtdotjs
    title: Nuxt Architecture.
    ---
    ::::
  :::
::

### Attributes

Thuộc tính hữu ích để làm nổi bật và sửa đổi một phần của đoạn văn. Cú pháp gần giống với cú pháp thành phần nội tuyến và cú pháp liên kết markdown.

Các giá trị có thể là tất cả thuộc tính được đặt tên, các lớp với ký hiệu `.class-name` và một ID với `#id-name`.

::code-group
```mdc [index.md]
Hello [World]{style="color: green;" .custom-class #custom-id}!
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  Hello [World]{#custom-id .custom-class style="color: green;"} !
  :::
::

Ngoài các thành phần mdc và `span`, cú pháp thuộc tính sẽ hoạt động trên hình ảnh, liên kết, `code` nội tuyến, \**bold*\* và \_italic\_ text.

::code-group
```md [index.md]
Attributes work on:

- [link](#attributes){style="background-color: green;"}, `code`{style="color: cyan;"},
- _italic_{style="background-color: yellow; color:black;"} and **bold**{style="background-color: lightgreen;"} texts.
```

  :::code-preview{prose label="Preview" prose=""}
  Attributes work on:
  
  - [link](https://nuxt.com/#attributes){style="background-color: green;"}, `code`,
  - *italic* and **bold** texts.
  :::
::

### Binding Data

Bạn có thể ràng buộc dữ liệu trong tài liệu Markdown của mình bằng cú pháp `{{ $doc.variable || 'defaultValue' }}`. Các giá trị này có thể được định nghĩa trong YAML frontmatter ở đầu tài liệu, trong mỗi thành phần MDC, hoặc được tiêm bằng prop `data` của thành phần `<ContentRenderer>`.

#### Define in YAML

```mdc
---
title: 'Title of the page'
description: 'meta description of the page'
customVariable: 'Custom Value'
---

# The Title is {{ $doc.title }} and customVariable is {{ $doc.customVariable || 'defaultValue' }}

```

#### Define in external with `<ContentRenderer>`

```html [test.vue]
<template>
  <div>
    <ContentRenderer :value="data" :data="mdcVars"/>
    <button type="button" v-on:click="mdcVars.name = 'Hugo'">Change name</button>
  </div>
</template>

<script setup lang="ts">
const { data } = await useAsyncData(() => queryCollection('content').path('/test').first());
const mdcVars = ref({ name: 'Maxime'});
</script>
```

```mdc [test.md]
# Hello {{ $doc.name || 'World' }}

```

## Prose Components

Trong Nuxt Content, prose đại diện cho các thẻ HTML được tạo bởi cú pháp Markdown, chẳng hạn như cấp độ tiêu đề và liên kết.

Đối với mỗi thẻ HTML, một thành phần Vue được sử dụng, cho phép bạn ghi đè chúng nếu cần, ví dụ `<p>` trở thành `<ProseP>`.

Nếu bạn muốn tùy chỉnh thành phần Prose, đây là các bước được khuyến nghị:

- Kiểm tra các nguồn thành phần gốc [component sources](https://github.com/nuxt-modules/mdc/blob/main/src/runtime/components/prose){rel="nofollow"}.
- Sử dụng cùng các props chính xác.
- Trong thư mục `components/content/` của bạn, đặt tên giống nhau.
- Làm cho nó của bạn 🚀.

::note{to="https://nuxt.com/docs/components/prose"}
Đọc tham chiếu Prose hoàn chỉnh trong phần Prose Components.
::

## Code Highlighting

Nuxt Content sử dụng [Shiki](https://github.com/shikijs/shiki){rel="nofollow"}, tô màu token với các chủ đề VSCode.

Đánh dấu mã hoạt động trên cả [`ProsePre`](https://nuxt.com/docs/components/prose#prosepre) và [`ProseCode`](https://nuxt.com/docs/components/prose#prosecodeinline).

Mỗi dòng của khối mã nhận số dòng của nó trong thuộc tính `line` để các dòng có thể được gắn nhãn hoặc tạo kiểu riêng lẻ.

::callout
[Đọc tham chiếu API để cấu hình hoặc vô hiệu hóa hoàn toàn đánh dấu cú pháp.](https://nuxt.com/docs/getting-started/configuration)
::

## Images

Bạn có thể thêm hình ảnh vào thư mục `public` của mình:

```bash [Directory structure]
content/
  index.md
public/
  image.png
nuxt.config.ts
package.json
```

Và sau đó sử dụng chúng trong tệp markdown của bạn trong thư mục `content` như sau:

```md [content/index.md]
![my image](/image.png)
```

## Excerpt

Nội dung excerpt hoặc tóm tắt có thể được trích xuất từ nội dung bằng cách sử dụng `<!--more-->` làm dấu phân cách.

```md [content/index.md]
---
title: Introduction
---

Learn how to use `@nuxt/content`.

<!--more-->

Full amount of content beyond the more divider.
```

Thuộc tính description sẽ chứa nội dung excerpt trừ khi được định nghĩa trong các props frontmatter.

Nếu không có dấu phân cách `<!--more-->` trong văn bản thì excerpt là undefined.

::tip
Bạn nên định nghĩa trường `excerpt` trong schema bộ sưu tập nếu bạn muốn sử dụng tính năng excerpt.

```ts [content.config.ts]
const content = defineCollection({
  type: 'page',
  source: '**',
  schema: z.object({
    excerpt: z.object({
      type: z.string(),
      children: z.any(),
    }),
  }),
})
```

Đọc thêm về [collection schema](https://nuxt.com/docs/collections/define#collection-schema).
::

Các biến ví dụ sẽ được tiêm vào tài liệu:

```json
{
  "excerpt": Object
  "body": Object
  // ... other keys
}
```


# YAML

## Define Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.yml',
      schema: z.object({
        name: z.string(),
        avatar: z.string(),
        url: z.string()
      })
    })
  }
})

```

## Create `.yml` files

Tạo authors files trong thư mục `content/authors/`.

::code-group
```yaml [farnabaz.yml]
name: Ahad Birang
avatar: https://avatars.githubusercontent.com/u/2047945?v=4
url: https://github.com/farnabaz
```

```yaml [larbish.yml]
name: Baptiste Leproux
avatar: https://avatars.githubusercontent.com/u/7290030?v=4
url: https://github.com/larbish
```
::

## Query Data

Bây giờ chúng ta có thể truy vấn authors:

```vue
<script lang="ts" setup>
// Find a single author
const { data: author } = await useAsyncData('larbish', () => {
  return queryCollection('authors')
    .where('stem', '=', 'larbish')
    .first()
})

// Get all authors
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'DESC')
    .all()
})
</script>
```


# JSON

## Define Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.json',
      schema: z.object({
        name: z.string(),
        avatar: z.string(),
        url: z.string()
      })
    })
  }
})

```

## Create `.json` files

Tạo authors files trong thư mục `content/authors/`.

::code-group
```json [farnabaz.json]
{
  "name": "Ahad Birang",
  "avatar": "https://avatars.githubusercontent.com/u/2047945?v=4",
  "url": "https://github.com/farnabaz"
}
```

```json [larbish.json]
{
  "name": "Baptiste Leproux",
  "avatar": "https://avatars.githubusercontent.com/u/7290030?v=4",
  "url": "https://github.com/larbish"
}
```
::

::warning
Mỗi file trong bộ sưu tập `data` nên chứa chỉ một object, do đó có mảng cấp cao nhất trong tệp JSON sẽ gây ra kết quả không hợp lệ khi truy vấn.
::

## Query Data

Bây giờ chúng ta có thể truy vấn authors:

```vue
<script lang="ts" setup>
// Find a single author
const { data: author } = await useAsyncData('larbish', () => {
  return queryCollection('authors')
    .where('stem', '=', 'larbish')
    .first()
})

// Get all authors
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'DESC')
    .all()
})
</script>
```


# CSV

## Define Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    authors: defineCollection({
      type: 'data',
      source: 'authors/**.csv',
      schema: z.object({
        name: z.string(),
        email: z.string(),
        avatar: z.string()
      })
    })
  }
})

```

## Create `.csv` files

Tạo author files trong thư mục `content/authors/`.

::code-group
```csv [users.csv]
id,name,email
1,John Doe,john@example.com
2,Jane Smith,jane@example.com
3,Alice Johnson,alice@example.com
```

```csv [team.csv]
name,role,avatar
John Doe,Developer,https://avatars.githubusercontent.com/u/1?v=4
Jane Smith,Designer,https://avatars.githubusercontent.com/u/2?v=4
```
::

::warning
Mỗi tệp CSV nên có hàng tiêu đề để định nghĩa tên cột, sẽ được sử dụng làm khóa đối tượng khi phân tích.
::

## Query Data

Bây giờ chúng ta có thể truy vấn authors:

```vue
<script lang="ts" setup>
// Find a single author
const { data: author } = await useAsyncData('john-doe', () => {
  return queryCollection('authors')
    .where('name', '=', 'John Doe')
    .first()
})

// Get all authors
const { data: authors } = await useAsyncData('authors', () => {
  return queryCollection('authors')
    .order('name', 'ASC')
    .all()
})
</script>

<template>
  <ul>
    <li v-for="author in authors" :key="author.id">
      {{ author.name }} ({{ author.email }})
    </li>
  </ul>
</template>
```

## Configuration

Bạn có thể cấu hình cách tệp CSV được phân tích trong `nuxt.config.ts` của mình:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      csv: {
        // Convert CSV data to JSON objects
        json: true,
        // Specify custom delimiter (default is ',')
        delimiter: ','
      }
    }
  }
})
```

Với `json: true` trong cấu hình, mỗi hàng sẽ được chuyển đổi thành một đối tượng JavaScript với hàng tiêu đề được sử dụng làm khóa:

```json
[
  {
    "id": "1",
    "name": "John Doe",
    "email": "john@example.com"
  },
  {
    "id": "2",
    "name": "Jane Smith",
    "email": "jane@example.com"
  }
]
```

## Custom Delimiters

Nếu tệp CSV của bạn sử dụng dấu phân cách khác, bạn có thể chỉ định nó trong cấu hình:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      csv: {
        delimiter: ';' // Use semicolon as delimiter
      }
    }
  }
})
```

Điều này sẽ phân tích tệp CSV như:

```csv [semicolon-data.csv]
id;name;email
1;John Doe;john@example.com
2;Jane Smith;jane@example.com
```

::note
Bộ phân tích CSV có thể bị vô hiệu hóa bằng cách đặt `csv: false` trong cấu hình nếu bạn không cần hỗ trợ CSV.
::


# queryCollection

## Usage

Sử dụng auto-imported `queryCollection` để tìm nội dung bên trong một collection. Ở đây chúng ta giả sử rằng bạn đã định nghĩa collection `docs` bên trong `content.config.ts`.

Nếu bạn chưa định nghĩa bất kỳ collection nào, hãy kiểm tra [How to define a collection](https://nuxt.com/docs/collections/define#defining-collections).

```vue [pages/[...slug\\].vue]
<script>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>
```

::tip
Tiện ích `queryCollection` có sẵn trong cả Vue và Nitro. Kiểm tra [Server Usage](https://nuxt.com/#server-usage) để biết thêm chi tiết về cách sử dụng ở phía server.
::

## API

### Type

```ts
function queryCollection<T extends keyof Collections>(collection: T): CollectionQueryBuilder<Collections[T]>

interface CollectionQueryBuilder<T> {
  where(field: keyof T | string, operator: SQLOperator, value?: unknown): CollectionQueryBuilder<T>
  andWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  orWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  order(field: keyof T, direction: 'ASC' | 'DESC'): CollectionQueryBuilder<T>
  // ... other methods
}
```

### `queryCollection(collection: CollectionName)`

Tạo một query builder để tìm kiếm trong collection cụ thể.

- Parameter:

  - `collection`: Khóa của collection đã định nghĩa trong `content.config.ts`

### `path(path: string)`

Tìm kiếm nội dung có `path` cụ thể. (`path` là một trường đặc biệt trong collection page được tạo dựa trên đường dẫn fs và có thể được sử dụng làm route để render nội dung)

- Parameter:

  - `path`: Chuỗi đường dẫn để khớp.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
```

### `select(...fields: keyof Collection)`

Chọn các trường cụ thể từ collection để được trả về trong kết quả query.

- Parameters:

  - `...fields`: Danh sách tên trường để chọn từ collection.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .select('path', 'title', 'description')
    .first()
})
```

### `where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)`

Thêm một điều kiện vào query để lọc kết quả dựa trên một trường cụ thể.

- Parameters:

  - `field`: Trường để lọc
  - `operator`: Toán tử SQL để sử dụng cho so sánh. Các giá trị có thể bao gồm:

    - `'='`: Bằng với
    - `'>'`: Lớn hơn
    - `'<'`: Nhỏ hơn
    - `'<>'`: Khác với
    - `'IN'`: Trong danh sách giá trị
    - `'BETWEEN'`: Giữa hai giá trị
    - `'NOT BETWEEN'`: Không giữa hai giá trị
    - `'IS NULL'`: Là null
    - `'IS NOT NULL'`: Không phải null
    - `'LIKE'`: Khớp với mẫu
    - `'NOT LIKE'`: Không khớp với mẫu
  - `value`: Giá trị để so sánh. Loại phụ thuộc vào toán tử được sử dụng.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    .where('category', '=', 'news')
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE date < '2024-04-04' AND category = 'news'
```

### `andWhere(groupFactory: QueryGroupFunction<Collection>)`

Thêm một nhóm điều kiện AND vào query. Điều này cho phép các điều kiện query phức tạp hơn.

- Parameter:

  - `groupFactory`: Một hàm nhận query builder và có thể thêm nhiều điều kiện được nhóm lại với AND

```ts
const { data } = await useAsyncData('recent-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .andWhere(query => query.where('date', '>', '2024-01-01').where('category', '=', 'news'))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (date > '2024-01-01' AND category = 'news')
```

### `orWhere(groupFactory: QueryGroupFunction<Collection>)`

Thêm một nhóm điều kiện OR vào query. Điều này cho phép các điều kiện thay thế.

- Parameter:

  - `groupFactory`: Một hàm nhận query builder và có thể thêm nhiều điều kiện được nhóm lại với OR

```ts
const { data } = await useAsyncData('featured-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .orWhere(query => query.where('featured', '=', true).where('priority', '>', 5))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (featured = true OR priority > 5)
```

### `order(field: keyof Collection, direction: 'ASC' | 'DESC')`

Sắp xếp kết quả query dựa trên một trường cụ thể.

- Parameters:

  - `field`: Trường để sắp xếp theo.
  - `direction`: Hướng sắp xếp, 'ASC' cho tăng dần hoặc 'DESC' cho giảm dần.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .all()
})
```

### `limit(limit: number)`

Giới hạn số lượng kết quả được trả về bởi query.

- Parameter:

  - `limit`: Số lượng kết quả tối đa để trả về.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .limit(10)
    .all()
})
```

### `skip(skip: number)`

Bỏ qua một số lượng kết quả cụ thể trong query.

- Parameter:

  - `skip`: Số lượng kết quả để bỏ qua.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // Skip first 5 items
    .skip(5)
    .all()
})
```

### `all()`

Thực thi query và trả về tất cả kết quả phù hợp.

- Returns: Một Promise giải quyết thành một mảng các tài liệu phù hợp.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').all()
})
```

### `first()`

Thực thi query và trả về kết quả phù hợp đầu tiên.

- Returns: Một Promise giải quyết thành tài liệu phù hợp đầu tiên, hoặc `null` nếu không có tài liệu nào phù hợp.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').first()
})
```

### `count()`

Đếm số lượng mục collection phù hợp dựa trên query.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // Count matches
    .count()
})

// Returns
5 // number of matches
```

Bạn cũng có thể sử dụng `count()` với các phương thức khác được định nghĩa ở trên như `where()` để áp dụng điều kiện bổ sung trong query collection.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    // Count matches
    .count()
})

// Returns
3 // number of matches for the provided query
```

## Examples

Đây là một ví dụ hoàn chỉnh về cách lấy danh sách tài liệu trong collection `docs`.

```vue [index.vue]
<script setup lang="ts">
const { data: docs } = await useAsyncData('documents-list', () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .select('title', 'path', 'description')
    .all()
})
</script>

<template>
  <NuxtLink v-for="doc in docs" :key="doc.path" :to="doc.path">
    <h2>{{ doc.title }}</h2>
    <p>{{ doc.description }}</p>
  </NuxtLink>
</template>
```

## Server Usage

Nuxt Content cung cấp một tiện ích tương tự để query collections ở phía server. Sự khác biệt duy nhất là bạn cần truyền `event` làm đối số đầu tiên cho hàm `queryCollection`.

```ts [server/api/[slug\\].ts]
export default eventHandler(async (event) => {
  const { slug } = getRouterParams(event)
  const page = await queryCollection(event, 'docs').path(slug).first()
  return page
})
```

::note
Hãy chắc chắn tạo file `server/tsconfig.json` với nội dung sau để tránh lỗi type.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# queryCollectionNavigation

## Type

```ts
function queryCollectionNavigation<T extends keyof PageCollections>(
  collection: T,
  fields?: Array<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## Usage

Sử dụng auto-imported `queryCollectionNavigation` để tạo cây điều hướng cho một collection cụ thể. Điều này đặc biệt hữu ích để tạo menu điều hướng động hoặc sidebar dựa trên cấu trúc nội dung của bạn.

Hàm trả về một promise có thể chain cho phép bạn thêm các điều kiện query bổ sung:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

::tip
Tiện ích `queryCollectionNavigation` có sẵn trong cả Vue và Nitro. Kiểm tra [Server Usage](https://nuxt.com/#server-usage) để biết thêm chi tiết về cách sử dụng ở phía server.
::

### Navigation metadata with `.navigation.yml`

Bạn có thể thêm metadata vào một thư mục bằng cách sử dụng file `.navigation.yml`.

```yml [.navigation.yml]
title: Getting Started
icon: i-lucide-square-play
```

## API

### `queryCollectionNavigation(collection: CollectionName, extraField: keyof Collection)`

Tạo cây điều hướng cho collection được chỉ định.

- Parameters:

  - `collection`: Khóa của collection đã định nghĩa trong `content.config.ts`.
  - `extraFields`: (Tùy chọn) Một mảng các trường bổ sung để bao gồm trong các mục điều hướng. (Theo mặc định `title` và `path` được bao gồm trong các mục điều hướng.)
- Returns: Một promise có thể chain giải quyết thành cấu trúc cây điều hướng. Promise bao gồm các phương thức để thêm điều kiện query:

  - `where(field, operator, value)`: Thêm điều kiện WHERE
  - `andWhere(groupFactory)`: Thêm điều kiện AND được nhóm
  - `orWhere(groupFactory)`: Thêm điều kiện OR được nhóm
  - `order(field, direction)`: Thêm mệnh đề ORDER BY

Cây điều hướng được tạo dựa trên cấu trúc thư mục và việc sắp xếp xảy ra dựa trên [ordering](https://nuxt.com/docs/collections/types#ordering-files) của files

## Examples

Sử dụng cơ bản mà không có điều kiện query bổ sung:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">{{ item.title }}</NuxtLink>
      </li>
    </ul>
  </nav>
</template>
```

Ví dụ với điều kiện query bổ sung và các trường extra:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs', ['description', 'badge'])
    .where('draft', '=', false)
    .where('partial', '=', false)
    .order('title', 'ASC')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">
          {{ item.title }}
          <span v-if="item.badge" class="badge">{{ item.badge }}</span>
        </NuxtLink>
        <p v-if="item.description">{{ item.description }}</p>
      </li>
    </ul>
  </nav>
</template>
```

## Server Usage

Nuxt Content cung cấp một tiện ích tương tự để query collections ở phía server. Sự khác biệt duy nhất là bạn cần truyền `event` làm đối số đầu tiên cho hàm `queryCollectionNavigation`.

```ts [server/api/navigation.ts]
export default eventHandler(async (event) => {
  const navigation = await queryCollectionNavigation(event, 'docs')
  return navigation
})
```

::note
Hãy chắc chắn tạo file `server/tsconfig.json` với nội dung sau để tránh lỗi type.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::

---

## Extra utilities to work with navigation

Module Content cung cấp một số tiện ích bổ sung để đơn giản hóa các trường hợp sử dụng phổ biến như xây dựng điều hướng breadcrumb.

### `findPageHeadline(navigation, path, options?)`

Trả về headline (tên của thư mục cha) cho một đường dẫn đã cho trong cây điều hướng. Hữu ích để hiển thị tiêu đề phần hoặc tiêu đề điều hướng theo ngữ cảnh.

- `navigation`: Cây điều hướng (mảng của ContentNavigationItem).
- `path`: Đường dẫn trang hiện tại.
- `options` (tùy chọn):

  - `indexAsChild`: Xử lý các trang index như children.

**Example:**

```ts
import { findPageHeadline } from '@nuxt/content/utils'

const headline = findPageHeadline(navigation, '/docs/guide/getting-started')
// headline is a string that contains the name of the parent folder
```

### `findPageBreadcrumb(navigation, path, options?)`

Trả về đường mòn breadcrumb (mảng các mục điều hướng) cho một đường dẫn đã cho trong cây điều hướng. Hữu ích để xây dựng các component điều hướng breadcrumb.

- `navigation`: Cây điều hướng (mảng của ContentNavigationItem).
- `path`: Đường dẫn trang hiện tại.
- `options` (tùy chọn):

  - `current`: Bao gồm trang hiện tại trong breadcrumb.
  - `indexAsChild`: Xử lý các trang index như children.

**Example:**

```ts
import { findPageBreadcrumb } from '@nuxt/content/utils'

const breadcrumb = findPageBreadcrumb(navigation, '/docs/guide/getting-started')
// breadcrumb is an array of navigation items leading to the current page
```

### `findPageChildren(navigation, path, options?)`

Tìm và trả về các children trực tiếp của một đường dẫn đã cho trong cây điều hướng.

- `navigation`: Cây điều hướng (mảng của ContentNavigationItem).
- `path`: Đường dẫn cha để tìm children.
- `options` (tùy chọn):

  - `indexAsChild`: Xử lý các trang index như children.

**Example:**

```ts
import { findPageChildren } from '@nuxt/content/utils'

const children = findPageChildren(navigation, '/docs/guide')
// children is an array of navigation items under '/docs/guide'
```

### `findPageSiblings(navigation, path, options?)`

Trả về các mục điều hướng anh chị em cho một đường dẫn đã cho (tức là các mục khác có cùng cha).

- `navigation`: Cây điều hướng (mảng của ContentNavigationItem).
- `path`: Đường dẫn trang hiện tại.
- `options` (tùy chọn):

  - `indexAsChild`: Xử lý các trang index như children.

**Example:**

```ts
import { findPageSiblings } from '@nuxt/content/utils'

const siblings = findPageSiblings(navigation, '/docs/guide/getting-started')
// siblings is an array of navigation items that share the same parent as the current page
```


# queryCollectionItemSurroundings

## Type

```ts
function queryCollectionItemSurroundings<T extends keyof PageCollections>(
  collection: T,
  path: string,
  opts?: SurroundOptions<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## Usage

Sử dụng auto-imported `queryCollectionItemSurroundings` để tìm các mục trước và sau liên quan đến một mục nội dung cụ thể trong một collection. Điều này đặc biệt hữu ích để tạo điều hướng giữa các trang nội dung liên quan.

Hàm trả về một promise có thể chain cho phép bạn thêm các điều kiện query bổ sung:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

::tip
Tiện ích `queryCollectionItemSurroundings` có sẵn trong cả Vue và Nitro. Kiểm tra [Server Usage](https://nuxt.com/#server-usage) để biết thêm chi tiết về cách sử dụng ở phía server.
::

## API

### `queryCollectionItemSurroundings(collection: CollectionName, path: string, opts?: SurroundOptions)`

Tìm các mục xung quanh (trước và sau) cho một mục nội dung cụ thể trong một collection.

- Parameters:

  - `collection`: Khóa của collection đã định nghĩa trong `content.config.ts`.
  - `path`: Đường dẫn của mục nội dung hiện tại.
  - `opts`: (Tùy chọn) Một đối tượng với các thuộc tính sau:

    - `before`: (Tùy chọn) Số lượng mục để lấy trước mục hiện tại. Mặc định là 1.
    - `after`: (Tùy chọn) Số lượng mục để lấy sau mục hiện tại. Mặc định là 1.
    - `fields`: (Tùy chọn) Một mảng các trường bổ sung để bao gồm trong các mục xung quanh.
- Returns: Một promise có thể chain giải quyết thành một mảng chứa các mục xung quanh. Promise bao gồm các phương thức để thêm điều kiện query:

  - `where(field, operator, value)`: Thêm điều kiện WHERE
  - `andWhere(groupFactory)`: Thêm điều kiện AND được nhóm
  - `orWhere(groupFactory)`: Thêm điều kiện OR được nhóm
  - `order(field, direction)`: Thêm mệnh đề ORDER BY

Kết quả cuối cùng sẽ là một mảng với cấu trúc sau:

- `[previousItem, nextItem]` nếu sử dụng tùy chọn mặc định
- `[...previousItems, ...nextItems]` nếu sử dụng giá trị `before` và `after` tùy chỉnh

Mỗi mục trong mảng là của loại `ContentNavigationItem` hoặc `null` nếu không có mục ở vị trí đó.

## Examples

Sử dụng cơ bản mà không có điều kiện query bổ sung:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
})
</script>

<template>
  <div class="flex justify-between">
    <NuxtLink v-if="data?.[0]" :to="data[0].path">
      ← {{ data[0].title }}
    </NuxtLink>
    <NuxtLink v-if="data?.[1]" :to="data[1].path">
      {{ data[1].title }} →
    </NuxtLink>
  </div>
</template>
```

Ví dụ với điều kiện query bổ sung:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo', {
    before: 1,
    after: 1,
    fields: ['badge', 'description']
  })
    .where('_draft', '=', false)
    .where('_partial', '=', false)
    .order('date', 'DESC')
})
</script>
```

## Server Usage

Nuxt Content cung cấp một tiện ích tương tự để query collections ở phía server. Sự khác biệt duy nhất là bạn cần truyền `event` làm đối số đầu tiên cho hàm `queryCollectionItemSurroundings`.

```ts [server/api/surroundings.ts]
export default eventHandler(async (event) => {
  const surroundings = await queryCollectionItemSurroundings(event, 'docs', '/foo')
  return surroundings
})
```

::note
Hãy chắc chắn tạo file `server/tsconfig.json` với nội dung sau để tránh lỗi type.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# queryCollectionSearchSections

## Type

```ts
function queryCollectionSearchSections(collection: keyof Collections, opts?: { ignoredTags: string[] }): ChainablePromise<T, Section[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## Usage

Sử dụng auto-imported `queryCollectionSearchSections` để tạo các phần có thể tìm kiếm từ một collection cụ thể. Điều này đặc biệt hữu ích để tạo chức năng tìm kiếm nâng cao hoặc các tính năng khám phá nội dung trong ứng dụng của bạn.

```vue [app.vue]
<script>
const { data: sections } = await useAsyncData('search-sections', () => {
  return queryCollectionSearchSections('docs')
})
</script>
```

::tip
Tiện ích `queryCollectionSearchSections` có sẵn trong cả Vue và Nitro. Kiểm tra [Server Usage](https://nuxt.com/#server-usage) để biết thêm chi tiết về cách sử dụng ở phía server.
::

## API

### `queryCollectionSearchSections(collection: CollectionName, options?: SearchSectionsOptions)`

Tạo các phần có thể tìm kiếm từ collection được chỉ định.

- Parameters:

  - `collection`: Khóa của collection đã định nghĩa trong `content.config.ts`.
  - `options`: (Tùy chọn) Một đối tượng với các thuộc tính sau:

    - `ignoredTags`: Một mảng tên tag để bỏ qua khi tạo các phần. Mặc định là một mảng trống.
- Returns: Một Promise giải quyết thành một mảng các phần có thể tìm kiếm. Mỗi phần là một đối tượng với các thuộc tính sau:

  - `id`: Một định danh duy nhất cho phần.
  - `title`: Tiêu đề của phần (thường là văn bản tiêu đề).
  - `titles`: Một mảng các tiêu đề phần cha, đại diện cho cấu trúc phân cấp.
  - `content`: Nội dung văn bản của phần.
  - `level`: Cấp độ tiêu đề (1-6) của phần, trong đó 1 là cấp cao nhất.

## Example

Đây là một ví dụ về cách sử dụng `queryCollectionSearchSections` để tạo các phần có thể tìm kiếm từ collection 'docs':

```vue [pages/[...slug\\].vue]
<script>
const { data: surround } = await useAsyncData('foo-surround', () => {
  return queryCollectionSearchSections('docs', {
    ignoredTags: ['code']
  })
})
</script>
```

## Server Usage

Nuxt Content cung cấp một tiện ích tương tự để query collections ở phía server. Sự khác biệt duy nhất là bạn cần truyền `event` làm đối số đầu tiên cho hàm `queryCollectionSearchSections`.

```ts [server/api/search-sections.ts]
export default eventHandler(async (event) => {
  const sections = await queryCollectionSearchSections(event, 'docs')
  return sections
})
```

::note
Hãy chắc chắn tạo file `server/tsconfig.json` với nội dung sau để tránh lỗi type.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```
::


# ContentRenderer

Thành phần `<ContentRenderer>` hiển thị một tài liệu từ một truy vấn với [`queryCollection()`](https://nuxt.com/docs/utils/query-collection).

::note
Thành phần này **chỉ hoạt động** với các tệp `Markdown`.
::

## Props

| Prop         | Default     | Type                  | Description                                                                                                                                              |
| ------------ | ----------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `value`      | `{}`        | `ParsedContent`       | Tài liệu cần hiển thị.                                                                                                                                   |
| `tag`        | `'div'`     | `string`              | Thẻ để sử dụng cho phần tử renderer nếu được sử dụng.                                                                                                    |
| `excerpt`    | `false`     | `boolean`             | Có hiển thị chỉ phần trích đoạn mà không có phần còn lại của nội dung hay không.                                                                         |
| `components` | `{}`        | `object`              | Bản đồ các thành phần tùy chỉnh để sử dụng cho việc hiển thị. Prop này sẽ được truyền đến markdown renderer và sẽ không ảnh hưởng đến các loại tệp khác. |
| `data`       | `{}`        | `object` (required)   | Bản đồ các biến để chèn vào nội dung markdown để sử dụng sau trong việc ràng buộc biến.                                                                  |
| `prose`      | `undefined` | `boolean`             | Có hiển thị các thành phần Prose thay vì các thẻ HTML hay không.                                                                                         |
| `class`      | `undefined` | `string` or `object`  | Thẻ gốc để sử dụng cho việc hiển thị.                                                                                                                    |
| `unwrap`     | `false`     | `boolean` or `string` | Các thẻ để bỏ vỏ, phân tách bằng dấu cách. Ví dụ: `'ul li'`.                                                                                             |

## Example Usage

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
</template>
```

## Handling Missing Pages

Nếu nội dung được truy vấn **thiếu**, bạn có thể hiển thị **thông báo dự phòng tùy chỉnh**.

```vue [pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <template v-if="page">
    <ContentRenderer :value="page" />
  </template>
  <template v-else>
    <div class="empty-page">
      <h1>Page Not Found</h1>
      <p>Oops! The content you're looking for doesn't exist.</p>
      <NuxtLink to="/">Go back home</NuxtLink>
    </div>
  </template>
</template>
```

## Handling Empty Pages

Nếu nội dung được truy vấn **trống**, bạn có thể hiển thị **thông báo dự phòng tùy chỉnh**.


# Slot

Khi bạn viết nội dung và đoạn văn bên trong một thành phần với cú pháp MDC, bạn có thể sử dụng thành phần `<slot>` của Vue để hiển thị nội dung.

## Usage

Nếu bạn không muốn sửa đổi nội dung được hiển thị, chỉ cần sử dụng thành phần `<slot>` của Vue.

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot />
  </div>
</template>
```

Bây giờ hãy sử dụng nó trong Markdown:

```mdc [content/index.md]
::callout
This is a callout.
::
```

HTML được hiển thị sẽ là:

```html
<div class="callout">
  <p>This is a callout.</p>
</div>
```

Cách sử dụng này tương tự như sử dụng thành phần `<slot>` gốc.

### Unwrapping

Thuộc tính `mdc-unwrap` cho phép bạn loại bỏ một hoặc nhiều phần tử bao bọc từ nội dung được hiển thị. Điều này hữu ích khi bạn muốn trích xuất nội dung lồng nhau trong cú pháp Markdown gốc. Mỗi thẻ được chỉ định sẽ được loại bỏ khỏi AST.

Hãy unwrap phần tử `<p>` từ ví dụ trước:

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot mdc-unwrap="p" />
  </div>
</template>
```

Bây giờ HTML được hiển thị sẽ là:

```html
<div class="callout">
  This is a callout.
</div>
```

### Named Slots

Thuộc tính `name` cho phép bạn ràng buộc một slot theo tên của nó. Điều này hữu ích khi bạn muốn hiển thị một slot không phải là slot mặc định.

Hãy cải thiện thành phần `Callout` của chúng ta để có một slot `title`:

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <h2 v-if="$slots.title">
      <slot name="title" mdc-unwrap="p" />
    </h2>
    <slot />
  </div>
</template>
```

Bây giờ hãy sử dụng nó trong Markdown:

```mdc [content/index.md]
::callout
#title
Please be careful!
#default
Using MDC & Vue components is addictive.
::
```

Điều này sẽ dẫn đến:

```html
<div class="callout">
  <h2>Please be careful!</h2>
  <p>Using MDC & Vue components is addictive.</p>
</div>
```

Khi không sử dụng slot `title`, phần tử `h2` sẽ không được hiển thị.

## Props

- `mdc-unwrap`: Có unwrap nội dung hay không. Điều này hữu ích khi bạn muốn trích xuất nội dung lồng nhau trong cú pháp Markdown gốc. Mỗi thẻ được chỉ định sẽ được loại bỏ khỏi AST.

  - **Type:** `boolean` or `string`
  - **Default:** `false`
  - **Example:** `'p'` or `'ul li'`


# Prose Components

Các thành phần Prose là thay thế cho các thẻ typography HTML. Các thành phần Prose cung cấp một cách đơn giản để tùy chỉnh giao diện nội dung.

Để ghi đè một thành phần prose, tạo một thành phần với cùng tên trong thư mục `components/content/` của dự án (ví dụ: `components/content/ProseA.vue`).

::note
Prose components are originally part of [`@nuxtjs/mdc`](https://github.com/nuxt-modules/mdc){rel="nofollow"}.
::

## `ProseA`

::code-group
```md [Code]
[Link](/docs/components/prose)
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  [Link](https://nuxt.com/docs/components/prose)
  :::
::

## `ProseBlockquote`

::code-group
```md [Code]
> Block quote
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  > Block quote
  :::
::

## `ProsePre`

::code-group
````md [Code]
  ```js [file.js]{2} meta-info=val
  export default () => {
    console.log('Code block')
  }
  ```
````

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ```js [file.js]
  export default () => {
    console.log('Code block')
  }
  ```
  :::
::

Thuộc tính thành phần sẽ là:

```json
{
  code: "export default () => {\n    console.log('Code block')\n}"
  language: "js"
  filename: "file.js"
  highlights: [2]
  meta: "meta-info=val"
}
```

Kiểm tra [tùy chọn highlight](https://nuxt.com/docs/getting-started/configuration#highlight) để biết thêm về cú pháp highlight.

::callout{type="warning"}
Nếu bạn muốn sử dụng `]` trong tên tệp, bạn cần escape nó với 2 dấu gạch chéo ngược: `\\]`. Điều này cần thiết vì JS sẽ tự động escape dấu gạch chéo ngược trong chuỗi nên `\]` sẽ được giải quyết thành `]` làm hỏng regex của chúng ta.
::

## `ProseCode`

::code-group
```md [Code]
`code`

`const code: string = 'highlighted code inline'`{lang="ts"}
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  `code`
  
  `const code: string = 'highlighted code inline'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}
  :::
::

## `ProseH1`

::code-group
```md [Code]
# H1 Heading
```

  :::code-preview{.pt-4 label="Preview"}
  # H1 Heading
  :::
::

## `ProseH2`

::code-group
```md [Code]
## H2 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ## H2 Heading
  :::
::

## `ProseH3`

::code-group
```md [Code]
### H3 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ### H3 Heading
  :::
::

## `ProseH4`

::code-group
```md [Code]
#### H4 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  #### H4 Heading
  :::
::

## `ProseH5`

::code-group
```md [Code]
##### H5 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ##### H5 Heading
  :::
::

## `ProseH6`

::code-group
```md [Code]
###### H6 Heading
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ###### H6 Heading
  :::
::

## `ProseHr`

::code-group
```md [Code]
Divider under.

---

Divider above.
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  Divider under.
  
  ---
  
  Divider above.
  :::
::

## `ProseImg`

::code-group
```md [Code]
![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)
  :::
::

## `ProseUl`

::code-group
```md [Code]
- Just
- An
- Unordered
- List
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  - Just
  - An
  - Unordered
  - List
  :::
::

## `ProseLi`

::code-group
```md [Code]
- List element
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  - List element
  :::
::

## `ProseOl`

::code-group
```md [Code]
1. Foo
2. Bar
3. Baz
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  1. Foo
  2. Bar
  3. Baz
  :::
::

## `ProseP`

::code-group
```md [Code]
Just a paragraph.
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  Just a paragraph.
  :::
::

## `ProseStrong`

::code-group
```md [Code]
**Just a strong paragraph.**
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  **Just a strong paragraph.**
  :::
::

## `ProseEm`

::code-group
```md [Code]
_Just an italic paragraph._
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  *Just an italic paragraph.*
  :::
::

## `ProseTable`

::code-group
```md [Code]
| Key | Type      | Description |
| --- | --------- | ----------- |
| 1   | Wonderful | Table       |
| 2   | Wonderful | Data        |
| 3   | Wonderful | Website     |
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
  | Key | Type      | Description |
  | --- | --------- | ----------- |
  | 1   | Wonderful | Table       |
  | 2   | Wonderful | Data        |
  | 3   | Wonderful | Website     |
  :::
::

## `ProseTbody`

Được bao gồm trong ví dụ **ProseTable**.

## `ProseTd`

Được bao gồm trong ví dụ **ProseTable**.

## `ProseTh`

Được bao gồm trong ví dụ **ProseTable**.

## `ProseThead`

Được bao gồm trong ví dụ **ProseTable**.

## `ProseTr`

Được bao gồm trong ví dụ **ProseTable**.

::callout
---
icon: i-simple-icons-github
to: https://github.com/nuxt-modules/mdc/tree/main/src/runtime/components/prose
---
Kiểm tra mã nguồn cho các thành phần này trên GitHub.
::


# Server Hosting

## What is Node.js preset?

Node preset là preset mặc định cho Nuxt, khi xây dựng dự án của bạn, Nuxt sẽ xuất ra một máy chủ Node.js mà bạn có thể chạy với `node .output/server/index.mjs`.

## Environment requirement

Nếu bạn đang sử dụng module `better-sqlite3` mặc định để vận hành cơ sở dữ liệu sqlite,
thì bạn phải triển khai lên một hệ điều hành có phiên bản Glibc cao hơn 2.29, ví dụ: Debian 11, Ubuntu 20.04.

::note
Bạn có thể sử dụng `ldd --version` để kiểm tra phiên bản Glibc. Xem [issue #3248](https://github.com/nuxt/content/issues/3248){rel="nofollow"} để biết thêm chi tiết.
::

## Building with Node.js preset

Xây dựng dự án với lệnh build của Nuxt:

```bash [Terminal]
nuxi build
```

Khi chạy `nuxi build` với preset máy chủ Node, kết quả sẽ là một điểm nhập khởi chạy máy chủ Node sẵn sàng chạy.

```bash [Terminal]
$ node .output/server/index.mjs
Listening on http://localhost:3000
```

::note
Cơ sở dữ liệu SQLite sẽ được tải ở phía máy chủ khi khởi động máy chủ cũng như trong trình duyệt cho điều hướng hoặc hành động phía máy khách.
::


# Static Hosting

## What is Static Hosting?

Static hosting là một loại hosting nơi trang web của bạn được xây dựng và phục vụ dưới dạng các tệp tĩnh (HTML, CSS, JS) có thể được phục vụ bởi bất kỳ máy chủ tệp tĩnh nào.

Nuxt Content có thể được triển khai lên static hosting bằng cách sử dụng Nuxt prerendering.

## Building with SSG

Để xây dựng ứng dụng của bạn với static site generation, chạy lệnh sau:

```bash
npx nuxi generate
```

::tip{icon="i-lucide-check"}
Lệnh này sẽ tạo một thư mục `dist/` với trang web tĩnh của bạn. Bạn có thể tải nó lên bất kỳ dịch vụ static hosting nào.
::

Nuxt sẽ tự động pre-render tất cả các trang bằng cách sử dụng một crawler nội bộ, bạn có thể tùy chỉnh hành vi của nó với các tùy chọn `nitro.prerender`.

::note{to="https://nuxt.com/docs/getting-started/prerendering"}
Tìm hiểu thêm về pre-rendering trong Nuxt.
::

## What about the Database?

Nuxt Content sẽ tải cơ sở dữ liệu trong trình duyệt bằng cách sử dụng [WASM SQLite](https://nuxt.com/docs/advanced/database#wasm-sqlite-in-browser), theo cách này, các truy vấn nội dung xảy ra trên điều hướng phía client hoặc hành động sẽ chạy trong trình duyệt.


# Serverless Hosting

## What is Serverless Hosting?

Việc lưu trữ serverless cho phép bạn chạy mã và ứng dụng mà không cần quản lý máy chủ trực tiếp - bạn chỉ cần tải lên mã của mình và nhà cung cấp đám mây sẽ tự động xử lý tất cả cơ sở hạ tầng, mở rộng quy mô và bảo trì trong khi chỉ tính phí cho các tài nguyên tính toán thực tế bạn sử dụng.

**Trong môi trường serverless, mỗi yêu cầu của người dùng kích hoạt một phiên bản mới của máy chủ Nuxt của bạn, nghĩa là nó khởi động từ đầu mỗi lần.** Bản chất "không trạng thái" này có nghĩa là bạn không thể lưu trữ dữ liệu trong bộ nhớ máy chủ hoặc sử dụng cơ sở dữ liệu dựa trên tệp như SQLite. Đó là lý do tại sao chúng ta cần sử dụng các dịch vụ cơ sở dữ liệu bên ngoài (như D1, Turso hoặc PostgreSQL) để duy trì dữ liệu độc lập với các phiên bản máy chủ của bạn.

## Deploy with Serverless

Module có hỗ trợ tích hợp cho một số nền tảng serverless nổi tiếng. Bạn có thể triển khai dự án của mình lên chúng một cách dễ dàng. Xem các hướng dẫn cho từng nền tảng:

- [NuxtHub](https://nuxt.com/docs/deploy/nuxthub)
- [Cloudflare Pages](https://nuxt.com/docs/deploy/cloudflare-pages)
- [Vercel](https://nuxt.com/docs/deploy/vercel)

Nếu bạn muốn triển khai lên các nền tảng khác, bạn có thể làm theo các bước dưới đây để triển khai dự án của mình.

### 1. Select a database service

Trước khi triển khai dự án của bạn, bạn cần chọn một dịch vụ cơ sở dữ liệu:

::code-group
```ts [PostgreSQL]
// 1. Create a PostgreSQL database
// 2. And add the `POSTGRES_URL` to the env variables
export default defineNuxtConfig({
  content: {
    database: {
      type: 'postgres',
      url: process.env.POSTGRES_URL
    }
  }
})
```

```ts [Cloudflare D1]
// 1. Create a D1 database in your CF account
// 2. Link it to your project with the same binding name
export default defineNuxtConfig({
  content: {
    database: {
      type: 'd1',
      bindingName: '<YOUR_BINDING_NAME>'
    }
  }
})
```

```ts [LibSQL]
// 1. Create a LibSQL database on Turso.tech
// 2. And add the `TURSO_DATABASE_URL` and `TURSO_AUTH_TOKEN` env variables
export default defineNuxtConfig({
  modules: ['@nuxt/content'],
  content: {
    database: {
      type: 'libsql',
      url: process.env.TURSO_DATABASE_URL,
      authToken: process.env.TURSO_AUTH_TOKEN,
    }
  }
})
```

```ts [NuxtHub]
// Install the NuxtHub module (see hub.nuxt.com)
export default defineNuxtConfig({
  modules: ['@nuxt/content', '@nuxthub/core'],
  content: {
    database: {
      type: 'd1',
      binding: 'DB'
    }
  },
  hub: {
    database: true
  }
})
```
::

### 2. Deploy your project

Nuxt Content sử dụng các preset triển khai của Nuxt để điều chỉnh quy trình xây dựng cho các nền tảng lưu trữ khác nhau.

Các nền tảng serverless khác nhau được hỗ trợ với cấu hình bằng không:

- [Cloudflare](https://nuxt.com/deploy/cloudflare){rel="nofollow"}
- [NuxtHub](https://nuxt.com/deploy/nuxthub){rel="nofollow"}
- [Vercel](https://nuxt.com/deploy/vercel){rel="nofollow"}
- [Netlify](https://nuxt.com/deploy/netlify){rel="nofollow"}

Tất cả những gì bạn cần làm là đặt lệnh xây dựng thành:

```bash [Terminal]
nuxi build
```

Đầu ra được tạo sẽ tương thích với nền tảng đã chọn.

::note
Cơ sở dữ liệu được liên kết sẽ được tải ở phía máy chủ khi khởi động máy chủ. Trong trình duyệt, cơ sở dữ liệu [WASM SQLite](https://nuxt.com/docs/advanced/database#wasm-sqlite-in-browser) sẽ được tải cho điều hướng và hành động phía máy khách.
::

::tip
Nếu bạn muốn triển khai lên AWS Lambda hoặc Azure Static Web Apps, bạn cần đảm bảo tệp sqlite của bạn nằm trong `/tmp` vì đây là thư mục duy nhất có thể ghi

```ts
export default defineNuxtConfig({
  modules: ['@nuxt/content'],
  content: {
    database: {
      type: 'sqlite',
      filename: '/tmp/contents.sqlite'
    }
  }
})
```
::

### 3. Optimize with pre-rendering

Vì mỗi yêu cầu kích hoạt một phiên bản mới của máy chủ Nuxt của bạn, hiệu suất của ứng dụng serverless của bạn sẽ bị ảnh hưởng nếu bạn không pre-render một số trang.

Để tối ưu hóa ứng dụng serverless của bạn, bạn có thể pre-render các trang của mình bằng cách sử dụng tùy chọn `routeRules`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true }
  }
})
```

::tip{to="https://hub.nuxt.com/docs/recipes/pre-rendering"}
Chúng tôi khuyên bạn nên xem **hướng dẫn Pre-rendering của NuxtHub** để tìm hiểu thêm về các chiến lược khác nhau để tối ưu hóa ứng dụng serverless của bạn, nó áp dụng cho tất cả các nền tảng serverless.
::


# NuxtHub

::card
Quick Setup

1. Cài đặt module `@nuxthub/core` `nuxi module add hub`
2. Sử dụng `npx nuxthub deploy` để triển khai nội dung của bạn lên NuxtHub
::

---

Module Nuxt Content có tích hợp sẵn với [NuxtHub](https://hub.nuxt.com){rel="nofollow"} để triển khai nội dung của bạn.

Để kích hoạt tích hợp NuxtHub, bạn cần cài đặt module `@nuxthub/core` và đăng ký nó trong `nuxt.config.ts` của bạn. Hiệu quả hơn, bạn có thể sử dụng lệnh `nuxi module` để làm cả hai cùng một lúc.

```bash
npx nuxi module add hub
```

Đó là nó 🎉

Bây giờ bạn có thể sử dụng lệnh `npx nuxthub deploy` để triển khai nội dung của bạn lên NuxtHub.

```bash
npx nuxthub deploy
```

::note
Module Nuxt Content tự động kích hoạt cơ sở dữ liệu NuxtHub. Và cập nhật cấu hình cơ sở dữ liệu để sử dụng Cloudflare D1 với tên binding `DB`. (Đây là cấu hình mặc định cho cơ sở dữ liệu NuxtHub.)

:br

Bạn có thể ghi đè cấu hình cơ sở dữ liệu bằng cách cung cấp cấu hình cơ sở dữ liệu của riêng mình trong `nuxt.config.ts`.
::

Tham khảo tài liệu [NuxtHub](https://hub.nuxt.com/docs/getting-started/deploy){rel="nofollow"} để biết thêm thông tin.


# Cloudflare Pages

::card
Quick Setup

1. Sử dụng `nuxi build --preset=cloudflare_pages` để xây dựng ứng dụng của bạn
2. Tạo cơ sở dữ liệu D1 và kết nối với dự án của bạn trong bảng điều khiển Cloudflare dưới tên binding `DB`
3. Triển khai/Tái triển khai ứng dụng của bạn
::

---

Module Nuxt Content có tích hợp sẵn với [Cloudflare Pages](https://pages.cloudflare.com){rel="nofollow"} để triển khai nội dung của bạn.

Module sẽ tự động phát hiện mục tiêu xây dựng và chuẩn bị cấu hình cần thiết cho Cloudflare Pages.

Bạn có thể sử dụng tùy chọn `--preset=cloudflare_pages` trên lệnh `nuxi build` hoặc sử dụng `nuxt.config.ts` để cấu hình preset.

```ts
export default defineNuxtConfig({
  nitro: {
    preset: 'cloudflare_pages',
  },
});
```

Module yêu cầu một cơ sở dữ liệu D1 được kết nối với ứng dụng để hoạt động. Theo mặc định, nó sẽ sử dụng tên binding `DB`. Bạn có thể ghi đè cấu hình cơ sở dữ liệu bằng cách cung cấp cấu hình cơ sở dữ liệu của riêng mình trong `nuxt.config.ts`.

Sau khi tạo một dự án Cloudflare Pages mới, bạn cần tạo một cơ sở dữ liệu D1 mới và kết nối nó với dự án. Đảm bảo sử dụng cùng tên binding mà module đang sử dụng. (mặc định là `DB`)

Đó là nó 🎉

Tham khảo:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/cloudflare){rel="nofollow"}
- [Cloudflare D1 documentation](https://developers.cloudflare.com/d1/){rel="nofollow"}
- [Cloudflare Pages documentation](https://developers.cloudflare.com/pages/){rel="nofollow"}


# Cloudflare Workers

::card
Quick Setup

1. Sử dụng preset `cloudflare_module` và ngày tương thích của `2024-09-19` hoặc sau đó.
2. Tạo một cơ sở dữ liệu D1 và kết nối nó với dự án của bạn trong bảng điều khiển Cloudflare dưới tên binding `DB`, và cấu hình cấu hình cơ sở dữ liệu trong tệp `nuxt.config.ts`.
3. Xây dựng và triển khai ứng dụng của bạn
::

---

Module Nuxt Content có tích hợp sẵn với [Cloudflare Workers](https://workers.cloudflare.com){rel="nofollow"} để triển khai nội dung của bạn.

Module sẽ tự động phát hiện mục tiêu xây dựng và chuẩn bị cấu hình cần thiết cho Cloudflare Workers.

Tất cả những gì bạn cần làm là tạo một cơ sở dữ liệu Cloudflare D1 và kết nối nó với dự án của bạn. Sau khi tạo một cơ sở dữ liệu D1, bạn nên
định nghĩa cấu hình cơ sở dữ liệu trong tệp `nuxt.config.ts` với tùy chọn `nitro.cloudflare.wrangler.d1_databases`.

Theo mặc định, module sẽ sử dụng tên binding `DB`. Bạn có thể ghi đè cấu hình cơ sở dữ liệu bằng cách cung cấp cấu hình cơ sở dữ liệu của riêng mình trong `nuxt.config.ts`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  compatibilityDate: "2025-05-15",
  nitro: {
    preset: 'cloudflare_module',
    cloudflare: {
      deployConfig: true,
      wrangler: {
        d1_databases: [
          {
            binding: 'DB',
            database_name: 'database-name',
            database_id: '*********-***-****-****-*********'
          }
        ]
      },
    },
  }
})
```

::note
Nếu bạn muốn sử dụng một tên binding khác, bạn có thể ghi đè cấu hình cơ sở dữ liệu bằng cách cung cấp cấu hình cơ sở dữ liệu của riêng mình trong `nuxt.config.ts`. Tham khảo [Cấu hình Cơ sở dữ liệu](https://nuxt.com/docs/getting-started/configuration#d1)
::

::note
Để triển khai một dự án Nuxt lên Cloudflare Workers, bạn cần sử dụng ngày tương thích của `2024-09-19` hoặc sau đó.
::

Xây dựng dự án của bạn với lệnh `nuxi build`, và bạn có thể triển khai dự án với lệnh `wrangler deploy`.

```bash
npx wrangler deploy
```

Đó là nó! 🎉

Tham khảo:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/cloudflare){rel="nofollow"}
- [Cloudflare D1 documentation](https://developers.cloudflare.com/d1/){rel="nofollow"}
- [Cloudflare Workers documentation](https://developers.cloudflare.com/workers/){rel="nofollow"}


# Vercel

::card
Quick Setup

- Thực thi lệnh `npx vercel deploy` hoặc truy cập bảng điều khiển Vercel và tạo một dự án mới bằng kho git.
::

---

Các dự án Nuxt Content có thể được triển khai lên Vercel mà không cần cấu hình. Module sẽ tự động phát hiện môi trường Vercel và chuẩn bị cấu hình cần thiết cho việc triển khai.

Tất cả những gì bạn cần làm là thực thi lệnh `npx vercel deploy` hoặc truy cập bảng điều khiển Vercel và tạo một dự án mới bằng kho git.

Đó là nó 🎉

::note
Theo mặc định, module sẽ sử dụng cơ sở dữ liệu SQlite trong Vercel nằm tại thư mục `/tmp`. Bạn có thể ghi đè cấu hình cơ sở dữ liệu bằng cách cung cấp cấu hình cơ sở dữ liệu của riêng mình.

:br

Có một số nhà cung cấp cơ sở dữ liệu được Vercel hỗ trợ. Bạn có thể sử dụng bất kỳ nhà cung cấp nào bằng cách cung cấp chuỗi kết nối chính xác trong `nuxt.config.ts`.
::

Tham khảo:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/vercel){rel="nofollow"}
- [Vercel documentation](https://vercel.com/docs/deployments/deployment-methods){rel="nofollow"}


# Netlify

::card
Quick Setup

- Truy cập bảng điều khiển Netlify và tạo một dự án mới bằng kho git.
- Truy cập `Site Configuration` trong `Dependency management` và thay đổi phiên bản Node thành `20.x` hoặc cao hơn.
- Truy cập `deploys` và thử lại lần triển khai cuối cùng.
::

---

Các dự án Nuxt Content có thể được triển khai lên Netlify mà không cần cấu hình. Module sẽ tự động phát hiện môi trường Netlify và chuẩn bị cấu hình cần thiết cho Netlify.

Tất cả những gì bạn cần làm là truy cập bảng điều khiển Netlify và tạo một dự án mới bằng kho git.

::note
Theo mặc định, Netlify sử dụng Node.js 18.x mà không được module hỗ trợ. Bạn cần thay đổi phiên bản Node.js trong `Site Configuration` dưới `Dependency management`.
::

Đó là nó 🎉

Tham khảo:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/netlify){rel="nofollow"}
- [Netlify documentation](https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/){rel="nofollow"}


# AWS Amplify

::card
Quick Setup

- Cài đặt gói `sqlite3` trong dự án của bạn.
- Truy cập bảng điều khiển AWS Amplify và tạo một dự án mới bằng kho git và triển khai ứng dụng.
::

---

Các dự án Nuxt Content có thể được triển khai lên AWS Amplify mà không cần cấu hình.
Module sẽ tự động phát hiện môi trường AWS Amplify và chuẩn bị cấu hình cần thiết cho việc triển khai.

Tất cả những gì bạn cần làm là cài đặt gói `sqlite3` trong dự án của bạn và truy cập bảng điều khiển AWS Amplify và tạo một dự án mới bằng kho git.

Đó là nó 🎉

::note
Theo mặc định, module sẽ sử dụng cơ sở dữ liệu SQlite nằm tại thư mục `/tmp`. Bạn có thể ghi đè cấu hình cơ sở dữ liệu bằng cách cung cấp cấu hình cơ sở dữ liệu của riêng mình.
::

Tham khảo:

- [Nuxt Deploy documentation](https://nuxt.com/deploy/aws-amplify){rel="nofollow"}


# Docker

Docker là một nền tảng containerization phổ biến cho phép bạn đóng gói ứng dụng của mình với tất cả các phụ thuộc vào một container duy nhất. Điều này giúp dễ dàng triển khai ứng dụng Content của bạn trên bất kỳ nền tảng nào hỗ trợ Docker.

## With Node.js image

Sử dụng hình ảnh Node.js của Docker, bạn có thể triển khai ứng dụng Content của mình. Tất cả những gì bạn cần là tạo một Dockerfile và xây dựng hình ảnh. Đây là một ví dụ Dockerfile:

```docker [Dockerfile]
# Build Stage 1

FROM node:22-alpine AS build
WORKDIR /app

RUN corepack enable

# Copy package.json and your lockfile, here we add pnpm-lock.yaml for illustration
COPY package.json pnpm-lock.yaml .npmrc ./

# Install dependencies
RUN pnpm i

# Copy the entire project
COPY . ./

# Build the project
RUN pnpm run build

# Build Stage 2

FROM node:22-alpine
WORKDIR /app

# Only `.output` folder is needed from the build stage
COPY --from=build /app/.output/ ./

# Change the port and host
ENV PORT=80
ENV HOST=0.0.0.0

EXPOSE 80

CMD ["node", "/app/server/index.mjs"]
```

## With Bun image

Nếu bạn muốn sử dụng Bun, bạn có thể sử dụng hình ảnh Bun chính thức. Đây là một ví dụ Dockerfile:

```docker [Dockerfile]
# use the official Bun image
# see all versions at https://hub.docker.com/r/oven/bun/tags
FROM oven/bun:1 AS build
WORKDIR /app

COPY package.json bun.lockb ./

# use ignore-scripts to avoid builting node modules like better-sqlite3
RUN bun install --frozen-lockfile --ignore-scripts

# Copy the entire project
COPY . .

RUN bun --bun run build

# copy production dependencies and source code into final image
FROM oven/bun:1 AS production
WORKDIR /app

# Only `.output` folder is needed from the build stage
COPY --from=build /app/.output /app

# run the app
EXPOSE 3000/tcp
ENTRYPOINT [ "bun", "--bun", "run", "/app/server/index.mjs" ]
```


# I18n module

Nuxt Content tích hợp với [`@nuxtjs/i18n`](https://i18n.nuxtjs.org/){rel="nofollow"} để tạo các trang web đa ngôn ngữ. Khi cả hai module được cấu hình cùng nhau, bạn có thể tổ chức nội dung theo ngôn ngữ và tự động phục vụ nội dung chính xác dựa trên ngôn ngữ của người dùng.

## Setup

::prose-steps
### Install the required module

```bash [terminal]
npm install @nuxtjs/i18n
```

### Configure your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content', '@nuxtjs/i18n'],
  i18n: {
    locales: [
      { code: 'en', name: 'English', language: 'en-US', dir: 'ltr' },
      { code: 'fr', name: 'French', language: 'fr-FR' },
      { code: 'fa', name: 'Farsi', language: 'fa-IR', dir: 'rtl' },
    ],
    strategy: 'prefix_except_default',
    defaultLocale: 'en',
  }
})
```

### Define collections for each language

Tạo các bộ sưu tập riêng biệt cho mỗi ngôn ngữ trong `content.config.ts` của bạn:

```ts [content.config.ts]
const commonSchema = ...;

export default defineContentConfig({
  collections: {
    // English content collection
    content_en: defineCollection({
      type: 'page',
      source: {
        include: 'en/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
    // French content collection
    content_fr: defineCollection({
      type: 'page',
      source: {
        include: 'fr/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
    // Farsi content collection
    content_fa: defineCollection({
      type: 'page',
      source: {
        include: 'fa/**',
        prefix: '',
      },
      schema: commonSchema,
    }),
  },
})
```

### Create dynamic pages

Tạo một trang catch-all lấy nội dung dựa trên ngôn ngữ hiện tại:

```vue [pages/[...slug\\].vue]
<script setup lang="ts">
import { withLeadingSlash } from 'ufo'
import type { Collections } from '@nuxt/content'

const route = useRoute()
const { locale } = useI18n()
const slug = computed(() => withLeadingSlash(String(route.params.slug)))

const { data: page } = await useAsyncData('page-' + slug.value, async () => {
  // Build collection name based on current locale
  const collection = ('content_' + locale.value) as keyof Collections
  const content = await queryCollection(collection).path(slug.value).first()

  // Optional: fallback to default locale if content is missing
  if (!content && locale.value !== 'en') {
    return await queryCollection('content_en').path(slug.value).first()
  }

  return content
}, {
  watch: [locale], // Refetch when locale changes
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
  <div v-else>
    <h1>Page not found</h1>
    <p>This page doesn't exist in {{ locale }} language.</p>
  </div>
</template>
```
::

Đó là nó! 🚀 Trang web nội dung đa ngôn ngữ của bạn đã sẵn sàng.

## Content Structure

Tổ chức các tệp nội dung của bạn trong các thư mục dành riêng cho ngôn ngữ để khớp với các bộ sưu tập của bạn:

```text
content/
  en/
    index.md
    about.md
    blog/
      post-1.md
  fr/
    index.md
    about.md
    blog/
      post-1.md
  fa/
    index.md
    about.md
```

Mỗi thư mục ngôn ngữ nên chứa cùng cấu trúc để đảm bảo tính đồng nhất nội dung trên các ngôn ngữ.

## Fallback Strategy

Bạn có thể triển khai chiến lược dự phòng để hiển thị nội dung từ ngôn ngữ mặc định khi nội dung bị thiếu trong ngôn ngữ hiện tại:

```ts [pages/[...slug\\].vue]
const { data: page } = await useAsyncData('page-' + slug.value, async () => {
  const collection = ('content_' + locale.value) as keyof Collections
  let content = await queryCollection(collection).path(slug.value).first()

  // Fallback to default locale if content is missing
  if (!content && locale.value !== 'en') {
    content = await queryCollection('content_en').path(slug.value).first()
  }

  return content
})
```

::prose-warning
Đảm bảo xử lý nội dung bị thiếu một cách nhẹ nhàng và cung cấp phản hồi rõ ràng cho người dùng khi nội dung không có sẵn trong ngôn ngữ ưa thích của họ.
::

## Complete Examples

Bạn có thể xem một ví dụ hoàn chỉnh đang hoạt động:

- **Nguồn**: <https://github.com/nuxt/content/tree/main/examples/i18n>{rel="nofollow"}
- **Bản demo trực tiếp**: <https://content3-i18n.nuxt.dev/>{rel="nofollow"}


# LLMs module

Module Nuxt Content tích hợp [`nuxt-llms`](https://github.com/nuxtlabs/nuxt-llms){rel="nofollow"} để chuẩn bị nội dung của bạn cho các Mô hình Ngôn ngữ Lớn (LLMs). Khi `nuxt-llms` được phát hiện, module Content tự động mở rộng module LLMs và chèn các bộ sưu tập loại [page](https://content.nuxt.com/docs/collections/types#page-type){rel="nofollow"} vào module LLMs.🚀

## Setup

::prose-steps
### Install the required module

```bash [terminal]
npm install nuxt-llms
```

### Configure your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/content', 'nuxt-llms'],
  llms: {
    domain: 'https://your-site.com',
    title: 'Your Site Name',
    description: 'A brief description of your site',
  },
})
```
::

Đó là nó 🚀 Tệp `/llms.txt` được tạo tự động và pre-rendered.

## Sections

Khi tạo nội dung, bạn có thể tạo các phần tùy chỉnh để xử lý nội dung của bạn thành các định dạng thân thiện với LLM.

Bạn có thể tạo các phần tùy chỉnh cho mảng `llms.sections` và định nghĩa tùy chọn `contentCollection` và `contentFilters` cho mỗi phần.

::prose-warning
Nếu không có phần nào được định nghĩa trong tùy chọn `contentCollection`, module sẽ chỉ thêm các bộ sưu tập [page](https://content.nuxt.com/docs/collections/types#page-type){rel="nofollow"} vào module LLMs.
::

### `contentCollection`

Tùy chọn này chỉ định bộ sưu tập nội dung nào để sử dụng làm nguồn.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  llms: {
    sections: [
      {
        title: 'Documentation',
        description: 'Technical documentation and guides',
        contentCollection: 'docs',
       },
    ],
  },
})
```

### `contentFilters`

Tùy chọn này định nghĩa các bộ lọc để chọn nội dung cụ thể trong bộ sưu tập.

Bạn kiểm soát chính xác nội dung nào được bao gồm. Mỗi bộ lọc bao gồm:

- `field`: Thuộc tính nội dung để kiểm tra
- `operator`: Toán tử so sánh (`=`, `<>`, `>`, `<`, `LIKE`, `IN`, `NOT IN`, `IS NULL`, `IS NOT NULL`, v.v.)
- `value`: Giá trị để so sánh

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  llms: {
    sections: [
      {
        title: 'Documentation',
        description: 'Technical documentation and guides',
        contentCollection: 'docs',
        contentFilters: [
            // Only include markdown files
            { field: 'extension', operator: '=', value: 'md' },
            // Only include published content
            { field: 'draft', operator: '<>', value: true },
            // Filter by directory
            { field: 'path', operator: 'LIKE', value: '/guide%' },
        ]
      },
    ],
  },
})
```

::tip{to="https://github.com/nuxtlabs/nuxt-llms"}
Tham khảo tài liệu nuxt-llms để biết thêm thông tin về module.
::


# Full-Text Search

Mô-đun Content cung cấp một tiện ích hữu ích [`queryCollectionSearchSections`](https://nuxt.com/docs/utils/query-collection-search-sections) để chia nhỏ các tệp nội dung thành các phần có thể tìm kiếm. Điều này hữu ích để triển khai tìm kiếm toàn văn trong trang web của bạn. Bạn có thể sử dụng kết quả của tiện ích này kết hợp với [Nuxt UI Content Search](https://ui.nuxt.com/pro/components/content-search){rel="nofollow"} hoặc các thư viện tìm kiếm khác như [Fuse.js](https://fusejs.io/){rel="nofollow"}, [minisearch](https://lucaong.github.io/minisearch){rel="nofollow"}, v.v.

## Nuxt UI Pro

Nuxt UI Pro cung cấp một thành phần sẵn sàng sử dụng cho tìm kiếm toàn văn. Bạn có thể sử dụng nó bằng cách truyền kết quả của `queryCollectionSearchSections` vào prop `files` của thành phần.

Đọc thêm về [Nuxt UI Content Search](https://ui.nuxt.com/pro/components/content-search){rel="nofollow"}.

::code-group
```vue [UContentSearchExample.vue]
<script setup lang="ts">
const { data: navigation } = await useAsyncData('navigation', () => queryCollectionNavigation('docs'))
const { data: files } = await useAsyncData('search', () => queryCollectionSearchSections('docs'))

const searchTerm = ref('')
</script>

<template>
  <UContentSearch
    v-model:search-term="searchTerm"
    :files="files"
    :navigation="navigation"
    :fuse="{ resultLimit: 42 }"
  />
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-fulltext-content-search
    ::::
  :::
::

## MiniSearch example

Đọc thêm về [minisearch](https://lucaong.github.io/minisearch){rel="nofollow"}.

::code-group
```vue [MiniSearchExample.vue]
<script setup lang="ts">
import MiniSearch from 'minisearch'

const query = ref('')
const { data } = await useAsyncData('search', () => queryCollectionSearchSections('docs'))

const miniSearch = new MiniSearch({
  fields: ['title', 'content'],
  storeFields: ['title', 'content'],
  searchOptions: {
    prefix: true,
    fuzzy: 0.2,
  },
})

// Add data to the MiniSearch instance
miniSearch.addAll(toValue(data.value))
const result = computed(() => miniSearch.search(toValue(query)))
</script>

<template>
  <UContainer class="p-4">
    <UCard>
      <UInput v-model="query" placeholder="Search..." />
      <ul>
        <li v-for="link of result" :key="link.id" class="mt-2">
          <NuxtLink :to="link.id">{{ link.title }}</NuxtLink>
          <p class="text-gray-500 text-xs">{{ link.content }}</p>
        </li>
      </ul>
    </UCard>
  </UContainer>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-fulltext-mini-search
    ::::
  :::
::

## Fuse.js example

Đọc thêm về [Fuse.js](https://fusejs.io){rel="nofollow"}.

::code-group
```vue [FusejsExample.vue]
<script setup lang="ts">
import Fuse from 'fuse.js'

const query = ref('')
const { data } = await useAsyncData('search-data', () => queryCollectionSearchSections('docs'))

const fuse = new Fuse(data.value, {
  keys: ['title', 'description']
})

const result = computed(() => fuse.search(toValue(query)).slice(0, 10))
</script>

<template>
  <UContainer class="p-4">
    <UCard>
      <UInput v-model="query" placeholder="Search..." class="w-full" />
      <ul>
        <li v-for="link of result" :key="link.item.id" class="mt-2">
          <UButton variant="ghost" class="w-full" :to="link.item.id">
            {{ link.item.title }}
            <span class="text-gray-500 text-xs">
              {{ link.item.content?.slice(0, 100) }}...
            </span>
          </UButton>
        </li>
      </ul>
    </UCard>
  </UContainer>
</template>
```

  :::code-preview{icon="i-lucide-eye" label="Preview"}
    ::::example-fulltext-fusejs
    ::::
  :::
::


# Raw Content

Có rất nhiều yêu cầu trong phiên bản Content 2 về việc truy cập dữ liệu thô của nội dung trong sản xuất. Trong phiên bản Content 3, có thể gửi dữ liệu thô của nội dung đến sản xuất.

Để gửi nội dung thô đến sản xuất, bạn cần định nghĩa trường `rawbody` trong schema của bộ sưu tập. Đó là tất cả.

Nuxt Content sẽ phát hiện trường ma thuật này trong schema của bạn và điền nó với nội dung thô.

```ts [content.config.ts]

import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      source: '**',
      type: 'page',
      schema: z.object({
        rawbody: z.string()
      })
    })
  }
})
```

Và bạn có thể sử dụng `queryCollection()` để lấy nội dung thô.

```vue [pages/index.vue]
<script setup lang="ts">
const route = useRoute()
const { data } = useAsyncData('page-' + route.path, () => queryCollection('docs').path(route.path).first())
</script>

<template>
  <pre>{{ data.rawbody }}</pre>
</template>
```

Trong trường hợp bạn không muốn gửi nội dung thô của một tệp cụ thể, bạn có thể thêm `rawbody: ''` vào frontmatter của tệp đó. Giá trị tự động điền của `rawbody` hoạt động như giá trị mặc định và khi bạn định nghĩa `rawbody` trong frontmatter, nó sẽ bị ghi đè.

```md [content.md]
---
title: My page
rawbody: ''
---

```

::callout
Điều quan trọng là điền các trường frontmatter với cùng loại dữ liệu được định nghĩa trong schema bộ sưu tập. Trong trường hợp này `rawbody` là một chuỗi, và bạn nên cân nhắc truyền chuỗi rỗng. Không sử dụng `boolean` hoặc các loại giá trị khác.
::


# Database

Trong Content v3, chúng tôi đã giới thiệu một lớp lưu trữ mạnh mẽ dựa trên SQLite, cung cấp một phương pháp mạnh mẽ và hiệu quả để quản lý nội dung. Điều này đánh dấu một cải tiến đáng kể so với hệ thống lưu trữ dựa trên tệp trước đó, bị hạn chế bởi hiệu suất và khả năng mở rộng.

> Trong Content v2, hệ thống đọc và phân tích nội dung trong thời gian chạy Nitro, tạo một tệp cache cho mỗi tệp nội dung để lưu trữ dữ liệu đã phân tích. Phương pháp này gây ra chi phí đáng kể cho thời gian chạy của trang web.
>
> - Thời gian I/O trong sản xuất là đáng kể, vì mô-đun phải tải tất cả các tệp cache để tìm kiếm qua nội dung.
> - Ngoài ra, thiếu tối ưu hóa và nén cho nội dung dẫn đến kích thước bundle lớn, đặc biệt có vấn đề trong môi trường edge.

Quản lý nội dung trong Content v3 bao gồm ba bước chính, được thiết kế để hợp lý hóa quy trình và nâng cao hiệu suất.

## Generating Database Dump

Đối với mỗi bộ sưu tập trong dự án của bạn, mô-đun đọc nội dung từ nguồn được định nghĩa và phân tích nó thành Cây Cú Pháp Trừu Tượng (AST). Nó tạo một bảng cụ thể cho mỗi bộ sưu tập dựa trên schema của nó. Nội dung đã phân tích sau đó được chèn vào bảng tương ứng, đảm bảo cấu trúc dữ liệu phù hợp với schema được định nghĩa để tối ưu hóa truy vấn. Mọi thứ sau đó được lưu trong một tệp dump.

## Restoring Dump on Cold Start

Trong thời gian chạy, khi ứng dụng thực hiện truy vấn đầu tiên để lấy nội dung, mô-đun đọc dump đã tạo từ bước trước và khôi phục nó vào cơ sở dữ liệu mục tiêu. Quy trình này nhanh chóng và được tối ưu hóa cho mỗi chế độ triển khai và nền tảng.

Mô-đun sử dụng một cơ chế kiểm tra tính toàn vẹn đặc biệt để đảm bảo cơ sở dữ liệu được cập nhật với nội dung mới nhất. Cùng cơ chế kiểm tra tính toàn vẹn này cũng ngăn chặn việc nhập trùng lặp, duy trì tính toàn vẹn và độ chính xác của dữ liệu được lưu trữ.

## WASM SQLite in Browser

Đối với điều hướng phía client, mô-đun sử dụng cách tiếp cận tương tự. Khi ứng dụng thực hiện truy vấn đầu tiên cho nội dung, nó tải xuống dump đã tạo từ máy chủ và khởi tạo cơ sở dữ liệu SQLite cục bộ trong trình duyệt. Từ thời điểm đó trở đi, tất cả các truy vấn được thực hiện cục bộ mà không cần gọi máy chủ, cải thiện đáng kể khả năng đáp ứng của ứng dụng và cung cấp trải nghiệm người dùng liền mạch.

Kiến trúc này không chỉ nâng cao hiệu suất mà còn cho phép khả năng ngoại tuyến, cho phép người dùng truy cập nội dung ngay cả khi không có kết nối internet hoạt động. Sự kết hợp của xử lý phía máy chủ và phía client đảm bảo rằng Nuxt Content v3 vừa mạnh mẽ vừa linh hoạt, phục vụ cho nhiều trường hợp sử dụng và môi trường khác nhau.


# Tools

Nuxt Content sử dụng &#x2A;*cơ sở dữ liệu SQLite (`contents.sqlite`)** để lưu trữ và truy vấn nội dung một cách hiệu quả. Nếu bạn gặp phải **nội dung bị thiếu, truy vấn chậm, hoặc vấn đề cơ sở dữ liệu**, việc gỡ lỗi cơ sở dữ liệu SQLite của bạn có thể giúp đỡ!

::callout
---
icon: i-simple-icons-visualstudiocode
to: https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite
---
Một cách đơn giản để kiểm tra nó? **Sử dụng tiện ích mở rộng SQLite VS Code!**
::

## Install SQLite VS Code Extension

1. Mở **Visual Studio Code**.
2. Đi đến **bảng Extensions** (`Ctrl+Shift+X` / `Cmd+Shift+X` trên Mac).
3. Tìm kiếm &#x2A;*"SQLite"** (bởi `alexcvzz`) và cài đặt nó.
4. Mở cơ sở dữ liệu Nuxt Content của bạn (`.data/content/contents.sqlite`).

::tip{icon="i-lucide-lightbulb"}
Nếu bạn không thấy `contents.sqlite`, hãy khởi động ứng dụng Nuxt của bạn trước:

```bash [Terminal]
npx nuxi dev
```
::

## Locate Your SQLite Database

Nuxt Content lưu trữ cơ sở dữ liệu của nó ở đây:

```bash
.data/content/contents.sqlite
```

::note{to="https://nuxt.com/docs/getting-started/prerendering"}
Tệp này được tạo tự động khi bạn khởi động ứng dụng Nuxt. Không cần tạo thủ công!
::

## Open & Explore the Database

1. **Nhấp chuột phải** vào `contents.sqlite` trong VS Code.
2. Chọn &#x2A;*"Open Database"**.
3. Mở rộng **bảng Database Explorer** để xem bảng & dữ liệu.

![SQLite Explorer in VS Code](https://github.com/user-attachments/assets/c9f22c4c-7a95-43e8-ab03-aa76f2e49c8e)

## Fixing Common Issues

### Nội dung không hiển thị?

1. **Kiểm tra xem cơ sở dữ liệu có tồn tại không** (`.data/content/contents.sqlite`).
2. **Chạy cleanup & khởi động lại Nuxt**:

   ```bash [Terminal]
   npx nuxi cleanup && npx nuxi dev
   ```
3. **Kiểm tra xem nội dung có trong cơ sở dữ liệu không** (chạy truy vấn SQL).

### Manually Reset the Database

Nếu mọi thứ có vẻ **thật sự hỏng**, hãy thử đặt lại nó:

1. **Xóa tệp cơ sở dữ liệu**:

   ```bash [Terminal]
   rm -rf .data/content/contents.sqlite
   ```
2. **Chạy cleanup** để xóa cache cũ:

   ```bash [Terminal]
   npx nuxi cleanup
   ```
3. **Khởi động lại Nuxt** để tạo cơ sở dữ liệu mới:

   ```bash [Terminal]
   npx nuxi dev
   ```

::note{icon="i-lucide-triangle-alert"}
Việc cleanup sẽ xóa dữ liệu cache. Đừng lo—nó sẽ tạo lại tự động!
::

## More Debugging Tools

Nếu VS Code không đủ, hãy xem:

- 🖥️ [**DB Browser for SQLite**](https://sqlitebrowser.org/){rel="nofollow"} – Một công cụ trực quan để kiểm tra & sửa đổi cơ sở dữ liệu.
- 🛠️ **SQLite Command Line** – Sử dụng `sqlite3 contents.sqlite` để chạy truy vấn SQL từ terminal của bạn.


# Hooks

## `content:file:beforeParse`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}

Hook này được gọi trước khi nội dung được phân tích.

Nó có thể được sử dụng để sửa đổi nội dung thô từ một `file` trước khi nó được chuyển đổi hoặc sửa đổi các tùy chọn chuyển đổi.

```ts
export default defineNuxtConfig({
  hooks: {
    'content:file:beforeParse'(ctx) {
      // ...
    }
  }
})
```

## `content:file:afterParse`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"}

Hook này được gọi sau khi nội dung được phân tích và trước khi nó được lưu vào cơ sở dữ liệu.

```ts
export default defineNuxtConfig({
  hooks: {
    'content:file:afterParse'(ctx) {
      // ...
    }
  }
})
```

## Example Usage

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // ...
  hooks: {
    'content:file:beforeParse'(ctx) {
      const { file } = ctx;

      if (file.id.endsWith(".md")) {
        file.body = file.body.replace(/react/gi, "Vue");
      }
    },
    'content:file:afterParse'(ctx) {
      const { file, content } = ctx;

      const wordsPerMinute = 180;
      const text = typeof file.body === 'string' ? file.body : '';
      const wordCount = text.split(/\s+/).length;

      content.readingTime = Math.ceil(wordCount / wordsPerMinute);
    }
  }
})
```

::note{icon="i-lucide-info"}
Trong hook `content:file:afterParse`, chúng tôi đã thêm một thuộc tính tùy chỉnh vào đối tượng nội dung của chúng tôi. Để có thể truy cập thuộc tính đó trong các trang của chúng tôi bằng cách sử dụng [`queryCollection()`](https://nuxt.com/docs/utils/query-collection), trước tiên chúng tôi cần định nghĩa nó trong schema nội dung.

```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    content: defineCollection({
      type: 'page',
      source: '**/*.md',
      schema: z.object({
        readingTime: z.number().optional()
      })
    })
  }
});
```
::


# Custom Source

Theo mặc định, Nuxt Content cung cấp một số nguồn tích hợp như nguồn tệp cục bộ và nguồn Github từ xa. Tuy nhiên điều này không đủ cho một số trường hợp, ví dụ, bạn muốn lấy dữ liệu từ một API từ xa. Trong trường hợp này, bạn có thể định nghĩa một nguồn tùy chỉnh để lấy dữ liệu và sử dụng nó trong các bộ sưu tập của bạn.

Sử dụng `defineCollectionSource`, bạn có thể định nghĩa một nguồn tùy chỉnh.

```ts
import { defineCollectionSource } from '@nuxt/content'

const hackernewsSource = defineCollectionSource({
  getKeys: () => {
    return fetch('https://hacker-news.firebaseio.com/v0/topstories.json')
      .then(res => res.json())
      .then(data => data.map((key: string) => `${key}.json`))
  },
  getItem: (key: string) => {
    const id = key.split('.')[0]
    return fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)
      .then(res => res.json())
  },
})
```

Sau đó bạn có thể sử dụng nguồn này trong các bộ sưu tập của bạn.

```ts [content.config.ts]
import { defineContentConfig, defineCollectionSource, defineCollection, z } from '@nuxt/content'

const hackernewsSource = defineCollectionSource({
  getKeys: () => {
    return fetch('https://hacker-news.firebaseio.com/v0/topstories.json')
      .then(res => res.json())
      .then(data => data.map((key: string) => `${key}.json`))
  },
  getItem: (key: string) => {
    const id = key.split('.')[0]
    return fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)
      .then(res => res.json())
  },
})

const hackernews = defineCollection({
  type: 'data',
  source: hackernewsSource,
  schema: z.object({
    title: z.string(),
    date: z.date(),
    type: z.string(),
    score: z.number(),
    url: z.string(),
    by: z.string(),
  }),
})

export default defineContentConfig({
  collections: {
    hackernews,
  },
})
```


# Transformers

Transformers trong Nuxt Content cho phép bạn phân tích cú pháp, sửa đổi hoặc phân tích các tệp nội dung của bạn theo chương trình khi chúng được xử lý. Chúng đặc biệt hữu ích cho:

- Thêm hoặc sửa đổi các trường (ví dụ: thêm vào tiêu đề, tạo slugs)
- Trích xuất metadata (ví dụ: liệt kê các thành phần được sử dụng)
- Làm phong phú nội dung với dữ liệu tính toán
- Hỗ trợ các loại nội dung mới

## Defining a Transformer

Bạn có thể định nghĩa một transformer bằng cách sử dụng helper `defineTransformer` từ `@nuxt/content`:

```ts [~~/transformers/title-suffix.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'title-suffix',
  extensions: ['.md'], // File extensions to apply this transformer to
  transform(file) {
    // Modify the file object as needed
    return {
      ...file,
      title: file.title + ' (suffix)',
    }
  },
})
```

### Transformer Options

- `name` (string): Tên duy nhất cho transformer của bạn.
- `extensions` (string [] ): Các phần mở rộng tệp mà transformer này nên áp dụng (ví dụ: `['.md']`).
- `transform` (function): Hàm nhận đối tượng tệp và trả về tệp đã sửa đổi.

## Registering Transformers

Transformers được đăng ký trong `nuxt.config.ts` của bạn:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~~/transformers/title-suffix',
        '~~/transformers/my-custom-transformer',
      ],
    },
  },
})
```

## Example: Adding Metadata

Transformers có thể thêm trường `__metadata` vào tệp. Trường này không được lưu trong cơ sở dữ liệu nhưng có thể được sử dụng cho logic runtime.

```ts [~~/transformers/component-metadata.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'component-metadata',
  extensions: ['.md'],
  transform(file) {
    // Example: Detect if a custom component is used
    const usesMyComponent = file.body?.includes('<MyCustomComponent>')
    return {
      ...file,
      __metadata: {
        components: usesMyComponent ? ['MyCustomComponent'] : [],
      },
    }
  },
})
```

**Lưu ý:** Trường `__metadata` chỉ khả dụng tại runtime và không được lưu trữ trong cơ sở dữ liệu nội dung.

## API Reference

```ts
interface Transformer {
  name: string
  extensions: string[]
  transform: (file: ContentFile) => ContentFile
}
```

- `ContentFile` là đối tượng đại diện cho tệp nội dung đã phân tích, bao gồm frontmatter, body và các trường khác.

## Supporting New File Formats with Transformers

Transformers không chỉ giới hạn ở việc sửa đổi nội dung hiện có—chúng cũng có thể được sử dụng để thêm hỗ trợ cho các định dạng tệp mới trong Nuxt Content. Bằng cách định nghĩa một transformer với phương thức `parse` tùy chỉnh, bạn có thể hướng dẫn Nuxt Content cách đọc và xử lý các tệp với các phần mở rộng mới, chẳng hạn như YAML.

### Example: YAML File Support

Giả sử bạn muốn hỗ trợ các tệp `.yml` và `.yaml` trong thư mục nội dung của bạn. Bạn có thể tạo một transformer phân tích cú pháp frontmatter và body YAML, và đăng ký nó cho các phần mở rộng đó:

```ts [~~/transformers/yaml.ts]
import { defineTransformer } from '@nuxt/content'

export default defineTransformer({
  name: 'Yaml',
  extensions: ['.yml', '.yaml'],
  parse: (file) => {
    const { id, body } = file
    
    // parse the body with your favorite yaml parser
    const parsed = parseYaml(body)

    return {
      ...parsed,
      id,
    }
  },
})
```

Đăng ký transformer YAML của bạn trong cấu hình Nuxt giống như bất kỳ transformer nào khác:

```ts
export default defineNuxtConfig({
  content: {
    build: {
      transformers: [
        '~~/transformers/yaml',
        // ...other transformers
      ],
    },
  },
})
```

Cách tiếp cận này cho phép bạn mở rộng Nuxt Content để xử lý bất kỳ định dạng tệp tùy chỉnh nào bạn cần.


# Setup Nuxt Studio

Studio là giao diện CMS trực quan để chỉnh sửa các trang web Nuxt Content của bạn.

Nó tận dụng `Preview API` có trong Nuxt Content để đề xuất trải nghiệm chỉnh sửa tốt nhất cho các tệp nội dung của bạn. Các biên tập viên có thể hưởng lợi từ giao diện thân thiện với người dùng để chỉnh sửa các tệp `Markdown`, `YAML` hoặc `JSON` của họ.

Các nhà phát triển có thể tùy chỉnh trải nghiệm chỉnh sửa và cung cấp công cụ cho biên tập viên tập trung vào nội dung mà không yêu cầu chuyên môn kỹ thuật.

:video{autoplay controls loop poster="/home/videos/HomeNotionLikePoster.webp" src="https://res.cloudinary.com/nuxt/video/upload/v1733494722/contentv3final_rc8bvu.mp4"}

## Authentication

Quản trị viên Studio nằm trên [nuxt.studio](https://nuxt.studio){rel="nofollow"}. Từ đó, bạn có thể đăng nhập bằng GitHub hoặc Google. Cả hai phương pháp đều cho bạn cùng quyền chỉnh sửa nhưng vì Studio được [đồng bộ hóa với GitHub](https://nuxt.com/docs/studio/github), việc nhập kho lưu trữ phải được xử lý bởi người dùng GitHub.

::warning
Xác thực Google được điều chỉnh cho người dùng không chuyên. Người dùng Google phải tham gia một nhóm với các dự án hiện có để chỉnh sửa chúng.
::

## Connect your Nuxt Content Repository

Sau khi đăng nhập vào quản trị viên, bạn có thể nhập kho lưu trữ Nuxt Content của mình từ giao diện.

::tip
Có hai tùy chọn khả dụng, bạn có thể nhập một kho lưu trữ hiện có hoặc sử dụng một trong các [mẫu](https://nuxt.com/templates) của chúng tôi.
::

Yêu cầu duy nhất là lưu trữ kho lưu trữ của bạn trên GitHub. Từ giao diện, kết nối với [ứng dụng GitHub](https://nuxt.com/docs/studio/github) của chúng tôi, sau đó bạn sẽ có thể liên kết kho lưu trữ GitHub với dự án Studio của mình.

Sau khi dự án được tạo, bạn có thể bắt đầu chỉnh sửa các tệp của mình với các biên tập viên Studio và xuất bản các thay đổi của bạn.

## **Enable the Full Editing Experience**

Để mở khóa phạm vi đầy đủ các tính năng trong Studio, hãy đảm bảo URL dự án của bạn được cấu hình đúng cách trong phần triển khai.

**Điều này sẽ kích hoạt tất cả các tính năng Studio bao gồm:**

- **Xem trước trực tiếp trang web của bạn:** ngay lập tức thấy các thay đổi được phản ánh trên trang web của bạn khi bạn làm việc.
- **Tạo biểu mẫu động:** Tự động tạo biểu mẫu để chỉnh sửa các tệp của bạn dựa trên [bộ sưu tập](https://nuxt.com/docs/collections/define) Nuxt Content của bạn.
- **Biên tập viên markdown nâng cao:** tận hưởng trải nghiệm chỉnh sửa được cải thiện, bao gồm khả năng liệt kê và tích hợp [thành phần Vue](https://nuxt.com/docs/studio/content#vue-components) mà bạn đã hiển thị.
- **Cấu hình ứng dụng tự động:** tạo [cấu hình ứng dụng](https://nuxt.com/docs/studio/config) dựa trên lược đồ bạn đã định nghĩa.

::tip
Chúng tôi đang đề xuất triển khai GitHub Pages. Bằng cách sử dụng nó, chúng tôi sẽ xử lý tất cả các yêu cầu cho bạn. Tuy nhiên, nếu bạn muốn sử dụng nền tảng triển khai theo lựa chọn của mình, vui lòng làm theo hướng dẫn đơn giản bên dưới.
::

Để có thể đặt URL của bạn trong Studio, bạn chỉ cần đặt `Preview API` trong cấu hình nội dung của tệp `nuxt.config.ts` của bạn.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  }
})
```

Sau khi triển khai, bạn có thể đảm bảo `Preview API` đã được kích hoạt bằng cách điều hướng đến trang `/__preview.json` trên trang web của bạn. Trang siêu dữ liệu này được tạo tự động bởi mô-đun Content và phải có thể truy cập để kết nối URL của bạn trong phần tự lưu trữ của Studio.

### Troubleshooting

Tệp `__preview.json` được tạo nhưng bạn gặp lỗi `Forbidden error: invalid property check` khi đặt URL của bạn trong phần tự lưu trữ, hãy làm theo các bước sau:

::prose-steps{level="4"}
#### Ensure the `gitInfo` field is set and accurate in the `__preview.json` file

```json [https://your-website.com/__preview.json]
"gitInfo": {
  "name": "content",
  "owner": "nuxt",
  "url": "https://github.com/nuxt/content"
},
```

  :::warning
  Thông tin này nên được điền tự động trong hầu hết các trường hợp. Chúng tôi hỗ trợ hầu hết các nhà cung cấp phổ biến (NuxtHub, Vercel, Netlify, v.v.), nhưng nếu bạn đang sử dụng nhà cung cấp không được hỗ trợ hoặc tùy chỉnh, nó có thể không được lấy chính xác.
  :::

#### Override `gitInfo` in your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio',
      gitInfo: {
        name: 'Your repository name',
        owner: 'Your repository owner/organization',
        url: 'Your GitHub repository URL'
      }
    }
  }
})
```

#### Ensure these fields are correctly set in `__preview.json`

Lỗi `Forbidden` nên được giải quyết và bạn sẽ có thể đặt URL của mình trên Nuxt Studio. Nếu không, vui lòng liên hệ với chúng tôi trên [máy chủ Discord](https://discord.gg/sBXDm6e8SP){rel="nofollow"}.
::


# Real time synchronization between Studio and GitHub

::tip
Phần này giải thích hành vi đồng bộ hóa giữa Studio và GitHub. Quá trình này được xử lý trực tiếp từ nền tảng và không yêu cầu bất kỳ hành động bên ngoài nào. Mục đích của trang này là thuần túy thông tin.
::

## Overview

Nuxt Studio tích hợp với API [GitHub](https://github.com){rel="nofollow"}, cho phép đồng bộ hóa mượt mà giữa Studio và các kho lưu trữ GitHub của bạn. Tích hợp hạng nhất này được thực hiện thông qua việc sử dụng [GitHub Apps](https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps#about-github-apps){rel="nofollow"}.

## Installation

Trong quá trình tạo dự án Studio, bạn sẽ cần cài đặt [Ứng dụng GitHub Nuxt Studio](https://github.com/apps/nuxt-studio){rel="nofollow"} trong tài khoản cá nhân hoặc các tổ chức bạn quản lý. Cài đặt Ứng dụng GitHub yêu cầu quyền sở hữu tổ chức hoặc quyền quản trị trong kho lưu trữ. Nếu bạn thiếu quyền cần thiết, chủ sở hữu kho lưu trữ sẽ cần phê duyệt yêu cầu.

Bạn có thể truy cập trang cài đặt từ bất kỳ đâu trên ứng dụng bằng cách nhấp vào [Cài đặt với GitHub](https://github.com/apps/nuxt-studio/installations/new){rel="nofollow"}.

### Permissions

Trong quá trình cài đặt ứng dụng GitHub của chúng tôi, bạn sẽ được nhắc cấp một số quyền nhất định:

- Quyền đọc đối với `actions`, `metadata`, `members`, và `plan`
- Quyền đọc và ghi đối với `secrets`, `administration`, `contents`, `pages`, `pull requests` và `workflows`

Chúng tôi cần quyền đọc đối với `actions` để gửi thông báo khi chạy workflow thất bại trên pull request hoặc trên nhánh mặc định của kho lưu trữ. `metadata` là bắt buộc để lấy dữ liệu kho lưu trữ, `members` để nhập các thành viên tổ chức và cộng tác viên kho lưu trữ và `plan` được sử dụng để đề xuất các tính năng dựa trên kế hoạch tài khoản GitHub của bạn.

Nuxt Studio hành động thay mặt bạn để tạo kho lưu trữ, nhánh, pull requests, và thực hiện commits và merges. Chúng tôi cũng cung cấp triển khai một cú nhấp chuột lên GitHub Pages với xem trước tức thì của workflows và quản lý bí mật biến môi trường. Để thực hiện điều này, chúng tôi cần quyền đọc và ghi đối với `administration`, `contents`, `pages`, `pull requests`, `workflows` và `secrets`.

### Repositories Installations

Khi cài đặt ứng dụng GitHub của chúng tôi, bạn sẽ được nhắc chọn tất cả kho lưu trữ hoặc một tập con của chúng. Lựa chọn này có thể được thay đổi bất cứ lúc nào bằng cách đi đến [cài đặt ứng dụng GitHub](https://github.com/apps/nuxt-studio/installations/new){rel="nofollow"}.

Bằng cách nhấp vào `Install`, Nuxt Studio sẽ cài đặt từng kho lưu trữ bạn đã chọn, cho phép bạn thực hiện tất cả các hành động được liệt kê ở trên.

## Uninstall

Tất cả dữ liệu nhập từ GitHub được liên kết trực tiếp với cài đặt ứng dụng GitHub của bạn. Nếu bạn gỡ cài đặt ứng dụng GitHub, tất cả dữ liệu liên quan sẽ bị xóa.

Nếu bạn xóa kho lưu trữ GitHub của mình, dự án Nuxt Studio liên quan sẽ được tự động xóa. Tuy nhiên, nếu dự án này đã đăng ký kế hoạch Nhóm, đăng ký sẽ không bị hủy tự động. Bạn sẽ cần kết thúc đăng ký theo cách thủ công qua [Lemon Squeezy]() hoặc [liên hệ với chúng tôi](https://nuxt.com/team@nuxt.studio) để được hỗ trợ.


# Edit your content

Nuxt Studio cung cấp không gian làm việc linh hoạt cho cả nhà phát triển và người viết nội dung, cho họ sự tự do lựa chọn giữa các biên tập viên khác nhau của chúng tôi:

- [Biên tập viên giống Notion](https://nuxt.com/#notion-like-editor-markdown-files) cho tệp `Markdown`
- [Biên tập viên biểu mẫu](https://nuxt.com/#form-editor) cho tệp `YAML` và `JSON`
- [Biên tập viên mã](https://nuxt.com/#code-editor) cho bất kỳ loại tệp nào (chỉ dành cho người dùng kỹ thuật)

::tip
Bạn có thể chọn biên tập viên yêu thích từ trang cài đặt của dự án của bạn.
::

Mỗi biên tập viên phục vụ mục đích riêng của nó. Một số người dùng quen với chỉnh sửa mã, trong khi những người khác thích cách tiếp cận trực quan, không kỹ thuật. Cuối cùng, **cú pháp mã là đầu ra cuối cùng** cho cả hai biên tập viên.

## Notion-like editor (`Markdown` files)

![edit your website with a visual interface](https://nuxt.com/docs/studio/visual-markdown-editor.webp)

Biên tập viên này được lấy cảm hứng mạnh mẽ từ Notion, nổi tiếng với thiết kế trực quan và tính linh hoạt. Giống như một biên tập viên văn bản tiêu chuẩn, biên tập viên này được thiết kế để quen thuộc và dễ sử dụng. Tuy nhiên, nó nổi bật với các tính năng bổ sung cải thiện trải nghiệm viết lách.

::tip{to="https://nuxt.com/blog/visual-editor"}
Bạn muốn biết cách chúng tôi xây dựng biên tập viên này và cách nó hoạt động dưới vỏ bọc? Kiểm tra bài đăng blog này.
::

### Frontmatter

[Frontmatter](https://nuxt.com/docs/files/markdown#frontmatter) là một quy ước của CMS dựa trên Markdown để cung cấp siêu dữ liệu cho các trang, như mô tả hoặc tiêu đề hoặc bất kỳ dữ liệu nào khác bạn muốn lưu trữ dưới dạng cặp `key: value`.

Dựa trên [bộ sưu tập và lược đồ](https://nuxt.com/docs/collections/define) do người dùng cung cấp, một biểu mẫu được tạo để chỉnh sửa siêu dữ liệu này từ biên tập viên.

:video{autoplay controls loop poster="/home/videos/HomeNotionLikePoster.webp" src="https://res.cloudinary.com/nuxt/video/upload/v1739982761/frontmatterform_yjafgt.mp4"}

::prose-note{to="https://nuxt.com/#form-editor-yaml-and-json-files"}
Kiểm tra phần này để tìm hiểu thêm về tạo biểu mẫu dựa trên lược đồ.
::

### Toolbar

Làm nổi bật văn bản của bạn để hiển thị thanh công cụ, cho bạn quyền truy cập vào tất cả các tính năng chỉnh sửa văn bản tiêu chuẩn (định dạng tiêu đề, In đậm, In nghiêng, Gạch ngang, mã, liên kết, lớp, danh sách dấu đầu dòng, danh sách đánh số...).

### Medias

Người dùng có thể đơn giản kéo và thả hình ảnh trực tiếp vào biên tập viên. Một modal tải lên sẽ mở để cho bạn chọn thư mục đích.

Bằng cách gõ `/` và tìm kiếm `Image` hoặc `Video`, họ có thể nhanh chóng chèn một phương tiện. Một modal sẽ mở để cho họ chọn phương tiện họ muốn chèn từ thư viện phương tiện (tức là thư mục `public` của ứng dụng Nuxt).

Từ modal phương tiện, bạn có thể đặt [thuộc tính alt](https://www.w3schools.com/tags/att_img_alt.asp){rel="nofollow"} cho mục đích SEO và khả năng truy cập.

### Vue Components

Một trong những tính năng nổi bật của biên tập viên này là khả năng tích hợp và tùy chỉnh bất kỳ thành phần `Vue` phức tạp nào trực tiếp trong biên tập viên.

#### Create and integrate your own component

Một nhà phát triển có thể tạo bất kỳ loại thành phần phức tạp về mặt thị giác nào và các biên tập viên sẽ có thể sử dụng chúng và tập trung vào nội dung. Một biên tập viên cũng có thể chơi với các thuộc tính thành phần, kiểu dáng và hành vi để phù hợp với yêu cầu cụ thể của họ miễn là nhà phát triển làm cho nó có thể tùy chỉnh.

::steps{level="4"}
#### Create your component

Bạn có thể tạo các thành phần Vue và tích hợp chúng vào Markdown. Chúng chỉ cần được đặt trong thư mục `/components/content` để có sẵn.

```vue [components/content/HomeFeature.vue]
<template>
  <div class="flex items-start gap-3">
    <div class="flex items-center justify-center border rounded-lg p-1.5">
      <UIcon :name="icon" />
    </div>
    <div class="flex flex-col">
      <h3 class="font-semibold">
        <slot name="title" />
      </h3>
      <span>
        <slot name="description" />
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
defineProps({
  icon: {
    type: String,
    default: 'i-ph-cursor-click',
  },
})
</script>
```

#### Integrate these components easily within any Markdown file using [MDC syntax](https://nuxt.com/docs/files/markdown#mdc-syntax)

```mdc [content/index.md]
::home-feature
  ---
  icon: i-mdi-vuejs
  ---
  #title
  Embedded Vue components
  #description
  Edit slots and props inside the Notion-like editor.
::
```

#### Edit them with our Studio editors

Biên tập viên trực quan đơn giản hóa việc chỉnh sửa thành phần, cho phép bạn tích hợp và chỉnh sửa chúng trực tiếp trong biên tập viên trực quan. Người dùng không chuyên có thể chơi với **slots** và **props** mà không cần kiến thức kỹ thuật.

:video{autoplay controls loop src="https://res.cloudinary.com/nuxt/video/upload/v1744126742/studio/finalpropscomps_usfabp.mp4"}

Tất cả các thành phần trong thư mục `/components/content` đều có sẵn trong biên tập viên. Người dùng Studio có thể gõ `/` ở bất kỳ đâu khi chỉnh sửa để truy cập danh sách các thành phần có sẵn.

  :::tip{to="https://nuxt.com/docs/studio/debug"}
  Xem phần này để xác thực tích hợp thành phần 
  
  `Vue`
  
   của bạn trong biên tập viên trong phát triển cục bộ.
  :::
::

#### Integrate built-in components from external libraries

Theo mặc định, bạn có thể tích hợp bất kỳ thành phần nào bên trong tệp Markdown và nó sẽ hoạt động và có thể chỉnh sửa từ Studio nhưng các thành phần bên ngoài **sẽ không được hiển thị trong danh sách thành phần trong Studio và không thể được tích hợp thủ công bởi biên tập viên Studio**.

Để liệt kê thành phần này bên trong Studio và lấy tất cả siêu dữ liệu của nó, bạn cần đặt nó là toàn cục trong tệp cấu hình Nuxt của bạn.

Đây là một ví dụ để tích hợp các thành phần Button và Icon từ thư viện [Nuxt UI](https://ui.nuxt.com){rel="nofollow"}:

```ts
export default defineNuxtConfig({
  hooks: {
    'components:extend': (components) => {
      const globals = components.filter(c => ['UButton', 'UIcon'].includes(c.pascalName))

      globals.forEach(c => c.global = true)
    }
  },
})
```

## Form editor

![YAML and JSON edition with auto generated form](https://nuxt.com/blog/frontmatters.png)

Biên tập viên này được sử dụng cho dù bạn đang chỉnh sửa [frontmatter]() của tệp `Markdown` hoặc tệp `JSON` / `YAML`.

Nó loại bỏ nhu cầu tương tác trực tiếp với cú pháp tệp phức tạp. Thay vào đó, một biểu mẫu được tạo tự động dựa trên [lược đồ bộ sưu tập](https://nuxt.com/docs/collections/define) do người dùng cung cấp.

### **Defining your form with** `zod` Schema

::prose-note{to="https://nuxt.com/docs/collections/define"}
Tìm hiểu thêm về định nghĩa bộ sưu tập lược đồ trong phần dành riêng.
::

Sau khi thuộc tính `schema` đã được định nghĩa trong bộ sưu tập của bạn, điều này sẽ tự động tạo biểu mẫu tương ứng trên giao diện Studio.

::prose-code-group
```ts [content.config.ts]
export default defineContentConfig({
  collections: {
    posts: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        draft: z.boolean().default(false),
        category: z.enum(['Alps', 'Himalaya', 'Pyrenees']).optional(),
        date: z.date(),
        image: z.object({
          src: z.string().editor({ input: 'media' }),
          alt: z.string(),
        }),
        slug: z.string().editor({ hidden: true }),
        icon: z.string().optional().editor({ input: 'icon' }),
        authors: z.array(z.object({
          slug: z.string(),
          username: z.string(),
          name: z.string(),
          to: z.string(),
          avatar: z.object({
            src: z.string(),
            alt: z.string(),
          }),
        })),
      }),
    }),
  },
})
```

  :::code-preview{icon="i-lucide-eye" label="Generated Form"}
  ![Form preview](https://nuxt.com/docs/studio/preview-schema.png)
  :::
::

### **Native Inputs Mapping**

Các loại Zod nguyên thủy được ánh xạ tự động đến các đầu vào biểu mẫu phù hợp trong:

- **String** → Đầu vào văn bản
- **Date** → Bộ chọn ngày
- **Number** → Đầu vào số (bộ đếm)
- **Boolean** → Công tắc chuyển đổi
- **Enum** → Danh sách thả xuống chọn
- **Mảng chuỗi** → Danh sách đầu vào huy hiệu
- **Mảng đối tượng** → Accordion của các mục với biểu mẫu nhúng

:video{autoplay controls loop poster="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.jpg" src="https://res.cloudinary.com/nuxt/video/upload/v1740679550/arrayobjectandstring_r1jpvz.mp4"}

### Custom Inputs Mapping

Studio vượt qua các loại nguyên thủy. Bạn có thể tùy chỉnh các trường biểu mẫu bằng phương thức `editor`, mở rộng các loại Zod với siêu dữ liệu để trao quyền cho giao diện biên tập viên.

Điều này cho phép bạn định nghĩa các đầu vào tùy chỉnh hoặc ẩn các trường.

#### Usage

```ts [content.config.ts]
mainScreen: z.string().editor({ input: 'media' })
```

#### Options

##### `input: 'media' | 'icon'`

Bạn có thể đặt loại đầu vào biên tập viên. Hiện tại `icon` và `media` có sẵn.

##### `hidden: Boolean`

Tùy chọn này có thể được đặt để tránh hiển thị một trường trong biên tập viên Studio.

::prose-tip
Các đầu vào Studio hoàn toàn có thể mở rộng. Chúng tôi có thể tạo bao nhiêu đầu vào tùy thích dựa trên nhu cầu của người dùng.
::

## Code editor

![Edit directly your raw content with our code editor](https://nuxt.com/docs/studio/code-editor.webp)

Mặc dù hai biên tập viên trước đó dành riêng cho một phần mở rộng tệp cụ thể (`md` hoặc `yaml`/`json`). Biên tập viên mã có thể được sử dụng với bất kỳ loại tệp nào.

Nó cung cấp kiểm soát đầy đủ đối với nội dung của bạn, cho phép bạn viết nội dung thô trực tiếp:

- Cú pháp [MDC](https://nuxt.com/docs/files/markdown) cho tệp `Markdown`
- Cú pháp [JSON](https://nuxt.com/docs/files/json) hoặc [YAML](https://nuxt.com/docs/files/yaml)

Khi tệp của bạn được lưu với biên tập viên mã, nội dung được lưu trữ chính xác như bạn đã viết, bảo toàn tất cả cú pháp và định dạng cụ thể. Biên tập viên này lý tưởng cho người dùng thoải mái với cú pháp mã (`Markdown`, `YAML` hoặc `JSON`) muốn kiểm soát chính xác cấu trúc nội dung của họ.


# Manage and integrate Medias in Nuxt Content Studio CMS

## Browse your medias

Tất cả phương tiện nằm trong thư mục `/public` đều có sẵn trong tab **Media** của nền tảng Studio.

![Media gallery on Studio](https://nuxt.com/docs/studio/editors-medias.webp)

Đó là giao diện trực quan cho người dùng không chuyên để quản lý thư mục `/public` của họ.

Người dùng có thể dễ dàng duyệt các thư mục, tải lên phương tiện mới ở bất kỳ cấp nào, và kéo thả phương tiện vào các thư mục khác, làm cho việc tổ chức phương tiện trở nên đơn giản.

Giao diện được thiết kế để trực quan cho người dùng không chuyên. Nó có thể được xem như một IDE thân thiện với người dùng.

## Use it in the Notion-like editor

Người dùng có thể đơn giản kéo và thả hình ảnh trực tiếp vào biên tập viên. Một modal tải lên sẽ mở để cho bạn chọn thư mục đích.

Bằng cách gõ `/` và tìm kiếm `Image`, họ có thể nhanh chóng chèn một phương tiện. Một modal sẽ mở để cho họ chọn phương tiện họ muốn chèn.

Từ modal phương tiện, bạn có thể đặt [thuộc tính alt](https://www.w3schools.com/tags/att_img_alt.asp){rel="nofollow"} cho mục đích SEO và khả năng truy cập.


# Tailor application configuration edition

Khi vào tab **Config** của biên tập viên, bạn có thể duyệt các cấu hình để tùy chỉnh trang web của mình. Các cấu hình này đại diện cho cài đặt được định nghĩa trong tệp `app.config.ts` của bạn.

## `app.config.ts`

Tệp [`app.config.ts`](https://nuxt.com/docs/guide/directory-structure/app-config){rel="nofollow"} là tệp cấu hình được giới thiệu trong Nuxt 3. Đó là tệp TypeScript cho phép bạn cấu hình các khía cạnh khác nhau của cài đặt ứng dụng của bạn. Các nhà phát triển có thể dễ dàng biến bất kỳ trang web nào thành trải nghiệm có thể cấu hình bằng tệp này.

## Customize edition

::prose-note
Đảm bảo bạn có ít nhất một tệp cấu hình trống trong ứng dụng của bạn.

```ts [app.config.ts]
export default defineAppConfig({})
```
::

Để tạo trải nghiệm chỉnh sửa tùy chỉnh cho `app.config.ts` của bạn trong Studio, bạn cần tạo tệp `nuxt.schema.ts` trong dự án của bạn. Lược đồ này phục vụ như một biểu diễn của `app.config.ts` của bạn.

### Helpers

::prose-note
Những trợ giúp này được cung cấp bởi Nuxt Content `Preview API`.
::

- Phương thức `group` cho phép bạn tùy chỉnh các đối tượng cha.
- Phương thức `field` cho phép bạn tùy chỉnh các đầu vào (tức là lá).

```ts [nuxt.schema.ts]
import { field, group } from '@nuxt/content/preview'

export default defineNuxtSchema({
  appConfig: {
    parent: group({
      title: 'Parent title',
      description: 'Parent description.',
      icon: 'i-icon-to-display',
      fields: {
        leaf: field({
          type: 'Type of component used to edit your field',
          title: 'Field title',
          description: 'Field Description',
          icon: 'i-icon-to-display',
          default: 'default value'
        })
      }
    })
  }
})
```

::tip
Không bắt buộc phải bao gồm tất cả các khóa cấu hình ứng dụng của bạn; chỉ những khóa bạn muốn trưng bày trên giao diện Studio cần được thêm vào.
::

#### Input Types

`type` trong tham số đầu tiên của phương thức `field()` có thể chấp nhận các giá trị khác nhau:

- string
- number
- boolean
- array
- object
- icon
- media

Dựa trên các giá trị này, giao diện Studio sẽ thích ứng để hiển thị loại đầu vào phù hợp. Ví dụ, một bộ chọn biểu tượng được hiển thị cho loại `icon` hoặc thư viện phương tiện được hiển thị cho loại `media`.

Văn bản có thể được hiển thị dưới dạng chọn thay vì đầu vào cổ điển nếu bạn cung cấp khóa `required` trong phương thức `field()`:

```ts [nuxt.schema.ts]
import { field, group } from '@nuxt/content/preview'

export default defineNuxtSchema({
  appConfig: {
    parent: group({
      title: 'UI',
      description: 'UI configuration',
      icon: 'i-ph-palette-fill',
      fields: {
        primary: field({
          type: 'string',
          title: 'Primary',
          description: 'Primary color of your UI.',
          icon: 'i-ph-palette',
          default: 'sky',
          required: ['sky', 'mint', 'rose', 'amber']
        })
      }
    })
  }
})
```

### Edit on Studio

Sau khi lược đồ của bạn được triển khai. Bất kỳ người dùng nào cũng có thể truy cập phần **Data** và chơi với biểu mẫu được tạo.

Bất kỳ cập nhật nào trong biểu mẫu sẽ được áp dụng trực tiếp cho tệp `app.config.ts`. Bạn có thể xem xét những thay đổi đó trên trang xem xét.

::code-group
  :::code-preview{icon="i-lucide-eye" label="Preview"}
  ![app config UI on Studio](https://nuxt.com/docs/studio/home-data-studio-dark.webp)
  :::

```ts [nuxt.schema.ts]
export default defineNuxtSchema({
  ui: group({
    title: 'UI',
    description: 'UI Customization.',
    icon: 'i-mdi-palette-outline',
    fields: {
      primary: field({
        type: 'string',
        title: 'Primary',
        description: 'Primary color of your UI.',
        icon: 'i-mdi-palette-outline',
        required: ['sky', 'mint', 'rose', 'amber', 'violet', 'emerald', 'fuchsia', '...']
      }),
      gray: field({ ... }),
      icons: group({
        title: 'Icons',
        description: 'Manage icons used in UI Pro.',
        icon: 'i-mdi-application-settings-outline',
        fields: {
          search: field({ ...}),
          dark: field({ ... }),
          light: field({ ... }),
          external: field({ ...}),
          chevron: field({ ... }),
          hash: field({ ... })
        }
      })
    }
  })
})
```
::

::tip{to="https://nuxt.com/docs/studio/debug"}
Xem phần này để xác thực lược đồ của bạn trong phát triển cục bộ.
::

::tip{to="https://github.com/nuxt-ui-pro/docs/blob/main/nuxt.schema.ts"}
Để có ví dụ thực tế, hãy xem lược đồ chúng tôi đã phát triển cho UI Pro Docs starter.
::


# Local Debug

## Purpose

Mục tiêu của phần này là giải thích cách xác thực tùy chỉnh của bạn cục bộ trước khi xuất bản trên sản xuất.

Nó có thể giúp nếu:

- Bạn muốn tạo tệp `nuxt.schema.ts` và [tạo giao diện phù hợp](https://nuxt.com/docs/studio/config) trên Studio.
- Bạn muốn tích hợp [thành phần Vue tùy chỉnh](https://nuxt.com/docs/studio/content) và đảm bảo chỉnh sửa hoạt động như mong đợi trong biên tập viên.

## Tutorial

::steps
### Import your project on Studio

### Clone your repository on local

### Enable Nuxt Content preview in development

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      // force module initialization on dev env
      dev: true
    }
  }
})
```

### Launch your app using your dev command with `--tunnel` to expose it to the internet

```bash [Terminal]
npx nuxt dev --tunnel
```

![local tunnel expose](https://nuxt.com/docs/studio/dev-tunnel.png)

### Ensure the metadata file has been generated

Tệp `__preview.json` nên có thể truy cập từ `https://your-localtunnel-url/__preview.json`

### Copy the tunnel URL and copy it in the self-hosting section of the deployment tab on Studio platform
::

::tip
Đó là nó! Bây giờ bạn sẽ có thể truy cập giao diện Studio và xác nhận rằng giao diện cấu hình của bạn đã được tạo thành công và các thành phần Vue của bạn có sẵn với props và slots trong biên tập viên.
::

::warning
Bất kỳ sửa đổi nào của tệp `nuxt.config.ts` hoặc bất kỳ thay đổi nào trong tệp Vue đều yêu cầu khởi động lại máy chủ dev Nuxt. Sau khi máy chủ đã khởi động lại, bạn có thể đồng bộ hóa giao diện Studio bằng cách gọi hành động `Sync meta` từ menu lệnh :shortcut{value="meta"} :shortcut{value="K"} . Việc làm mới ứng dụng Studio cũng nên áp dụng cập nhật.
::


# Introduction

:iframe{.rounded-md allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen="true" frameBorder="0" height="100%" referrerPolicy="strict-origin-when-cross-origin" src="https://www.youtube-nocookie.com/embed/_eQxomah-nA?si=pDSzchUBDKb2NQu7" style="aspect-ratio: 16/9;" title="YouTube video player" width="100%"}

## Reka UI

We've transitioned from [Headless UI](https://headlessui.com/){rel="nofollow"} to [Reka UI](https://reka-ui.com/){rel="nofollow"} as our core component foundation. This shift brings several key advantages:

- **Extensive Component Library**: With 55+ primitives, Reka UI significantly expands our component offerings.
- **Active Development**: Reka UI's growing popularity ensures ongoing improvements and updates.
- **Enhanced Accessibility**: Built-in accessibility features align with our commitment to inclusive design.
- **Vue 3 Optimization**: Seamless integration with Vue 3 and the Composition API.

This transition empowers Nuxt UI to become a more comprehensive and flexible UI library, offering developers greater power and customization options.

## Tailwind CSS v4

Nuxt UI integrates the latest Tailwind CSS v4, bringing significant improvements:

- **Built for performance**: Full builds in the new engine are up to 5x faster, and incremental builds are over 100x faster — and measured in microseconds.
- **Unified toolchain**: Built-in import handling, vendor prefixing, and syntax transforms, with no additional tooling required.
- **CSS-first configuration**: A reimagined developer experience where you customize and extend the framework directly in CSS instead of a JavaScript configuration file.
- **Designed for the modern web**: Built on native cascade layers, wide-gamut colors, and including first-class support for modern CSS features like container queries, @starting-style, popovers, and more.

::note
---
ariaLabel: Tailwind CSS v4 upgrade guide
target: _blank
to: https://tailwindcss.com/docs/upgrade-guide#changes-from-v3
---
Learn about all the breaking changes in Tailwind CSS v4.
::

## Tailwind Variants

We've adopted [Tailwind Variants](https://www.tailwind-variants.org/){rel="nofollow"} to manage our design system, offering:

- **Dynamic Styling**: Flexible component variants with a powerful API
- **Type Safety**: Full TypeScript support with auto-completion
- **Conflict Resolution**: Efficient merging of conflicting styles

This integration unifies the styling of components, ensuring consistency and code maintainability.

## TypeScript Integration

Nuxt UI offers significantly improved TypeScript integration, providing a superior developer experience:

- **Enhanced Auto-completion**:
  - Full auto-completion for component props based on your theme
  - Intelligent suggestions for `app.config.ts` theme configuration
- **Generic-based Components**:
  - Built using [Vue 3 Generics](https://vuejs.org/api/sfc-script-setup.html#generics){rel="nofollow"}
  - Improved type inference for slots and events
- **Type-safe Theming**:
  - Leveraging Tailwind Variants for type-safe styling options
  - Customizable types for extended theme configurations

::note
---
ariaLabel: Accordion component with custom slot
to: https://nuxt.com/components/accordion#with-custom-slot
---
Check out an example of the Accordion component with auto-completion for props and slots.
::

## Vue compatibility

You can now use Nuxt UI in any Vue project without Nuxt by adding the Vite and Vue plugins to your configuration. This provides:

- **Auto-imports**: Components and composables are automatically imported and available globally
- **Theming System**: Full theming support with customizable colors, sizes, variants and more
- **Developer Experience**: Complete TypeScript support with IntelliSense and auto-completion

::tip
---
ariaLabel: Vue installation guide
to: https://nuxt.com/getting-started/installation/vue
---
Learn how to install and configure Nuxt UI in a Vue project in the **Vue installation guide**.
::

## Nuxt DevTools Integration

You can play with Nuxt UI components as well as your app components directly from Nuxt Devtools with the [compodium](https://github.com/romhml/compodium){rel="nofollow"} module, providing a powerful development experience:

- **Component Inspector**: Inspect and analyze Nuxt UI components in real-time
- **Live Preview**: Modify component props and see changes instantly
- **Code Generation**: Get the corresponding code for your component configurations

::note
Install the module to your Nuxt application with one command:

```bash [Terminal]
npx nuxt module add compodium
```
::

:video{.w-full.h-auto.rounded controls controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/so_0/v1740751953/nuxt-ui/nuxt-compodium_y2bvqw.jpg"}

## Migration

We want to be transparent: migrating from Nuxt UI v2 to v3 will require significant effort. While we've maintained core concepts and components, Nuxt UI v3 has been rebuilt from the ground up, resulting in a new library with enhanced capabilities.

Key points to consider:

- Read our [migration guide](https://nuxt.com/getting-started/migration) to upgrade your project from v2 to v3.
- Review the new documentation and components carefully before attempting to upgrade.
- If you encounter any issues, please report them on our [GitHub repository](https://github.com/nuxt/ui/issues){rel="nofollow"}.

## FAQ

::accordion
  :::accordion-item{label="Is Nuxt UI compatible with standalone Vue projects?"}
  Nuxt UI is now compatible with Vue! You can follow the [installation guide](https://nuxt.com/getting-started/installation/vue) to get started.
  :::

  :::accordion-item{label="What about Nuxt UI Pro?"}
  We've also rebuilt Nuxt UI Pro from scratch as v3 to match Nuxt UI version. The license you bought or will buy is valid for both Nuxt UI Pro v1 and v3, this is a **free update**. You can follow the [installation guide](https://nuxt.com/getting-started/installation/pro/nuxt) to get started.
  :::

  :::accordion-item
  ---
  label: Will Nuxt UI work with other CSS frameworks like UnoCSS?
  ---
  Nuxt UI is currently designed to work exclusively with Tailwind CSS. While there's interest in UnoCSS support, implementing it would require significant changes to the theme structure due to differences in class naming conventions. As a result, we don't have plans to add UnoCSS support.
  :::

  :::accordion-item{label="How does Nuxt UI handle accessibility?"}
  Nuxt UI enhances accessibility through Reka UI integration. This provides automatic ARIA attributes, keyboard navigation support, intelligent focus management, and screen reader announcements. While offering a strong foundation, proper implementation and testing in your specific use case remains crucial for full accessibility compliance. For more detailed information, refer to [Reka UI's accessibility documentation](https://reka-ui.com/docs/overview/accessibility){rel="nofollow"}.
  :::

  :::accordion-item{label="What is the testing approach for Nuxt UI?"}
  Nuxt UI ensures reliability with 1000+ Vitest tests, covering core functionality and accessibility. This robust testing suite supports the library's stability and serves as a reference for developers.
  :::
::

---

We're excited about the possibilities Nuxt UI v3 brings to your projects. Explore our documentation to learn more about new features, components, and best practices for building powerful, accessible user interfaces.


# Installation

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/installation/vue
---
Looking for the **Vue** version?
::

## Setup

### Add to a Nuxt project

::steps{level="4"}
#### Install the Nuxt UI package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add @nuxt/ui
  ```
  
  ```bash [yarn]
  yarn add @nuxt/ui
  ```
  
  ```bash [npm]
  npm install @nuxt/ui
  ```
  
  ```bash [bun]
  bun add @nuxt/ui
  ```
  :::

  :::warning
  If you're using **pnpm**, ensure that you either set [`shamefully-hoist=true`](https://pnpm.io/npmrc#shamefully-hoist){rel="nofollow"} in your `.npmrc` file or install `tailwindcss` in your project's root directory.
  :::

#### Add the Nuxt UI module in your `nuxt.config.ts`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui']
})
```

#### Import Tailwind CSS and Nuxt UI in your CSS

  :::code-group
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  ```
  
  ```ts [nuxt.config.ts] {3}
  export default defineNuxtConfig({
    modules: ['@nuxt/ui'],
    css: ['~/assets/css/main.css']
  })
  ```
  :::

  :::callout{icon="i-simple-icons-visualstudiocode"}
  It's recommended to install the [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss){rel="nofollow"} extension for VSCode and add the following settings:
  
  ```json [.vscode/settings.json]
  {
    "files.associations": {
      "*.css": "tailwindcss"
    },
    "editor.quickSuggestions": {
      "strings": "on"
    },
    "tailwindCSS.classAttributes": ["class", "ui"],
    "tailwindCSS.experimental.classRegex": [
      ["ui:\\s*{([^)]*)\\s*}", "(?:'|\"|`)([^']*)(?:'|\"|`)"]
    ]
  }
  ```
  :::

#### Wrap your app with App component

```vue [app.vue]
<template>
  <UApp>
    <NuxtPage />
  </UApp>
</template>
```

  :::note{to="https://nuxt.com/components/app"}
  The `App` component provides global configurations and is required for **Toast**, **Tooltip** components to work as well as **Programmatic Overlays**.
  :::
::

### Use our Nuxt Starter

Start your project using the [nuxt/starter#ui](https://github.com/nuxt/starter/tree/ui){rel="nofollow"} template with Nuxt UI pre-configured.

Create a new project locally by running the following command:

```bash [Terminal]
npm create nuxt@latest -- -t ui
```

::note
The `<my-app>` argument is the name of the directory where the project will be created, replace it with your project name.
::

Once the installation is complete, navigate into your project and start the development server:

```bash [Terminal]
cd <my-app>
npm run dev
```

## Options

You can customize Nuxt UI by providing options in your `nuxt.config.ts`.

### `prefix`

Use the `prefix` option to change the prefix of the components.

- Default: `U`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    prefix: 'Nuxt'
  }
})
```

### `fonts`

Use the `fonts` option to enable or disable the [`@nuxt/fonts`](https://github.com/nuxt/fonts){rel="nofollow"} module.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    fonts: false
  }
})
```

### `colorMode`

Use the `colorMode` option to enable or disable the [`@nuxt/color-mode`](https://github.com/nuxt-modules/color-mode){rel="nofollow"} module.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    colorMode: false
  }
})
```

### `theme.colors`

Use the `theme.colors` option to define the dynamic color aliases used to generate components theme.

- Default: `['primary', 'secondary', 'success', 'info', 'warning', 'error']`{.inline,language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    theme: {
      colors: ['primary', 'error']
    }
  }
})
```

::tip{to="https://nuxt.com/getting-started/theme#colors"}
Learn more about color customization and theming in the Theme section.
::

### `theme.transitions`

Use the `theme.transitions` option to enable or disable transitions on components.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    theme: {
      transitions: false
    }
  }
})
```

::note
This option adds the `transition-colors` class on components with hover or active states.
::

### `theme.defaultVariants` :badge{.align-text-top label="New"}

Use the `theme.defaultVariants` option to override the default `color` and `size` variants for components.

- Default: `{ color: 'primary', size: 'md' }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    theme: {
      defaultVariants: {
        color: 'neutral',
        size: 'sm'
      }
    }
  }
})
```

## Continuous Releases

Nuxt UI uses [pkg.pr.new](https://github.com/stackblitz-labs/pkg.pr.new){rel="nofollow"} for continuous preview releases, providing developers with instant access to the latest features and bug fixes without waiting for official releases.

Automatic preview releases are created for all commits and PRs to the `v3` branch. Use them by replacing your package version with the specific commit hash or PR number.

```diff [package.json]
{
  "dependencies": {
-   "@nuxt/ui": "^3.0.0",
+   "@nuxt/ui": "https://pkg.pr.new/@nuxt/ui@4c96909",
  }
}
```

::note
**pkg.pr.new** will automatically comment on PRs with the installation URL, making it easy to test changes.
::


# Installation

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/installation/nuxt
---
Looking for the **Nuxt** version?
::

## Setup

### Add to a Vue project

::steps{level="4"}
#### Install the Nuxt UI package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add @nuxt/ui
  ```
  
  ```bash [yarn]
  yarn add @nuxt/ui
  ```
  
  ```bash [npm]
  npm install @nuxt/ui
  ```
  
  ```bash [bun]
  bun add @nuxt/ui
  ```
  :::

  :::warning
  If you're using **pnpm**, ensure that you either set [`shamefully-hoist=true`](https://pnpm.io/npmrc#shamefully-hoist){rel="nofollow"} in your `.npmrc` file or install `tailwindcss`, `vue-router` and `@unhead/vue` in your project's root directory.
  :::

#### Add the Nuxt UI Vite plugin in your `vite.config.ts`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts] {3,8}
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui()
  ]
})
```

  :::tip
  Nuxt UI registers `unplugin-auto-import` and `unplugin-vue-components`, which will generate `auto-imports.d.ts` and `components.d.ts` type declaration files. You will likely want to gitignore these, and add them to your `tsconfig`.
  
  ```json [tsconfig.app.json]
  {
    "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "auto-imports.d.ts", "components.d.ts"]
  }
  ```
  
  ```bash [.gitignore]
  # Auto-generated type declarations
  auto-imports.d.ts
  components.d.ts
  ```
  :::

  :::tip
  Internally, Nuxt UI relies on custom alias to resolve the theme types. If you're using TypeScript, you should add an alias to your `tsconfig` to enable auto-completion in your `vite.config.ts`.
  
  ```json [tsconfig.node.json]
  {
    "compilerOptions": {
      "paths": {
        "#build/ui": [
          "./node_modules/@nuxt/ui/.nuxt/ui"
        ]
      }
    }
  }
  ```
  :::

#### Use the Nuxt UI Vue plugin in your `main.ts`

```ts [main.ts] {3,14}
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import ui from '@nuxt/ui/vue-plugin'
import App from './App.vue'

const app = createApp(App)

const router = createRouter({
  routes: [],
  history: createWebHistory()
})

app.use(router)
app.use(ui)

app.mount('#app')
```

  :::note{to="https://nuxt.com/#inertia"}
  If you're using [Inertia.js](https://inertiajs.com/){rel="nofollow"}, you can skip the `vue-router` setup as Inertia provides its own routing system.
  :::

#### Import Tailwind CSS and Nuxt UI in your CSS

```css [assets/main.css]
@import "tailwindcss";
@import "@nuxt/ui";
```

  :::tip
  Import the CSS file in your `main.ts`.
  
  ```ts [main.ts] {1}
  import './assets/main.css'
  
  import { createApp } from 'vue'
  import { createRouter, createWebHistory } from 'vue-router'
  import ui from '@nuxt/ui/vue-plugin'
  import App from './App.vue'
  
  const app = createApp(App)
  
  const router = createRouter({
    routes: [],
    history: createWebHistory()
  })
  
  app.use(router)
  app.use(ui)
  
  app.mount('#app')
  ```
  :::

  :::callout{icon="i-simple-icons-visualstudiocode"}
  It's recommended to install the [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss){rel="nofollow"} extension for VSCode and add the following settings:
  
  ```json [.vscode/settings.json]
  {
    "files.associations": {
      "*.css": "tailwindcss"
    },
    "editor.quickSuggestions": {
      "strings": "on"
    },
    "tailwindCSS.classAttributes": ["class", "ui"],
    "tailwindCSS.experimental.classRegex": [
      ["ui:\\s*{([^)]*)\\s*}", "(?:'|\"|`)([^']*)(?:'|\"|`)"]
    ]
  }
  ```
  :::

#### Wrap your app with App component

```vue [App.vue]
<template>
  <UApp>
    <RouterView />
  </UApp>
</template>
```

  :::note{to="https://nuxt.com/components/app"}
  The `App` component sets up global config and is required for **Toast**, **Tooltip** and **programmatic overlays**.
  :::

#### Add the `isolate` class to your root container

```html [index.html] {9}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nuxt UI</title>
  </head>
  <body>
    <div id="app" class="isolate"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

  :::note
  This ensures styles are scoped to your app and prevents issues with overlays and stacking contexts.
  :::
::

### Use our Vue starter

Start your project using the [nuxtlabs/nuxt-ui-vue-starter](https://github.com/nuxtlabs/nuxt-ui-vue-starter){rel="nofollow"} template with Nuxt UI pre-configured.

Create a new project locally by running the following command:

```bash [Terminal]
npm create nuxt@latest -- -t github:nuxtlabs/nuxt-ui-vue-starter
```

::note
The `<my-app>` argument is the name of the directory where the project will be created, replace it with your project name.
::

Once the installation is complete, navigate into your project and start the development server:

```bash [Terminal]
cd <my-app>
npm run dev
```

## Options

You can customize Nuxt UI by providing options in your `vite.config.ts`.

### `prefix`

Use the `prefix` option to change the prefix of the components.

- Default: `U`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      prefix: 'Nuxt'
    })
  ]
})
```

### `ui`

Use the `ui` option to provide configuration for Nuxt UI.

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      ui: {
        colors: {
          primary: 'green',
          neutral: 'slate'
        }
      }
    })
  ]
})
```

### `colorMode`

Use the `colorMode` option to enable or disable the color mode integration from `@vueuse/core`.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      colorMode: false
    })
  ]
})
```

### `theme.colors`

Use the `theme.colors` option to define the dynamic color aliases used to generate components theme.

- Default: `['primary', 'secondary', 'success', 'info', 'warning', 'error']`{.inline,language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      theme: {
        colors: ['primary', 'error']
      }
    })
  ]
})
```

::tip{to="https://nuxt.com/getting-started/theme#colors"}
Learn more about color customization and theming in the Theme section.
::

### `theme.transitions`

Use the `theme.transitions` option to enable or disable transitions on components.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      theme: {
        transitions: false
      }
    })
  ]
})
```

::note
This option adds the `transition-colors` class on components with hover or active states.
::

### `theme.defaultVariants` :badge{.align-text-top label="New"}

Use the `theme.defaultVariants` option to override the default `color` and `size` variants for components.

- Default: `{ color: 'primary', size: 'md' }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      theme: {
        defaultVariants: {
          color: 'neutral',
          size: 'sm'
        }
      }
    })
  ]
})
```

### `inertia`

Use the `inertia` option to enable compatibility with [Inertia.js](https://inertiajs.com/){rel="nofollow"}.

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      inertia: true
    })
  ]
})
```

::note
When using this option, `vue-router` is not required as Inertia.js provides its own routing system. The components that would normally use `RouterLink` will automatically use Inertia's `InertiaLink` component instead.
::

## Continuous Releases

Nuxt UI uses [pkg.pr.new](https://github.com/stackblitz-labs/pkg.pr.new){rel="nofollow"} for continuous preview releases, providing developers with instant access to the latest features and bug fixes without waiting for official releases.

Automatic preview releases are created for all commits and PRs to the `v3` branch. Use them by replacing your package version with the specific commit hash or PR number.

```diff [package.json]
{
  "dependencies": {
-   "@nuxt/ui": "^3.0.0",
+   "@nuxt/ui": "https://pkg.pr.new/@nuxt/ui@4c96909",
  }
}
```

::note
**pkg.pr.new** will automatically comment on PRs with the installation URL, making it easy to test changes.
::


# Migration

Nuxt UI v3 is a new major version rebuilt from the ground up, introducing a modern architecture with significant performance improvements and an enhanced developer experience. This major release includes several breaking changes alongside powerful new features and capabilities:

- **Tailwind CSS v4**: Migration from JavaScript to CSS-based configuration
- **Reka UI**: Replacing Headless UI as the underlying component library
- **Tailwind Variants**: New styling API for component variants

This guide provides step by step instructions to migrate your application from v2 to v3.

## Migrate your project

::steps
### Update Tailwind CSS

Tailwind CSS v4 introduces significant changes to its configuration approach. The official Tailwind upgrade tool will help automate most of the migration process.

  :::note
  ---
  target: _blank
  to: https://tailwindcss.com/docs/upgrade-guide#changes-from-v3
  ---
  For a detailed walkthrough of all changes, refer to the official **Tailwind CSS v4 upgrade guide**.
  :::

1. Create a `main.css` file and import it in your `nuxt.config.ts` file:

  :::code-group
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  ```
  
  ```ts [nuxt.config.ts]
  export default defineNuxtConfig({
    css: ['~/assets/css/main.css']
  })
  ```
  :::

2. Run the Tailwind CSS upgrade tool:

```bash
npx @tailwindcss/upgrade
```

### Update Nuxt UI

3. Install the latest version of the package:

  :::module-only
  #ui
    ::::div
      :::::code-group{sync="pm"}
      ```bash [pnpm]
      pnpm add @nuxt/ui
      ```
      
      ```bash [yarn]
      yarn add @nuxt/ui
      ```
      
      ```bash [npm]
      npm install @nuxt/ui
      ```
      
      ```bash [bun]
      bun add @nuxt/ui
      ```
      :::::
    ::::
  
  #ui-pro
    ::::div
      :::::code-group{sync="pm"}
      ```bash [pnpm]
      pnpm add @nuxt/ui-pro
      ```
      
      ```bash [yarn]
      yarn add @nuxt/ui-pro
      ```
      
      ```bash [npm]
      npm install @nuxt/ui-pro
      ```
      
      ```bash [bun]
      bun add @nuxt/ui-pro
      ```
      :::::
    ::::
  :::

4. Import it in your CSS:

  :::module-only
  #ui
    ::::div
    ```css [app/assets/css/main.css] {2}
    @import "tailwindcss";
    @import "@nuxt/ui";
    ```
    ::::
  
  #ui-pro
    ::::div
    ```css [app/assets/css/main.css] {2}
    @import "tailwindcss";
    @import "@nuxt/ui-pro";
    ```
    ::::
  :::

  :::module-only
  #ui
    ::::div
    5. Wrap your app with the [App](https://nuxt.com/components/app) component:
    ::::
  
  #ui-pro
    ::::div
    5. Add the `@nuxt/ui-pro` module in your `nuxt.config.ts` file as it's no longer a layer:
    
    ```diff [nuxt.config.ts]
    export default defineNuxtConfig({
    -  extends: ['@nuxt/ui-pro'],
    -  modules: ['@nuxt/ui']
    +  modules: ['@nuxt/ui-pro']
    })
    ```
    
    6. Wrap your app with the [App](https://nuxt.com/components/app) component:
    ::::
  :::

```vue [app.vue] {2,4}
<template>
  <UApp>
    <NuxtPage />
  </UApp>
</template>
```
::

## Changes from v2

Now that you have updated your project, you can start migrating your code. Here's a comprehensive list of all the breaking changes in Nuxt UI v3.

### Updated design system

In Nuxt UI v2, we had a mix between a design system with `primary`, `gray`, `error` aliases and all the colors from Tailwind CSS. We've replaced it with a proper [design system](https://nuxt.com/getting-started/theme#design-system) with 7 color aliases:

| Color                          | Default  | Description                                                 |
| ------------------------------ | -------- | ----------------------------------------------------------- |
| `primary`{color="primary"}     | `green`  | Main brand color, used as the default color for components. |
| `secondary`{color="secondary"} | `blue`   | Secondary color to complement the primary color.            |
| `success`{color="success"}     | `green`  | Used for success states.                                    |
| `info`{color="info"}           | `blue`   | Used for informational states.                              |
| `warning`{color="warning"}     | `yellow` | Used for warning states.                                    |
| `error`{color="error"}         | `red`    | Used for form error validation states.                      |
| `neutral`                      | `slate`  | Neutral color for backgrounds, text, etc.                   |

This change introduces several breaking changes that you need to be aware of:

- The `gray` color has been renamed to `neutral`

```diff
<template>
- <p class="text-gray-500 dark:text-gray-400" />
+ <p class="text-neutral-500 dark:text-neutral-400" />
</template>
```

::note
You can also use the new [design tokens](https://nuxt.com/getting-started/theme#neutral-palette) to handle light and dark mode:

```diff
<template>
- <p class="text-gray-500 dark:text-gray-400" />
+ <p class="text-muted" />

- <p class="text-gray-900 dark:text-white" />
+ <p class="text-highlighted" />
</template>
```
::

- The `gray`, `black` and `white` in the `color` props have been removed in favor of `neutral`:

```diff
- <UButton color="black" />
+ <UButton color="neutral" />

- <UButton color="gray" />
+ <UButton color="neutral" variant="subtle" />

- <UButton color="white" />
+ <UButton color="neutral" variant="outline" />
```

- You can no longer use Tailwind CSS colors in the `color` props, use the new aliases instead:

```diff
- <UButton color="red" />
+ <UButton color="error" />
```

::note{to="https://nuxt.com/getting-started/theme#colors"}
Learn how to extend the design system to add new color aliases.
::

- The color configuration in `app.config.ts` has been moved into a `colors` object:

```diff
export default defineAppConfig({
  ui: {
-   primary: 'green',
-   gray: 'cool'
+   colors: {
+     primary: 'green',
+     neutral: 'slate'
+   }
  }
})
```

### Updated theming system

Nuxt UI components are now styled using the [Tailwind Variants API](https://nuxt.com/getting-started/theme#components-theme), which makes all the overrides you made using the `app.config.ts` and the `ui` prop obsolete.

- Update your [`app.config.ts`](https://nuxt.com/getting-started/theme#config) to override components with their new theme:

```diff
export default defineAppConfig({
   ui: {
     button: {
-       font: 'font-bold',
-       default: {
-         size: 'md',
-         color: 'primary'
-       }
+       slots: {
+         base: 'font-medium'
+       },
+       defaultVariants: {
+         size: 'md',
+         color: 'primary'
+       }
     }
   }
})
```

- Update your [`ui` props](https://nuxt.com/getting-started/theme#props) to override each component's slots using their new theme:

```diff
<template>
- <UButton :ui="{ font: 'font-bold' }" />
+ <UButton :ui="{ base: 'font-bold' }" />
</template>
```

::tip{to="https://nuxt.com/components/button#theme"}
We can't detail all the changes here but you can check each component's theme in the **Theme** section.
::

### Renamed components

We've renamed some Nuxt UI components to align with the Reka UI naming convention:

| v2                     | v3                                                                                              |
| ---------------------- | ----------------------------------------------------------------------------------------------- |
| `Divider`              | [`Separator`](https://nuxt.com/components/separator)                                            |
| `Dropdown`             | [`DropdownMenu`](https://nuxt.com/components/dropdown-menu)                                     |
| `FormGroup`            | [`FormField`](https://nuxt.com/components/form-field)                                           |
| `Range`                | [`Slider`](https://nuxt.com/components/slider)                                                  |
| `Toggle`               | [`Switch`](https://nuxt.com/components/switch)                                                  |
| `Notification`         | [`Toast`](https://nuxt.com/components/toast)                                                    |
| `VerticalNavigation`   | [`NavigationMenu`](https://nuxt.com/components/navigation-menu) with `orientation="vertical"`   |
| `HorizontalNavigation` | [`NavigationMenu`](https://nuxt.com/components/navigation-menu) with `orientation="horizontal"` |

::module-only
#ui-pro
  :::div
  Here are the Nuxt UI Pro components that have been renamed or removed:
  
  | v1                      | v3                                                                                                                 |
  | ----------------------- | ------------------------------------------------------------------------------------------------------------------ |
  | `BlogList`              | [`BlogPosts`](https://nuxt.com/components/blog-posts)                                                              |
  | `ColorModeToggle`       | [`ColorModeSwitch`](https://nuxt.com/components/color-mode-switch)                                                 |
  | `DashboardCard`         | Removed (use [`PageCard`](https://nuxt.com/components/page-card) instead)                                          |
  | `DashboardLayout`       | [`DashboardGroup`](https://nuxt.com/components/dashboard-group)                                                    |
  | `DashboardModal`        | Removed (use [`Modal`](https://nuxt.com/components/modal) instead)                                                 |
  | `DashboardNavbarToggle` | [`DashboardSidebarToggle`](https://nuxt.com/components/dashboard-sidebar-toggle)                                   |
  | `DashboardPage`         | Removed                                                                                                            |
  | `DashboardPanelContent` | Removed (use `#body` slot instead)                                                                                 |
  | `DashboardPanelHandle`  | [`DashboardResizeHandle`](https://nuxt.com/components/dashboard-resize-handle)                                     |
  | `DashboardSection`      | Removed (use [`PageCard`](https://nuxt.com/components/page-card) instead)                                          |
  | `DashboardSidebarLinks` | Removed (use [`NavigationMenu`](https://nuxt.com/components/navigation-menu) instead)                              |
  | `DashboardSlideover`    | Removed (use [`Slideover`](https://nuxt.com/components/slideover) instead)                                         |
  | `FooterLinks`           | Removed (use [`NavigationMenu`](https://nuxt.com/components/navigation-menu) instead)                              |
  | `HeaderLinks`           | Removed (use [`NavigationMenu`](https://nuxt.com/components/navigation-menu) instead)                              |
  | `LandingCard`           | Removed (use [`PageCard`](https://nuxt.com/components/page-card) instead)                                          |
  | `LandingCTA`            | [`PageCTA`](https://nuxt.com/components/page-cta)                                                                  |
  | `LandingFAQ`            | Removed (use [`PageAccordion`](https://nuxt.com/components/page-accordion) instead)                                |
  | `LandingGrid`           | Removed (use [`PageGrid`](https://nuxt.com/components/page-grid) instead)                                          |
  | `LandingHero`           | Removed (use [`PageHero`](https://nuxt.com/components/page-hero) instead)                                          |
  | `LandingLogos`          | [`PageLogos`](https://nuxt.com/components/page-logos)                                                              |
  | `LandingSection`        | [`PageSection`](https://nuxt.com/components/page-section)                                                          |
  | `LandingTestimonial`    | Removed (use [`PageCard`](https://nuxt.com/components/page-card#as-a-testimonial) instead)                         |
  | `NavigationAccordion`   | [`ContentNavigation`](https://nuxt.com/components/content-navigation)                                              |
  | `NavigationLinks`       | [`ContentNavigation`](https://nuxt.com/components/content-navigation)                                              |
  | `NavigationTree`        | [`ContentNavigation`](https://nuxt.com/components/content-navigation)                                              |
  | `PageError`             | [`Error`](https://nuxt.com/components/error)                                                                       |
  | `PricingCard`           | [`PricingPlan`](https://nuxt.com/components/pricing-plan)                                                          |
  | `PricingGrid`           | [`PricingPlans`](https://nuxt.com/components/pricing-plans)                                                        |
  | `PricingSwitch`         | Removed (use [`Switch`](https://nuxt.com/components/switch) or [`Tabs`](https://nuxt.com/components/tabs) instead) |
  :::
::

### Changed components

In addition to the renamed components, there are lots of changes to the components API. Let's detail the most important ones:

- The `links` and `options` props have been renamed to `items` for consistency:

```diff
<template>
- <USelect :options="countries" />
+ <USelect :items="countries" />

- <UHorizontalNavigation :links="links" />
+ <UNavigationMenu :items="links" />
</template>
```

::note
This change affects the following components: `Breadcrumb`, `HorizontalNavigation`, `InputMenu`, `RadioGroup`, `Select`, `SelectMenu`, `VerticalNavigation`.
::

- The `click` field in different components has been removed in favor of the native Vue `onClick` event:

```diff
<script setup lang="ts">
const items = [{
  label: 'Edit',
-  click: () => {
+  onClick: () => {
    console.log('Edit')
  }
}]
</script>
```

::note
This change affects the `Toast` component as well as all component that have `items` links like `NavigationMenu`, `DropdownMenu`, `CommandPalette`, etc.
::

- The global `Modals`, `Slideovers` and `Notifications` components have been removed in favor the [App](https://nuxt.com/components/app) component:

```diff [app.vue]
<template>
+  <UApp>
+    <NuxtPage />
+  </UApp>
-  <UModals />
-  <USlideovers />
-  <UNotifications />
</template>
```

- The `v-model:open` directive and `default-open` prop are now used to control visibility:

```diff
<template>
- <UModal v-model="open" />
+ <UModal v-model:open="open" />
</template>
```

::note
This change affects the following components: `ContextMenu`, `Modal` and `Slideover` and enables controlling visibility for `InputMenu`, `Select`, `SelectMenu` and `Tooltip`.
::

- The default slot is now used for the trigger and the content goes inside the `#content` slot (you don't need to use a `v-model:open` directive with this method):

```diff
<script setup lang="ts">
- const open = ref(false)
</script>

<template>
- <UButton label="Open" @click="open = true" />

- <UModal v-model="open">
+ <UModal>
+   <UButton label="Open" />

+   <template #content>
      <div class="p-4">
        <Placeholder class="h-48" />
      </div>
+   </template>
  </UModal>
</template>
```

::note
This change affects the following components: `Modal`, `Popover`, `Slideover`, `Tooltip`.
::

- A `#header`, `#body` and `#footer` slots have been added inside the `#content` slot like the `Card` component:

```diff
<template>
- <UModal>
+ <UModal title="Title" description="Description">
-   <div class="p-4">
+   <template #body>
      <Placeholder class="h-48" />
+   </template>
-   </div>
  </UModal>
</template>
```

::note
This change affects the following components: `Modal`, `Slideover`.
::

### Changed composables

- The `useToast()` composable `timeout` prop has been renamed to `duration`:

```diff
<script setup lang="ts">
const toast = useToast()

- toast.add({ title: 'Invitation sent', timeout: 0 })
+ toast.add({ title: 'Invitation sent', duration: 0 })
</script>
```

- The `useModal` and `useSlideover` composables have been removed in favor of a more generic `useOverlay` composable:

Some important differences:

- The `useOverlay` composable is now used to create overlay instances
- Overlays that are opened, can be awaited for their result
- Overlays can no longer be close using `modal.close()` or `slideover.close()`, rather, they close automatically: either when a `close` event is fired explicitly from the opened component OR when the overlay closes itself (clicking on backdrop, pressing the ESC key, etc)
- To capture the return value in the parent component you must explictly emit a `close` event with the desired value

```diff
<script setup lang="ts">
import { ModalExampleComponent } from '#components'

- const modal = useModal()
+ const overlay = useOverlay()

- modal.open(ModalExampleComponent)
+ const modal = overlay.create(ModalExampleComponent)
</script>
```

Props are now passed through a props attribute:

```diff
<script setup lang="ts">
import { ModalExampleComponent } from '#components'

- const modal = useModal()
+ const overlay = useOverlay()

const count = ref(0)

- modal.open(ModalExampleComponent, {
-   count: count.value
- })
+ const modal = overlay.create(ModalExampleComponent, {
+   props: {
+     count: count.value
+   }
+ })
</script>
```

Closing a modal is now done through the `close` event. The `modal.open` method now returns an instance that can be used to await for the result of the modal whenever the modal is closed:

```diff
<script setup lang="ts">
import { ModalExampleComponent } from '#components'

- const modal = useModal()
+ const overlay = useOverlay()

+ const modal = overlay.create(ModalExampleComponent)

- function openModal() {
-   modal.open(ModalExampleComponent, {
-     onSuccess() {
-       toast.add({ title: 'Success!' })
-     }
-   })
- }
+ async function openModal() {
+   const instance = modal.open(ModalExampleComponent, {
+     count: count.value
+   })
+
+   const result = await instance.result
+
+   if (result) {
+     toast.add({ title: 'Success!' })
+   }
+ }
</script>
```

### Changed form validation

- The error object property for targeting form fields has been renamed from `path` to `name`:

```diff
<script setup lang="ts">
const validate = (state: any): FormError[] => {
  const errors = []
  if (!state.email) {
    errors.push({
-     path: 'email',
+     name: 'email',
      message: 'Required'
    })
  }
  if (!state.password) {
    errors.push({
-     path: 'password',
+     name: 'password',
      message: 'Required'
    })
  }
  return errors
}
</script>
```

---

::warning
This page is a work in progress, we'll improve it regularly.
::


# Theme

## Tailwind CSS

Nuxt UI uses Tailwind CSS v4, you can read the official [upgrade guide](https://tailwindcss.com/docs/upgrade-guide#changes-from-v3){rel="nofollow"} to learn about all the breaking changes.

### `@theme`

Tailwind CSS v4 takes a CSS-first configuration approach, you now customize your theme with CSS variables inside a [`@theme`](https://tailwindcss.com/docs/functions-and-directives#theme-directive){rel="nofollow"} directive to define your project's custom design tokens, like fonts, colors, and breakpoints:

::module-only
#ui
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @theme static {
    --font-sans: 'Public Sans', sans-serif;
  
    --breakpoint-3xl: 1920px;
  
    --color-green-50: #EFFDF5;
    --color-green-100: #D9FBE8;
    --color-green-200: #B3F5D1;
    --color-green-300: #75EDAE;
    --color-green-400: #00DC82;
    --color-green-500: #00C16A;
    --color-green-600: #00A155;
    --color-green-700: #007F45;
    --color-green-800: #016538;
    --color-green-900: #0A5331;
    --color-green-950: #052E16;
  }
  ```
  :::

#ui-pro
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @theme static {
    --font-sans: 'Public Sans', sans-serif;
  
    --breakpoint-3xl: 1920px;
  
    --color-green-50: #EFFDF5;
    --color-green-100: #D9FBE8;
    --color-green-200: #B3F5D1;
    --color-green-300: #75EDAE;
    --color-green-400: #00DC82;
    --color-green-500: #00C16A;
    --color-green-600: #00A155;
    --color-green-700: #007F45;
    --color-green-800: #016538;
    --color-green-900: #0A5331;
    --color-green-950: #052E16;
  }
  ```
  :::
::

The `@theme` directive tells Tailwind to make new utilities and variants available based on these variables. It's the equivalent of the `theme.extend` key in Tailwind CSS v3 `tailwind.config.ts` file.

::note{target="_blank" to="https://tailwindcss.com/docs/theme"}
Learn more about customizing your theme in the theme variables documentation.
::

### `@source`

You can use the [`@source` directive](https://tailwindcss.com/docs/functions-and-directives#source-directive){rel="nofollow"} to explicitly specify source files that aren't picked up by Tailwind's automatic content detection:

This can be useful when writing Tailwind CSS classes in markdown files with [`@nuxt/content`](https://github.com/nuxt/content){rel="nofollow"} for example:

::module-only
#ui
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @source "../../../content";
  /* Use this if you're not using compatibilityVersion: 4: https://nuxt.com/docs/getting-started/upgrade#opting-in-to-nuxt-4 */
  @source "../../content";
  ```
  :::

#ui-pro
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @source "../../../content";
  /* Use this if you're not using compatibilityVersion: 4: https://nuxt.com/docs/getting-started/upgrade#opting-in-to-nuxt-4 */
  @source "../../content";
  ```
  :::
::

::note{to="https://tailwindcss.com/docs/detecting-classes-in-source-files"}
Learn more about automatic content detection in the detecting classes in source files documentation.
::

## Design system

Nuxt UI extends Tailwind CSS's theming capabilities, providing a flexible design system with pre-configured color aliases based on [Tailwind CSS colors](https://tailwindcss.com/docs/customizing-colors#color-palette-reference){rel="nofollow"}. This allows for easy customization and quick adaptation of the UI to your brand's aesthetic.

| Color                          | Default  | Description                                                 |
| ------------------------------ | -------- | ----------------------------------------------------------- |
| `primary`{color="primary"}     | `green`  | Main brand color, used as the default color for components. |
| `secondary`{color="secondary"} | `blue`   | Secondary color to complement the primary color.            |
| `success`{color="success"}     | `green`  | Used for success states.                                    |
| `info`{color="info"}           | `blue`   | Used for informational states.                              |
| `warning`{color="warning"}     | `yellow` | Used for warning states.                                    |
| `error`{color="error"}         | `red`    | Used for form error validation states.                      |
| `neutral`                      | `slate`  | Neutral color for backgrounds, text, etc.                   |

These colors are used to style the components but also to generate the `color` props:

::component-code
---
props:
  color: primary
slots:
  default: Button
slug: button
---
::

::note
Try the :prose-icon{.text-primary name="i-lucide-swatch-book"} theme picker in the header above to change `primary` and `neutral` colors.
::

### Configuration

::framework-only
#nuxt
  :::div
  You can configure these color aliases at runtime in your [`app.config.ts`](https://nuxt.com/docs/guide/directory-structure/app-config#app-config-file){rel="nofollow"} file under the `ui.colors` key, allowing for dynamic theme customization without requiring an application rebuild:
  
  ```ts [app.config.ts]
  export default defineAppConfig({
    ui: {
      colors: {
        primary: 'blue',
        neutral: 'zinc'
      }
    }
  })
  ```
  :::

#vue
  :::div
  You can configure these color aliases at runtime in your `vite.config.ts` file under the `ui.colors` key:
  
    ::::module-only
    #ui
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import ui from '@nuxt/ui/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          ui({
            ui: {
              colors: {
                primary: 'blue',
                neutral: 'zinc'
              }
            }
          })
        ]
      })
      ```
      :::::
    
    #ui-pro
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import uiPro from '@nuxt/ui-pro/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          uiPro({
            ui: {
              colors: {
                primary: 'blue',
                neutral: 'zinc'
              }
            }
          })
        ]
      })
      ```
      :::::
    ::::
  :::
::

::caution
When configuring your theme colors, you must use either color names from the [default Tailwind palette](https://tailwindcss.com/docs/colors){rel="nofollow"} (like 'blue', 'green', etc.) or reference custom colors that you've previously defined in your [CSS file](https://nuxt.com/#theme).
::

### Extend colors

::framework-only
#nuxt
  :::div
  You can add you own dynamic color aliases in your `app.config.ts`, you just have to make sure to define them in the [`ui.theme.colors`](https://nuxt.com/getting-started/installation/nuxt#themecolors) option in your `nuxt.config.ts` file:
  
  ```ts [app.config.ts] {4}
  export default defineAppConfig({
    ui: {
      colors: {
        tertiary: 'indigo'
      }
    }
  })
  ```
  
  ```ts [nuxt.config.ts] {7}
  export default defineNuxtConfig({
    ui: {
      theme: {
        colors: [
          'primary',
          'secondary',
          'tertiary',
          'info',
          'success',
          'warning',
          'error'
        ]
      }
    }
  })
  ```
  :::

#vue
  :::div
  You can add you own dynamic color aliases in your `vite.config.ts`, you just have to make sure to also define them in the [`theme.colors`](https://nuxt.com/getting-started/installation/vue#themecolors) option of the `ui` plugin:
  
    ::::module-only
    #ui
      :::::div
      ```ts [vite.config.ts] {11,18}
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import ui from '@nuxt/ui/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          ui({
            ui: {
              colors: {
                tertiary: 'indigo'
              }
            },
            theme: {
              colors: [
                'primary',
                'secondary',
                'tertiary',
                'info',
                'success',
                'warning',
                'error'
              ]
            }
          })
        ]
      })
      ```
      :::::
    
    #ui-pro
      :::::div
      ```ts [vite.config.ts] {11,18}
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import uiPro from '@nuxt/ui-pro/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          uiPro({
            ui: {
              colors: {
                tertiary: 'indigo'
              }
            },
            theme: {
              colors: [
                'primary',
                'secondary',
                'tertiary',
                'info',
                'success',
                'warning',
                'error'
              ]
            }
          })
        ]
      })
      ```
      :::::
    ::::
  :::
::

## CSS Variables

Nuxt UI leverages a robust system of CSS variables as design tokens to ensure consistent and flexible component styling. These tokens form the foundation of the theming system, offering smooth support for both light and dark modes.

### Colors

Nuxt UI provides a CSS variable for each color alias you define which represent the default shade used in both light and dark modes:

::code-group
```css [Light]
:root {
  --ui-primary: var(--ui-color-primary-500);
  --ui-secondary: var(--ui-color-secondary-500);
  --ui-success: var(--ui-color-success-500);
  --ui-info: var(--ui-color-info-500);
  --ui-warning: var(--ui-color-warning-500);
  --ui-error: var(--ui-color-error-500);
}
```

```css [Dark]
.dark {
  --ui-primary: var(--ui-color-primary-400);
  --ui-secondary: var(--ui-color-secondary-400);
  --ui-success: var(--ui-color-success-400);
  --ui-info: var(--ui-color-info-400);
  --ui-warning: var(--ui-color-warning-400);
  --ui-error: var(--ui-color-error-400);
}
```
::

These CSS variables are defined in Tailwind CSS's `@theme` so you can use them as classes:

::code-preview
[Primary]{.text-primary.text-sm.px-4}[Secondary]{.text-secondary.text-sm.px-4}[Success]{.text-success.text-sm.px-4}[Info]{.text-info.text-sm.px-4}[Warning]{.text-warning.text-sm.px-4}[Error]{.text-error.text-sm.px-4}

#code
```vue
<template>
  <span class="text-primary">Primary</span>
  <span class="text-secondary">Secondary</span>
  <span class="text-success">Success</span>
  <span class="text-info">Info</span>
  <span class="text-warning">Warning</span>
  <span class="text-error">Error</span>
</template>
```
::

::note
This is how the `@theme` is generated for each color alias:

  :::code-collapse{class="[&>div]:!my-0"}
  ```scss
  @theme default {
    --color-primary: var(--ui-primary);
    --color-primary-50: var(--ui-color-primary-50);
    --color-primary-100: var(--ui-color-primary-100);
    --color-primary-200: var(--ui-color-primary-200);
    --color-primary-300: var(--ui-color-primary-300);
    --color-primary-400: var(--ui-color-primary-400);
    --color-primary-500: var(--ui-color-primary-500);
    --color-primary-600: var(--ui-color-primary-600);
    --color-primary-700: var(--ui-color-primary-700);
    --color-primary-800: var(--ui-color-primary-800);
    --color-primary-900: var(--ui-color-primary-900);
    --color-primary-950: var(--ui-color-primary-950);
    --color-secondary: var(--ui-secondary);
    --color-secondary-50: var(--ui-color-secondary-50);
    --color-secondary-100: var(--ui-color-secondary-100);
    --color-secondary-200: var(--ui-color-secondary-200);
    --color-secondary-300: var(--ui-color-secondary-300);
    --color-secondary-400: var(--ui-color-secondary-400);
    --color-secondary-500: var(--ui-color-secondary-500);
    --color-secondary-600: var(--ui-color-secondary-600);
    --color-secondary-700: var(--ui-color-secondary-700);
    --color-secondary-800: var(--ui-color-secondary-800);
    --color-secondary-900: var(--ui-color-secondary-900);
    --color-secondary-950: var(--ui-color-secondary-950);
    --color-success: var(--ui-success);
    --color-success-50: var(--ui-color-success-50);
    --color-success-100: var(--ui-color-success-100);
    --color-success-200: var(--ui-color-success-200);
    --color-success-300: var(--ui-color-success-300);
    --color-success-400: var(--ui-color-success-400);
    --color-success-500: var(--ui-color-success-500);
    --color-success-600: var(--ui-color-success-600);
    --color-success-700: var(--ui-color-success-700);
    --color-success-800: var(--ui-color-success-800);
    --color-success-900: var(--ui-color-success-900);
    --color-success-950: var(--ui-color-success-950);
    --color-info: var(--ui-info);
    --color-info-50: var(--ui-color-info-50);
    --color-info-100: var(--ui-color-info-100);
    --color-info-200: var(--ui-color-info-200);
    --color-info-300: var(--ui-color-info-300);
    --color-info-400: var(--ui-color-info-400);
    --color-info-500: var(--ui-color-info-500);
    --color-info-600: var(--ui-color-info-600);
    --color-info-700: var(--ui-color-info-700);
    --color-info-800: var(--ui-color-info-800);
    --color-info-900: var(--ui-color-info-900);
    --color-info-950: var(--ui-color-info-950);
    --color-warning: var(--ui-warning);
    --color-warning-50: var(--ui-color-warning-50);
    --color-warning-100: var(--ui-color-warning-100);
    --color-warning-200: var(--ui-color-warning-200);
    --color-warning-300: var(--ui-color-warning-300);
    --color-warning-400: var(--ui-color-warning-400);
    --color-warning-500: var(--ui-color-warning-500);
    --color-warning-600: var(--ui-color-warning-600);
    --color-warning-700: var(--ui-color-warning-700);
    --color-warning-800: var(--ui-color-warning-800);
    --color-warning-900: var(--ui-color-warning-900);
    --color-warning-950: var(--ui-color-warning-950);
    --color-error: var(--ui-error);
    --color-error-50: var(--ui-color-error-50);
    --color-error-100: var(--ui-color-error-100);
    --color-error-200: var(--ui-color-error-200);
    --color-error-300: var(--ui-color-error-300);
    --color-error-400: var(--ui-color-error-400);
    --color-error-500: var(--ui-color-error-500);
    --color-error-600: var(--ui-color-error-600);
    --color-error-700: var(--ui-color-error-700);
    --color-error-800: var(--ui-color-error-800);
    --color-error-900: var(--ui-color-error-900);
    --color-error-950: var(--ui-color-error-950);
    --color-neutral-50: var(--ui-color-neutral-50);
    --color-neutral-100: var(--ui-color-neutral-100);
    --color-neutral-200: var(--ui-color-neutral-200);
    --color-neutral-300: var(--ui-color-neutral-300);
    --color-neutral-400: var(--ui-color-neutral-400);
    --color-neutral-500: var(--ui-color-neutral-500);
    --color-neutral-600: var(--ui-color-neutral-600);
    --color-neutral-700: var(--ui-color-neutral-700);
    --color-neutral-800: var(--ui-color-neutral-800);
    --color-neutral-900: var(--ui-color-neutral-900);
    --color-neutral-950: var(--ui-color-neutral-950);
  }
  ```
  :::
::

You can change which shade is used for each color on light and dark mode in your `main.css` file:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-primary: var(--ui-color-primary-700);
  }
  
  .dark {
    --ui-primary: var(--ui-color-primary-200);
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-primary: var(--ui-color-primary-700);
  }
  
  .dark {
    --ui-primary: var(--ui-color-primary-200);
  }
  ```
  :::
::

::framework-only
#nuxt
You cannot set `primary: 'black'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} in your [`app.config.ts`](https://nuxt.com/#config) because this color has no shade, instead you can override the primary color in your `main.css` file to create a black & white theme:

#vue
You cannot set `primary: 'black'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} in your [`vite.config.ts`](https://nuxt.com/#config) because this color has no shade, instead you can override the primary color in your `main.css` file to create a black & white theme:
::

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-primary: black;
  }
  
  .dark {
    --ui-primary: white;
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-primary: black;
  }
  
  .dark {
    --ui-primary: white;
  }
  ```
  :::
::

### Neutral

Nuxt UI provides a comprehensive set of design tokens for the `neutral` color palette, ensuring consistent and accessible UI styling across both light and dark modes. These tokens offer fine-grained control over text, background, and border colors:

::code-group
```css [Light]
:root {
  --ui-text-dimmed: var(--ui-color-neutral-400);
  --ui-text-muted: var(--ui-color-neutral-500);
  --ui-text-toned: var(--ui-color-neutral-600);
  --ui-text: var(--ui-color-neutral-700);
  --ui-text-highlighted: var(--ui-color-neutral-900);
  --ui-text-inverted: var(--color-white);

  --ui-bg: var(--color-white);
  --ui-bg-muted: var(--ui-color-neutral-50);
  --ui-bg-elevated: var(--ui-color-neutral-100);
  --ui-bg-accented: var(--ui-color-neutral-200);
  --ui-bg-inverted: var(--ui-color-neutral-900);

  --ui-border: var(--ui-color-neutral-200);
  --ui-border-muted: var(--ui-color-neutral-200);
  --ui-border-accented: var(--ui-color-neutral-300);
  --ui-border-inverted: var(--ui-color-neutral-900);
}
```

```css [Dark]
.dark {
  --ui-text-dimmed: var(--ui-color-neutral-500);
  --ui-text-muted: var(--ui-color-neutral-400);
  --ui-text-toned: var(--ui-color-neutral-300);
  --ui-text: var(--ui-color-neutral-200);
  --ui-text-highlighted: var(--color-white);
  --ui-text-inverted: var(--ui-color-neutral-900);

  --ui-bg: var(--ui-color-neutral-900);
  --ui-bg-muted: var(--ui-color-neutral-800);
  --ui-bg-elevated: var(--ui-color-neutral-800);
  --ui-bg-accented: var(--ui-color-neutral-700);
  --ui-bg-inverted: var(--color-white);

  --ui-border: var(--ui-color-neutral-800);
  --ui-border-muted: var(--ui-color-neutral-700);
  --ui-border-accented: var(--ui-color-neutral-700);
  --ui-border-inverted: var(--color-white);
}
```
::

These CSS variables are defined in Tailwind CSS's `@theme` so you can use them as classes:

::code-preview
[Dimmed]{.text-dimmed.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Muted]{.text-muted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Toned]{.text-toned.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Text]{.text-default.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Highlighted]{.text-highlighted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Inverted]{.text-inverted.bg-inverted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}

#code
```vue
<template>
  <span class="text-dimmed">Dimmed</span>
  <span class="text-muted">Muted</span>
  <span class="text-toned">Toned</span>
  <span class="text-default">Text</span>
  <span class="text-highlighted">Highlighted</span>
  <span class="text-inverted bg-inverted">Inverted</span>
</template>
```
::

::code-preview
[Default]{.bg-default.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Muted]{.bg-muted.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Elevated]{.bg-elevated.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Accented]{.bg-accented.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Inverted]{.bg-inverted.text-inverted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}

#code
```vue
<template>
  <div class="bg-default">Default</div>
  <div class="bg-muted">Muted</div>
  <div class="bg-elevated">Elevated</div>
  <div class="bg-accented">Accented</div>
  <div class="bg-inverted text-inverted">Inverted</div>
</template>
```
::

::code-preview
[Default]{.border-2.border-default.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Muted]{.border-2.border-muted.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Accented]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Inverted]{.border-2.border-inverted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}

#code
```vue
<template>
  <div class="border border-default">Default</div>
  <div class="border border-muted">Muted</div>
  <div class="border border-accented">Accented</div>
  <div class="border border-inverted">Inverted</div>
</template>
```
::

::note
This is how the `@theme` is generated for each design token:

  :::code-collapse{class="[&>div]:!my-0"}
  ```scss
  @theme default {
    --text-color-dimmed: var(--ui-text-dimmed);
    --text-color-muted: var(--ui-text-muted);
    --text-color-toned: var(--ui-text-toned);
    --text-color-default: var(--ui-text);
    --text-color-highlighted: var(--ui-text-highlighted);
    --text-color-inverted: var(--ui-text-inverted);
    --background-color-default: var(--ui-bg);
    --background-color-muted: var(--ui-bg-muted);
    --background-color-elevated: var(--ui-bg-elevated);
    --background-color-accented: var(--ui-bg-accented);
    --background-color-inverted: var(--ui-bg-inverted);
    --background-color-border: var(--ui-border);
    --border-color-default: var(--ui-border);
    --border-color-muted: var(--ui-border-muted);
    --border-color-accented: var(--ui-border-accented);
    --border-color-inverted: var(--ui-border-inverted);
    --border-color-bg: var(--ui-bg);
    --ring-color-default: var(--ui-border);
    --ring-color-muted: var(--ui-border-muted);
    --ring-color-accented: var(--ui-border-accented);
    --ring-color-inverted: var(--ui-border-inverted);
    --ring-color-bg: var(--ui-bg);
    --ring-offset-color-default: var(--ui-border);
    --ring-offset-color-muted: var(--ui-border-muted);
    --ring-offset-color-accented: var(--ui-border-accented);
    --ring-offset-color-inverted: var(--ui-border-inverted);
    --ring-offset-color-bg: var(--ui-bg);
    --divide-color-default: var(--ui-border);
    --divide-color-muted: var(--ui-border-muted);
    --divide-color-accented: var(--ui-border-accented);
    --divide-color-inverted: var(--ui-border-inverted);
    --divide-color-bg: var(--ui-bg);
    --outline-color-default: var(--ui-border);
    --outline-color-inverted: var(--ui-border-inverted);
    --stroke-color-default: var(--ui-border);
    --stroke-color-inverted: var(--ui-border-inverted);
    --fill-color-default: var(--ui-border);
    --fill-color-inverted: var(--ui-border-inverted);
  }
  ```
  :::
::

You can customize these CSS variables to tailor the appearance of your application in your `main.css` file:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-bg: var(--ui-color-neutral-50);
    --ui-text: var(--ui-color-neutral-900);
  }
  
  .dark {
    --ui-bg: var(--ui-color-neutral-950);
    --ui-border: var(--ui-color-neutral-900);
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-bg: var(--ui-color-neutral-50);
    --ui-text: var(--ui-color-neutral-900);
  }
  
  .dark {
    --ui-bg: var(--ui-color-neutral-950);
    --ui-border: var(--ui-color-neutral-900);
  }
  ```
  :::
::

::note
Nuxt UI applies a text and background color on the `<body>` element of your app:

```css
body {
  @apply antialiased text-default bg-default scheme-light dark:scheme-dark;
}
```
::

### Radius

Nuxt UI provides a centralized border radius system through the `--ui-radius` CSS variable.

```css
:root {
  --ui-radius: 0.25rem;
}
```

This CSS variable replaces Tailwind CSS's default `rounded-*` utilities so you can use the same class names:

::code-preview
[xs]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-xs.mr-2 class="py-1.5"}[sm]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-sm.mr-2 class="py-1.5"}[md]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[lg]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-lg.mr-2 class="py-1.5"}[xl]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-xl.mr-2 class="py-1.5"}[2xl]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-2xl.mr-2 class="py-1.5"}[3xl]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-3xl.mr-2 class="py-1.5"}

#code
```vue
<template>
  <div class="rounded-xs">xs</div>
  <div class="rounded-sm">sm</div>
  <div class="rounded-md">md</div>
  <div class="rounded-lg">lg</div>
  <div class="rounded-xl">xl</div>
  <div class="rounded-2xl">2xl</div>
  <div class="rounded-3xl">3xl</div>
</template>
```
::

::note
This is how the `@theme` is generated for each radius value:

  :::code-collapse{class="[&>div]:!my-0"}
  ```scss
  @theme default {
    --radius-xs: calc(var(--ui-radius) * 0.5);    /* 0.125rem */
    --radius-sm: var(--ui-radius);                /* 0.25rem */
    --radius-md: calc(var(--ui-radius) * 1.5);    /* 0.375rem */
    --radius-lg: calc(var(--ui-radius) * 2);      /* 0.5rem */
    --radius-xl: calc(var(--ui-radius) * 3);      /* 0.75rem */
    --radius-2xl: calc(var(--ui-radius) * 4);     /* 1rem */
    --radius-3xl: calc(var(--ui-radius) * 6);     /* 1.5rem */
  }
  ```
  :::
::

You can customize the base radius value in your `main.css` file:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-radius: 0.5rem;
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-radius: 0.5rem;
  }
  ```
  :::
::

::note
Try the :prose-icon{.text-primary name="i-lucide-swatch-book"} theme picker in the header above to change the base radius value.
::

### Container

Nuxt UI provides a `--ui-container` CSS variable that controls the maximum width of the [Container](https://nuxt.com/components/container) component.

```css
:root {
  --ui-container: var(--container-7xl);
}
```

You can customize this value in your `main.css` file to adjust container widths consistently throughout your application:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @theme {
    --container-8xl: 90rem;
  }
  
  :root {
    --ui-container: var(--container-8xl);
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @theme {
    --container-8xl: 90rem;
  }
  
  :root {
    --ui-container: var(--container-8xl);
  }
  ```
  :::
::

## Components theme

Nuxt UI components are styled using the [Tailwind Variants](https://www.tailwind-variants.org/){rel="nofollow"} API, which provides a powerful way to create variants and manage component styles. Let's explore the key features of this API:

### Slots

Components in Nuxt UI can have multiple `slots`, each representing a distinct HTML element or section within the component. These slots allow for flexible content insertion and styling. Let's take the [Card](https://nuxt.com/components/card) component as an example:

::code-group
```ts [src/theme/card.ts]
export default {
  slots: {
    root: 'bg-default ring ring-default divide-y divide-default rounded-lg',
    header: 'p-4 sm:px-6',
    body: 'p-4 sm:p-6',
    footer: 'p-4 sm:px-6'
  }
}
```

```vue [src/runtime/components/Card.vue]
<template>
  <div :class="ui.root({ class: [props.ui?.root, props.class] })">
    <div :class="ui.header({ class: props.ui?.header })">
      <slot name="header" />
    </div>

    <div :class="ui.body({ class: props.ui?.body })">
      <slot />
    </div>

    <div :class="ui.footer({ class: props.ui?.footer })">
      <slot name="footer" />
    </div>
  </div>
</template>
```
::

Some components don't have slots, they are just composed of a single root element. In this case, the theme only defines the `base` slot like the [Container](https://nuxt.com/components/container) component for example:

::code-group
```ts [src/theme/container.ts]
export default {
  base: 'max-w-(--ui-container) mx-auto px-4 sm:px-6 lg:px-8'
}
```

```vue [src/runtime/components/Container.vue]
<template>
  <div :class="container({ class: props.class })">
    <slot />
  </div>
</template>
```
::

::warning
Components without slots don't have a [`ui` prop](https://nuxt.com/#ui-prop), only the [`class` prop](https://nuxt.com/#class-prop) is available to override styles.
::

### Variants

Nuxt UI components use `variants` to change the `slots` styles based on props. Here's an example of the [Avatar](https://nuxt.com/components/avatar) component:

```ts [src/theme/avatar.ts]
export default {
  slots: {
    root: 'inline-flex items-center justify-center shrink-0 select-none overflow-hidden rounded-full align-middle bg-elevated',
    image: 'h-full w-full rounded-[inherit] object-cover'
  },
  variants: {
    size: {
      sm: {
        root: 'size-7 text-sm'
      },
      md: {
        root: 'size-8 text-base'
      },
      lg: {
        root: 'size-9 text-lg'
      }
    }
  },
  defaultVariants: {
    size: 'md'
  }
}
```

This way, the `size` prop will apply the corresponding styles to the `root` slot:

::component-code
---
ignore:
  - src
props:
  src: https://github.com/nuxt.png
  size: lg
slug: avatar
---
::

The `defaultVariants` property specifies the default values for each variant. It determines how a component looks and behaves when no prop is provided.

::framework-only
#nuxt
  :::tip
  These default values can be customized in your [`app.config.ts`](https://nuxt.com/#config) to adjust the standard appearance of components throughout your application.
  :::

#vue
  :::tip
  These default values can be customized in your [`vite.config.ts`](https://nuxt.com/#config) to adjust the standard appearance of components throughout your application.
  :::
::

## Customize theme

You have multiple ways to customize the appearance of Nuxt UI components, you can do it for all components at once or on a per-component basis.

::note
Tailwind Variants uses [`tailwind-merge`](https://github.com/dcastil/tailwind-merge){rel="nofollow"} under the hood to merge classes so you don't have to worry about conflicting classes.
::

::tip
You can explore the theme for each component in two ways:

- Check the `Theme` section in the documentation of each individual component.
- Browse the source code directly in the GitHub repository at [`v3/src/theme`](https://github.com/nuxt/ui/tree/v3/src/theme){rel="nofollow"}.
::

### Config

::framework-only
#nuxt
  :::div
  You can override the theme of components globally inside your `app.config.ts` by using the exact same structure as the theme object.
  
  Let's say you want to change the font weight of all your buttons, you can do it like this:
  
  ```ts [app.config.ts]
  export default defineAppConfig({
    ui: {
      button: {
        slots: {
          base: 'font-bold'
        }
      }
    }
  })
  ```
  :::

#vue
  :::div
  You can override the theme of components globally inside your `vite.config.ts` by using the exact same structure as the theme object.
  
  Let's say you want to change the font weight of all your buttons, you can do it like this:
  
    ::::module-only
    #ui
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import ui from '@nuxt/ui/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          ui({
            ui: {
              button: {
                slots: {
                  base: 'font-bold'
                }
              }
            }
          })
        ]
      })
      ```
      :::::
    
    #ui-pro
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import uiPro from '@nuxt/ui-pro/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          uiPro({
            ui: {
              button: {
                slots: {
                  base: 'font-bold'
                }
              }
            }
          })
        ]
      })
      ```
      :::::
    ::::
  :::
::

::note
In this example, the `font-bold` class will override the default `font-medium` class on all buttons.
::

### Props

#### `ui` prop

You can also override a component's **slots** using the `ui` prop. This has priority over the global configuration and `variants` resolution.

::component-code
---
ignore:
  - ui.trailingIcon
  - color
  - variant
  - size
  - icon
prettier: true
props:
  trailingIcon: i-lucide-chevron-right
  size: md
  color: neutral
  variant: outline
  ui:
    trailingIcon: rotate-90 size-3
slots:
  default: |
    
    Button
slug: button
---
::

::note
In this example, the `trailingIcon` slot is overwritten with `size-3` even though the `md` size variant would apply a `size-5` class to it.
::

#### `class` prop

The `class` prop allows you to override the classes of the `root` or `base` slot. This has priority over the global configuration and `variants` resolution.

::component-code
---
props:
  class: font-bold rounded-full
slots:
  default: Button
slug: button
---
::

::note
In this example, the `font-bold` class will override the default `font-medium` class on this button.
::


# Icons

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/icons/vue
---
Looking for the **Vue** version?
::

## Usage

Nuxt UI automatically registers the [`@nuxt/icon`](https://github.com/nuxt/icon){rel="nofollow"} module for you, so there's no additional setup required.

### Icon Component

You can use the [Icon](https://nuxt.com/components/icon) component with a `name` prop to display an icon:

::component-code
---
props:
  name: i-lucide-lightbulb
  class: size-5
slug: icon
---
::

::note
You can use any name from the <https://icones.js.org>{rel="nofollow"} collection.
::

### Component Props

Some components also have an `icon` prop to display an icon, like the [Button](https://nuxt.com/components/button) for example:

::component-code
---
ignore:
  - color
  - variant
props:
  icon: i-lucide-sun
  variant: subtle
slots:
  default: Button
slug: button
---
::

## Collections

### Iconify Dataset

It's highly recommended to install the icon data locally with:

::code-group{sync="pm"}
```bash [pnpm]
pnpm i @iconify-json/{collection_name}
```

```bash [yarn]
yarn add @iconify-json/{collection_name}
```

```bash [npm]
npm install @iconify-json/{collection_name}
```
::

For example, to use the `i-uil-github` icon, install it's collection with `@iconify-json/uil`. This way the icons can be served locally or from your serverless functions, which is faster and more reliable on both SSR and client-side.

::note
---
target: _blank
to: https://github.com/nuxt/icon?tab=readme-ov-file#iconify-dataset
---
Read more about this in the `@nuxt/icon` documentation.
::

### Custom Local Collections

You can use local SVG files to create a custom Iconify collection.

For example, place your icons' SVG files under a folder of your choice, for example, `./app/assets/icons`:

```bash
assets/icons
├── add.svg
└── remove.svg
```

In your `nuxt.config.ts`, add an item in `icon.customCollections`:

```ts
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  icon: {
    customCollections: [{
      prefix: 'custom',
      dir: './app/assets/icons'
    }]
  }
})
```

Then you can use the icons like this:

```vue
<template>
  <UIcon name="i-custom-add" />
</template>
```

::note
---
target: _blank
to: https://github.com/nuxt/icon?tab=readme-ov-file#custom-local-collections
---
Read more about this in the `@nuxt/icon` documentation.
::

## Theme

You can change the default icons used by components in your `app.config.ts`:

::icons-theme
::


# Icons

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/icons/nuxt
---
Looking for the **Nuxt** version?
::

## Usage

### Icon Component

You can use the [Icon](https://nuxt.com/components/icon) component with a `name` prop to display an icon:

::component-code
---
props:
  name: i-lucide-lightbulb
  class: size-5
slug: icon
---
::

::note
You can use any name from the <https://icones.js.org>{rel="nofollow"} collection.
::

::warning
When using collections with a dash (`-`), you need to separate the icon name from the collection name with a colon (`:`) as `@iconify/vue` does not handle this case like `@nuxt/icon`. For example, instead of `i-simple-icons-github` you need to write `i-simple-icons:github` or `simple-icons:github`.

Learn more about the [Iconify naming convention](https://iconify.design/docs/icon-components/vue/#icon){rel="nofollow"}.
::

### Component Props

Some components also have an `icon` prop to display an icon, like the [Button](https://nuxt.com/components/button) for example:

::component-code
---
ignore:
  - color
  - variant
props:
  icon: i-lucide-sun
  variant: subtle
slots:
  default: Button
slug: button
---
::

## Theme

You can change the default icons used by Nuxt UI components in your `vite.config.ts`:

::icons-theme
::


# Fonts

## Usage

Nuxt UI automatically registers the [`@nuxt/fonts`](https://github.com/nuxt/fonts){rel="nofollow"} module for you, so there's no additional setup required. To use a font in your Nuxt UI application, you can simply declare it in your CSS. It will be automatically loaded and optimized for you.

::module-only
#ui
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @theme {
    --font-sans: 'Public Sans', sans-serif;
  }
  ```
  :::

#ui-pro
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @theme {
    --font-sans: 'Public Sans', sans-serif;
  }
  ```
  :::
::

You can disable the `@nuxt/fonts` module with the `ui.fonts` option in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ui: {
    fonts: false
  }
})
```


# Color Mode

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/color-mode/vue
---
Looking for the **Vue** version?
::

## Usage

Nuxt UI automatically registers the [`@nuxtjs/color-mode`](https://github.com/nuxt-modules/color-mode){rel="nofollow"} module for you, so there's no additional setup required. You can simply use the `useColorMode` composable to switch between light and dark modes:

```vue [ColorModeButton.vue]
<script setup>
const colorMode = useColorMode()

const isDark = computed({
  get() {
    return colorMode.value === 'dark'
  },
  set(_isDark) {
    colorMode.preference = _isDark ? 'dark' : 'light'
  }
})
</script>

<template>
  <ClientOnly v-if="!colorMode?.forced">
    <UButton
      :icon="isDark ? 'i-lucide-moon' : 'i-lucide-sun'"
      color="neutral"
      variant="ghost"
      @click="isDark = !isDark"
    />

    <template #fallback>
      <div class="size-8" />
    </template>
  </ClientOnly>
</template>
```

You can disable the `@nuxtjs/color-mode` module with the `ui.colorMode` option in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    colorMode: false
  }
})
```


# Color Mode

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/color-mode/nuxt
---
Looking for the **Nuxt** version?
::

## Usage

Nuxt UI automatically registers the [useDark](https://vueuse.org/core/useDark){rel="nofollow"} composable as a Vue plugin, so there's no additional setup required. You can simply use it to switch between light and dark modes:

```vue [ColorModeButton.vue]
<script setup>
import { useColorMode } from '@vueuse/core'

const mode = useColorMode()
</script>

<template>
  <UButton
    :icon="mode === 'dark' ? 'i-lucide-moon' : 'i-lucide-sun'"
    color="neutral"
    variant="ghost"
    @click="mode = mode === 'dark' ? 'light' : 'dark'"
  />
</template>
```

You can disable this plugin with the `colorMode` option in your `vite.config.ts`:

::module-only
#ui
  :::div
  ```ts [vite.config.ts]
  import { defineConfig } from 'vite'
  import vue from '@vitejs/plugin-vue'
  import ui from '@nuxt/ui/vite'
  
  export default defineConfig({
    plugins: [
      vue(),
      ui({
        colorMode: false
      })
    ]
  })
  ```
  :::

#ui-pro
  :::div
  ```ts [vite.config.ts]
  import { defineConfig } from 'vite'
  import vue from '@vitejs/plugin-vue'
  import uiPro from '@nuxt/ui-pro/vite'
  
  export default defineConfig({
    plugins: [
      vue(),
      uiPro({
        colorMode: false
      })
    ]
  })
  ```
  :::
::


# Internationalization (i18n)

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/i18n/vue
---
Looking for the **Vue** version?
::

## Usage

::note{to="https://nuxt.com/components/app"}
Nuxt UI provides an **App** component that wraps your app to provide global configurations.
::

### Locale

::module-only
#ui
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui/locale`:
  
  ```vue [app.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui-pro/locale`:
  
  ```vue [app.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui-pro/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

### Custom locale

You can create your own locale using the `defineLocale` composable:

::module-only
#ui
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui-pro'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

::tip
Look at the `code` parameter, there you need to pass the iso code of the language. Example:

- `hi` Hindi (language)
- `de-AT`: German (language) as used in Austria (region)
::

### Extend locale

You can customize an existing locale by overriding its `messages` or `code` using the `extendLocale` composable:

::module-only
#ui
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui/locale'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui-pro/locale'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

### Dynamic locale

To dynamically switch between languages, you can use the [Nuxt I18n](https://i18n.nuxtjs.org/){rel="nofollow"} module.

::steps{level="4"}
#### Install the Nuxt I18n package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add @nuxtjs/i18n
  ```
  
  ```bash [yarn]
  yarn add @nuxtjs/i18n
  ```
  
  ```bash [npm]
  npm install @nuxtjs/i18n
  ```
  
  ```bash [bun]
  bun add @nuxtjs/i18n
  ```
  :::

#### Add the Nuxt I18n module in your `nuxt.config.ts`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    '@nuxt/ui',
    '@nuxtjs/i18n'
  ],
  css: ['~/assets/css/main.css'],
  i18n: {
    locales: [{
      code: 'de',
      name: 'Deutsch'
    }, {
      code: 'en',
      name: 'English'
    }, {
      code: 'fr',
      name: 'Français'
    }]
  }
})
```

#### Set the `locale` prop using `useI18n`

  :::module-only
  #ui
    ::::div
    ```vue [app.vue]
    <script setup lang="ts">
    import * as locales from '@nuxt/ui/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <NuxtPage />
      </UApp>
    </template>
    ```
    ::::
  
  #ui-pro
    ::::div
    ```vue [app.vue]
    <script setup lang="ts">
    import * as locales from '@nuxt/ui-pro/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <NuxtPage />
      </UApp>
    </template>
    ```
    ::::
  :::
::

### Dynamic direction

Each locale has a `dir` property which will be used by the `App` component to set the directionality of all components.

In a multilingual application, you might want to set the `lang` and `dir` attributes on the `<html>` element dynamically based on the user's locale, which you can do with the [useHead](https://nuxt.com/docs/api/composables/use-head){rel="nofollow"} composable:

::module-only
#ui
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import * as locales from '@nuxt/ui/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import * as locales from '@nuxt/ui-pro/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

## Supported languages

::supported-languages
::


# Internationalization (i18n)

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/i18n/nuxt
---
Looking for the **Nuxt** version?
::

## Usage

::note{to="https://nuxt.com/components/app"}
Nuxt UI provides an **App** component that wraps your app to provide global configurations.
::

### Locale

::module-only
#ui
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui/locale`:
  
  ```vue [App.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui-pro/locale`:
  
  ```vue [App.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui-pro/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

### Custom locale

You can create your own locale using the `defineLocale` composable:

::module-only
#ui
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui'
  import { defineLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui-pro'
  import { defineLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

::tip
Look at the `code` parameter, there you need to pass the iso code of the language. Example:

- `hi` Hindi (language)
- `de-AT`: German (language) as used in Austria (region)
::

### Extend locale

You can customize an existing locale by overriding its `messages` or `code` using the `extendLocale` composable:

::module-only
#ui
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui/locale'
  import { extendLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui-pro/locale'
  import { extendLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

### Dynamic locale

To dynamically switch between languages, you can use the [Vue I18n](https://vue-i18n.intlify.dev/){rel="nofollow"} plugin.

::steps{level="4"}
#### Install the Vue I18n package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add vue-i18n@11
  ```
  
  ```bash [yarn]
  yarn add vue-i18n@11
  ```
  
  ```bash [npm]
  npm install vue-i18n@11
  ```
  
  ```bash [bun]
  bun add vue-i18n@11
  ```
  :::

#### Use the Vue I18n plugin in your `main.ts`

```ts [main.ts] {3,14-26,29}
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import { createI18n } from 'vue-i18n'
import ui from '@nuxt/ui/vue-plugin'
import App from './App.vue'

const app = createApp(App)

const router = createRouter({
  routes: [],
  history: createWebHistory()
})

const i18n = createI18n({
  legacy: false,
  locale: 'en',
  availableLocales: ['en', 'de'],
  messages: {
    en: {
      // ...
    },
    de: {
      // ...
    }
  }
})

app.use(router)
app.use(i18n)
app.use(ui)

app.mount('#app')
```

#### Set the `locale` prop using `useI18n`

  :::module-only
  #ui
    ::::div
    ```vue [App.vue]
    <script setup lang="ts">
    import { useI18n } from 'vue-i18n'
    import * as locales from '@nuxt/ui/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <RouterView />
      </UApp>
    </template>
    ```
    ::::
  
  #ui-pro
    ::::div
    ```vue [App.vue]
    <script setup lang="ts">
    import { useI18n } from 'vue-i18n'
    import * as locales from '@nuxt/ui-pro/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <RouterView />
      </UApp>
    </template>
    ```
    ::::
  :::
::

### Dynamic direction

Each locale has a `dir` property which will be used by the `App` component to set the directionality of all components.

In a multilingual application, you might want to set the `lang` and `dir` attributes on the `<html>` element dynamically based on the user's locale, which you can do with the [useHead](https://unhead.unjs.io/usage/composables/use-head){rel="nofollow"} composable:

::module-only
#ui
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { computed } from 'vue'
  import { useI18n } from 'vue-i18n'
  import { useHead } from '@unhead/vue'
  import * as locales from '@nuxt/ui/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { computed } from 'vue'
  import { useI18n } from 'vue-i18n'
  import { useHead } from '@unhead/vue'
  import * as locales from '@nuxt/ui-pro/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

## Supported languages

::supported-languages
::


# Contribution Guide

Nuxt UI thrives thanks to its incredible community ❤️. We welcome all contributions through bug reports, pull requests, and feedback to help make this library even better.

::caution
Before reporting a bug or requesting a feature, make sure that you have read through our [documentation](https://ui.nuxt.com/){rel="nofollow"} and existing [issues](https://github.com/nuxt/ui/issues?q=is%3Aissue%20is%3Aopen%20sort%3Aupdated-desc%20label%3Av3){rel="nofollow"}.
::

## Project Structure

Here's an overview of the key directories and files in the Nuxt UI project structure:

### Documentation

The documentation lives in the `docs` folder as a Nuxt app using `@nuxt/content` v3 to generate pages from Markdown files. See the [Nuxt Content documentation](https://content.nuxt.com/docs/getting-started){rel="nofollow"} for details on how it works. Here's a breakdown of its structure:

```bash
├── app/
│   ├── assets/
│   ├── components/
│   │   └── content/
│   │       └── examples   # Components used in documentation as examples
│   ├── composables/
│   └── ...
├── content/
│   ├── 1.getting-started
│   ├── 2.composables
│   └── 3.components       # Components documentation
```

### Module

The module code resides in the `src` folder. Here's a breakdown of its structure:

```bash
├── plugins/
├── runtime/
│   ├── components/        # Where all the components are located
│   │   ├── Accordion.vue
│   │   ├── Alert.vue
│   │   └── ...
│   ├── composables/
│   ├── locale/
│   ├── plugins/
│   ├── types/
│   ├── utils/
│   └── vue/
│       ├── components/
│       └── plugins/
├── theme/                 # This where the theme for each component is located
│   ├── accordion.ts       # Theme for Accordion component
│   ├── alert.ts
│   └── ...
└── module.ts
```

## CLI

To make development easier, we've created a CLI that you can use to generate components and locales. You can access it using the `nuxt-ui make` command.

First, you need to link the CLI to your global environment:

```sh
npm link
```

### Components

You can create new components using the following command:

```sh
nuxt-ui make component <name> [options]
```

Available options:

- `--primitive` Create a primitive component
- `--pro` Create a pro component
- `--prose` Create a prose component (requires `--pro`)
- `--content` Create a content component (requires `--pro`)
- `--template` Only generate specific template (available templates: `playground`, `docs`, `test`, `theme`, `component`)

Example:

```sh
# Create a basic component
nuxt-ui make component my-component

# Create a pro component
nuxt-ui make component page-section --pro

# Create a pro prose component
nuxt-ui make component heading --pro --prose

# Create a pro content component
nuxt-ui make component block --pro --content

# Generate only documentation template
nuxt-ui make component my-component --template=docs
```

::note
When creating a new component, the CLI will automatically generate all the necessary files like the component itself, theme, tests, and documentation.
::

### Locales

You can create new locales using the following command:

```sh
nuxt-ui make locale --code <code> --name <name>
```

::note{to="https://nuxt.com/getting-started/i18n/nuxt#supported-languages"}
Learn more about **i18n** in the documentation.
::

## Submit a Pull Request (PR)

Before you start, check if there's an existing issue describing the problem or feature request you're working on. If there is, please leave a comment on the issue to let us know you're working on it.

If there isn't, open a new issue to discuss the problem or feature.

### Local Development

To begin local development, follow these steps:

::steps{level="4"}
#### Clone the `nuxt/ui` repository to your local machine

```sh
git clone -b v3 https://github.com/nuxt/ui.git
```

#### Enable [Corepack](https://github.com/nodejs/corepack){rel="nofollow"}

```sh
corepack enable
```

#### Install dependencies

```sh
pnpm install
```

#### Generate type stubs

```sh
pnpm run dev:prepare
```

#### Start development

- To work on the **documentation** located in the `docs` folder, run:

```sh
pnpm run docs
```

- To test the Nuxt components using the **playground**, run:

```sh
pnpm run dev
```

- To test the Vue components using the **playground**, run:

```sh
pnpm run dev:vue
```
::

::note{to="https://nuxt.com/#cli"}
If you're working on implementing a new component, check the **CLI** section to kickstart the process.
::

### IDE Setup

We recommend using VSCode alongside the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint){rel="nofollow"}. You can enable auto-fix and formatting when saving your code. Here's how:

```json
{
  "editor.codeActionsOnSave": {
    "source.fixAll": false,
    "source.fixAll.eslint": true
  }
}
```

::warning
Since ESLint is already configured to format the code, there's no need for duplicating functionality with **Prettier**. If you have it installed in your editor, we recommend disabling it to avoid conflicts.
::

### Linting

You can use the `lint` command to check for linting errors:

```sh
pnpm run lint # check for linting errors
pnpm run lint:fix # fix linting errors
```

### Type Checking

We use TypeScript for type checking. You can use the `typecheck` command to check for type errors:

```sh
pnpm run typecheck
```

### Testing

Before submitting a PR, ensure that you run the tests for both `nuxt` and `vue`:

```sh
pnpm run test # for Nuxt
pnpm run test:vue # for Vue
```

::tip
If you have to update the snapshots, press `u` after the tests have finished running.
::

### Commit Conventions

We use [Conventional Commits](https://www.conventionalcommits.org/){rel="nofollow"} for commit messages, which allows a changelog to be auto-generated based on the commits. Please read the [guide](https://www.conventionalcommits.org/en/v1.0.0/#summary){rel="nofollow"} through if you aren't familiar with it already.

- Use `fix` and `feat` for code changes that affect functionality or logic
- Use `docs` for documentation changes and `chore` for maintenance tasks

### Making a Pull Request

- Follow along the [instructions](https://github.com/nuxt/ui/blob/v3/.github/PULL_REQUEST_TEMPLATE.md?plain=1){rel="nofollow"} provided when creating a PR
- Ensure your PR's title adheres to the [Conventional Commits](https://www.conventionalcommits.org/){rel="nofollow"} since it will be used once the code is merged.
- Multiple commits are fine; no need to rebase or force push. We'll use `Squash and Merge` when merging.
- Ensure `lint`, `typecheck` and `tests` work before submitting the PR. Avoid making unrelated changes.

We'll review it promptly. If assigned to a maintainer, they'll review it carefully. Ignore the red text; it's for tracking purposes.

## Thanks

Thank you again for being interested in this project! You are awesome! ❤️


# defineShortcuts

## Usage

Use the auto-imported `defineShortcuts` composable to define keyboard shortcuts.

```vue
<script setup lang="ts">
const open = ref(false)

defineShortcuts({
  meta_k: () => {
    open.value = !open.value
  }
})
</script>
```

- Shortcuts are automatically adjusted for non-macOS platforms, converting `meta` to `ctrl`.
- The composable uses VueUse's [`useEventListener`](https://vueuse.org/core/useEventListener/){rel="nofollow"} to handle keydown events.
- For a complete list of available shortcut keys, refer to the [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values){rel="nofollow"} API documentation. Note that the key should be written in lowercase.

::tip{to="https://nuxt.com/components/kbd"}
Learn how to display shortcuts in components in the **Kbd** component documentation.
::

## API

### `defineShortcuts(config: ShortcutsConfig, options?: ShortcutsOptions)`

Define keyboard shortcuts for your application.

- `config`: An object where keys are shortcut definitions and values are either handler functions or shortcut configuration objects.
- `options`: Optional configuration for the shortcuts behavior.

  - `chainDelay`: The delay between key presses to consider the shortcut as chained. Default is `250`.

#### Shortcut Definition

Shortcuts are defined using the following format:

- Single key: `'a'`, `'b'`, `'1'`, `'?'`, etc.
- Key combinations: Use `_` to separate keys, e.g., `'meta_k'`, `'ctrl_shift_f'`
- Key sequences: Use `-` to define a sequence, e.g., `'g-d'`

#### Modifiers

- `meta`: Represents `⌘ Command` on macOS and `Ctrl` on other platforms
- `ctrl`: Represents `Ctrl` on all platforms
- `shift`: Used for alphabetic keys when Shift is required

#### Special Keys

- `escape`: Triggers on Esc key
- `enter`: Triggers on Enter key
- `arrowleft`, `arrowright`, `arrowup`, `arrowdown`: Trigger on respective arrow keys

#### Shortcut Configuration

Each shortcut can be defined as a function or an object with the following properties:

```ts
interface ShortcutConfig {
  handler: () => void
  usingInput?: boolean | string
}
```

- `handler`: Function to be executed when the shortcut is triggered
- `usingInput`:

  - `false` (default): Shortcut only triggers when no input is focused
  - `true`: Shortcut triggers even when any input is focused
  - `string`: Shortcut only triggers when the specified input (by name) is focused

## Examples

### Basic usage

```vue
<script setup lang="ts">
defineShortcuts({
  '?': () => openHelpModal(),
  'meta_k': () => openCommandPalette(),
  'g-d': () => navigateToDashboard()
})
</script>
```

### With input focus handling

The `usingInput` option allows you to specify that a shortcut should only trigger when a specific input is focused.

```vue
<template>
  <UInput v-model="query" name="queryInput" />
</template>

<script setup lang="ts">
const query = ref('')

defineShortcuts({
  enter: {
    usingInput: 'queryInput',
    handler: () => performSearch()
  },
  escape: {
    usingInput: true,
    handler: () => clearSearch()
  }
})
</script>
```

### Extracting shortcuts from menu items

The `extractShortcuts` utility can be used to automatically define shortcuts from menu items:

```vue
<script setup lang="ts">
const items = [{
  label: 'Save',
  icon: 'i-lucide-file-down',
  kbds: ['meta', 'S'],
  onSelect() {
    save()
  }
}, {
  label: 'Copy',
  icon: 'i-lucide-copy',
  kbds: ['meta', 'C'],
  onSelect() {
    copy()
  }
}]

defineShortcuts(extractShortcuts(items))
</script>
```


# useFormField

## Usage

Use the auto-imported `useFormField` composable to integrate custom inputs with a [Form](https://nuxt.com/components/form).

```vue
<script setup lang="ts">
const { id, emitFormBlur, emitFormInput, emitFormChange } = useFormField()
</script>
```


# useOverlay

## Usage

Use the auto-imported `useOverlay` composable to programmatically control [Modal](https://nuxt.com/components/modal) and [Slideover](https://nuxt.com/components/slideover) components.

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const overlay = useOverlay()

const modal = overlay.create(LazyModalExample)

async function openModal() {
  modal.open()
}
</script>
```

- The `useOverlay` composable is created using `createSharedComposable`, ensuring that the same overlay state is shared across your entire application.

::note
In order to return a value from the overlay, the `overlay.open().instance` can be awaited. In order for this to work, however, the **overlay component must emit a `close` event**. See example below for details.
::

## API

### `create(component: T, options: OverlayOptions): OverlayInstance`

Create an overlay, and return a factory instance.

- Parameters:

  - `component`: The overlay component.
  - `options`:

    - `defaultOpen?: boolean` Open the overlay immediately after being created. Defaults to `false`.
    - `props?: ComponentProps`: An optional object of props to pass to the rendered component.
    - `destroyOnClose?: boolean` Removes the overlay from memory when closed. Defaults to `false`.

### `open(id: symbol, props?: ComponentProps<T>): OpenedOverlay<T>`

Open an overlay by its `id`.

- Parameters:

  - `id`: The identifier of the overlay.
  - `props`: An optional object of props to pass to the rendered component.

### `close(id: symbol, value?: any): void`

Close an overlay by its `id`.

- Parameters:

  - `id`: The identifier of the overlay.
  - `value`: A value to resolve the overlay promise with.

### `patch(id: symbol, props: ComponentProps<T>): void`

Update an overlay by its `id`.

- Parameters:

  - `id`: The identifier of the overlay.
  - `props`: An object of props to update on the rendered component.

### `unmount(id: symbol): void`

Remove an overlay from the DOM by its `id`.

- Parameters:

  - `id`: The identifier of the overlay.

### `isOpen(id: symbol): boolean`

Check if an overlay is open using its `id`.

- Parameters:

  - `id`: The identifier of the overlay.

### `overlays: Overlay[]`

In-memory list of all overlays that were created.

## Instance API

### `open(props?: ComponentProps<T>): Promise<OpenedOverlay<T>>`

Open the overlay.

- Parameters:

  - `props`: An optional object of props to pass to the rendered component.

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const overlay = useOverlay()

const modal = overlay.create(LazyModalExample)

function openModal() {
  modal.open({
    title: 'Welcome'
  })
}
</script>
```

### `close(value?: any): void`

Close the overlay.

- Parameters:

  - `value`: A value to resolve the overlay promise with.

### `patch(props: ComponentProps<T>)`

Update the props of the overlay.

- Parameters:

  - `props`: An object of props to update on the rendered component.

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const overlay = useOverlay()

const modal = overlay.create(LazyModalExample, {
  title: 'Welcome'
})

function openModal() {
  modal.open()
}

function updateModalTitle() {
  modal.patch({ title: 'Updated Title' })
}
</script>
```

## Example

Here's a complete example of how to use the `useOverlay` composable:

```vue
<script setup lang="ts">
import { ModalA, ModalB, SlideoverA } from '#components'

const overlay = useOverlay()

// Create with default props
const modalA = overlay.create(ModalA, { title: 'Welcome' })
const modalB = overlay.create(ModalB)

const slideoverA = overlay.create(SlideoverA)

const openModalA = () => {
  // Open modalA, but override the title prop
  modalA.open({ title: 'Hello' })
}

const openModalB = async () => {
  // Open modalB, and wait for its result
  const modalBInstance = modalB.open()

  const input = await modalBInstance

  // Pass the result from modalB to the slideover, and open it
  slideoverA.open({ input })
}
</script>

<template>
  <button @click="openModalA">Open Modal</button>
</template>
```

In this example, we're using the `useOverlay` composable to control multiple modals and slideovers.

## Caveats

### Provide / Inject

When opening overlays programmatically (e.g. modals, slideovers, etc), the overlay component can only access injected values from the component containing `UApp` (typically `app.vue` or layout components). This is because overlays are mounted outside of the page context by the `UApp` component.

As such, using `provide()` in pages or parent components isn't supported directly. To pass provided values to overlays, the recommended approach is to use props instead:

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const providedValue = inject('valueProvidedInPage')

const modal = overlay.create(LazyModalExample, {
  props: {
    providedValue,
    otherData: someValue
  }
})
</script>
```


# useToast

## Usage

Use the auto-imported `useToast` composable to display [Toast](https://nuxt.com/components/toast) notifications.

```vue
<script setup lang="ts">
const toast = useToast()
</script>
```

- The `useToast` composable uses Nuxt's `useState` to manage the toast state, ensuring reactivity across your application.
- A maximum of 5 toasts are displayed at a time. When adding a new toast that would exceed this limit, the oldest toast is automatically removed.
- When removing a toast, there's a 200ms delay before it's actually removed from the state, allowing for exit animations.

::warning
Make sure to wrap your app with the [`App`](https://nuxt.com/components/app) component which uses our [`Toaster`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/Toaster.vue){rel="nofollow"} component which uses the [`ToastProvider`](https://reka-ui.com/docs/components/toast#provider){rel="nofollow"} component from Reka UI.
::

::tip{to="https://nuxt.com/components/toast"}
Learn how to customize the appearance and behavior of toasts in the **Toast** component documentation.
::

## API

### `add(toast: Partial<Toast>): Toast`

Adds a new toast notification.

- Parameters:

  - `toast`: A partial `Toast` object with the following properties:

    - `id` (optional): A unique identifier for the toast. If not provided, a timestamp will be used.
    - `open` (optional): Whether the toast is open. Defaults to `true`.
    - Other properties from the `Toast` interface.
- Returns: The complete `Toast` object that was added.

```vue
<script setup lang="ts">
const toast = useToast()

function showToast() {
  toast.add({
    title: 'Success',
    description: 'Your action was completed successfully.',
    color: 'success'
  })
}
</script>
```

### `update(id: string | number, toast: Partial<Toast>)`

Updates an existing toast notification.

- Parameters:

  - `id`: The unique identifier of the toast to update.
  - `toast`: A partial `Toast` object with the properties to update.

```vue
<script setup lang="ts">
const toast = useToast()

function updateToast(id: string | number) {
  toast.update(id, {
    title: 'Updated Toast',
    description: 'This toast has been updated.'
  })
}
</script>
```

### `remove(id: string | number)`

Removes a toast notification.

- Parameters:

  - `id`: The unique identifier of the toast to remove.

```vue
<script setup lang="ts">
const toast = useToast()

function removeToast(id: string | number) {
  toast.remove(id)
}
</script>
```

### `clear()`

Removes all toast notifications.

```vue
<script setup lang="ts">
const toast = useToast()

function clearAllToasts() {
  toast.clear()
}
</script>
```

### `toasts`

- Type: `Ref<Toast[]>`
- Description: A reactive array containing all current toast notifications.


# App

## Usage

This component implements Reka UI [ConfigProvider](https://reka-ui.com/docs/utilities/config-provider){rel="nofollow"} to provide global configuration to all components:

- Enables all primitives to inherit global reading direction.
- Enables changing the behavior of scroll body when setting body lock.
- Much more controls to prevent layout shifts.

It's also using [ToastProvider](https://reka-ui.com/docs/components/toast#provider){rel="nofollow"} and [TooltipProvider](https://reka-ui.com/docs/components/tooltip#provider){rel="nofollow"} to provide global toasts and tooltips, as well as programmatic modals and slideovers.

Use it at the root of your app:

```vue [app.vue]
<template>
  <UApp>
    <NuxtPage />
  </UApp>
</template>
```

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/i18n/nuxt#locale"}
  Learn how to use the `locale` prop to change the locale of your app.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/i18n/vue#locale"}
  Learn how to use the `locale` prop to change the locale of your app.
  :::
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Changelog

::component-changelog
::


# Accordion

## Usage

### Items

Use the `items` prop as an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `trailingIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `content?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, header?: ClassNameValue, trigger?: ClassNameValue, leadingIcon?: ClassNameValue, label?: ClassNameValue, trailingIcon?: ClassNameValue, content?: ClassNameValue, body?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Multiple

Set the `type` prop to `multiple` to allow multiple items to be active at the same time. Defaults to `single`.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - type
  - items
props:
  class: px-4
  type: multiple
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Collapsible

When `type` is `single`, you can set the `collapsible` prop to `false` to prevent the active item from collapsing.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - collapsible
  - items
props:
  class: px-4
  collapsible: false
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Unmount

Use the `unmount-on-hide` prop to prevent the content from being unmounted when the accordion is collapsed. Defaults to `true`.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  unmountOnHide: false
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

::note
You can inspect the DOM to see each item's content being rendered.
::

### Disabled

Use the `disabled` property to disable the Accordion.

You can also disable a specific item by using the `disabled` property in the item object.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  disabled: true
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
      disabled: true
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Trailing Icon

Use the `trailing-icon` prop to customize the trailing [Icon](https://nuxt.com/components/icon) of each item. Defaults to `i-lucide-chevron-down`.

::tip
You can also set an icon for a specific item by using the `trailingIcon` property in the item object.
::

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  trailingIcon: i-lucide-arrow-down
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
      trailingIcon: i-lucide-plus
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronDown` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronDown` key.
  :::
::

## Examples

### Control active item(s)

You can control the active item(s) by using the `default-value` prop or the `v-model` directive with the index of the item.

::component-example
---
props:
  class: px-4
name: accordion-model-value-example
---
::

::tip
You can also pass the `value` of one of the items if provided.
::

::caution
When `type="multiple"`, ensure to pass an array to the `default-value` prop or the `v-model` directive.
::

### With drag and drop

Use the [`useSortable`](https://vueuse.org/integrations/useSortable/){rel="nofollow"} composable from [`@vueuse/integrations`](https://vueuse.org/integrations/README.html){rel="nofollow"} to enable drag and drop functionality on the Accordion. This integration wraps [Sortable.js](https://sortablejs.github.io/Sortable/){rel="nofollow"} to provide a seamless drag and drop experience.

::component-example{name="accordion-drag-and-drop-example"}
::

### With body slot

Use the `#body` slot to customize the body of each item.

::component-example
---
props:
  class: px-4
name: accordion-body-slot-example
---
::

::tip
The `#body` slot includes some pre-defined styles, use the [`#content` slot](https://nuxt.com/#with-content-slot) if you want to start from scratch.
::

### With content slot

Use the `#content` slot to customize the content of each item.

::component-example
---
props:
  class: px-4
name: accordion-content-slot-example
---
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example
---
props:
  class: px-4
name: accordion-custom-slot-example
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Alert

## Usage

### Title

Use the `title` prop to set the title of the Alert.

::component-code{:props='{"title":"Heads up!"}'}
::

### Description

Use the `description` prop to set the description of the Alert.

::component-code
---
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
---
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon).

::component-code
---
ignore:
  - title
  - description
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-terminal
---
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar).

::component-code
---
ignore:
  - title
  - description
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  avatar:
    src: https://github.com/nuxt.png
---
::

### Color

Use the `color` prop to change the color of the Alert.

::component-code
---
ignore:
  - title
  - description
  - icon
prettier: true
props:
  color: neutral
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-terminal
---
::

### Variant

Use the `variant` prop to change the variant of the Alert.

::component-code
---
ignore:
  - title
  - description
  - icon
prettier: true
props:
  color: neutral
  variant: subtle
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-terminal
---
::

### Close

Use the `close` prop to display a [Button](https://nuxt.com/components/button) to dismiss the Alert.

::tip
An `update:open` event will be emitted when the close button is clicked.
::

::component-code
---
ignore:
  - title
  - description
  - close
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  close: true
---
::

You can pass any property from the [Button](https://nuxt.com/components/button) component to customize it.

::component-code
---
ignore:
  - title
  - description
  - close.color
  - close.variant
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  close:
    color: primary
    variant: outline
    class: rounded-full
---
::

### Close Icon

Use the `close-icon` prop to customize the close button [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-x`.

::component-code
---
ignore:
  - title
  - description
  - close
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  close: true
  closeIcon: i-lucide-arrow-right
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.close` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.close` key.
  :::
::

### Actions

Use the `actions` prop to add some [Button](https://nuxt.com/components/button) actions to the Alert.

::component-code
---
ignore:
  - title
  - actions
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  actions:
    - label: Action 1
    - label: Action 2
      color: neutral
      variant: subtle
---
::

### Orientation

Use the `orientation` prop to change the orientation of the Alert.

::component-code
---
ignore:
  - title
  - actions
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  orientation: horizontal
  actions:
    - label: Action 1
    - label: Action 2
      color: neutral
      variant: subtle
---
::

## Examples

### `class` prop

Use the `class` prop to override the base styles of the Alert.

::component-code
---
ignore:
  - title
  - description
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  class: rounded-none
---
::

### `ui` prop

Use the `ui` prop to override the slots styles of the Alert.

::component-code
---
ignore:
  - ui
  - title
  - description
  - icon
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-rocket
  ui:
    icon: size-11
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Avatar

## Usage

The Avatar uses the `<NuxtImg>` component when [`@nuxt/image`](https://github.com/nuxt/image){rel="nofollow"} is installed, falling back to `img` otherwise.

::note
You can pass any property from the HTML `<img>` element such as `alt`, `loading`, etc.
::

### Src

Use the `src` prop to set the image URL.

::component-code{:props='{"src":"https://github.com/benjamincanac.png"}'}
::

### Size

Use the `size` prop to set the size of the Avatar.

::component-code
---
ignore:
  - src
props:
  src: https://github.com/benjamincanac.png
  size: xl
---
::

::note
The `<img>` element's `width` and `height` are automatically set based on the `size` prop.
::

### Icon

Use the `icon` prop to display a fallback [Icon](https://nuxt.com/components/icon).

::component-code{:props='{"icon":"i-lucide-image","size":"md"}'}
::

### Text

Use the `text` prop to display a fallback text.

::component-code{:props='{"text":"+1","size":"md"}'}
::

### Alt

When no icon or text is provided, the **initials** of the `alt` prop is used as fallback.

::component-code{:props='{"alt":"Benjamin Canac","size":"md"}'}
::

::note
The `alt` prop is passed to the `img` element as the `alt` attribute.
::

### Chip

Use the `chip` prop to display a chip around the Avatar.

::component-code
---
ignore:
  - src
  - chip.inset
prettier: true
props:
  src: https://github.com/benjamincanac.png
  chip:
    inset: true
---
::

## Examples

### With tooltip

You can use a [Tooltip](https://nuxt.com/components/tooltip) component to display a tooltip when hovering the Avatar.

::component-example{name="avatar-tooltip-example"}
::

### With mask

You can use a CSS mask to display an Avatar with a custom shape instead of a simple circle.

::component-example{name="avatar-mask-example"}
::

## API

### Props

::component-props
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# AvatarGroup

## Usage

Wrap multiple [Avatar](https://nuxt.com/components/avatar) within an AvatarGroup to stack them.

::component-code
---
prettier: true
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" alt="Benjamin Canac" />
    <UAvatar src="https://github.com/romhml.png" alt="Romain Hamel" />
    <UAvatar src="https://github.com/noook.png" alt="Neil Richter" />
---
  :::u-avatar{alt="Benjamin Canac" src="https://github.com/benjamincanac.png"}
  :::

  :::u-avatar{alt="Romain Hamel" src="https://github.com/romhml.png"}
  :::

  :::u-avatar{alt="Neil Richter" src="https://github.com/noook.png"}
  :::
::

### Size

Use the `size` prop to change the size of all the avatars.

::component-code
---
prettier: true
props:
  size: xl
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" alt="Benjamin Canac" />
    <UAvatar src="https://github.com/romhml.png" alt="Romain Hamel" />
    <UAvatar src="https://github.com/noook.png" alt="Neil Richter" />
---
  :::u-avatar{alt="Benjamin Canac" src="https://github.com/benjamincanac.png"}
  :::

  :::u-avatar{alt="Romain Hamel" src="https://github.com/romhml.png"}
  :::

  :::u-avatar{alt="Neil Richter" src="https://github.com/noook.png"}
  :::
::

### Max

Use the `max` prop to limit the number of avatars displayed. The rest is displayed as an `+X` avatar.

::component-code
---
prettier: true
props:
  max: 2
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" alt="Benjamin Canac" />
    <UAvatar src="https://github.com/romhml.png" alt="Romain Hamel" />
    <UAvatar src="https://github.com/noook.png" alt="Neil Richter" />
---
  :::u-avatar{alt="Benjamin Canac" src="https://github.com/benjamincanac.png"}
  :::

  :::u-avatar{alt="Romain Hamel" src="https://github.com/romhml.png"}
  :::

  :::u-avatar{alt="Neil Richter" src="https://github.com/noook.png"}
  :::
::

## Examples

### With tooltip

Wrap each avatar with a [Tooltip](https://nuxt.com/components/tooltip) to display a tooltip on hover.

::component-example{name="avatar-group-tooltip-example"}
::

### With chip

Wrap each avatar with a [Chip](https://nuxt.com/components/chip) to display a chip around the avatar.

::component-example{name="avatar-group-chip-example"}
::

### With link

Wrap each avatar with a [Link](https://nuxt.com/components/link) to make them clickable.

::component-example{name="avatar-group-link-example"}
::

### With mask

Wrap an avatar with a CSS mask to display it with a custom shape.

::component-example{name="avatar-group-mask-example"}
::

::warning
The `chip` prop does not work correctly when using a mask. Chips may be cut depending on the mask shape.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Badge

## Usage

### Label

Use the default slot to set the label of the Badge.

::component-code{:slots='{"default":"Badge"}'}
::

You can achieve the same result by using the `label` prop.

::component-code{:props='{"label":"Badge"}'}
::

### Color

Use the `color` prop to change the color of the Badge.

::component-code{:props='{"color":"neutral"}' :slots='{"default":"Badge"}'}
::

### Variant

Use the `variant` props to change the variant of the Badge.

::component-code
---
props:
  color: neutral
  variant: outline
slots:
  default: Badge
---
::

### Size

Use the `size` prop to change the size of the Badge.

::component-code{:props='{"size":"xl"}' :slots='{"default":"Badge"}'}
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the Badge.

::component-code
---
props:
  icon: i-lucide-rocket
  size: md
  color: primary
  variant: solid
slots:
  default: Badge
---
::

Use the `leading` and `trailing` props to set the icon position or the `leading-icon` and `trailing-icon` props to set a different icon for each position.

::component-code
---
props:
  trailingIcon: i-lucide-arrow-right
  size: md
slots:
  default: Badge
---
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar) inside the Badge.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  color: neutral
  variant: outline
slots:
  default: |
    
    Badge
---
::

## Examples

### `class` prop

Use the `class` prop to override the base styles of the Badge.

::component-code
---
props:
  class: font-bold rounded-full
slots:
  default: Badge
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Breadcrumb

## Usage

### Items

Use the `items` prop as an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, link?: ClassNameValue, linkLeadingIcon?: ClassNameValue, linkLeadingAvatar?: ClassNameValue, linkLabel?: ClassNameValue, separator?: ClassNameValue, separatorIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

You can pass any property from the [Link](https://nuxt.com/components/link#props) component such as `to`, `target`, etc.

::component-code
---
external:
  - items
externalTypes:
  - BreadcrumbItem[]
ignore:
  - items
props:
  items:
    - label: Home
      icon: i-lucide-house
    - label: Components
      icon: i-lucide-box
      to: /components
    - label: Breadcrumb
      icon: i-lucide-link
      to: /components/breadcrumb
---
::

::note
A `span` is rendered instead of a link when the `to` property is not defined.
::

### Separator Icon

Use the `separator-icon` prop to customize the [Icon](https://nuxt.com/components/icon) between each item. Defaults to `i-lucide-chevron-right`.

::component-code
---
external:
  - items
externalTypes:
  - BreadcrumbItem[]
ignore:
  - items
props:
  separatorIcon: i-lucide-arrow-right
  items:
    - label: Home
      icon: i-lucide-house
    - label: Components
      icon: i-lucide-box
      to: /components
    - label: Breadcrumb
      icon: i-lucide-link
      to: /components/breadcrumb
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronRight` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronRight` key.
  :::
::

## Examples

### With separator slot

Use the `#separator` slot to customize the separator between each item.

::component-example{name="breadcrumb-separator-slot-example"}
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="breadcrumb-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
You can also use the `#item`, `#item-leading`, `#item-label` and `#item-trailing` slots to customize all items.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Button

## Usage

### Label

Use the default slot to set the label of the Button.

::component-code{:slots='{"default":"Button"}'}
::

You can achieve the same result by using the `label` prop.

::component-code{:props='{"label":"Button"}'}
::

### Color

Use the `color` prop to change the color of the Button.

::component-code{:props='{"color":"neutral"}' :slots='{"default":"Button"}'}
::

### Variant

Use the `variant` prop to change the variant of the Button.

::component-code
---
props:
  color: neutral
  variant: outline
slots:
  default: Button
---
::

### Size

Use the `size` prop to change the size of the Button.

::component-code{:props='{"size":"xl"}' :slots='{"default":"Button"}'}
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the Button.

::component-code
---
props:
  icon: i-lucide-rocket
  size: md
  color: primary
  variant: solid
slots:
  default: Button
---
::

Use the `leading` and `trailing` props to set the icon position or the `leading-icon` and `trailing-icon` props to set a different icon for each position.

::component-code
---
props:
  trailingIcon: i-lucide-arrow-right
  size: md
slots:
  default: Button
---
::

The `label` as prop or slot is optional so you can use the Button as an icon-only button.

::component-code
---
props:
  icon: i-lucide-search
  size: md
  color: primary
  variant: solid
---
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar) inside the Button.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  color: neutral
  variant: outline
slots:
  default: |
    
    Button
---
::

The `label` as prop or slot is optional so you can use the Button as an avatar-only button.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  color: neutral
  variant: outline
---
::

### Link

You can pass any property from the [Link](https://nuxt.com/components/link#props) component such as `to`, `target`, etc.

::component-code
---
ignore:
  - target
props:
  to: https://github.com/nuxt/ui
  target: _blank
slots:
  default: Button
---
::

When the Button is a link or when using the `active` prop, you can use the `active-color` and `active-variant` props to customize the active state.

::component-code
---
ignore:
  - color
  - variant
items:
  activeColor:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  activeVariant:
    - solid
    - outline
    - soft
    - subtle
    - ghost
    - link
prettier: true
props:
  active: true
  color: neutral
  variant: outline
  activeColor: primary
  activeVariant: solid
slots:
  default: |
    
    Button
---
Button
::

You can also use the `active-class` and `inactive-class` props to customize the active state.

::component-code
---
props:
  active: true
  activeClass: font-bold
  inactiveClass: font-light
slots:
  default: Button
---
Button
::

::tip
You can configure these styles globally in your `app.config.ts` file under the `ui.button.variants.active` key.

```ts
export default defineAppConfig({
  ui: {
    button: {
      variants: {
        active: {
          true: {
            base: 'font-bold'
          }
        }
      }
    }
  }
})
```
::

### Loading

Use the `loading` prop to show a loading icon and disable the Button.

::component-code
---
props:
  loading: true
  trailing: false
slots:
  default: Button
---
Button
::

Use the `loading-auto` prop to show the loading icon automatically while the `@click` promise is pending.

::component-example{name="button-loading-auto-example"}
::

This also works with the [Form](https://nuxt.com/components/form) component.

::component-example{name="button-loading-auto-form-example"}
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
props:
  loading: true
  loadingIcon: i-lucide-loader
slots:
  default: Button
---
Button
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the Button.

::component-code{:props='{"disabled":true}' :slots='{"default":"Button"}'}
Button
::

## Examples

### `class` prop

Use the `class` prop to override the base styles of the Button.

::component-code
---
props:
  class: font-bold rounded-full
slots:
  default: Button
---
::

### `ui` prop

Use the `ui` prop to override the slots styles of the Button.

::component-code
---
ignore:
  - ui
  - color
  - variant
  - icon
prettier: true
props:
  icon: i-lucide-rocket
  color: neutral
  variant: outline
  ui:
    leadingIcon: text-primary
slots:
  default: |
    
    Button
---
::

## API

### Props

::component-props
::

::callout
---
icon: i-simple-icons-github
to: https://github.com/nuxt/ui/blob/v3/src/runtime/components/Link.vue#L13
---
The `Button` component extends the `Link` component. Check out the source code on GitHub.
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# ButtonGroup

## Usage

Wrap multiple [Button](https://nuxt.com/components/button) within a ButtonGroup to group them together.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton color="neutral" variant="subtle" label="Button" />
    <UButton color="neutral" variant="outline" icon="i-lucide-chevron-down" />
---
  :::u-button{color="neutral" label="Button" variant="subtle"}
  :::

  :::u-button{color="neutral" icon="i-lucide-chevron-down" variant="outline"}
  :::
::

### Size

Use the `size` prop to change the size of all the buttons.

::component-code
---
prettier: true
props:
  size: xl
slots:
  default: |
    
    <UButton color="neutral" variant="subtle" label="Button" />
    <UButton color="neutral" variant="outline" icon="i-lucide-chevron-down" />
---
  :::u-button{color="neutral" label="Button" variant="subtle"}
  :::

  :::u-button{color="neutral" icon="i-lucide-chevron-down" variant="outline"}
  :::
::

### Orientation

Use the `orientation` prop to change the orientation of the buttons. Defaults to `horizontal`.

::component-code
---
prettier: true
props:
  orientation: vertical
slots:
  default: |
    
    <UButton color="neutral" variant="subtle" label="Submit" />
    <UButton color="neutral" variant="outline" label="Cancel" />
---
  :::u-button{color="neutral" label="Submit" variant="subtle"}
  :::

  :::u-button{color="neutral" label="Cancel" variant="outline"}
  :::
::

## Examples

### With input

You can use components like [Input](https://nuxt.com/components/input), [InputMenu](https://nuxt.com/components/input-menu), [Select](https://nuxt.com/components/select) [SelectMenu](https://nuxt.com/components/select-menu), etc. within a button group.

::component-code
---
prettier: true
slots:
  default: |
    
    <UInput color="neutral" variant="outline" placeholder="Enter token" />

    <UButton color="neutral" variant="subtle" icon="i-lucide-clipboard" />
---
  :::u-input{color="neutral" placeholder="Enter token" variant="outline"}
  :::

  :::u-button{color="neutral" icon="i-lucide-clipboard" variant="subtle"}
  :::
::

### With tooltip

You can use a [Tooltip](https://nuxt.com/components/tooltip) within a button group.

::component-example{name="button-group-tooltip-example"}
::

### With dropdown

You can use a [DropdownMenu](https://nuxt.com/components/dropdown-menu) within a button group.

::component-example{name="button-group-dropdown-example"}
::

### With badge

You can use a [Badge](https://nuxt.com/components/badge) within a button group.

::component-example{name="button-group-badge-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Calendar

::note
This component relies on the [`@internationalized/date`](https://react-spectrum.adobe.com/internationalized/date/index.html){rel="nofollow"} package which provides objects and functions for representing and manipulating dates and times in a locale-aware manner.
::

## Usage

Use the `v-model` directive to control the selected date.

::component-code
---
cast:
  modelValue: DateValue
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue:
    - 2022
    - 2
    - 3
---
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code
---
cast:
  defaultValue: DateValue
external:
  - defaultValue
ignore:
  - defaultValue
props:
  defaultValue:
    - 2022
    - 2
    - 6
---
::

### Multiple

Use the `multiple` prop to allow multiple selections.

::component-code
---
cast:
  modelValue: DateValue[]
external:
  - modelValue
ignore:
  - multiple
  - modelValue
prettier: true
props:
  multiple: true
  modelValue:
    - - 2022
      - 2
      - 4
    - - 2022
      - 2
      - 6
    - - 2022
      - 2
      - 8
---
::

### Range

Use the `range` prop to select a range of dates.

::component-code
---
cast:
  modelValue: DateRange
external:
  - modelValue
ignore:
  - range
  - modelValue.start
  - modelValue.end
prettier: true
props:
  range: true
  modelValue:
    start:
      - 2022
      - 2
      - 3
    end:
      - 2022
      - 2
      - 20
---
::

### Color

Use the `color` prop to change the color of the calendar.

::component-code{:props='{"color":"neutral"}'}
::

### Size

Use the `size` prop to change the size of the calendar.

::component-code{:props='{"size":"xl"}'}
::

### Disabled

Use the `disabled` prop to disable the calendar.

::component-code{:props='{"disabled":true}'}
::

### Number Of Months

Use the `numberOfMonths` prop to change the number of months in the calendar.

::component-code{:props='{"numberOfMonths":3}'}
::

### Month Controls

Use the `month-controls` prop to show the month controls. Defaults to `true`.

::component-code{:props='{"monthControls":false}'}
::

### Year Controls

Use the `year-controls` prop to show the year controls. Defaults to `true`.

::component-code{:props='{"yearControls":false}'}
::

### Fixed Weeks

Use the `fixed-weeks` prop to display the calendar with fixed weeks.

::component-code{:props='{"fixedWeeks":false}'}
::

## Examples

### With chip events

Use the [Chip](https://nuxt.com/components/chip) component to add events to specific days.

::component-example{name="calendar-events-example"}
::

### With disabled dates

Use the `is-date-disabled` prop with a function to mark specific dates as disabled.

::component-example{name="calendar-disabled-dates-example"}
::

### With unavailable dates

Use the `is-date-unavailable` prop with a function to mark specific dates as unavailable.

::component-example{name="calendar-unavailable-dates-example"}
::

### With min/max dates

Use the `min-value` and `max-value` props to limit the dates.

::component-example{name="calendar-min-max-dates-example"}
::

### With other calendar systems

You can use other calenders from `@internationalized/date` to implement a different calendar system.

::component-example{name="calendar-other-system-example"}
::

::note
---
to: https://react-spectrum.adobe.com/internationalized/date/Calendar.html#implementations
---
You can check all the available calendars on `@internationalized/date` docs.
::

### With external controls

You can control the calendar with external controls by manipulating the date passed in the `v-model`.

::component-example{name="calendar-external-controls-example"}
::

### As a DatePicker

Use a [Button](https://nuxt.com/components/button) and a [Popover](https://nuxt.com/components/popover) component to create a date picker.

::component-example{name="calendar-date-picker-example"}
::

### As a DateRangePicker

Use a [Button](https://nuxt.com/components/button) and a [Popover](https://nuxt.com/components/popover) component to create a date range picker.

::component-example{name="calendar-date-range-picker-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Card

## Usage

::component-example{:props='{"class":"w-full"}' name="card-example"}
::

### Variant

Use the `variant` prop to change the variant of the Card.

::component-code
---
hide:
  - class
prettier: true
props:
  variant: subtle
  class: w-full
slots:
  header: |
    
    <Placeholder class="h-8" />
  default: |
    
    <Placeholder class="h-32" />
  footer: |
    
    <Placeholder class="h-8" />
---
  :::placeholder{.h-32}
  :::

#header
  :::placeholder{.h-8}
  :::

#footer
  :::placeholder{.h-8}
  :::
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Carousel

## Usage

### Items

Use the `items` prop as an array and render each item using the default slot:

::note
Use your mouse to drag the carousel horizontally on desktop.
::

::component-example{.p-8 name="carousel-items-example"}
::

You can also pass an array of objects with the following properties:

- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

You can control how many items are visible by using the [`basis`](https://tailwindcss.com/docs/flex-basis){rel="nofollow"} / [`width`](https://tailwindcss.com/docs/width){rel="nofollow"} utility classes on the `item`:

::component-example{.p-8.px-16 name="carousel-items-multiple-example"}
::

### Orientation

Use the `orientation` prop to change the orientation of the Progress. Defaults to `horizontal`.

::note
Use your mouse to drag the carousel vertically on desktop.
::

::component-example{.p-8 name="carousel-orientation-example"}
::

::caution
You need to specify a `height` on the container in vertical orientation.
::

### Arrows

Use the `arrows` prop to display prev and next buttons.

::component-example{.p-8 name="carousel-arrows-example"}
::

### Prev / Next

Use the `prev` and `next` props to customize the prev and next buttons with any [Button](https://nuxt.com/components/button) props.

::component-example{.p-8 name="carousel-prev-next-example"}
::

### Prev / Next Icons

Use the `prev-icon` and `next-icon` props to customize the buttons [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-arrow-left` / `i-lucide-arrow-right`.

::component-example
---
options:
  - name: prevIcon
    label: prevIcon
    default: i-lucide-chevron-left
  - name: nextIcon
    label: nextIcon
    default: i-lucide-chevron-right
class: p-8
name: carousel-prev-next-icon-example
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize these icons globally in your `app.config.ts` under `ui.icons.arrowLeft` / `ui.icons.arrowRight` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize these icons globally in your `vite.config.ts` under `ui.icons.arrowLeft` / `ui.icons.arrowRight` key.
  :::
::

### Dots

Use the `dots` prop to display a list of dots to scroll to a specific slide.

::component-example{.p-8.pb-12 name="carousel-dots-example"}
::

The number of dots is based on the number of slides displayed in the view:

::component-example{.p-8.px-16.pb-12 name="carousel-dots-multiple-example"}
::

## Plugins

The Carousel component implements the official [Embla Carousel plugins](https://www.embla-carousel.com/plugins/){rel="nofollow"}.

### Autoplay

This plugin is used to extend Embla Carousel with **autoplay** functionality.

Use the `autoplay` prop as a boolean or an object to configure the [Autoplay plugin](https://www.embla-carousel.com/plugins/autoplay/){rel="nofollow"}.

::component-example{.p-8.px-16.pb-12 name="carousel-autoplay-example"}
::

::note
In this example, we're using the `loop` prop for an infinite carousel.
::

### Auto Scroll

This plugin is used to extend Embla Carousel with **auto scroll** functionality.

Use the `auto-scroll` prop as a boolean or an object to configure the [Auto Scroll plugin](https://www.embla-carousel.com/plugins/auto-scroll/){rel="nofollow"}.

::component-example{.p-8.px-16.pb-12 name="carousel-auto-scroll-example"}
::

::note
In this example, we're using the `loop` prop for an infinite carousel.
::

### Auto Height

This plugin is used to extend Embla Carousel with **auto height** functionality. It changes the height of the carousel container to fit the height of the highest slide in view.

Use the `auto-height` prop as a boolean or an object to configure the [Auto Height plugin](https://www.embla-carousel.com/plugins/auto-height/){rel="nofollow"}.

::component-example{.p-8.pt-16 name="carousel-auto-height-example"}
::

::note
In this example, we add the `transition-[height]` class on the container to animate the height change.
::

### Class Names

Class Names is a **class name toggle** utility plugin for Embla Carousel that enables you to automate the toggling of class names on your carousel.

Use the `class-names` prop as a boolean or an object to configure the [Class Names plugin](https://www.embla-carousel.com/plugins/class-names/){rel="nofollow"}.

::component-example{.p-8 name="carousel-class-names-example"}
::

::note
In this example, we add the `transition-opacity [&:not(.is-snapped)]:opacity-10` classes on the `item` to animate the opacity change.
::

### Fade

This plugin is used to replace the Embla Carousel scroll functionality with **fade transitions**.

Use the `fade` prop as a boolean or an object to configure the [Fade plugin](https://www.embla-carousel.com/plugins/fade/){rel="nofollow"}.

::component-example{.p-8.pb-12 name="carousel-fade-example"}
::

### Wheel Gestures

This plugin is used to extend Embla Carousel with the ability to **use the mouse/trackpad wheel** to navigate the carousel.

Use the `wheel-gestures` prop as a boolean or an object to configure the [Wheel Gestures plugin](https://www.embla-carousel.com/plugins/wheel-gestures/){rel="nofollow"}.

::note
Use your mouse wheel to scroll the carousel.
::

::component-example{.p-8.px-16 name="carousel-wheel-gestures-example"}
::

## Examples

### With thumbnails

You can use the [`emblaApi`](https://nuxt.com/#expose) function [scrollTo](https://www.embla-carousel.com/api/methods/#scrollto){rel="nofollow"} to display thumbnails under the carousel that allows you to navigate to a specific slide.

::component-example{.p-8.px-16 name="carousel-thumbnails-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

You can access the typed component instance using [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const carousel = useTemplateRef('carousel')
</script>

<template>
  <UCarousel ref="carousel" />
</template>
```

This will give you access to the following:

| Name                                                                                                                                   | Type                                                                                                                                                                                                                                  |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `emblaRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                 |
| `emblaApi`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | [`Ref<EmblaCarouselType | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://www.embla-carousel.com/api/methods/#typescript){rel="nofollow"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Checkbox

## Usage

Use the `v-model` directive to control the checked state of the Checkbox.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: true
---
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":true}'}
::

### Indeterminate

Use the `indeterminate` value in the `v-model` directive or `default-value` prop to set the Checkbox to an [indeterminate state](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#indeterminate_state_checkboxes){rel="nofollow"}.

::component-code
---
ignore:
  - defaultValue
props:
  defaultValue: indeterminate
---
::

### Indeterminate Icon

Use the `indeterminate-icon` prop to customize the indeterminate icon. Defaults to `i-lucide-minus`.

::component-code
---
ignore:
  - defaultValue
props:
  defaultValue: indeterminate
  indeterminateIcon: i-lucide-plus
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.minus` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.minus` key.
  :::
::

### Label

Use the `label` prop to set the label of the Checkbox.

::component-code{:props='{"label":"Check me"}'}
::

When using the `required` prop, an asterisk is added next to the label.

::component-code
---
ignore:
  - label
props:
  required: true
  label: Check me
---
::

### Description

Use the `description` prop to set the description of the Checkbox.

::component-code
---
ignore:
  - label
props:
  label: Check me
  description: This is a checkbox.
---
::

### Icon

Use the `icon` prop to set the icon of the Checkbox when it is checked. Defaults to `i-lucide-check`.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  icon: i-lucide-heart
  defaultValue: true
  label: Check me
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.check` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.check` key.
  :::
::

### Color

Use the `color` prop to change the color of the Checkbox.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  color: neutral
  defaultValue: true
  label: Check me
---
::

### Variant

Use the `variant` prop to change the variant of the Checkbox.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  color: primary
  variant: card
  defaultValue: true
  label: Check me
---
::

### Size

Use the `size` prop to change the size of the Checkbox.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  size: xl
  variant: list
  defaultValue: true
  label: Check me
---
::

### Indicator

Use the `indicator` prop to change the position or hide the indicator. Defaults to `start`.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  indicator: end
  variant: card
  defaultValue: true
  label: Check me
---
::

### Disabled

Use the `disabled` prop to disable the Checkbox.

::component-code
---
ignore:
  - label
props:
  disabled: true
  label: Check me
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# CheckboxGroup

## Usage

Use the `v-model` directive to control the value of the CheckboxGroup or the `default-value` prop to set the initial value when you do not need to control its state.

### Items

Use the `items` prop as an array of strings or numbers:

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - CheckboxGroupItem[]
  - CheckboxGroupValue[]
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

You can also pass an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#value-key)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, base?: ClassNameValue, 'indicator'?: ClassNameValue, icon?: ClassNameValue, wrapper?: ClassNameValue, label?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - CheckboxGroupItem[]
  - CheckboxGroupValue[]
ignore:
  - modelValue
  - items
props:
  modelValue:
    - system
  items:
    - label: System
      description: This is the first option.
      value: system
    - label: Light
      description: This is the second option.
      value: light
    - label: Dark
      description: This is the third option.
      value: dark
---
::

::caution
When using objects, you need to reference the `value` property of the object in the `v-model` directive or the `default-value` prop.
::

### Value Key

You can change the property that is used to set the value by using the `value-key` prop. Defaults to `value`.

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - CheckboxGroupItem[]
  - CheckboxGroupValue[]
ignore:
  - modelValue
  - items
  - valueKey
props:
  modelValue:
    - light
  valueKey: id
  items:
    - label: System
      description: This is the first option.
      id: system
    - label: Light
      description: This is the second option.
      id: light
    - label: Dark
      description: This is the third option.
      id: dark
---
::

### Legend

Use the `legend` prop to set the legend of the CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  legend: Theme
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Color

Use the `color` prop to change the color of the CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
prettier: true
props:
  color: neutral
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Variant

Use the `variant` prop to change the variant of the CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  variant:
    - list
    - card
    - table
prettier: true
props:
  color: primary
  variant: card
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Size

Use the `size` prop to change the size of the CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  variant:
    - list
    - card
    - table
prettier: true
props:
  size: xl
  variant: list
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Orientation

Use the `orientation` prop to change the orientation of the CheckboxGroup. Defaults to `vertical`.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  variant:
    - list
    - card
    - table
prettier: true
props:
  orientation: horizontal
  variant: list
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Indicator

Use the `indicator` prop to change the position or hide the indicator. Defaults to `start`.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  indicator:
    - start
    - end
    - hidden
  variant:
    - list
    - card
    - table
prettier: true
props:
  indicator: end
  variant: card
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Disabled

Use the `disabled` prop to disable the CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  disabled: true
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Chip

## Usage

Wrap any component with a Chip to display an indicator.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Color

Use the `color` prop to change the color of the Chip.

::component-code
---
prettier: true
props:
  color: neutral
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Size

Use the `size` prop to change the size of the Chip.

::component-code
---
prettier: true
props:
  size: 3xl
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Text

Use the `text` prop to set the text of the Chip.

::component-code
---
prettier: true
props:
  text: 5
  size: 3xl
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Position

Use the `position` prop to change the position of the Chip.

::component-code
---
prettier: true
props:
  position: bottom-left
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Inset

Use the `inset` prop to display the Chip inside the component. This is useful when dealing with rounded components.

::component-code
---
prettier: true
props:
  inset: true
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" />
---
  :::u-avatar{src="https://github.com/benjamincanac.png"}
  :::
::

### Standalone

Use the `standalone` prop alongside the `inset` prop to display the Chip inline.

::component-code{:props='{"standalone":true,"inset":true}'}
::

::note
It's used this way in the [`CommandPalette`](https://nuxt.com/components/command-palette), [`InputMenu`](https://nuxt.com/components/input-menu), [`Select`](https://nuxt.com/components/select) or [`SelectMenu`](https://nuxt.com/components/select-menu) components for example.
::

## Examples

### Control visibility

You can control the visibility of the Chip using the `show` prop.

::component-example{name="chip-show-example"}
::

::note
In this example, the Chip has a color per status and is displayed when the status is not `offline`.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Collapsible

## Usage

Use a [Button](https://nuxt.com/components/button) or any other component in the default slot of the Collapsible.

Then, use the `#content` slot to add the content displayed when the Collapsible is open.

::component-code
---
ignore:
  - class
prettier: true
props:
  class: flex flex-col gap-2 w-48
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-down" block />
  content: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  block: true
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-down
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48}
  :::
::

### Unmount

Use the `unmount-on-hide` prop to prevent the content from being unmounted when the Collapsible is collapsed. Defaults to `true`.

::component-code
---
ignore:
  - class
prettier: true
props:
  unmountOnHide: false
  class: flex flex-col gap-2 w-48
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-down" block />
  content: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  block: true
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-down
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48}
  :::
::

::note
You can inspect the DOM to see the content being rendered.
::

### Disabled

Use the `disabled` prop to disable the Collapsible.

::component-code
---
ignore:
  - class
prettier: true
props:
  class: flex flex-col gap-2 w-48
  disabled: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-down" block />
  content: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  block: true
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-down
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48}
  :::
::

## Examples

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="collapsible-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the Collapsible by pressing ``.
::

::tip
This allows you to move the trigger outside of the Collapsible or remove it entirely.
::

### With rotating icon

Here is an example with a rotating icon in the Button that indicates the open state of the Collapsible.

::component-example{name="collapsible-icon-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# ColorPicker

## Usage

Use the `v-model` directive to control the value of the ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: "#00C16A"
---
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":"#00BCD4"}'}
::

### RGB Format

Use the `format` prop to set `rgb` value of the ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: rgb
  modelValue: rgb(0, 193, 106)
---
::

### HSL Format

Use the `format` prop to set `hsl` value of the ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: hsl
  modelValue: hsl(153, 100%, 37.8%)
---
::

### CMYK Format

Use the `format` prop to set `cmyk` value of the ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: cmyk
  modelValue: cmyk(100%, 0%, 45.08%, 24.31%)
---
::

### CIELab Format

Use the `format` prop to set `lab` value of the ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: lab
  modelValue: lab(68.88% -60.41% 32.55%)
---
::

### Throttle

Use the `throttle` prop to set the throttle value of the ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  throttle: 100
  modelValue: "#00C16A"
---
::

### Size

Use the `size` prop to set the size of the ColorPicker.

::component-code{:props='{"size":"xl"}'}
::

### Disabled

Use the `disabled` prop to disable the ColorPicker.

::component-code{:props='{"disabled":true}'}
::

## Examples

### As a Color chooser

Use a [Button](https://nuxt.com/components/button) and a [Popover](https://nuxt.com/components/popover) component to create a color chooser.

::component-example{name="color-picker-chooser-example"}
::

## API

### Props

::component-props
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# CommandPalette

## Usage

Use the `v-model` directive to control the value of the CommandPalette or the `default-value` prop to set the initial value when you do not need to control its state.

::tip{to="https://nuxt.com/#control-selected-items"}
You can also use the `@update:model-value` event to listen to the selected item(s).
::

### Groups

The CommandPalette component filters groups and ranks matching commands by relevance as users type. It provides dynamic, instant search results for efficient command discovery. Use the `groups` prop as an array of objects with the following properties:

- `id: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `items?: CommandPaletteItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`ignoreFilter?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-ignore-filter)
- [`postFilter?: (searchTerm: string, items: T[]) => T[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-post-filtered-items)
- `highlightedIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::caution
You must provide an `id` for each group otherwise the group will be ignored.
::

Each group contains an `items` array of objects that define the commands. Each item can have the following properties:

- `prefix?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `suffix?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `kbds?: string[] | KbdProps[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `active?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `loading?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `placeholder?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `children?: CommandPaletteItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e?: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLabel?: ClassNameValue, itemLabelPrefix?: ClassNameValue, itemLabelBase?: ClassNameValue, itemLabelSuffix?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingKbds?: ClassNameValue, itemTrailingKbdsSize?: ClassNameValue, itemTrailingHighlightedIcon?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

You can pass any property from the [Link](https://nuxt.com/components/link#props) component such as `to`, `target`, etc.

::component-code
---
collapse: true
external:
  - groups
  - modelValue
hide:
  - autofocus
ignore:
  - groups
  - modelValue
  - class
props:
  modelValue: {}
  autofocus: false
  groups:
    - id: users
      label: Users
      items:
        - label: Benjamin Canac
          suffix: benjamincanac
          avatar:
            src: https://github.com/benjamincanac.png
        - label: Sylvain Marroufin
          suffix: smarroufin
          avatar:
            src: https://github.com/smarroufin.png
        - label: Sébastien Chopin
          suffix: atinux
          avatar:
            src: https://github.com/atinux.png
        - label: Romain Hamel
          suffix: romhml
          avatar:
            src: https://github.com/romhml.png
        - label: Haytham A. Salama
          suffix: Haythamasalama
          avatar:
            src: https://github.com/Haythamasalama.png
        - label: Daniel Roe
          suffix: danielroe
          avatar:
            src: https://github.com/danielroe.png
        - label: Neil Richter
          suffix: noook
          avatar:
            src: https://github.com/noook.png
  class: flex-1
class: "!p-0"
---
::

::tip{to="https://nuxt.com/#with-children-in-items"}
Each item can take a `children` array of objects with the following properties to create submenus:
::

### Multiple

Use the `multiple` prop to allow multiple selections.

::component-code
---
collapse: true
external:
  - groups
  - modelValue
hide:
  - autofocus
ignore:
  - groups
  - modelValue
  - multiple
  - class
props:
  multiple: true
  autofocus: false
  modelValue: []
  groups:
    - id: users
      label: Users
      items:
        - label: Benjamin Canac
          suffix: benjamincanac
          avatar:
            src: https://github.com/benjamincanac.png
        - label: Sylvain Marroufin
          suffix: smarroufin
          avatar:
            src: https://github.com/smarroufin.png
        - label: Sébastien Chopin
          suffix: atinux
          avatar:
            src: https://github.com/atinux.png
        - label: Romain Hamel
          suffix: romhml
          avatar:
            src: https://github.com/romhml.png
        - label: Haytham A. Salama
          suffix: Haythamasalama
          avatar:
            src: https://github.com/Haythamasalama.png
        - label: Daniel Roe
          suffix: danielroe
          avatar:
            src: https://github.com/danielroe.png
        - label: Neil Richter
          suffix: noook
          avatar:
            src: https://github.com/noook.png
  class: flex-1
class: "!p-0"
---
::

::caution
Ensure to pass an array to the `default-value` prop or the `v-model` directive.
::

### Placeholder

Use the `placeholder` prop to change the placeholder text.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  placeholder: Search an app...
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

### Icon

Use the `icon` prop to customize the input [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-search`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  icon: i-lucide-box
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.search` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.search` key.
  :::
::

### Selected Icon

Use the `selected-icon` prop to customize the selected item [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-check`.

::component-code
---
collapse: true
external:
  - groups
  - modelValue
hide:
  - autofocus
ignore:
  - groups
  - modelValue
  - multiple
  - class
props:
  multiple: true
  autofocus: false
  modelValue:
    - label: Benjamin Canac
      suffix: benjamincanac
      avatar:
        src: https://github.com/benjamincanac.png
  selectedIcon: i-lucide-circle-check
  groups:
    - id: users
      label: Users
      items:
        - label: Benjamin Canac
          suffix: benjamincanac
          avatar:
            src: https://github.com/benjamincanac.png
        - label: Sylvain Marroufin
          suffix: smarroufin
          avatar:
            src: https://github.com/smarroufin.png
        - label: Sébastien Chopin
          suffix: atinux
          avatar:
            src: https://github.com/atinux.png
        - label: Romain Hamel
          suffix: romhml
          avatar:
            src: https://github.com/romhml.png
        - label: Haytham A. Salama
          suffix: Haythamasalama
          avatar:
            src: https://github.com/Haythamasalama.png
        - label: Daniel Roe
          suffix: danielroe
          avatar:
            src: https://github.com/danielroe.png
        - label: Neil Richter
          suffix: noook
          avatar:
            src: https://github.com/noook.png
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.check` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.check` key.
  :::
::

### Trailing Icon

Use the `trailing-icon` prop to customize the trailing [Icon](https://nuxt.com/components/icon) when an item has children. Defaults to `i-lucide-chevron-right`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - groups
  - class
prettier: true
props:
  autofocus: false
  trailingIcon: i-lucide-arrow-right
  groups:
    - id: actions
      items:
        - label: Share
          icon: i-lucide-share
          children:
            - label: Email
              icon: i-lucide-mail
            - label: Copy
              icon: i-lucide-copy
            - label: Link
              icon: i-lucide-link
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronRight` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronRight` key.
  :::
::

### Loading

Use the `loading` prop to show a loading icon on the CommandPalette.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  loading: true
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  loading: true
  loadingIcon: i-lucide-loader
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Close

Use the `close` prop to display a [Button](https://nuxt.com/components/button) to dismiss the CommandPalette.

::tip
An `update:open` event will be emitted when the close button is clicked.
::

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
  - close
props:
  autofocus: false
  close: true
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

You can pass any property from the [Button](https://nuxt.com/components/button) component to customize it.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - close.color
  - close.variant
  - groups
  - class
prettier: true
props:
  autofocus: false
  close:
    color: primary
    variant: outline
    class: rounded-full
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

### Close Icon

Use the `close-icon` prop to customize the close button [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-x`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
  - close
props:
  autofocus: false
  close: true
  closeIcon: i-lucide-arrow-right
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.close` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.close` key.
  :::
::

### Back

Use the `back` prop to customize or hide the back button (with `false` value) displayed when navigating into a submenu.

You can pass any property from the [Button](https://nuxt.com/components/button) component to customize it.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - back.color
  - groups
  - class
prettier: true
props:
  autofocus: false
  back:
    color: primary
  groups:
    - id: actions
      items:
        - label: Share
          icon: i-lucide-share
          children:
            - label: Email
              icon: i-lucide-mail
            - label: Copy
              icon: i-lucide-copy
            - label: Link
              icon: i-lucide-link
  class: flex-1
class: "!p-0"
---
::

### Back Icon

Use the `back-icon` prop to customize the back button [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-arrow-left`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
  - back
props:
  autofocus: false
  back: true
  backIcon: i-lucide-house
  groups:
    - id: actions
      items:
        - label: Share
          icon: i-lucide-share
          children:
            - label: Email
              icon: i-lucide-mail
            - label: Copy
              icon: i-lucide-copy
            - label: Link
              icon: i-lucide-link
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.arrowLeft` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.arrowLeft` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the CommandPalette.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - groups
  - class
props:
  autofocus: false
  disabled: true
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

## Examples

### Control selected item(s)

You can control the selected item(s) by using the `default-value` prop or the `v-model` directive, by using the `onSelect` field on each item or by using the `@update:model-value` event.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-select-example
---
::

### Control search term

Use the `v-model:search-term` directive to control the search term.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-search-term-example
---
::

::note
This example uses the `@update:model-value` event to reset the search term when an item is selected.
::

### With children in items

You can create hierarchical menus by using the `children` property in items. When an item has children, it will automatically display a chevron icon and enable navigation into a submenu.

::component-example
---
collapse: true
prettier: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-items-children-example
---
::

::note
When navigating into a submenu:

- The search term is reset
- A back button appears in the input
- You can go back to the previous group by pressing the `` key
::

### With fetched items

You can fetch items from an API and use them in the CommandPalette.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-fetch-example
---
::

### With ignore filter

You can set the `ignoreFilter` field to `true` on a group to disable the internal search and use your own search logic.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-ignore-filter-example
---
::

::note
This example uses [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} to debounce the API calls.
::

### With post-filtered items

You can use the `postFilter` field on a group to filter items after the search happened.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-post-filter-example
---
::

::note
Start typing to see items with higher level appear.
::

### With custom fuse search

You can use the `fuse` prop to override the options of [useFuse](https://vueuse.org/integrations/useFuse){rel="nofollow"} which defaults to:

```ts
{
  fuseOptions: {
    ignoreLocation: true,
    threshold: 0.1,
    keys: ['label', 'suffix']
  },
  resultLimit: 12,
  matchAllWhenSearchEmpty: true
}
```

::tip
The `fuseOptions` are the options of [Fuse.js](https://www.fusejs.io/api/options.html){rel="nofollow"}, the `resultLimit` is the maximum number of results to return and the `matchAllWhenSearchEmpty` is a boolean to match all items when the search term is empty.
::

You can for example set `{ fuseOptions: { includeMatches: true } }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} to highlight the search term in the items.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-fuse-example
---
::

### Within a Popover

You can use the CommandPalette component inside a [Popover](https://nuxt.com/components/popover)'s content.

::component-example
---
collapse: true
props:
  autofocus: false
name: popover-command-palette-example
---
::

### Within a Modal

You can use the CommandPalette component inside a [Modal](https://nuxt.com/components/modal)'s content.

::component-example
---
collapse: true
props:
  autofocus: false
name: modal-command-palette-example
---
::

### Within a Drawer

You can use the CommandPalette component inside a [Drawer](https://nuxt.com/components/drawer)'s content.

::component-example
---
collapse: true
props:
  autofocus: false
name: drawer-command-palette-example
---
::

### Listen open state

When using the `close` prop, you can listen to the `update:open` event when the button is clicked.

::component-example
---
collapse: true
props:
  autofocus: false
name: command-palette-open-example
---
::

::note
This can be useful when using the CommandPalette inside a [`Modal`](https://nuxt.com/components/modal) for example.
::

### With footer slot :badge{.align-text-top label="New"}

Use the `#footer` slot to add custom content at the bottom of the CommandPalette, such as keyboard shortcuts help or additional actions.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-footer-slot-example
---
::

### With custom slot

Use the `slot` property to customize a specific item or group.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-custom-slot-example
---
::

::tip{to="https://nuxt.com/#slots"}
You can also use the `#item`, `#item-leading`, `#item-label` and `#item-trailing` slots to customize all items.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Container

## Usage

::component-example{:props='{"class":"w-full"}' name="container-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# ContextMenu

## Usage

Use anything you like in the default slot of the ContextMenu, and right-click on it to display the menu.

### Items

Use the `items` prop as an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `kbds?: string[] | KbdProps[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "link" | "label" | "separator" | "checkbox"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- [`color?: "error" | "primary" | "secondary" | "success" | "info" | "warning" | "neutral"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-color-items)
- [`checked?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`onUpdateChecked?(checked: boolean): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `children?: ContextMenuItem[] | ContextMenuItem[][]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, label?: ClassNameValue, separator?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLabel?: ClassNameValue, itemLabelExternalIcon?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue, itemTrailingKbds?: ClassNameValue, itemTrailingKbdsSize?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

You can pass any property from the [Link](https://nuxt.com/components/link#props) component such as `to`, `target`, etc.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - ContextMenuItem[][]
ignore:
  - items
  - ui.content
prettier: true
props:
  items:
    - - label: Appearance
        children:
          - label: System
            icon: i-lucide-monitor
          - label: Light
            icon: i-lucide-sun
          - label: Dark
            icon: i-lucide-moon
    - - label: Show Sidebar
        kbds:
          - meta
          - s
      - label: Show Toolbar
        kbds:
          - shift
          - meta
          - d
      - label: Collapse Pinned Tabs
        disabled: true
    - - label: Refresh the Page
      - label: Clear Cookies and Refresh
      - label: Clear Cache and Refresh
      - type: separator
      - label: Developer
        children:
          - - label: View Source
              kbds:
                - meta
                - shift
                - u
            - label: Developer Tools
              kbds:
                - option
                - meta
                - i
            - label: Inspect Elements
              kbds:
                - option
                - meta
                - c
          - - label: JavaScript Console
              kbds:
                - option
                - meta
                - j
  ui:
    content: w-48
slots:
  default: >
    
    <div class="flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72">
      Right click here
    </div>
---
  :::div
  ---
  class: flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72
  ---
  Right click here
  :::
::

::note
You can also pass an array of arrays to the `items` prop to create separated groups of items.
::

::tip
Each item can take a `children` array of objects with the same properties as the `items` prop to create a nested menu which can be controlled using the `open`, `defaultOpen` and `content` properties.
::

### Size

Use the `size` prop to change the size of the ContextMenu.

::component-code
---
external:
  - items
externalTypes:
  - ContextMenuItem[]
ignore:
  - items
  - ui.content
prettier: true
props:
  size: xl
  items:
    - label: System
      icon: i-lucide-monitor
    - label: Light
      icon: i-lucide-sun
    - label: Dark
      icon: i-lucide-moon
  ui:
    content: w-48
slots:
  default: >
    
    <div class="flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72">
      Right click here
    </div>
---
  :::div
  ---
  class: flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72
  ---
  Right click here
  :::
::

### Disabled

Use the `disabled` prop to disable the ContextMenu.

::component-code
---
external:
  - items
externalTypes:
  - ContextMenuItem[]
ignore:
  - items
  - ui.content
prettier: true
props:
  disabled: true
  items:
    - label: System
      icon: i-lucide-monitor
    - label: Light
      icon: i-lucide-sun
    - label: Dark
      icon: i-lucide-moon
  ui:
    content: w-48
slots:
  default: >
    
    <div class="flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72">
      Right click here
    </div>
---
  :::div
  ---
  class: flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72
  ---
  Right click here
  :::
::

## Examples

### With checkbox items

You can use the `type` property with `checkbox` and use the `checked` / `onUpdateChecked` properties to control the checked state of the item.

::component-example{collapse name="context-menu-checkbox-items-example"}
::

::note
To ensure reactivity for the `checked` state of items, it's recommended to wrap your `items` array inside a `computed`.
::

### With color items

You can use the `color` property to highlight certain items with a color.

::component-example{name="context-menu-color-items-example"}
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="context-menu-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
You can also use the `#item`, `#item-leading`, `#item-label` and `#item-trailing` slots to customize all items.
::

### Extract shortcuts

When you have some items with `kbds` property (displaying some [Kbd](https://nuxt.com/components/kbd)), you can easily make them work with the [defineShortcuts](https://nuxt.com/composables/define-shortcuts) composable.

Inside the `defineShortcuts` composable, there is an `extractShortcuts` utility that will extract the shortcuts recursively from the items and return an object that you can pass to `defineShortcuts`. It will automatically call the `select` function of the item when the shortcut is pressed.

```vue
<script setup lang="ts">
const items = [
  [{
    label: 'Show Sidebar',
    kbds: ['meta', 'S'],
    onSelect() {
      console.log('Show Sidebar clicked')
    }
  }, {
    label: 'Show Toolbar',
    kbds: ['shift', 'meta', 'D'],
    onSelect() {
      console.log('Show Toolbar clicked')
    }
  }, {
    label: 'Collapse Pinned Tabs',
    disabled: true
  }], [{
    label: 'Refresh the Page'
  }, {
    label: 'Clear Cookies and Refresh'
  }, {
    label: 'Clear Cache and Refresh'
  }, {
    type: 'separator' as const
  }, {
    label: 'Developer',
    children: [[{
      label: 'View Source',
      kbds: ['option', 'meta', 'U'],
      onSelect() {
        console.log('View Source clicked')
      }
    }, {
      label: 'Developer Tools',
      kbds: ['option', 'meta', 'I'],
      onSelect() {
        console.log('Developer Tools clicked')
      }
    }], [{
      label: 'Inspect Elements',
      kbds: ['option', 'meta', 'C'],
      onSelect() {
        console.log('Inspect Elements clicked')
      }
    }], [{
      label: 'JavaScript Console',
      kbds: ['option', 'meta', 'J'],
      onSelect() {
        console.log('JavaScript Console clicked')
      }
    }]]
  }]
]

defineShortcuts(extractShortcuts(items))
</script>
```

::note
In this example, `` ``, `` `` ``, `` `` ``, `` `` ``, `` `` `` and `` `` `` would trigger the `select` function of the corresponding item.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Drawer

## Usage

Use a [Button](https://nuxt.com/components/button) or any other component in the default slot of the Drawer.

Then, use the `#content` slot to add the content displayed when the Drawer is open.

::component-code
---
prettier: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

You can also use the `#header`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}, `#body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} and `#footer`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} slots to customize the Drawer's content.

### Title

Use the `title` prop to set the title of the Drawer's header.

::component-code
---
prettier: true
props:
  title: Drawer with title
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Description

Use the `description` prop to set the description of the Drawer's header.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Drawer with description
  description: Lorem ipsum dolor sit amet, consectetur adipiscing elit.
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Direction

Use the `direction` prop to control the direction of the Drawer. Defaults to `bottom`.

::component-code
---
prettier: true
props:
  direction: right
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="min-w-96 min-h-96 size-full m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.min-w-96.min-h-96.size-full.m-4}
  :::
::

### Inset

Use the `inset` prop to inset the Drawer from the edges.

::component-code
---
prettier: true
props:
  direction: right
  inset: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="min-w-96 min-h-96 size-full m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.min-w-96.min-h-96.size-full.m-4}
  :::
::

### Handle

Use the `handle` prop to control whether the Drawer has a handle or not. Defaults to `true`.

::component-code
---
prettier: true
props:
  handle: false
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

### Handle Only

Use the `handle-only` prop to only allow the Drawer to be dragged by the handle.

::component-code
---
prettier: true
props:
  handleOnly: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

### Overlay

Use the `overlay` prop to control whether the Drawer has an overlay or not. Defaults to `true`.

::component-code
---
prettier: true
props:
  overlay: false
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

### Scale background

Use the `should-scale-background` prop to scale the background when the Drawer is open, creating a visual depth effect. You can set the `set-background-color-on-scale` prop to `false` to prevent changing the background color.

::component-code
---
prettier: true
props:
  shouldScaleBackground: true
  setBackgroundColorOnScale: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-screen.m-4}
  :::
::

::warning
Make sure to add the `data-vaul-drawer-wrapper` directive to a parent element of your app to make this work.

```vue [app.vue]
<template>
  <UApp>
    <div class="bg-default" data-vaul-drawer-wrapper>
      <NuxtLayout>
        <NuxtPage />
      </NuxtLayout>
    </div>
  </UApp>
</template>
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    rootAttrs: {
      'data-vaul-drawer-wrapper': '',
      'class': 'bg-default'
    }
  }
})
```
::

## Examples

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{prettier name="drawer-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the Drawer by pressing ``.
::

::tip
This allows you to move the trigger outside of the Drawer or remove it entirely.
::

### Disable dismissal

Set the `dismissible` prop to `false` to prevent the Drawer from being closed when clicking outside of it or pressing escape.

::component-example{prettier name="drawer-dismissible-example"}
::

::note
In this example, the `header` slot is used to add a close button which is not done by default.
::

### With interactive background

Set the `overlay` and `modal` props to `false` alongside the `dismissible` prop to make the Drawer's background interactive without closing the Drawer.

::component-example{prettier name="drawer-modal-example"}
::

### Responsive drawer

You can render a [Modal](https://nuxt.com/components/modal) component on desktop and a Drawer on mobile for example.

::component-example{prettier name="drawer-responsive-example"}
::

### Nested drawers :badge{.align-text-top label="New"}

You can nest drawers within each other by using the `nested` prop.

::component-example{prettier name="drawer-nested-example"}
::

### With footer slot

Use the `#footer` slot to add content after the Drawer's body.

::component-example{collapse prettier name="drawer-footer-slot-example"}
::

### With command palette

You can use a [CommandPalette](https://nuxt.com/components/command-palette) component inside the Drawer's content.

::component-example{collapse name="drawer-command-palette-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# DropdownMenu

## Usage

Use a [Button](https://nuxt.com/components/button) or any other component in the default slot of the DropdownMenu.

### Items

Use the `items` prop as an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `kbds?: string[] | KbdProps[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "link" | "label" | "separator" | "checkbox"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- [`color?: "error" | "primary" | "secondary" | "success" | "info" | "warning" | "neutral"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-color-items)
- [`checked?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`onUpdateChecked?(checked: boolean): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `children?: DropdownMenuItem[] | DropdownMenuItem[][]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, label?: ClassNameValue, separator?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLabel?: ClassNameValue, itemLabelExternalIcon?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue, itemTrailingKbds?: ClassNameValue, itemTrailingKbdsSize?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

You can pass any property from the [Link](https://nuxt.com/components/link#props) component such as `to`, `target`, etc.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - DropdownMenuItem[][]
ignore:
  - items
  - ui.content
prettier: true
props:
  items:
    - - label: Benjamin
        avatar:
          src: https://github.com/benjamincanac.png
        type: label
    - - label: Profile
        icon: i-lucide-user
      - label: Billing
        icon: i-lucide-credit-card
      - label: Settings
        icon: i-lucide-cog
        kbds:
          - ","
      - label: Keyboard shortcuts
        icon: i-lucide-monitor
    - - label: Team
        icon: i-lucide-users
      - label: Invite users
        icon: i-lucide-user-plus
        children:
          - - label: Email
              icon: i-lucide-mail
            - label: Message
              icon: i-lucide-message-square
          - - label: More
              icon: i-lucide-circle-plus
      - label: New team
        icon: i-lucide-plus
        kbds:
          - meta
          - n
    - - label: GitHub
        icon: i-simple-icons-github
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Support
        icon: i-lucide-life-buoy
        to: /components/dropdown-menu
      - label: API
        icon: i-lucide-cloud
        disabled: true
    - - label: Logout
        icon: i-lucide-log-out
        kbds:
          - shift
          - meta
          - q
  ui:
    content: w-48
slots:
  default: |
    
    <UButton icon="i-lucide-menu" color="neutral" variant="outline" />
---
  :::u-button{color="neutral" icon="i-lucide-menu" variant="outline"}
  :::
::

::note
You can also pass an array of arrays to the `items` prop to create separated groups of items.
::

::tip
Each item can take a `children` array of objects with the same properties as the `items` prop to create a nested menu which can be controlled using the `open`, `defaultOpen` and `content` properties.
::

### Content

Use the `content` prop to control how the DropdownMenu content is rendered, like its `align` or `side` for example.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - items
  - ui.content
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  content:
    align: start
    side: bottom
    sideOffset: 8
  ui:
    content: w-48
slots:
  default: >
    
    <UButton label="Open" icon="i-lucide-menu" color="neutral" variant="outline"
    />
---
  :::u-button{color="neutral" icon="i-lucide-menu" label="Open" variant="outline"}
  :::
::

### Arrow

Use the `arrow` prop to display an arrow on the DropdownMenu.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - arrow
  - items
  - ui.content
prettier: true
props:
  arrow: true
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  ui:
    content: w-48
slots:
  default: >
    
    <UButton label="Open" icon="i-lucide-menu" color="neutral" variant="outline"
    />
---
  :::u-button{color="neutral" icon="i-lucide-menu" label="Open" variant="outline"}
  :::
::

### Size

Use the `size` prop to control the size of the DropdownMenu.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - items
  - content.align
  - ui.content
prettier: true
props:
  size: xl
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  content:
    align: start
  ui:
    content: w-48
slots:
  default: >
    
    <UButton size="xl" label="Open" icon="i-lucide-menu" color="neutral"
    variant="outline" />
---
  :::u-button
  ---
  color: neutral
  icon: i-lucide-menu
  label: Open
  size: xl
  variant: outline
  ---
  :::
::

::warning
The `size` prop will not be proxied to the Button, you need to set it yourself.
::

::note
When using the same size, the DropdownMenu items will be perfectly aligned with the Button.
::

### Disabled

Use the `disabled` prop to disable the DropdownMenu.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - items
  - ui.content
prettier: true
props:
  disabled: true
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  ui:
    content: w-48
slots:
  default: >
    
    <UButton label="Open" icon="i-lucide-menu" color="neutral" variant="outline"
    />
---
  :::u-button{color="neutral" icon="i-lucide-menu" label="Open" variant="outline"}
  :::
::

## Examples

### With checkbox items

You can use the `type` property with `checkbox` and use the `checked` / `onUpdateChecked` properties to control the checked state of the item.

::component-example{collapse name="dropdown-menu-checkbox-items-example"}
::

::note
To ensure reactivity for the `checked` state of items, it's recommended to wrap your `items` array inside a `computed`.
::

### With color items

You can use the `color` property to highlight certain items with a color.

::component-example{name="dropdown-menu-color-items-example"}
::

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="dropdown-menu-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the DropdownMenu by pressing ``.
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="dropdown-menu-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
You can also use the `#item`, `#item-leading`, `#item-label` and `#item-trailing` slots to customize all items.
::

### Extract shortcuts

When you have some items with `kbds` property (displaying some [Kbd](https://nuxt.com/components/kbd)), you can easily make them work with the [defineShortcuts](https://nuxt.com/composables/define-shortcuts) composable.

Inside the `defineShortcuts` composable, there is an `extractShortcuts` utility that will extract the shortcuts recursively from the items and return an object that you can pass to `defineShortcuts`. It will automatically call the `select` function of the item when the shortcut is pressed.

```vue
<script setup lang="ts">
import type { DropdownMenuItem } from '@nuxt/ui'

const items: DropdownMenuItem[] = [{
  label: 'Invite users',
  icon: 'i-lucide-user-plus',
  children: [{
    label: 'Invite by email',
    icon: 'i-lucide-send-horizontal',
    kbds: ['meta', 'e'],
    onSelect() {
      console.log('Invite by email clicked')
    }
  }, {
    label: 'Invite by link',
    icon: 'i-lucide-link',
    kbds: ['meta', 'i'],
    onSelect() {
      console.log('Invite by link clicked')
    }
  }]
}, {
  label: 'New team',
  icon: 'i-lucide-plus',
  kbds: ['meta', 'n'],
  onSelect() {
    console.log('New team clicked')
  }
}]

defineShortcuts(extractShortcuts(items))
</script>
```

::note
In this example, `` ``, `` `` and `` `` would trigger the `select` function of the corresponding item.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# FileUpload

## Usage

Use the `v-model` directive to control the value of the FileUpload.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - class
props:
  modelValue: null
  class: w-96 min-h-48
---
::

### Multiple

Use the `multiple` prop to allow multiple files to be selected.

::component-code
---
ignore:
  - class
props:
  multiple: true
  class: w-96 min-h-48
---
::

### Dropzone

Use the `dropzone` prop to enable/disable the droppable area. Defaults to `true`.

::component-code
---
ignore:
  - class
props:
  dropzone: false
  class: w-96 min-h-48
---
::

### Interactive

Use the `interactive` prop to enable/disable the clickable area. Defaults to `true`.

::tip{to="https://nuxt.com/#with-files-bottom-slot"}
This can be useful when adding a [`Button`](https://nuxt.com/components/button) component in the `#actions` slot.
::

::component-code
---
ignore:
  - class
props:
  interactive: false
  class: w-96 min-h-48
---
::

### Accept

Use the `accept` prop to specify the allowed file types for the input. Provide a comma-separated list of [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/MIME_types){rel="nofollow"} or file extensions (e.g., `image/png,application/pdf,.jpg`). Defaults to `*` (all file types).

::component-code
---
ignore:
  - accept
  - class
props:
  accept: image/*
  class: w-96 min-h-48
---
::

### Label

Use the `label` prop to set the label of the FileUpload.

::component-code
---
ignore:
  - class
prettier: true
props:
  label: Drop your image here
  class: w-96 min-h-48
---
::

### Description

Use the `description` prop to set the description of the FileUpload.

::component-code
---
ignore:
  - label
  - class
prettier: true
props:
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96 min-h-48
---
::

### Icon

Use the `icon` prop to set the icon of the FileUpload. Defaults to `i-lucide-upload`.

::component-code
---
ignore:
  - label
  - description
  - class
prettier: true
props:
  icon: i-lucide-image
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96 min-h-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.upload` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.upload` key.
  :::
::

### Color

Use the `color` prop to change the color of the FileUpload.

::component-code
---
ignore:
  - label
  - description
  - class
prettier: true
props:
  color: neutral
  highlight: true
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96 min-h-48
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variant

Use the `variant` prop to change the variant of the FileUpload.

::component-code{:ignore='["class"]' :props='{"variant":"button"}'}
::

### Size

Use the `size` prop to change the size of the FileUpload.

::component-code
---
ignore:
  - label
  - description
  - class
prettier: true
props:
  size: xl
  variant: area
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
---
::

### Layout

Use the `layout` prop to change how the files are displayed in the FileUpload. Defaults to `grid`.

::warning
This prop only works when `variant` is `area`.
::

::component-code
---
ignore:
  - label
  - description
  - multiple
  - class
  - ui.base
prettier: true
props:
  layout: list
  multiple: true
  label: Drop your images here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96
  ui:
    base: min-h-48
---
::

### Position

Use the `position` prop to change the position of the files in the FileUpload. Defaults to `outside`.

::warning
This prop only works when `variant` is `area` and when `layout` is `list`.
::

::component-code
---
ignore:
  - label
  - description
  - multiple
  - layout
  - class
  - ui.base
prettier: true
props:
  position: inside
  layout: list
  multiple: true
  label: Drop your images here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96
  ui:
    base: min-h-48
---
::

## Examples

### With Form validation

You can use the FileUpload within a [Form](https://nuxt.com/components/form) and [FormField](https://nuxt.com/components/form-field) components to handle validation and error handling.

::component-example
---
collapse: true
prettier: true
name: file-upload-form-validation-example
---
::

### With default slot

You can use the default slot to make your own FileUpload component.

::component-example{collapse prettier name="file-upload-default-slot-example"}
::

### With files-bottom slot

You can use the `files-bottom` slot to add a [Button](https://nuxt.com/components/button) under the files list to remove all files for example.

::component-example
---
collapse: true
prettier: true
name: file-upload-files-bottom-slot-example
---
::

::note{to="https://nuxt.com/#interactive"}
The `interactive` prop is set to `false` in this example to prevent the default clickable area.
::

### With files-top slot

You can use the `files-top` slot to add a [Button](https://nuxt.com/components/button) above the files list to add new files for example.

::component-example{collapse prettier name="file-upload-files-top-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                      | Type                                                                                                                                                       |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}    | `Ref<HTMLInputElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |
| `dropzoneRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLDivElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}   |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Form

## Usage

Use the Form component to validate form data using validation libraries such as [Valibot](https://github.com/fabian-hiller/valibot){rel="nofollow"}, [Zod](https://github.com/colinhacks/zod){rel="nofollow"}, [Yup](https://github.com/jquense/yup){rel="nofollow"}, [Joi](https://github.com/hapijs/joi){rel="nofollow"}, [Superstruct](https://github.com/ianstormtaylor/superstruct){rel="nofollow"} or your own validation logic.

It works with the [FormField](https://nuxt.com/components/form-field) component to display error messages around form elements automatically.

### Schema Validation

It requires two props:

- `state` - a reactive object holding the form's state.
- `schema` - any [Standard Schema](https://standardschema.dev/){rel="nofollow"} or a schema from [Yup](https://github.com/jquense/yup){rel="nofollow"}, [Joi](https://github.com/hapijs/joi){rel="nofollow"} or [Superstruct](https://github.com/ianstormtaylor/superstruct){rel="nofollow"}.

::warning
**No validation library is included** by default, ensure you **install the one you need**.
::

::tabs{.gap-0}
  :::component-example
  ---
  props:
    class: w-60
  label: Valibot
  name: form-example-valibot
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Zod
  name: form-example-zod
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Yup
  name: form-example-yup
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Joi
  name: form-example-joi
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Superstruct
  name: form-example-superstruct
  ---
  :::
::

Errors are reported directly to the [FormField](https://nuxt.com/components/form-field) component based on the `name` or `error-pattern` prop. This means the validation rules defined for the `email` attribute in your schema will be applied to `<FormField name="email">`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="vue"}.

Nested validation rules are handled using dot notation. For example, a rule like `{ user: z.object({ email: z.string() }) }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} will be applied to `<FormField name="user.email">`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="vue"}.

### Custom Validation

Use the `validate` prop to apply your own validation logic.

The validation function must return a list of errors with the following attributes:

- `message` - the error message to display.
- `name` - the `name` of the `FormField` to send the error to.

::tip
It can be used alongside the `schema` prop to handle complex use cases.
::

::component-example{:props='{"class":"w-60"}' name="form-example-basic"}
::

### Input Events

The Form component automatically triggers validation when an input emits an `input`, `change`, or `blur` event.

- Validation on `input` occurs **as you type**.
- Validation on `change` occurs when you **commit to a value**.
- Validation on `blur` happens when an input **loses focus**.

You can control when validation happens this using the `validate-on` prop.

::tip
The form always validates on submit.
::

::component-example
---
options:
  - name: validate-on
    label: validate-on
    items:
      - input
      - change
      - blur
    default:
      - input
      - change
      - blur
    multiple: true
source: false
label: Default
name: form-example-elements
---
::

::tip
You can use the [`useFormField`](https://nuxt.com/composables/use-form-field) composable to implement this inside your own components.
::

### Error Event

You can listen to the `@error` event to handle errors. This event is triggered when the form is submitted and contains an array of `FormError` objects with the following fields:

- `id` - the input's `id`.
- `name` - the `name` of the `FormField`
- `message` - the error message to display.

Here's an example that focuses the first input element with an error after the form is submitted:

::component-example
---
collapse: true
props:
  class: w-60
name: form-example-on-error
---
::

### Nesting Forms

Nesting form components allows you to manage complex data structures, such as lists or conditional fields, more efficiently.

For example, it can be used to dynamically add fields based on user's input:

::component-example{collapse name="form-example-nested"}
::

Or to validate list inputs:

::component-example{collapse name="form-example-nested-list"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

You can access the typed component instance using [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const form = useTemplateRef('form')
</script>

<template>
  <UForm ref="form" />
</template>
```

This will give you access to the following:

| Name                                                                                                                                                                                                                                    | Type                                                                                                                                                                                                                                                                                         |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `submit()`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                  | `Promise<void>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} :br ::div{.text-toned.mt-1}
Triggers form submission.
::                                                                                         |
| `validate(opts: { name?: keyof T | (keyof T)[], silent?: boolean, nested?: boolean, transform?: boolean })`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Promise<T>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} :br ::div{.text-toned.mt-1}
Triggers form validation. Will raise any errors unless `opts.silent` is set to true.
::                                 |
| `clear(path?: keyof T | RegExp)`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                            | `void` :br ::div{.text-toned.mt-1}
Clears form errors associated with a specific path. If no path is provided, clears all form errors.
::                                                                                                                                                    |
| `getErrors(path?: keyof T RegExp)`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                          | `FormError[]`{lang="ts-type :br ::div{.text-toned.mt-1}
Retrieves form errors associated with a specific path. If no path is provided, returns all form errors.
::                                                                                                                           |
| `setErrors(errors: FormError[], name?: keyof T RegExp)`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                     | `void` :br ::div{.text-toned.mt-1}
Sets form errors for a given path. If no path is provided, overrides all errors.
::                                                                                                                                                                       |
| `errors`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                    | `Ref<FormError[]>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} :br ::div{.text-toned.mt-1}
A reference to the array containing validation errors. Use this to access or manipulate the error information.
:: |
| `disabled`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                  | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                                                                   |
| `dirty`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                     | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} `true` if at least one form field has been updated by the user.                                                                                   |
| `dirtyFields`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                               | `DeepReadonly<Set<keyof T>>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} Tracks fields that have been modified by the user.                                                                                  |
| `touchedFields`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                             | `DeepReadonly<Set<keyof T>>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} Tracks fields that the user interacted with.                                                                                        |
| `blurredFields`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                             | `DeepReadonly<Set<keyof T>>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} Tracks fields blurred by the user.                                                                                                  |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# FormField

## Usage

Wrap any form component with a FormField. Used in a [Form](https://nuxt.com/components/form), it provides validation and error handling.

### Label

Use the `label` prop to set the label for the form control.

::component-code
---
prettier: true
props:
  label: Email
slots:
  default: |
    
    <UInput placeholder="Enter your email" />
---
  :::u-input{placeholder="Enter your email"}
  :::
::

::note
The label `for` attribute and the form control are associated with a unique `id` if not provided.
::

When using the `required` prop, an asterisk is added next to the label.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  required: true
slots:
  default: |
    
    <UInput placeholder="Enter your email" />
---
  :::u-input{placeholder="Enter your email"}
  :::
::

### Description

Use the `description` prop to provide additional information below the label.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  description: We'll never share your email with anyone else.
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

### Hint

Use the `hint` prop to display a hint message next to the label.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  hint: Optional
slots:
  default: |
    
    <UInput placeholder="Enter your email" />
---
  :::u-input{placeholder="Enter your email"}
  :::
::

### Help

Use the `help` prop to display a help message below the form control.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  help: Please enter a valid email address.
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

### Error

Use the `error` prop to display an error message below the form control. When used together with the `help` prop, the `error` prop takes precedence.

When used inside a [Form](https://nuxt.com/components/form), this is automatically set when a validation error occurs.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  error: Please enter a valid email address.
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

::tip{to="https://nuxt.com/getting-started/theme#colors"}
This sets the `color` to `error` on the form control. You can change it globally in your `app.config.ts`.
::

### Size

Use the `size` prop to change the size of the FormField, the `size` is proxied to the form control.

::component-code
---
ignore:
  - label
  - description
  - hint
  - help
prettier: true
props:
  label: Email
  description: We'll never share your email with anyone else.
  hint: Optional
  help: Please enter a valid email address.
  size: xl
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Icon

## Usage

Use the `name` prop to display an icon:

::component-code{:props='{"name":"i-lucide-lightbulb","class":"size-5"}'}
::

::framework-only
#nuxt
  :::caution{to="https://nuxt.com/getting-started/icons/nuxt#collections"}
  It's highly recommended to install the icons collections you need, read more about this.
  :::
::

## API

### Props

::component-props
::

## Changelog

::component-changelog
::


# Input

## Usage

Use the `v-model` directive to control the value of the Input.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: ""
---
::

### Type

Use the `type` prop to change the input type. Defaults to `text`.

Some types have been implemented in their own components such as [Checkbox](https://nuxt.com/components/checkbox), [Radio](https://nuxt.com/components/radio-group), [InputNumber](https://nuxt.com/components/input-number) etc. and others have been styled like `file` for example.

::component-code
---
items:
  type:
    - text
    - number
    - password
    - search
    - file
props:
  type: file
---
::

::callout
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types
---
You can check all the available types on the MDN Web Docs.
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code{:props='{"placeholder":"Search..."}'}
::

### Color

Use the `color` prop to change the ring color when the Input is focused.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  highlight: true
  placeholder: Search...
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variant

Use the `variant` prop to change the variant of the Input.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  variant: subtle
  highlight: false
  placeholder: Search...
---
::

### Size

Use the `size` prop to change the size of the Input.

::component-code
---
ignore:
  - placeholder
props:
  size: xl
  placeholder: Search...
---
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the Input.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  icon: i-lucide-search
  size: md
  variant: outline
  placeholder: Search...
---
::

Use the `leading` and `trailing` props to set the icon position or the `leading-icon` and `trailing-icon` props to set a different icon for each position.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  trailingIcon: i-lucide-at-sign
  placeholder: Enter your email
  size: md
---
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar) inside the Input.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  variant: outline
  placeholder: Search...
---
::

### Loading

Use the `loading` prop to show a loading icon on the Input.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  trailing: false
  placeholder: Search...
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  loadingIcon: i-lucide-loader
  placeholder: Search...
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the Input.

::component-code
---
ignore:
  - placeholder
props:
  disabled: true
  placeholder: Search...
---
::

## Examples

### With clear button

You can put a [Button](https://nuxt.com/components/button) inside the `#trailing` slot to clear the Input.

::component-example{name="input-clear-button-example"}
::

### With copy button

You can put a [Button](https://nuxt.com/components/button) inside the `#trailing` slot to copy the value to the clipboard.

::component-example{name="input-copy-button-example"}
::

### With password toggle

You can put a [Button](https://nuxt.com/components/button) inside the `#trailing` slot to toggle the password visibility.

::component-example{name="input-password-toggle-example"}
::

### With password strength indicator

You can use the [Progress](https://nuxt.com/components/progress) component to display the password strength indicator.

::component-example{collapse name="input-password-strength-indicator-example"}
::

### With character limit

You can use the `#trailing` slot to add a character limit to the Input.

::component-example{name="input-character-limit-example"}
::

### With keyboard shortcut

You can use the [Kbd](https://nuxt.com/components/kbd) component inside the `#trailing` slot to add a keyboard shortcut to the Input.

::component-example{name="input-kbd-example"}
::

::note{to="https://nuxt.com/composables/define-shortcuts"}
This example uses the `defineShortcuts` composable to focus the Input when the `` key is pressed.
::

### With mask

There's no built-in support for masks, but you can use libraries like [maska](https://github.com/beholdr/maska){rel="nofollow"} to mask the Input.

::component-example{name="input-mask-example"}
::

### With floating label

You can use the `#default` slot to add a floating label to the Input.

::component-example{name="input-floating-label-example"}
::

### Within a FormField

You can use the Input within a [FormField](https://nuxt.com/components/form-field) component to display a label, help text, required indicator, etc.

::component-example{name="input-form-field-example"}
::

::tip{to="https://nuxt.com/components/form"}
It also provides validation and error handling when used within a **Form** component.
::

### Within a ButtonGroup

You can use the Input within a [ButtonGroup](https://nuxt.com/components/button-group) component to group multiple elements together.

::component-example{name="input-button-group-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                       |
| -------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLInputElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# InputMenu

## Usage

Use the `v-model` directive to control the value of the InputMenu or the `default-value` prop to set the initial value when you do not need to control its state.

::tip
Use this over an [`Input`](https://nuxt.com/components/input) to take advantage of Reka UI's [`Combobox`](https://reka-ui.com/docs/components/combobox){rel="nofollow"} component that offers autocomplete capabilities.
::

::note
This component is similar to the [`SelectMenu`](https://nuxt.com/components/select-menu) but it's using an Input instead of a Select.
::

### Items

Use the `items` prop as an array of strings, numbers or booleans:

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue: Backlog
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

You can also pass an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "label" | "separator" | "item"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-items-type)
- [`icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-icons-in-items)
- [`avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-avatar-in-items)
- [`chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-chip-in-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { tagsItem?: ClassNameValue, tagsItemText?: ClassNameValue, tagsItemDelete?: ClassNameValue, tagsItemDeleteIcon?: ClassNameValue, label?: ClassNameValue, separator?: ClassNameValue, item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLabel?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue.label
  - items
props:
  modelValue:
    label: Todo
  items:
    - label: Backlog
    - label: Todo
    - label: In Progress
    - label: Done
---
::

You can also pass an array of arrays to the `items` prop to display separated groups of items.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue: Apple
  items:
    - - Apple
      - Banana
      - Blueberry
      - Grapes
      - Pineapple
    - - Aubergine
      - Broccoli
      - Carrot
      - Courgette
      - Leek
---
::

### Value Key

You can choose to bind a single property of the object rather than the whole object by using the `value-key` prop. Defaults to `undefined`.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - valueKey
  - items
props:
  modelValue: todo
  valueKey: id
  items:
    - label: Backlog
      id: backlog
    - label: Todo
      id: todo
    - label: In Progress
      id: in_progress
    - label: Done
      id: done
---
::

### Multiple

Use the `multiple` prop to allow multiple selections, the selected items will be displayed as tags.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::caution
Ensure to pass an array to the `default-value` prop or the `v-model` directive.
::

### Delete Icon

With `multiple`, use the `delete-icon` prop to customize the delete [Icon](https://nuxt.com/components/icon) in the tags. Defaults to `i-lucide-x`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  deleteIcon: i-lucide-trash
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.close` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.close` key.
  :::
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code
---
external:
  - items
ignore:
  - items
prettier: true
props:
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Content

Use the `content` prop to control how the InputMenu content is rendered, like its `align` or `side` for example.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  modelValue: Backlog
  content:
    align: center
    side: bottom
    sideOffset: 8
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Arrow

Use the `arrow` prop to display an arrow on the InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - arrow
prettier: true
props:
  modelValue: Backlog
  arrow: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Color

Use the `color` prop to change the ring color when the InputMenu is focused.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  color: neutral
  highlight: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variant

Use the `variant` prop to change the variant of the InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  color: neutral
  variant: subtle
  highlight: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Size

Use the `size` prop to change the size of the InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  size: xl
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  icon: i-lucide-search
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Trailing Icon

Use the `trailing-icon` prop to customize the trailing [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-chevron-down`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  trailingIcon: i-lucide-arrow-down
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronDown` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronDown` key.
  :::
::

### Selected Icon

Use the `selected-icon` prop to customize the icon when an item is selected. Defaults to `i-lucide-check`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  selectedIcon: i-lucide-flame
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.check` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.check` key.
  :::
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar) inside the InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Nuxt
  avatar:
    src: https://github.com/nuxt.png
  items:
    - Nuxt
    - NuxtHub
    - NuxtLabs
    - Nuxt Modules
    - Nuxt Community
---
::

### Loading

Use the `loading` prop to show a loading icon on the InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  loading: true
  trailing: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  loading: true
  loadingIcon: i-lucide-loader
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the InputMenu.

::component-code
---
external:
  - items
ignore:
  - items
  - placeholder
prettier: true
props:
  disabled: true
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

## Examples

### With items type

You can use the `type` property with `separator` to display a separator between items or `label` to display a label.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
props:
  modelValue: Apple
  items:
    - type: label
      label: Fruits
    - Apple
    - Banana
    - Blueberry
    - Grapes
    - Pineapple
    - type: separator
    - type: label
      label: Vegetables
    - Aubergine
    - Broccoli
    - Carrot
    - Courgette
    - Leek
---
::

### With icon in items

You can use the `icon` property to display an [Icon](https://nuxt.com/components/icon) inside the items.

::component-example{collapse name="input-menu-items-icon-example"}
::

::tip
You can also use the `#leading` slot to display the selected icon.
::

### With avatar in items

You can use the `avatar` property to display an [Avatar](https://nuxt.com/components/avatar) inside the items.

::component-example{collapse name="input-menu-items-avatar-example"}
::

::tip
You can also use the `#leading` slot to display the selected avatar.
::

### With chip in items

You can use the `chip` property to display a [Chip](https://nuxt.com/components/chip) inside the items.

::component-example{collapse name="input-menu-items-chip-example"}
::

::note
In this example, the `#leading` slot is used to display the selected chip.
::

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="input-menu-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the InputMenu by pressing ``.
::

### Control open state on focus

You can use the `open-on-focus` or `open-on-click` props to open the menu when the input is focused or clicked.

::component-example{name="input-menu-open-focus-example"}
::

### Control search term

Use the `v-model:search-term` directive to control the search term.

::component-example{name="input-menu-search-term-example"}
::

### With rotating icon

Here is an example with a rotating icon that indicates the open state of the InputMenu.

::component-example{name="input-menu-icon-example"}
::

### With create item

Use the `create-item` prop to enable users to add custom values that aren't in the predefined options.

::component-example{collapse name="input-menu-create-item-example"}
::

::note
The create option shows when no match is found by default. Set it to `always` to show it even when similar values exist.
::

::tip{to="https://nuxt.com/#emits"}
Use the `@create` event to handle the creation of the item. You will receive the event and the item as arguments.
::

### With fetched items

You can fetch items from an API and use them in the InputMenu.

::component-example{collapse name="input-menu-fetch-example"}
::

### With ignore filter

Set the `ignore-filter` prop to `true` to disable the internal search and use your own search logic.

::component-example{collapse name="input-menu-ignore-filter-example"}
::

::note
This example uses [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} to debounce the API calls.
::

### With filter fields

Use the `filter-fields` prop with an array of fields to filter on. Defaults to `[labelKey]`.

::component-example{collapse name="input-menu-filter-fields-example"}
::

### With full content width

You can expand the content to the full width of its items by using the `ui.content` key.

::component-example{collapse name="input-menu-content-width-example"}
::

::tip
You can also change the content width globally in your `app.config.ts`:

```text
export default defineAppConfig({
  ui: {
    inputMenu: {
      slots: {
        content: 'min-w-fit'
      }
    }
  }
})
```
::

### As a CountryPicker

This example demonstrates using the InputMenu as a country picker with lazy loading - countries are only fetched when the menu is opened.

::component-example{collapse name="input-menu-countries-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                                           |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof ComboboxTrigger> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# InputNumber

::note
This component relies on the [`@internationalized/number`](https://react-spectrum.adobe.com/internationalized/number/index.html){rel="nofollow"} package which provides utilities for formatting and parsing numbers across locales and numbering systems.
::

## Usage

Use the `v-model` directive to control the value of the InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
---
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":5}'}
::

### Min / Max

Use the `min` and `max` props to set the minimum and maximum values of the InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  min: 0
  max: 10
---
::

### Step

Use the `step` prop to set the step value of the InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  step: 2
---
::

### Orientation

Use the `orientation` prop to change the orientation of the InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  orientation: vertical
---
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code{:props='{"placeholder":"Enter a number"}'}
::

### Color

Use the `color` prop to change the ring color when the InputNumber is focused.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  color: neutral
  highlight: true
---
::

### Variant

Use the `variant` prop to change the variant of the InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  variant: subtle
  color: neutral
  highlight: false
---
::

### Size

Use the `size` prop to change the size of the InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  size: xl
---
::

### Disabled

Use the `disabled` prop to disable the InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  disabled: true
---
::

### Increment / Decrement

Use the `increment` and `decrement` props to customize the increment and decrement buttons with any [Button](https://nuxt.com/components/button) props. Defaults to `{ variant: 'link' }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - increment.size
  - increment.color
  - increment.variant
  - decrement.size
  - decrement.color
  - decrement.variant
prettier: true
props:
  modelValue: 5
  increment:
    color: neutral
    variant: solid
    size: xs
  decrement:
    color: neutral
    variant: solid
    size: xs
---
::

### Increment / Decrement Icons

Use the `increment-icon` and `decrement-icon` props to customize the buttons [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-plus` / `i-lucide-minus`.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue: 5
  incrementIcon: i-lucide-arrow-right
  decrementIcon: i-lucide-arrow-left
---
::

## Examples

### With decimal format

Use the `format-options` prop to customize the format of the value.

::component-example{name="input-number-decimal-example"}
::

### With percentage format

Use the `format-options` prop with `style: 'percent'` to customize the format of the value.

::component-example{name="input-number-percentage-example"}
::

### With currency format

Use the `format-options` prop with `style: 'currency'` to customize the format of the value.

::component-example{name="input-number-currency-example"}
::

### Within a FormField

You can use the InputNumber within a [FormField](https://nuxt.com/components/form-field) component to display a label, help text, required indicator, etc.

::component-example{name="input-number-form-field-example"}
::

### With slots

Use the `#increment` and `#decrement` slots to customize the buttons.

::component-example{name="input-number-slots-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                                            |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof NumberFieldInput> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# InputTags

## Usage

Use the `v-model` directive to control the value of the InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
---
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code
---
ignore:
  - defaultValue
prettier: true
props:
  defaultValue:
    - Vue
---
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code{:props='{"placeholder":"Enter tags..."}'}
::

### Max Length :badge{.align-text-top label="New"}

Use the `max-length` prop to set the maximum number of characters allowed in a tag.

::component-code{:props='{"maxLength":4}'}
::

### Color

Use the `color` prop to change the ring color when the InputTags is focused.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  color: neutral
  highlight: true
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variants

Use the `variant` prop to change the appearance of the InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  variant: subtle
  color: neutral
  highlight: false
---
::

### Sizes

Use the `size` prop to adjust the size of the InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  size: xl
---
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  icon: i-lucide-search
  size: md
  variant: outline
---
::

::note
Use the `leading` and `trailing` props to set the icon position or the `leading-icon` and `trailing-icon` props to set a different icon for each position.
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar) inside the InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  avatar:
    src: https://github.com/vuejs.png
  size: md
  variant: outline
---
::

### Delete Icon

Use the `delete-icon` prop to customize the delete [Icon](https://nuxt.com/components/icon) in the tags. Defaults to `i-lucide-x`.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  deleteIcon: i-lucide-trash
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.close` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.close` key.
  :::
::

### Loading

Use the `loading` prop to show a loading icon on the InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  loading: true
  trailing: false
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  loading: true
  loadingIcon: i-lucide-loader
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  disabled: true
---
::

## Examples

### Within a FormField

You can use the InputTags within a [FormField](https://nuxt.com/components/form-field) component to display a label, help text, required indicator, etc.

::component-example{name="input-tags-form-field-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                                          |
| -------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof TagsInputInput> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Kbd

## Usage

### Value

Use the default slot to set the value of the Kbd.

::component-code{:slots='{"default":"K"}'}
::

You can achieve the same result by using the `value` prop.

::component-code{:props='{"value":"K"}'}
::

You can pass special keys to the `value` prop that goes through the [`useKbd`](https://github.com/nuxt/ui/blob/v3/src/runtime/composables/useKbd.ts){rel="nofollow"} composable. For example, the `meta` key displays as `⌘` on macOS and `Ctrl` on other platforms.

::component-code
---
items:
  value:
    - meta
    - win
    - command
    - shift
    - ctrl
    - option
    - alt
    - enter
    - delete
    - backspace
    - escape
    - tab
    - capslock
    - arrowup
    - arrowright
    - arrowdown
    - arrowleft
    - pageup
    - pagedown
    - home
    - end
props:
  value: meta
---
::

### Color :badge{.align-text-top label="New"}

Use the `color` prop to change the color of the Kbd.

::component-code{:props='{"color":"neutral"}' :slots='{"default":"K"}'}
::

### Variant

Use the `variant` prop to change the variant of the Kbd.

::component-code
---
props:
  color: neutral
  variant: solid
slots:
  default: K
---
::

### Size

Use the `size` prop to change the size of the Kbd.

::component-code{:props='{"size":"lg"}' :slots='{"default":"K"}'}
::

## Examples

### `class` prop

Use the `class` prop to override the base styles of the Badge.

::component-code
---
props:
  class: font-bold rounded-full
  variant: subtle
slots:
  default: K
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Link

## Usage

The Link component is a wrapper around [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link){rel="nofollow"} using the [`custom`](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-custom){rel="nofollow"} prop. It provides a few extra props:

- `inactive-class` prop to set a class when the link is inactive, `active-class` is used when active.
- `exact` prop to style with `active-class` when the link is active and the route is exactly the same as the current route.
- `exact-query` and `exact-hash` props to style with `active-class` when the link is active and the query or hash is exactly the same as the current query or hash.

  - use `exact-query="partial"` to style with `active-class` when the link is active and the query partially match the current query.

The incentive behind this is to provide the same API as NuxtLink back in Nuxt 2 / Vue 2. You can read more about it in the Vue Router [migration from Vue 2](https://router.vuejs.org/guide/migration/#removal-of-the-exact-prop-in-router-link){rel="nofollow"} guide.

::note
It is used by the [`Breadcrumb`](https://nuxt.com/components/breadcrumb), [`Button`](https://nuxt.com/components/button), [`ContextMenu`](https://nuxt.com/components/context-menu), [`DropdownMenu`](https://nuxt.com/components/dropdown-menu) and [`NavigationMenu`](https://nuxt.com/components/navigation-menu) components.
::

### Tag

The `Link` components renders an `<a>` tag when a `to` prop is provided, otherwise it renders a `<button>` tag. You can use the `as` prop to change fallback tag.

::component-code{:props='{"to":"","as":"button"}' :slots='{"default":"Link"}'}
::

::note
You can inspect the rendered HTML by changing the `to` prop.
::

### Style

By default, the link has default active and inactive styles, check out the [#theme](https://nuxt.com/#theme) section.

::component-code{:props='{"to":"/components/link"}' :slots='{"default":"Link"}'}
::

::note
Try changing the `to` prop to see the active and inactive states.
::

You can override this behavior by using the `raw` prop and provide your own styles using `class`, `active-class` and `inactive-class`.

::component-code
---
ignore:
  - raw
props:
  raw: true
  to: /components/link
  activeClass: font-bold
  inactiveClass: text-muted
slots:
  default: Link
---
Link
::

## IntelliSense

If you're using VSCode and wish to get autocompletion for the classes `active-class` and `inactive-class`, you can add the following settings to your `.vscode/settings.json`:

```json [.vscode/settings.json]
{
  "tailwindCSS.classAttributes": [
    "active-class",
    "inactive-class"
  ]
}
```

## API

### Props

::component-props{:ignore='["custom"]'}
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Modal

## Usage

Use a [Button](https://nuxt.com/components/button) or any other component in the default slot of the Modal.

Then, use the `#content` slot to add the content displayed when the Modal is open.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

You can also use the `#header`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}, `#body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} and `#footer`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} slots to customize the Modal's content.

### Title

Use the `title` prop to set the title of the Modal's header.

::component-code
---
prettier: true
props:
  title: Modal with title
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Description

Use the `description` prop to set the description of the Modal's header.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Modal with description
  description: Lorem ipsum dolor sit amet, consectetur adipiscing elit.
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Close

Use the `close` prop to customize or hide the close button (with `false` value) displayed in the Modal's header.

You can pass any property from the [Button](https://nuxt.com/components/button) component to customize it.

::component-code
---
ignore:
  - title
  - close.color
  - close.variant
prettier: true
props:
  title: Modal with close button
  close:
    color: primary
    variant: outline
    class: rounded-full
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

::tip
The close button is not displayed if the `#content` slot is used as it's a part of the header.
::

### Close Icon

Use the `close-icon` prop to customize the close button [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-x`.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Modal with close button
  closeIcon: i-lucide-arrow-right
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.close` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.close` key.
  :::
::

### Overlay

Use the `overlay` prop to control whether the Modal has an overlay or not. Defaults to `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  overlay: false
  title: Modal without overlay
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Transition

Use the `transition` prop to control whether the Modal is animated or not. Defaults to `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  transition: false
  title: Modal without transition
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Fullscreen

Use the `fullscreen` prop to make the Modal fullscreen.

::component-code
---
ignore:
  - title
  - fullscreen
prettier: true
props:
  fullscreen: true
  title: Modal fullscreen
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

## Examples

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="modal-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the Modal by pressing ``.
::

::tip
This allows you to move the trigger outside of the Modal or remove it entirely.
::

### Disable dismissal

Set the `dismissible` prop to `false` to prevent the Modal from being closed when clicking outside of it or pressing escape. A `close:prevent` event will be emitted when the user tries to close it.

::component-code
---
ignore:
  - title
  - dismissible
prettier: true
props:
  dismissible: false
  title: Modal non-dismissible
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Programmatic usage

You can use the [`useOverlay`](https://nuxt.com/composables/use-overlay) composable to open a Modal programmatically.

::warning
Make sure to wrap your app with the [`App`](https://nuxt.com/components/app) component which uses the [`OverlayProvider`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/OverlayProvider.vue){rel="nofollow"} component.
::

First, create a modal component that will be opened programmatically:

::component-example{prettier :preview='false' name="modal-example"}
::

::note
We are emitting a `close` event when the modal is closed or dismissed here. You can emit any data through the `close` event, however, the event must be emitted in order to capture the return value.
::

Then, use it in your app:

::component-example{name="modal-programmatic-example"}
::

::tip
You can close the modal within the modal component by emitting `emit('close')`.
::

### Nested modals

You can nest modals within each other.

::component-example{name="modal-nested-example"}
::

### With footer slot

Use the `#footer` slot to add content after the Modal's body.

::component-example{name="modal-footer-slot-example"}
::

### With command palette

You can use a [CommandPalette](https://nuxt.com/components/command-palette) component inside the Modal's content.

::component-example{collapse name="modal-command-palette-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# NavigationMenu

## Usage

### Items

Use the `items` prop as an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `badge?: string | number | BadgeProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `tooltip?: TooltipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `trailingIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `type?: 'label' | 'trigger' | 'link'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `defaultOpen?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `open?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `children?: NavigationMenuChildItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { linkLeadingAvatarSize?: ClassNameValue, linkLeadingAvatar?: ClassNameValue, linkLeadingIcon?: ClassNameValue, linkLabel?: ClassNameValue, linkLabelExternalIcon?: ClassNameValue, linkTrailing?: ClassNameValue, linkTrailingBadgeSize?: ClassNameValue, linkTrailingBadge?: ClassNameValue, linkTrailingIcon?: ClassNameValue, label?: ClassNameValue, link?: ClassNameValue, content?: ClassNameValue, childList?: ClassNameValue, childLabel?: ClassNameValue, childItem?: ClassNameValue, childLink?: ClassNameValue, childLinkIcon?: ClassNameValue, childLinkWrapper?: ClassNameValue, childLinkLabel?: ClassNameValue, childLinkLabelExternalIcon?: ClassNameValue, childLinkDescription?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

You can pass any property from the [Link](https://nuxt.com/components/link#props) component such as `to`, `target`, etc.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - class
props:
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
    - label: GitHub
      icon: i-simple-icons-github
      badge: 3.8k
      to: https://github.com/nuxt/ui
      target: _blank
    - label: Help
      icon: i-lucide-circle-help
      disabled: true
  class: w-full justify-center
---
::

::note
You can also pass an array of arrays to the `items` prop to display groups of items.
::

::tip
Each item can take a `children` array of objects with the following properties to create submenus:

- `label: string`
- `description?: string`
- `icon?: string`
- `onSelect?(e: Event): void`
- `class?: any`
::

### Orientation

Use the `orientation` prop to change the orientation of the NavigationMenu.

::note
When orientation is `vertical`, an [Accordion](https://nuxt.com/components/accordion) component is used to display each group. You can control the open state of each item using the `open` and `defaultOpen` properties and change the behavior using the [`collapsible`](https://nuxt.com/components/accordion#collapsible) and [`type`](https://nuxt.com/components/accordion#multiple) props.
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
props:
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        defaultOpen: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
  class: data-[orientation=vertical]:w-48
---
::

::note
Groups will be spaced when orientation is `horizontal` and separated when orientation is `vertical`.
::

### Collapsed

In `vertical` orientation, use the `collapsed` prop to collapse the NavigationMenu, this can be useful in a sidebar for example.

::note
You can use the [`tooltip`](https://nuxt.com/#with-tooltip-in-items) and [`popover`](https://nuxt.com/#with-popover-in-items) props to display more information on the collapsed items.
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - orientation
  - class
items:
  tooltip:
    - true
    - false
  popover:
    - true
    - false
props:
  collapsed: true
  tooltip: false
  popover: false
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
---
::

### Highlight

Use the `highlight` prop to display a highlighted border for the active item.

Use the `highlight-color` prop to change the color of the border. It defaults to the `color` prop.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
prettier: true
props:
  highlight: true
  highlightColor: primary
  orientation: horizontal
  items:
    - - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        defaultOpen: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
  class: data-[orientation=horizontal]:border-b border-default
    data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-48
---
::

::note
In this example, the `border-b` class is applied to display a border in `horizontal` orientation, this is not done by default to let you have a clean slate to work with.
::

::caution
In `vertical` orientation, the `highlight` prop only highlights the border of active children.
::

### Color

Use the `color` prop to change the color of the NavigationMenu.

::component-code
---
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
props:
  color: neutral
  items:
    - - label: Guide
        icon: i-lucide-book-open
        to: /getting-started
      - label: Composables
        icon: i-lucide-database
        to: /composables
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
  class: w-full
---
::

### Variant

Use the `variant` prop to change the variant of the NavigationMenu.

::component-code
---
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
props:
  color: neutral
  variant: link
  highlight: false
  items:
    - - label: Guide
        icon: i-lucide-book-open
        to: /getting-started
      - label: Composables
        icon: i-lucide-database
        to: /composables
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
  class: w-full
---
::

::note
The `highlight` prop changes the `pill` variant active item style. Try it out to see the difference.
::

### Trailing Icon

Use the `trailing-icon` prop to customize the trailing [Icon](https://nuxt.com/components/icon) of each item. Defaults to `i-lucide-chevron-down`. This icon is only displayed when an item has children.

::tip
You can also set an icon for a specific item by using the `trailingIcon` property in the item object.
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - class
props:
  trailingIcon: i-lucide-arrow-down
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
  class: w-full justify-center
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronDown` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronDown` key.
  :::
::

### Arrow

Use the `arrow` prop to display an arrow on the NavigationMenu content when items have children.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - arrow
  - class
props:
  arrow: true
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
  class: w-full justify-center
---
::

::note
The arrow is animated to follow the active item.
::

### Content Orientation

Use the `content-orientation` prop to change the orientation of the content.

::warning
This prop only works when `orientation` is `horizontal`.
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - arrow
  - class
props:
  arrow: true
  contentOrientation: vertical
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
  class: w-full justify-center
---
::

### Unmount

Use the `unmount-on-hide` prop to control the content unmounting behavior. Defaults to `true`.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - arrow
  - class
props:
  unmountOnHide: false
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
  class: w-full justify-center
---
::

::note
You can inspect the DOM to see each item's content being rendered.
::

## Examples

### With tooltip in items

When orientation is `vertical` and the menu is `collapsed`, you can set the `tooltip` prop to `true` to display a [Tooltip](https://nuxt.com/components/tooltip) around items with their label but you can also use the `tooltip` property on each item to override the default tooltip.

You can pass any property from the [Tooltip](https://nuxt.com/components/tooltip) component globally or on each item.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - orientation
  - class
items:
  tooltip:
    - true
    - false
props:
  tooltip: true
  collapsed: true
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
        tooltip:
          text: Open on GitHub
          kbds:
            - 3.8k
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
---
::

### With popover in items

When orientation is `vertical` and the menu is `collapsed`, you can set the `popover` prop to `true` to display a [Popover](https://nuxt.com/components/popover) around items with their children but you can also use the `popover` property on each item to override the default popover.

You can pass any property from the [Popover](https://nuxt.com/components/popover) component globally or on each item.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - orientation
  - class
items:
  popover:
    - true
    - false
props:
  popover: true
  collapsed: true
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        popover:
          mode: click
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
        tooltip:
          text: Open on GitHub
          kbds:
            - 3.8k
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
---
::

::tip{to="https://nuxt.com/#with-content-slot"}
You can use the `#content` slot to customize the content of the popover in the `vertical` orientation.
::

### Control active item

You can control the active item by using the `default-value` prop or the `v-model` directive with the index of the item.

::component-example{collapse name="navigation-menu-model-value-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can switch the active item by pressing ``, ``, or ``.
::

::tip
You can also pass the `value` of one of the items if provided.
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-content`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="navigation-menu-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
You can also use the `#item`, `#item-leading`, `#item-label`, `#item-trailing` and `#item-content` slots to customize all items.
::

### With content slot

Use the `#item-content` slot or the `slot` property (`#{{ item.slot }}-content`) to customize the content of a specific item.

::component-example{collapse name="navigation-menu-content-slot-example"}
::

::note
In this example, we add the `sm:w-(--reka-navigation-menu-viewport-width)` class on the `viewport` to have a dynamic width. This requires to set a width on the content's first child.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Pagination

## Usage

Use the `default-page` prop or the `v-model:page` directive to control the current page.

::note
The Pagination component uses some [`Button`](https://nuxt.com/components/button) to display the pages, use [`color`](https://nuxt.com/#color), [`variant`](https://nuxt.com/#variant) and [`size`](https://nuxt.com/#size) props to style them.
::

### Total

Use the `total` prop to set the total number of items in the list.

::component-code
---
external:
  - page
model:
  - page
props:
  page: 5
  total: 100
---
::

### Items Per Page

Use the `items-per-page` prop to set the number of items per page. Defaults to `10`.

::component-code
---
external:
  - page
ignore:
  - page
model:
  - page
props:
  page: 5
  itemsPerPage: 20
  total: 100
---
::

### Sibling Count

Use the `sibling-count` prop to set the number of siblings to show. Defaults to `2`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  siblingCount: 1
  total: 100
---
::

### Show Edges

Use the `show-edges` prop to always show the ellipsis, first and last pages. Defaults to `false`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  showEdges: true
  siblingCount: 1
  total: 100
---
::

### Show Controls

Use the `show-controls` prop to show the first, prev, next and last buttons. Defaults to `true`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  showControls: false
  showEdges: true
  total: 100
---
::

### Color

Use the `color` prop to set the color of the inactive controls. Defaults to `neutral`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
model:
  - page
props:
  page: 5
  color: primary
  total: 100
---
::

### Variant

Use the `variant` prop to set the variant of the inactive controls. Defaults to `outline`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  variant:
    - solid
    - outline
    - soft
    - subtle
    - ghost
    - link
model:
  - page
props:
  page: 5
  color: neutral
  variant: subtle
  total: 100
---
::

### Active Color

Use the `active-color` prop to set the color of the active control. Defaults to `primary`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  activeColor:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
model:
  - page
props:
  page: 5
  activeColor: neutral
  total: 100
---
::

### Active Variant

Use the `active-variant` prop to set the variant of the active control. Defaults to `solid`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  activeColor:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  activeVariant:
    - solid
    - outline
    - soft
    - subtle
    - ghost
    - link
model:
  - page
props:
  page: 5
  activeColor: primary
  activeVariant: subtle
  total: 100
---
::

### Size

Use the `size` prop to set the size of the controls. Defaults to `md`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  size:
    - xs
    - sm
    - md
    - lg
    - xl
model:
  - page
props:
  page: 5
  size: xl
  total: 100
---
::

### Disabled

Use the `disabled` prop to disable the pagination controls.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  total: 100
  disabled: true
---
::

## Examples

### With links

Use the `to` prop to transform buttons into links. Pass a function that receives the page number and returns a route destination.

::component-example{name="pagination-links-example"}
::

::note
In this example we're adding the `#with-links` hash to avoid going to the top of the page.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# PinInput

## Usage

Use the `v-model` directive to control the value of the PinInput.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue: []
---
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code
---
ignore:
  - defaultValue
prettier: true
props:
  defaultValue:
    - "1"
    - "2"
    - "3"
---
::

### Type

Use the `type` prop to change the input type. Defaults to `text`.

::component-code{:items='{"type":["text","number"]}' :props='{"type":"number"}'}
::

::note
When `type` is set to `number`, it will only accept numeric characters.
::

### Mask

Use the `mask` prop to treat the input like a password.

::component-code
---
ignore:
  - placeholder
  - defaultValue
prettier: true
props:
  mask: true
  defaultValue:
    - "1"
    - "2"
    - "3"
    - "4"
    - "5"
---
::

### OTP

Use the `otp` prop to enable One-Time Password functionality. When enabled, mobile devices can automatically detect and fill OTP codes from SMS messages or clipboard content, with autocomplete support.

::component-code{:props='{"otp":true}'}
::

### Length

Use the `length` prop to change the amount of inputs.

::component-code{:props='{"length":6}'}
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code{:props='{"placeholder":"○"}'}
::

### Color

Use the `color` prop to change the ring color when the PinInput is focused.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  highlight: true
  placeholder: ○
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variant

Use the `variant` prop to change the variant of the PinInput.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  variant: subtle
  highlight: false
  placeholder: ○
---
::

### Size

Use the `size` prop to change the size of the PinInput.

::component-code
---
ignore:
  - placeholder
props:
  size: xl
  placeholder: ○
---
::

### Disabled

Use the `disabled` prop to disable the PinInput.

::component-code
---
ignore:
  - placeholder
props:
  disabled: true
  placeholder: ○
---
::

## API

### Props

::component-props
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                    | Type                                                                                                                                                         |
| --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `inputsRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<ComponentPublicInstance[]>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Popover

## Usage

Use a [Button](https://nuxt.com/components/button) or any other component in the default slot of the Popover.

Then, use the `#content` slot to add the content displayed when the Popover is open.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.size-48.m-4.inline-flex}
  :::
::

### Mode

Use the `mode` prop to change the mode of the Popover. Defaults to `click`.

::component-code
---
items:
  mode:
    - click
    - hover
prettier: true
props:
  mode: hover
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.size-48.m-4.inline-flex}
  :::
::

::note
When using the `hover` mode, the Reka UI [`HoverCard`](https://reka-ui.com/docs/components/hover-card){rel="nofollow"} component is used instead of the [`Popover`](https://reka-ui.com/docs/components/popover){rel="nofollow"}.
::

### Delay

When using the `hover` mode, you can use the `open-delay` and `close-delay` props to control the delay before the Popover is opened or closed.

::component-code
---
ignore:
  - mode
prettier: true
props:
  mode: hover
  openDelay: 500
  closeDelay: 300
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.size-48.m-4.inline-flex}
  :::
::

### Content

Use the `content` prop to control how the Popover content is rendered, like its `align` or `side` for example.

::component-code
---
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  content:
    align: center
    side: bottom
    sideOffset: 8
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.size-48.m-4.inline-flex}
  :::
::

### Arrow

Use the `arrow` prop to display an arrow on the Popover.

::component-code
---
ignore:
  - arrow
prettier: true
props:
  arrow: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.size-48.m-4.inline-flex}
  :::
::

## Examples

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="popover-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the Popover by pressing ``.
::

### Disable dismissal

Set the `dismissible` prop to `false` to prevent the Popover from being closed when clicking outside of it or pressing escape. A `close:prevent` event will be emitted when the user tries to close it.

::component-example{name="popover-dismissible-example"}
::

### With command palette

You can use a [CommandPalette](https://nuxt.com/components/command-palette) component inside the Popover's content.

::component-example{collapse name="popover-command-palette-example"}
::

### With following cursor :badge{.align-text-top label="New"}

You can make the Popover follow the cursor when hovering over an element using the [`reference`](https://reka-ui.com/docs/components/tooltip#trigger){rel="nofollow"} prop:

::component-example{name="popover-cursor-example"}
::

### With anchor slot

You can use the `#anchor` slot to position the Popover against a custom element.

::warning
This slot only works when `mode` is `click`.
::

::component-example{collapse name="popover-anchor-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Progress

## Usage

Use the `v-model` directive to control the value of the Progress.

::component-code{:external='["modelValue"]' :props='{"modelValue":50}'}
::

### Max

Use the `max` prop to set the maximum value of the Progress.

::component-code{:external='["modelValue"]' :props='{"modelValue":3,"max":4}'}
::

Use the `max` prop with an array of strings to display the active step under the bar, the maximum value of the Progress is the length of the array.

::component-code
---
external:
  - modelValue
ignore:
  - max
prettier: true
props:
  modelValue: 3
  max:
    - Waiting...
    - Cloning...
    - Migrating...
    - Deploying...
    - Done!
---
::

### Status

Use the `status` prop to display the current Progress value above the bar.

::component-code
---
external:
  - modelValue
props:
  modelValue: 50
  status: true
---
::

### Indeterminate

When no `v-model` is set or the value is `null`, the Progress becomes *indeterminate*. The progress bar is animated as a `carousel`, but you can change it using the [`animation`](https://nuxt.com/#animation) prop.

::component-code{:external='["modelValue"]' :props='{"modelValue":null}'}
::

### Animation

Use the `animation` prop to change the animation of the Progress to an inverse carousel, a swinging bar or an elastic bar. Defaults to `carousel`.

::component-code{:props='{"animation":"swing"}'}
::

### Orientation

Use the `orientation` prop to change the orientation of the Progress. Defaults to `horizontal`.

::component-code
---
ignore:
  - class
props:
  orientation: vertical
  class: h-48
---
::

### Color

Use the `color` prop to change the color of the Slider.

::component-code{:props='{"color":"neutral"}'}
::

### Size

Use the `size` prop to change the size of the Slider.

::component-code{:props='{"size":"xl"}'}
::

### Inverted

Use the `inverted` prop to visually invert the Progress.

::component-code{:props='{"inverted":true,"modelValue":25}'}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# RadioGroup

## Usage

Use the `v-model` directive to control the value of the RadioGroup or the `default-value` prop to set the initial value when you do not need to control its state.

### Items

Use the `items` prop as an array of strings or numbers:

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - RadioGroupItem[]
  - RadioGroupValue
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue: System
  items:
    - System
    - Light
    - Dark
---
::

You can also pass an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#value-key)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, base?: ClassNameValue, 'indicator'?: ClassNameValue, wrapper?: ClassNameValue, label?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - RadioGroupItem[]
  - RadioGroupValue
ignore:
  - modelValue
  - items
props:
  modelValue: system
  items:
    - label: System
      description: This is the first option.
      value: system
    - label: Light
      description: This is the second option.
      value: light
    - label: Dark
      description: This is the third option.
      value: dark
---
::

::caution
When using objects, you need to reference the `value` property of the object in the `v-model` directive or the `default-value` prop.
::

### Value Key

You can change the property that is used to set the value by using the `value-key` prop. Defaults to `value`.

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - RadioGroupItem[]
  - RadioGroupValue
ignore:
  - modelValue
  - items
  - valueKey
props:
  modelValue: light
  valueKey: id
  items:
    - label: System
      description: This is the first option.
      id: system
    - label: Light
      description: This is the second option.
      id: light
    - label: Dark
      description: This is the third option.
      id: dark
---
::

### Legend

Use the `legend` prop to set the legend of the RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  legend: Theme
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Color

Use the `color` prop to change the color of the RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  color: neutral
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Variant

Use the `variant` prop to change the variant of the RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  color: primary
  variant: table
  defaultValue: pro
  items:
    - label: Pro
      value: pro
      description: Tailored for indie hackers, freelancers and solo founders.
    - label: Startup
      value: startup
      description: Best suited for small teams, startups and agencies.
    - label: Enterprise
      value: enterprise
      description: Ideal for larger teams and organizations.
---
::

### Size

Use the `size` prop to change the size of the RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  size: xl
  variant: list
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Orientation

Use the `orientation` prop to change the orientation of the RadioGroup. Defaults to `vertical`.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  orientation: horizontal
  variant: list
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Indicator

Use the `indicator` prop to change the position or hide the indicator. Defaults to `start`.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  indicator: end
  variant: card
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Disabled

Use the `disabled` prop to disable the RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  disabled: true
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Select

## Usage

Use the `v-model` directive to control the value of the Select or the `default-value` prop to set the initial value when you do not need to control its state.

### Items

Use the `items` prop as an array of strings, numbers or booleans:

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Backlog
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

You can also pass an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#value-key)
- [`type?: "label" | "separator" | "item"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-items-type)
- [`icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-icons-in-items)
- [`avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-avatar-in-items)
- [`chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-chip-in-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { label?: ClassNameValue, separator?: ClassNameValue, item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLabel?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
props:
  modelValue: backlog
  items:
    - label: Backlog
      value: backlog
    - label: Todo
      value: todo
    - label: In Progress
      value: in_progress
    - label: Done
      value: done
  class: w-48
---
::

::caution
When using objects, you need to reference the `value` property of the object in the `v-model` directive or the `default-value` prop.
::

You can also pass an array of arrays to the `items` prop to display separated groups of items.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Apple
  items:
    - - Apple
      - Banana
      - Blueberry
      - Grapes
      - Pineapple
    - - Aubergine
      - Broccoli
      - Carrot
      - Courgette
      - Leek
  class: w-48
---
::

### Value Key

You can change the property that is used to set the value by using the `value-key` prop. Defaults to `value`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - valueKey
  - items
  - class
props:
  modelValue: backlog
  valueKey: id
  items:
    - label: Backlog
      id: backlog
    - label: Todo
      id: todo
    - label: In Progress
      id: in_progress
    - label: Done
      id: done
  class: w-48
---
::

### Multiple

Use the `multiple` prop to allow multiple selections, the selected items will be separated by a comma in the trigger.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
  - class
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::caution
Ensure to pass an array to the `default-value` prop or the `v-model` directive.
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code
---
external:
  - items
ignore:
  - items
  - class
prettier: true
props:
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Content

Use the `content` prop to control how the Select content is rendered, like its `align` or `side` for example.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  modelValue: Backlog
  content:
    align: center
    side: bottom
    sideOffset: 8
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Arrow

Use the `arrow` prop to display an arrow on the Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
  - arrow
prettier: true
props:
  modelValue: Backlog
  arrow: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Color

Use the `color` prop to change the ring color when the Select is focused.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  highlight: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variant

Use the `variant` prop to change the variant of the Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  variant: subtle
  highlight: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Size

Use the `size` prop to change the size of the Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  size: xl
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  icon: i-lucide-search
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Trailing Icon

Use the `trailing-icon` prop to customize the trailing [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-chevron-down`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  trailingIcon: i-lucide-arrow-down
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronDown` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronDown` key.
  :::
::

### Selected Icon

Use the `selected-icon` prop to customize the icon when an item is selected. Defaults to `i-lucide-check`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  selectedIcon: i-lucide-flame
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.check` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.check` key.
  :::
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar) inside the Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Nuxt
  avatar:
    src: https://github.com/nuxt.png
  items:
    - Nuxt
    - NuxtHub
    - NuxtLabs
    - Nuxt Modules
    - Nuxt Community
  class: w-48
---
::

### Loading

Use the `loading` prop to show a loading icon on the Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  trailing: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  loadingIcon: i-lucide-loader
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the Select.

::component-code
---
external:
  - items
ignore:
  - items
  - placeholder
  - class
prettier: true
props:
  disabled: true
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

## Examples

### With items type

You can use the `type` property with `separator` to display a separator between items or `label` to display a label.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
props:
  modelValue: Apple
  items:
    - type: label
      label: Fruits
    - Apple
    - Banana
    - Blueberry
    - Grapes
    - Pineapple
    - type: separator
    - type: label
      label: Vegetables
    - Aubergine
    - Broccoli
    - Carrot
    - Courgette
    - Leek
  class: w-48
---
::

### With icon in items

You can use the `icon` property to display an [Icon](https://nuxt.com/components/icon) inside the items.

::component-example{collapse name="select-items-icon-example"}
::

::note
In this example, the icon is computed from the `value` property of the selected item.
::

::tip
You can also use the `#leading` slot to display the selected icon.
::

### With avatar in items

You can use the `avatar` property to display an [Avatar](https://nuxt.com/components/avatar) inside the items.

::component-example{collapse name="select-items-avatar-example"}
::

::note
In this example, the avatar is computed from the `value` property of the selected item.
::

::tip
You can also use the `#leading` slot to display the selected avatar.
::

### With chip in items

You can use the `chip` property to display a [Chip](https://nuxt.com/components/chip) inside the items.

::component-example{collapse name="select-items-chip-example"}
::

::note
In this example, the `#leading` slot is used to display the selected chip.
::

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="select-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the Select by pressing ``.
::

### With rotating icon

Here is an example with a rotating icon that indicates the open state of the Select.

::component-example{name="select-icon-example"}
::

### With fetched items

You can fetch items from an API and use them in the Select.

::component-example{collapse name="select-fetch-example"}
::

### With full content width

You can expand the content to the full width of its items by using the `ui.content` key.

::component-example{collapse name="select-content-width-example"}
::

::tip
You can also change the content width globally in your `app.config.ts`:

```text
export default defineAppConfig({
  ui: {
    select: {
      slots: {
        content: 'min-w-fit'
      }
    }
  }
})
```
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                     | Type                                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `triggerRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof SelectTrigger> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# SelectMenu

## Usage

Use the `v-model` directive to control the value of the SelectMenu or the `default-value` prop to set the initial value when you do not need to control its state.

::tip
Use this over a [`Select`](https://nuxt.com/components/select) to take advantage of Reka UI's [`Combobox`](https://reka-ui.com/docs/components/combobox){rel="nofollow"} component that offers search capabilities and multiple selection.
::

::note
This component is similar to the [`InputMenu`](https://nuxt.com/components/input-menu) but it's using a Select instead of an Input with the search inside the menu.
::

### Items

Use the `items` prop as an array of strings, numbers or booleans:

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Backlog
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

You can also pass an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "label" | "separator" | "item"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-items-type)
- [`icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-icons-in-items)
- [`avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-avatar-in-items)
- [`chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-chip-in-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { label?: ClassNameValue, separator?: ClassNameValue, item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLabel?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue.label
  - items
  - class
props:
  modelValue:
    label: Todo
  items:
    - label: Backlog
    - label: Todo
    - label: In Progress
    - label: Done
  class: w-48
---
::

::caution
Unlike the [`Select`](https://nuxt.com/components/select) component, the SelectMenu expects the whole object to be passed to the `v-model` directive or the `default-value` prop by default.
::

You can also pass an array of arrays to the `items` prop to display separated groups of items.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Apple
  items:
    - - Apple
      - Banana
      - Blueberry
      - Grapes
      - Pineapple
    - - Aubergine
      - Broccoli
      - Carrot
      - Courgette
      - Leek
  class: w-48
---
::

### Value Key

You can choose to bind a single property of the object rather than the whole object by using the `value-key` prop. Defaults to `undefined`.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - valueKey
  - items
  - class
props:
  modelValue: todo
  valueKey: id
  items:
    - label: Backlog
      id: backlog
    - label: Todo
      id: todo
    - label: In Progress
      id: in_progress
    - label: Done
      id: done
  class: w-48
---
::

### Multiple

Use the `multiple` prop to allow multiple selections, the selected items will be separated by a comma in the trigger.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
  - class
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::caution
Ensure to pass an array to the `default-value` prop or the `v-model` directive.
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code
---
external:
  - items
ignore:
  - items
  - class
prettier: true
props:
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Search Input

Use the `search-input` prop to customize or hide the search input (with `false` value).

You can pass any property from the [Input](https://nuxt.com/components/input) component to customize it.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue.label
  - modelValue.icon
  - items
  - class
prettier: true
props:
  modelValue:
    label: Backlog
    icon: i-lucide-circle-help
  searchInput:
    placeholder: Filter...
    icon: i-lucide-search
  items:
    - label: Backlog
      icon: i-lucide-circle-help
    - label: Todo
      icon: i-lucide-circle-plus
    - label: In Progress
      icon: i-lucide-circle-arrow-up
    - label: Done
      icon: i-lucide-circle-check
  class: w-48
---
::

::tip
You can set the `search-input` prop to `false` to hide the search input.
::

### Content

Use the `content` prop to control how the SelectMenu content is rendered, like its `align` or `side` for example.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  modelValue: Backlog
  content:
    align: center
    side: bottom
    sideOffset: 8
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Arrow

Use the `arrow` prop to display an arrow on the SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
  - arrow
prettier: true
props:
  modelValue: Backlog
  arrow: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Color

Use the `color` prop to change the ring color when the SelectMenu is focused.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  highlight: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variant

Use the `variant` prop to change the variant of the SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  variant: subtle
  highlight: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Size

Use the `size` prop to change the size of the SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  size: xl
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  icon: i-lucide-search
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Trailing Icon

Use the `trailing-icon` prop to customize the trailing [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-chevron-down`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  trailingIcon: i-lucide-arrow-down
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronDown` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronDown` key.
  :::
::

### Selected Icon

Use the `selected-icon` prop to customize the icon when an item is selected. Defaults to `i-lucide-check`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  selectedIcon: i-lucide-flame
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.check` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.check` key.
  :::
::

### Avatar

Use the `avatar` prop to display an [Avatar](https://nuxt.com/components/avatar) inside the SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Nuxt
  avatar:
    src: https://github.com/nuxt.png
  items:
    - Nuxt
    - NuxtHub
    - NuxtLabs
    - Nuxt Modules
    - Nuxt Community
  class: w-48
---
::

### Loading

Use the `loading` prop to show a loading icon on the SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  trailing: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  loadingIcon: i-lucide-loader
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the SelectMenu.

::component-code
---
external:
  - items
ignore:
  - items
  - placeholder
  - class
prettier: true
props:
  disabled: true
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

## Examples

### With items type

You can use the `type` property with `separator` to display a separator between items or `label` to display a label.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
props:
  modelValue: Apple
  items:
    - type: label
      label: Fruits
    - Apple
    - Banana
    - Blueberry
    - Grapes
    - Pineapple
    - type: separator
    - type: label
      label: Vegetables
    - Aubergine
    - Broccoli
    - Carrot
    - Courgette
    - Leek
  class: w-48
---
::

### With icon in items

You can use the `icon` property to display an [Icon](https://nuxt.com/components/icon) inside the items.

::component-example{collapse name="select-menu-items-icon-example"}
::

::tip
You can also use the `#leading` slot to display the selected icon.
::

### With avatar in items

You can use the `avatar` property to display an [Avatar](https://nuxt.com/components/avatar) inside the items.

::component-example{collapse name="select-menu-items-avatar-example"}
::

::tip
You can also use the `#leading` slot to display the selected avatar.
::

### With chip in items

You can use the `chip` property to display a [Chip](https://nuxt.com/components/chip) inside the items.

::component-example{collapse name="select-menu-items-chip-example"}
::

::note
In this example, the `#leading` slot is used to display the selected chip.
::

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="select-menu-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the SelectMenu by pressing ``.
::

### Control search term

Use the `v-model:search-term` directive to control the search term.

::component-example{name="select-menu-search-term-example"}
::

### With rotating icon

Here is an example with a rotating icon that indicates the open state of the SelectMenu.

::component-example{name="select-menu-icon-example"}
::

### With create item

Use the `create-item` prop to enable users to add custom values that aren't in the predefined options.

::component-example{collapse name="select-menu-create-item-example"}
::

::note
The create option shows when no match is found by default. Set it to `always` to show it even when similar values exist.
::

::tip{to="https://nuxt.com/#emits"}
Use the `@create` event to handle the creation of the item. You will receive the event and the item as arguments.
::

### With fetched items

You can fetch items from an API and use them in the SelectMenu.

::component-example{collapse name="select-menu-fetch-example"}
::

### With ignore filter

Set the `ignore-filter` prop to `true` to disable the internal search and use your own search logic.

::component-example{collapse name="select-menu-ignore-filter-example"}
::

::note
This example uses [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} to debounce the API calls.
::

### With filter fields

Use the `filter-fields` prop with an array of fields to filter on. Defaults to `[labelKey]`.

::component-example{collapse name="select-menu-filter-fields-example"}
::

### With full content width

You can expand the content to the full width of its items by using the `ui.content` key.

::component-example{collapse name="select-menu-content-width-example"}
::

::tip
You can also change the content width globally in your `app.config.ts`:

```text
export default defineAppConfig({
  ui: {
    selectMenu: {
      slots: {
        content: 'min-w-fit'
      }
    }
  }
})
```
::

### As a CountryPicker

This example demonstrates using the SelectMenu as a country picker with lazy loading - countries are only fetched when the menu is opened.

::component-example{collapse name="select-menu-countries-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                     | Type                                                                                                                                                                           |
| ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `triggerRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof ComboboxTrigger> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Separator

## Usage

Use the Separator component as-is to separate content.

::component-code{.p-8}
::

### Orientation

Use the `orientation` prop to change the orientation of the Separator. Defaults to `horizontal`.

::component-code
---
ignore:
  - class
props:
  orientation: vertical
  class: h-48
class: p-8
---
::

### Label

Use the `label` prop to display a label in the middle of the Separator.

::component-code{.p-8 :props='{"label":"Hello World"}'}
::

### Icon

Use the `icon` prop to display an icon in the middle of the Separator.

::component-code{.p-8 :props='{"icon":"i-simple-icons-nuxtdotjs"}'}
::

### Avatar

Use the `avatar` prop to display an avatar in the middle of the Separator.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
class: p-8
---
::

### Color

Use the `color` prop to change the color of the Separator. Defaults to `neutral`.

::component-code{.p-8 :props='{"color":"primary","type":"solid"}'}
::

### Type

Use the `type` prop to change the type of the Separator. Defaults to `solid`.

::component-code{.p-8 :props='{"type":"dashed"}'}
::

### Size

Use the `size` prop to change the size of the Separator. Defaults to `xs`.

::component-code{.p-8 :props='{"size":"lg"}'}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Skeleton

## Usage

::component-example{name="skeleton-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Slideover

## Usage

Use a [Button](https://nuxt.com/components/button) or any other component in the default slot of the Slideover.

Then, use the `#content` slot to add the content displayed when the Slideover is open.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="h-full m-4" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.h-full.m-4}
  :::
::

You can also use the `#header`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}, `#body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} and `#footer`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} slots to customize the Slideover's content.

### Title

Use the `title` prop to set the title of the Slideover's header.

::component-code
---
prettier: true
props:
  title: Slideover with title
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Description

Use the `description` prop to set the description of the Slideover's header.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Slideover with description
  description: Lorem ipsum dolor sit amet, consectetur adipiscing elit.
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Close

Use the `close` prop to customize or hide the close button (with `false` value) displayed in the Slideover's header.

You can pass any property from the [Button](https://nuxt.com/components/button) component to customize it.

::component-code
---
ignore:
  - title
  - close.color
  - close.variant
prettier: true
props:
  title: Slideover with close button
  close:
    color: primary
    variant: outline
    class: rounded-full
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

::note
The close button is not displayed if the `#content` slot is used as it's a part of the header.
::

### Close Icon

Use the `close-icon` prop to customize the close button [Icon](https://nuxt.com/components/icon). Defaults to `i-lucide-x`.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Slideover with close button
  closeIcon: i-lucide-arrow-right
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.close` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.close` key.
  :::
::

### Side

Use the `side` prop to set the side of the screen where the Slideover will slide in from. Defaults to `right`.

::component-code
---
ignore:
  - title
prettier: true
props:
  side: left
  title: Slideover with side
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full min-h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full.min-h-48}
  :::
::

### Overlay

Use the `overlay` prop to control whether the Slideover has an overlay or not. Defaults to `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  overlay: false
  title: Slideover without overlay
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Transition

Use the `transition` prop to control whether the Slideover is animated or not. Defaults to `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  transition: false
  title: Slideover without transition
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

## Examples

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="slideover-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the Slideover by pressing ``.
::

::tip
This allows you to move the trigger outside of the Slideover or remove it entirely.
::

### Disable dismissal

Set the `dismissible` prop to `false` to prevent the Slideover from being closed when clicking outside of it or pressing escape. A `close:prevent` event will be emitted when the user tries to close it.

::component-code
---
ignore:
  - title
  - dismissible
prettier: true
props:
  dismissible: false
  title: Slideover non-dismissible
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Programmatic usage

You can use the [`useOverlay`](https://nuxt.com/composables/use-overlay) composable to open a Slideover programmatically.

::warning
Make sure to wrap your app with the [`App`](https://nuxt.com/components/app) component which uses the [`OverlayProvider`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/OverlayProvider.vue){rel="nofollow"} component.
::

First, create a slideover component that will be opened programmatically:

::component-example{prettier :preview='false' name="slideover-example"}
::

::note
We are emitting a `close` event when the slideover is closed or dismissed here. You can emit any data through the `close` event, however, the event must be emitted in order to capture the return value.
::

Then, use it in your app:

::component-example{name="slideover-programmatic-example"}
::

::tip
You can close the slideover within the slideover component by emitting `emit('close')`.
::

### Nested slideovers

You can nest slideovers within each other.

::component-example{name="slideover-nested-example"}
::

### With footer slot

Use the `#footer` slot to add content after the Slideover's body.

::component-example{name="slideover-footer-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Slider

## Usage

Use the `v-model` directive to control the value of the Slider.

::component-code{:external='["modelValue"]' :props='{"modelValue":50}'}
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":50}'}
::

### Min / Max

Use the `min` and `max` props to set the minimum and maximum values of the Slider. Defaults to `0` and `100`.

::component-code
---
ignore:
  - defaultValue
props:
  min: 0
  max: 50
  defaultValue: 50
---
::

### Step

Use the `step` prop to set the increment value of the Slider. Defaults to `1`.

::component-code
---
ignore:
  - defaultValue
props:
  step: 10
  defaultValue: 50
---
::

### Multiple

Use the `v-model` directive or the `default-value` prop with an array of values to create a range Slider.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue:
    - 25
    - 75
---
::

Use the `min-steps-between-thumbs` prop to limit the minimum distance between the thumbs.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue:
    - 25
    - 50
    - 75
  minStepsBetweenThumbs: 10
---
::

### Orientation

Use the `orientation` prop to change the orientation of the Slider. Defaults to `horizontal`.

::component-code
---
ignore:
  - defaultValue
  - class
props:
  orientation: vertical
  defaultValue: 50
  class: h-48
---
::

### Color

Use the `color` prop to change the color of the Slider.

::component-code
---
ignore:
  - defaultValue
props:
  color: neutral
  defaultValue: 50
---
::

### Size

Use the `size` prop to change the size of the Slider.

::component-code
---
ignore:
  - defaultValue
props:
  size: xl
  defaultValue: 50
---
::

### Tooltip

Use the `tooltip` prop to display a [Tooltip](https://nuxt.com/components/tooltip) around the Slider thumbs with the current value. You can set it to `true` for default behavior or pass an object to customize it with any property from the [Tooltip](https://nuxt.com/components/tooltip#props) component.

::component-code
---
ignore:
  - defaultValue
  - tooltip
props:
  defaultValue: 50
  tooltip: true
---
::

### Disabled

Use the `disabled` prop to disable the Slider.

::component-code
---
ignore:
  - defaultValue
props:
  disabled: true
  defaultValue: 50
---
::

### Inverted

Use the `inverted` prop to visually invert the Slider.

::component-code
---
ignore:
  - defaultValue
props:
  inverted: true
  defaultValue: 25
---
::

## API

### Props

::component-props
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Stepper

## Usage

### Items

Use the `items` prop as an array of objects with the following properties:

- `title?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `content?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string | number`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, trigger?: ClassNameValue, indicator?: ClassNameValue, icon?: ClassNameValue, separator?: ClassNameValue, wrapper?: ClassNameValue, title?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - items
  - class
props:
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

::note
Click on the items to navigate through the steps.
::

### Color

Use the `color` prop to change the color of the Stepper.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  color: neutral
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

### Size

Use the `size` prop to change the size of the Stepper.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  size: xl
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

### Orientation

Use the `orientation` prop to change the orientation of the Stepper. Defaults to `horizontal`.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  orientation: vertical
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

### Disabled

Use the `disabled` prop to disable navigation through the steps.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  disabled: true
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
---
::

::note{to="https://nuxt.com/#with-controls"}
This can be useful when you want to force navigation with controls.
::

## Examples

### With controls

You can add additional controls for the stepper using buttons.

::component-example{name="stepper-with-controls-example"}
::

### Control active item

You can control the active item by using the `default-value` prop or the `v-model` directive with the index of the item.

::component-example{name="stepper-model-value-example"}
::

::tip
You can also pass the `value` of one of the items if provided.
::

### With content slot

Use the `#content` slot to customize the content of each item.

::component-example{name="stepper-content-slot-example"}
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="stepper-custom-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

You can access the typed component instance using [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const stepper = useTemplateRef('stepper')
</script>

<template>
  <UStepper ref="stepper" />
</template>
```

This will give you access to the following:

| Name                                                                                                                                  | Type                                                                                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `next`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}    | `() => void`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}   |
| `prev`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}    | `() => void`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}   |
| `hasNext`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |
| `hasPrev`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Switch

## Usage

Use the `v-model` directive to control the checked state of the Switch.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: true
---
::

Use the `default-value` prop to set the initial value when you do not need to control its state.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":true}'}
::

### Label

Use the `label` prop to set the label of the Switch.

::component-code{:props='{"label":"Check me"}'}
::

When using the `required` prop, an asterisk is added next to the label.

::component-code
---
ignore:
  - label
props:
  required: true
  label: Check me
---
::

### Description

Use the `description` prop to set the description of the Switch.

::component-code
---
ignore:
  - label
props:
  label: Check me
  description: This is a checkbox.
---
::

### Icon

Use the `checked-icon` and `unchecked-icon` props to set the icons of the Switch when checked and unchecked.

::component-code
---
ignore:
  - label
  - defaultValue
prettier: true
props:
  uncheckedIcon: i-lucide-x
  checkedIcon: i-lucide-check
  defaultValue: true
  label: Check me
---
::

### Loading

Use the `loading` prop to show a loading icon on the Switch.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  loading: true
  defaultValue: true
  label: Check me
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  loading: true
  loadingIcon: i-lucide-loader
  defaultValue: true
  label: Check me
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Color

Use the `color` prop to change the color of the Switch.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  color: neutral
  defaultValue: true
  label: Check me
---
::

### Size

Use the `size` prop to change the size of the Switch.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  size: xl
  defaultValue: true
  label: Check me
---
::

### Disabled

Use the `disabled` prop to disable the Switch.

::component-code
---
ignore:
  - label
props:
  disabled: true
  label: Check me
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Table

## Usage

The Table component is built on top of [TanStack Table](https://tanstack.com/table/latest){rel="nofollow"} and is powered by the [useVueTable](https://tanstack.com/table/latest/docs/framework/vue/vue-table#usevuetable){rel="nofollow"} composable to provide a flexible and fully type-safe API. &#x2A;Some features of TanStack Table are not supported yet, we'll add more over time.*

::component-example{.!p-0 :source='false' name="table-example"}
::

::callout
---
ariaLabel: View source code
icon: i-simple-icons-github
to: https://github.com/nuxt/ui/tree/v3/docs/app/components/content/examples/table/TableExample.vue
---
This example demonstrates the most common use case of the `Table` component. Check out the source code on GitHub.
::

### Data

Use the `data` prop as an array of objects, the columns will be generated based on the keys of the objects.

::component-code
---
collapse: true
external:
  - data
ignore:
  - data
  - class
props:
  data:
    - id: "4600"
      date: 2024-03-11T15:30:00
      status: paid
      email: james.anderson@example.com
      amount: 594
    - id: "4599"
      date: 2024-03-11T10:10:00
      status: failed
      email: mia.white@example.com
      amount: 276
    - id: "4598"
      date: 2024-03-11T08:50:00
      status: refunded
      email: william.brown@example.com
      amount: 315
    - id: "4597"
      date: 2024-03-10T19:45:00
      status: paid
      email: emma.davis@example.com
      amount: 529
    - id: "4596"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
  class: flex-1
class: "!p-0"
---
::

### Columns

Use the `columns` prop as an array of [ColumnDef](https://tanstack.com/table/latest/docs/api/core/column-def){rel="nofollow"} objects with properties like:

- `accessorKey`: [The key of the row object to use when extracting the value for the column.]{.text-muted}
- `header`: [The header to display for the column. If a string is passed, it can be used as a default for the column ID. If a function is passed, it will be passed a props object for the header and should return the rendered header value (the exact type depends on the adapter being used).]{.text-muted}
- `footer`: [The footer to display for the column. Works exactly like header, but is displayed under the table.]{.text-muted}
- `cell`: [The cell to display each row for the column. If a function is passed, it will be passed a props object for the cell and should return the rendered cell value (the exact type depends on the adapter being used).]{.text-muted}
- `meta`: [Extra properties for the column.]{.text-muted}
  - `class`:

    - `td`: [The classes to apply to the `td` element.]{.text-muted}
    - `th`: [The classes to apply to the `th` element.]{.text-muted}
  - `style`:

    - `td`: [The style to apply to the `td` element.]{.text-muted}
    - `th`: [The style to apply to the `th` element.]{.text-muted}

In order to render components or other HTML elements, you will need to use the Vue [`h` function](https://vuejs.org/api/render-function.html#h){rel="nofollow"} inside the `header` and `cell` props. This is different from other components that use slots but allows for more flexibility.

::tip{ariaLabel="Table columns with slots" to="https://nuxt.com/#with-slots"}
You can also use slots to customize the header and data cells of the table.
::

::component-example
---
collapse: true
highlights:
  - 53
  - 105
prettier: true
class: "!p-0"
name: table-columns-example
---
::

::note
When rendering components with `h`, you can either use the `resolveComponent` function or import from `#components`.
::

### Meta

Use the `meta` prop as an object ([TableMeta](https://tanstack.com/table/latest/docs/api/core/table#meta){rel="nofollow"}) to pass properties like:

- `class`:

  - `tr`: [The classes to apply to the `tr` element.]{.text-muted}
- `style`:

  - `tr`: [The style to apply to the `tr` element.]{.text-muted}

::component-example{.!p-0 collapse prettier name="table-custom-meta-example"}
::

### Loading

Use the `loading` prop to display a loading state, the `loading-color` prop to change its color and the `loading-animation` prop to change its animation.

::component-code
---
collapse: true
external:
  - data
ignore:
  - data
  - class
props:
  loading: true
  loadingColor: primary
  loadingAnimation: carousel
  data:
    - id: "4600"
      date: 2024-03-11T15:30:00
      status: paid
      email: james.anderson@example.com
      amount: 594
    - id: "4599"
      date: 2024-03-11T10:10:00
      status: failed
      email: mia.white@example.com
      amount: 276
    - id: "4598"
      date: 2024-03-11T08:50:00
      status: refunded
      email: william.brown@example.com
      amount: 315
    - id: "4597"
      date: 2024-03-10T19:45:00
      status: paid
      email: emma.davis@example.com
      amount: 529
    - id: "4596"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
  class: flex-1
class: "!p-0"
---
::

### Sticky

Use the `sticky` prop to make the header or footer sticky.

::component-code
---
collapse: true
external:
  - data
ignore:
  - data
  - class
items:
  sticky:
    - true
    - false
props:
  sticky: true
  data:
    - id: "4600"
      date: 2024-03-11T15:30:00
      status: paid
      email: james.anderson@example.com
      amount: 594
    - id: "4599"
      date: 2024-03-11T10:10:00
      status: failed
      email: mia.white@example.com
      amount: 276
    - id: "4598"
      date: 2024-03-11T08:50:00
      status: refunded
      email: william.brown@example.com
      amount: 315
    - id: "4597"
      date: 2024-03-10T19:45:00
      status: paid
      email: emma.davis@example.com
      amount: 529
    - id: "4596"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
    - id: "4595"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
    - id: "4594"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
  class: flex-1 max-h-[312px]
class: "!p-0"
---
::

## Examples

### With row actions

You can add a new column that renders a [DropdownMenu](https://nuxt.com/components/dropdown-menu) component inside the `cell` to render row actions.

::component-example
---
collapse: true
highlights:
  - 110
  - 134
prettier: true
class: "!p-0"
name: table-row-actions-example
---
::

### With expandable rows

You can add a new column that renders a [Button](https://nuxt.com/components/button) component inside the `cell` to toggle the expandable state of a row using the TanStack Table [Expanding APIs](https://tanstack.com/table/latest/docs/api/features/expanding){rel="nofollow"}.

::caution
You need to define the `#expanded` slot to render the expanded content which will receive the row as a parameter.
::

::component-example
---
collapse: true
highlights:
  - 55
  - 71
prettier: true
class: "!p-0"
name: table-row-expandable-example
---
::

::tip
You can use the `expanded` prop to control the expandable state of the rows (can be binded with `v-model`).
::

::note
You could also add this action to the [`DropdownMenu`](https://nuxt.com/components/dropdown-menu) component inside the `actions` column.
::

### With grouped rows

You can group rows based on a given column value and show/hide sub rows via some button added to the cell using the TanStack Table [Grouping APIs](https://tanstack.com/table/latest/docs/api/features/grouping){rel="nofollow"}.

#### Important parts:

- Add `grouping` prop with an array of column ids you want to group by.
- Add `grouping-options` prop. It must include `getGroupedRowModel`, you can import it from `@tanstack/vue-table` or implement your own.
- Expand rows via `row.toggleExpanded()` method on any cell of the row. Keep in mind, it also toggles `#expanded` slot.
- Use `aggregateFn` on column definition to define how to aggregate the rows.
- `agregatedCell` renderer on column definition only works if there is no `cell` renderer.

::component-example
---
collapse: true
highlights:
  - 159
  - 169
prettier: true
class: "!p-0"
name: table-grouped-rows-example
---
::

### With row selection

You can add a new column that renders a [Checkbox](https://nuxt.com/components/checkbox) component inside the `header` and `cell` to select rows using the TanStack Table [Row Selection APIs](https://tanstack.com/table/latest/docs/api/features/row-selection){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 55
  - 72
prettier: true
class: "!p-0"
name: table-row-selection-example
---
::

::tip
You can use the `row-selection` prop to control the selection state of the rows (can be binded with `v-model`).
::

### With row select event

You can add a `@select` listener to make rows clickable with or without a checkbox column.

::note
The handler function receives the `TableRow` instance as the first argument and an optional `Event` as the second argument.
::

::component-example
---
collapse: true
highlights:
  - 123
  - 130
prettier: true
class: "!p-0"
name: table-row-select-event-example
---
::

::tip
You can use this to navigate to a page, open a modal or even to select the row manually.
::

### With row context menu event :badge{.align-text-top label="New"}

You can add a `@contextmenu` listener to make rows right clickable and wrap the Table in a [ContextMenu](https://nuxt.com/components/context-menu) component to display row actions for example.

::note
The handler function receives the `Event` and `TableRow` instance as the first and second arguments respectively.
::

::component-example
---
collapse: true
highlights:
  - 130
  - 170
prettier: true
class: "!p-0"
name: table-row-context-menu-event-example
---
::

### With row hover event :badge{.align-text-top label="New"}

You can add a `@hover` listener to make rows hoverable and use a [Popover](https://nuxt.com/components/popover) or a [Tooltip](https://nuxt.com/components/tooltip) component to display row details for example.

::note
The handler function receives the `Event` and `TableRow` instance as the first and second arguments respectively.
::

::component-example
---
collapse: true
highlights:
  - 126
  - 149
prettier: true
class: "!p-0"
name: table-row-hover-event-example
---
::

::note
This example is similar as the Popover [with following cursor example](https://nuxt.com/components/popover#with-following-cursor) and uses a [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} to prevent the Popover from opening and closing too quickly when moving the cursor from one row to another.
::

### With column footer :badge{.align-text-top label="New"}

You can add a `footer` property to the column definition to render a footer for the column.

::component-example
---
collapse: true
highlights:
  - 94
  - 108
prettier: true
class: "!p-0"
name: table-column-footer-example
---
::

### With column sorting

You can update a column `header` to render a [Button](https://nuxt.com/components/button) component inside the `header` to toggle the sorting state using the TanStack Table [Sorting APIs](https://tanstack.com/table/latest/docs/api/features/sorting){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 90
  - 105
prettier: true
class: "!p-0"
name: table-column-sorting-example
---
::

::tip
You can use the `sorting` prop to control the sorting state of the columns (can be binded with `v-model`).
::

You can also create a reusable component to make any column header sortable.

::component-example
---
collapse: true
highlights:
  - 110
  - 161
prettier: true
class: "!p-0"
name: table-column-sorting-reusable-example
---
::

::note
In this example, we use a function to define the column header but you can also create an actual component.
::

### With column pinning

You can update a column `header` to render a [Button](https://nuxt.com/components/button) component inside the `header` to toggle the pinning state using the TanStack Table [Pinning APIs](https://tanstack.com/table/latest/docs/api/features/row-pinning){rel="nofollow"}.

::note
A pinned column will become sticky on the left or right side of the table.
::

::component-example
---
collapse: true
highlights:
  - 100
  - 113
prettier: true
class: "!p-0 overflow-clip"
name: table-column-pinning-example
---
::

::tip
You can use the `column-pinning` prop to control the pinning state of the columns (can be binded with `v-model`).
::

### With column visibility

You can use a [DropdownMenu](https://nuxt.com/components/dropdown-menu) component to toggle the visibility of the columns using the TanStack Table [Column Visibility APIs](https://tanstack.com/table/latest/docs/api/features/column-visibility){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 135
  - 142
prettier: true
class: "!p-0"
name: table-column-visibility-example
---
::

::tip
You can use the `column-visibility` prop to control the visibility state of the columns (can be binded with `v-model`).
::

### With column filters

You can use an [Input](https://nuxt.com/components/input) component to filter per column the rows using the TanStack Table [Column Filtering APIs](https://tanstack.com/table/latest/docs/api/features/column-filtering){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 135
  - 142
prettier: true
class: "!p-0"
name: table-column-filters-example
---
::

::tip
You can use the `column-filters` prop to control the filters state of the columns (can be binded with `v-model`).
::

### With global filter

You can use an [Input](https://nuxt.com/components/input) component to filter the rows using the TanStack Table [Global Filtering APIs](https://tanstack.com/table/latest/docs/api/features/global-filtering){rel="nofollow"}.

::component-example{.!p-0 collapse prettier name="table-global-filter-example"}
::

::tip
You can use the `global-filter` prop to control the global filter state (can be binded with `v-model`).
::

### With pagination

You can use a [Pagination](https://nuxt.com/components/pagination) component to control the pagination state using the [Pagination APIs](https://tanstack.com/table/latest/docs/api/features/pagination){rel="nofollow"}.

There are different pagination approaches as explained in [Pagination Guide](https://tanstack.com/table/latest/docs/guide/pagination#pagination-guide){rel="nofollow"}. In this example, we use client-side pagination so we need to manually pass `getPaginationRowModel()`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} function.

::component-example{.!p-0 collapse prettier name="table-pagination-example"}
::

::tip
You can use the `pagination` prop to control the pagination state (can be binded with `v-model`).
::

### With fetched data

You can fetch data from an API and use them in the Table.

::component-example{.!p-0 collapse prettier name="table-fetch-example"}
::

### With infinite scroll

If you use server-side pagination, you can use the [`useInfiniteScroll`](https://vueuse.org/core/useInfiniteScroll/#useinfinitescroll){rel="nofollow"} composable to load more data when scrolling.

::component-example
---
collapse: true
overflowHidden: true
prettier: true
class: "!p-0"
name: table-infinite-scroll-example
---
::

### With drag and drop

Use the [`useSortable`](https://vueuse.org/integrations/useSortable/){rel="nofollow"} composable from [`@vueuse/integrations`](https://vueuse.org/integrations/README.html){rel="nofollow"} to enable drag and drop functionality on the Table. This integration wraps [Sortable.js](https://sortablejs.github.io/Sortable/){rel="nofollow"} to provide a seamless drag and drop experience.

::note
Since the table ref doesn't expose the tbody element, add a unique class to it via the `:ui` prop to target it with `useSortable` (e.g. `:ui="{ tbody: 'my-table-tbody' }"`).
::

::component-example{.!p-0 collapse prettier name="table-drag-and-drop-example"}
::

### With slots

You can use slots to customize the header and data cells of the table.

Use the `#<column>-header` slot to customize the header of a column. You will have access to the `column`, `header` and `table` properties in the slot scope.

Use the `#<column>-cell` slot to customize the cell of a column. You will have access to the `cell`, `column`, `getValue`, `renderValue`, `row`, and `table` properties in the slot scope.

::component-example{.!p-0 collapse prettier name="table-slots-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Expose

You can access the typed component instance using [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const table = useTemplateRef('table')
</script>

<template>
  <UTable ref="table" />
</template>
```

This will give you access to the following:

| Name                                                                                                                                   | Type                                                                                                                                                                                                                               |
| -------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `tableRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLTableElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                         |
| `tableApi`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | [`Ref<Table | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://tanstack.com/table/latest/docs/api/core/table#table-api){rel="nofollow"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Tabs

## Usage

### Items

Use the `items` prop as an array of objects with the following properties:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `badge?: string | number | BadgeProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `content?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string | number`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { trigger?: ClassNameValue, leadingIcon?: ClassNameValue, leadingAvatar?: ClassNameValue, leadingAvatarSize?: ClassNameValue, label?: ClassNameValue, trailingBadge?: ClassNameValue, trailingBadgeSize?: ClassNameValue, content?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - items
  - class
props:
  items:
    - label: Account
      icon: i-lucide-user
      content: This is the account content.
    - label: Password
      icon: i-lucide-lock
      content: This is the password content.
  class: w-full
---
::

### Content

Set the `content` prop to `false` to turn the Tabs into a toggle-only control without displaying any content. Defaults to `true`.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  content: false
  items:
    - label: Account
      icon: i-lucide-user
      content: This is the account content.
    - label: Password
      icon: i-lucide-lock
      content: This is the password content.
  class: w-full
---
::

### Unmount

Use the `unmount-on-hide` prop to prevent the content from being unmounted when the Tabs is collapsed. Defaults to `true`.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  unmountOnHide: false
  items:
    - label: Account
      icon: i-lucide-user
      content: This is the account content.
    - label: Password
      icon: i-lucide-lock
      content: This is the password content.
  class: w-full
---
::

::note
You can inspect the DOM to see each item's content being rendered.
::

### Color

Use the `color` prop to change the color of the Tabs.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  color: neutral
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

### Variant

Use the `variant` prop to change the variant of the Tabs.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  color: neutral
  variant: link
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

### Size

Use the `size` prop to change the size of the Tabs.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  size: md
  variant: pill
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

### Orientation

Use the `orientation` prop to change the orientation of the Tabs. Defaults to `horizontal`.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  orientation: vertical
  variant: pill
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

## Examples

### Control active item

You can control the active item by using the `default-value` prop or the `v-model` directive with the index of the item.

::component-example{name="tabs-model-value-example"}
::

### With content slot

Use the `#content` slot to customize the content of each item.

::component-example{name="tabs-content-slot-example"}
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="tabs-custom-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                      | Type                                                                                                                                                         |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `triggersRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<ComponentPublicInstance[]>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Textarea

## Usage

Use the `v-model` directive to control the value of the Textarea.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: ""
---
::

### Rows

Use the `rows` prop to set the number of rows. Defaults to `3`.

::component-code{:props='{"rows":12}'}
::

### Placeholder

Use the `placeholder` prop to set a placeholder text.

::component-code{:props='{"placeholder":"Type something..."}'}
::

### Autoresize

Use the `autoresize` prop to enable autoresizing the height of the Textarea.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: This is a long text that will autoresize the height of the Textarea.
  autoresize: true
---
::

Use the `maxrows` prop to set the maximum number of rows when autoresizing. If set to `0`, the Textarea will grow indefinitely.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: This is a long text that will autoresize the height of the Textarea
    with a maximum of 4 rows.
  maxrows: 4
  autoresize: true
---
::

### Color

Use the `color` prop to change the ring color when the Textarea is focused.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  highlight: true
  placeholder: Type something...
---
::

::note
The `highlight` prop is used here to show the focus state. It's used internally when a validation error occurs.
::

### Variant

Use the `variant` prop to change the variant of the Textarea.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  variant: subtle
  highlight: false
  placeholder: Type something...
---
::

### Size

Use the `size` prop to change the size of the Textarea.

::component-code
---
ignore:
  - placeholder
props:
  size: xl
  placeholder: Type something...
---
::

### Icon

Use the `icon` prop to show an [Icon](https://nuxt.com/components/icon) inside the Textarea.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  icon: i-lucide-search
  size: md
  variant: outline
  placeholder: Search...
  rows: 1
---
::

Use the `leading` and `trailing` props to set the icon position or the `leading-icon` and `trailing-icon` props to set a different icon for each position.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  trailingIcon: i-lucide-at-sign
  placeholder: Enter your email
  size: md
  rows: 1
---
::

### Avatar

Use the `avatar` prop to show an [Avatar](https://nuxt.com/components/avatar) inside the Textarea.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  variant: outline
  placeholder: Search...
  rows: 1
---
::

### Loading

Use the `loading` prop to show a loading icon on the Textarea.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  trailing: false
  placeholder: Search...
  rows: 1
---
::

### Loading Icon

Use the `loading-icon` prop to customize the loading icon. Defaults to `i-lucide-loader-circle`.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  loadingIcon: i-lucide-loader
  placeholder: Search...
  rows: 1
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.loading` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.loading` key.
  :::
::

### Disabled

Use the `disabled` prop to disable the Textarea.

::component-code
---
ignore:
  - placeholder
props:
  disabled: true
  placeholder: Type something...
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                      | Type                                                                                                                                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `textareaRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLTextAreaElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Timeline

## Usage

### Items

Use the `items` prop as an array of objects with the following properties:

- `date?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `title?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string | number`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, indicator?: ClassNameValue, separator?: ClassNameValue, wrapper?: ClassNameValue, date?: ClassNameValue, title?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment. Set up project
        milestones and allocated resources.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops. Created wireframes and
        prototypes for user testing.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development. Implemented core features and
        integrated with APIs.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization. Deployed the application
        to production.
      icon: i-lucide-check-circle
  class: w-96
---
::

### Color

Use the `color` prop to change the color of the active items in a Timeline.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  color: neutral
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment. Set up project
        milestones and allocated resources.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops. Created wireframes and
        prototypes for user testing.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development. Implemented core features and
        integrated with APIs.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization. Deployed the application
        to production.
      icon: i-lucide-check-circle
  class: w-96
---
::

### Size

Use the `size` prop to change the size of the Timeline.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  size: xs
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment. Set up project
        milestones and allocated resources.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops. Created wireframes and
        prototypes for user testing.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development. Implemented core features and
        integrated with APIs.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization. Deployed the application
        to production.
      icon: i-lucide-check-circle
  class: w-96
---
::

### Orientation

Use the `orientation` prop to change the orientation of the Timeline. Defaults to `vertical`.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  orientation: horizontal
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization.
      icon: i-lucide-check-circle
  class: w-full
class: overflow-x-auto
---
::

### Reverse

Use the reverse prop to reverse the direction of the Timeline.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  reverse: true
  modelValue: 2
  orientation: vertical
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization.
      icon: i-lucide-check-circle
  class: w-full
class: overflow-x-auto
---
::

## Examples

### Control active item

You can control the active item by using the `default-value` prop or the `v-model` directive with the index of the item.

::component-example{prettier name="timeline-model-value-example"}
::

::tip
You can also pass the `value` of one of the items if provided.
::

### With alternating layout

Use the `ui` prop to create a Timeline with alternating layout.

::component-example{prettier name="timeline-alternating-layout-example"}
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}-indicator`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-date`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-title`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-description`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{prettier name="timeline-custom-slot-example"}
::

### With slots

Use the available slots to create a more complex Timeline.

::component-example{prettier name="timeline-slots-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Toast

## Usage

Use the [useToast](https://nuxt.com/composables/use-toast) composable to display a toast in your application.

::warning
Make sure to wrap your app with the [`App`](https://nuxt.com/components/app) component which uses our [`Toaster`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/Toaster.vue){rel="nofollow"} component which uses the [`ToastProvider`](https://reka-ui.com/docs/components/toast#provider){rel="nofollow"} component from Reka UI.
::

::tip{to="https://nuxt.com/components/app#props"}
You can check the `App` component `toaster` prop to see how to configure the Toaster globally.
::

### Title

Pass a `title` field to the `toast.add` method to display a title.

::component-example
---
options:
  - name: title
    label: title
    default: Uh oh! Something went wrong.
name: toast-title-example
---
::

### Description

Pass a `description` field to the `toast.add` method to display a description.

::component-example
---
options:
  - name: title
    label: title
    default: Uh oh! Something went wrong.
  - name: description
    label: description
    default: There was a problem with your request.
name: toast-description-example
---
::

### Icon

Pass an `icon` field to the `toast.add` method to display an [Icon](https://nuxt.com/components/icon).

::component-example
---
options:
  - name: icon
    label: icon
    default: i-lucide-wifi
name: toast-icon-example
---
::

### Avatar

Pass an `avatar` field to the `toast.add` method to display an [Avatar](https://nuxt.com/components/avatar).

::component-example
---
options:
  - name: avatar.src
    alias: avatar
    label: avatar.src
    default:
      src: https://github.com/benjamincanac.png
name: toast-avatar-example
---
::

### Color

Pass a `color` field to the `toast.add` method to change the color of the Toast.

::component-example
---
options:
  - name: color
    label: color
    default: neutral
    items:
      - primary
      - secondary
      - success
      - info
      - warning
      - error
      - neutral
name: toast-color-example
---
::

### Close

Pass a `close` field to customize or hide the close [Button](https://nuxt.com/components/button) (with `false` value).

::component-example{name="toast-close-example"}
::

### Close Icon

Pass a `closeIcon` field to customize the close button [Icon](https://nuxt.com/components/icon). Default to `i-lucide-x`.

::component-example
---
options:
  - name: closeIcon
    label: closeIcon
    default: i-lucide-arrow-right
name: toast-close-icon-example
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.close` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.close` key.
  :::
::

### Actions

Pass an `actions` field to add some [Button](https://nuxt.com/components/button) actions to the Toast.

::component-example
---
options:
  - name: description
    label: description
    default: There was a problem with your request.
name: toast-actions-example
---
::

### Progress :badge{.align-text-top label="New"}

Pass a `progress` field to customize or hide the [Progress](https://nuxt.com/components/progress) bar (with `false` value).

::tip
The Progress bar inherits the Toast color by default, but you can override it using the `progress.color` field.
::

::component-example{name="toast-progress-example"}
::

### Orientation

Pass an `orientation` field to the `toast.add` method to change the orientation of the Toast.

::component-example
---
options:
  - name: orientation
    label: orientation
    default: horizontal
    items:
      - horizontal
      - vertical
name: toast-orientation-example
---
::

## Examples

::note{to="https://nuxt.com/components/app"}
Nuxt UI provides an **App** component that wraps your app to provide global configurations.
::

### Change global position

Change the `toaster.position` prop on the [App](https://nuxt.com/components/app#props) component to change the position of the toasts.

```vue [app.vue]
<script setup lang="ts">
const toaster = { position: 'bottom-right' }
</script>

<template>
  <UApp :toaster="toaster">
    <NuxtPage />
  </UApp>
</template>
```

::component-example
---
prettier: true
name: toast-example
---
#options
  :::toaster-position-example
  :::
::

::note{to="https://github.com/nuxt/ui/blob/v3/docs/app/app.config.ts#L3"}
In this example, we use the `AppConfig` to configure the `position` prop of the `Toaster` component globally.
::

### Change global duration

Change the `toaster.duration` prop on the [App](https://nuxt.com/components/app#props) component to change the duration of the toasts.

```vue [app.vue]
<script setup lang="ts">
const toaster = { duration: 5000 }
</script>

<template>
  <UApp :toaster="toaster">
    <NuxtPage />
  </UApp>
</template>
```

::component-example
---
prettier: true
name: toast-example
---
#options
  :::toaster-duration-example
  :::
::

::note{to="https://github.com/nuxt/ui/blob/v3/docs/app/app.config.ts#L5"}
In this example, we use the `AppConfig` to configure the `duration` prop of the `Toaster` component globally.
::

### Stacked toasts

Set the `toaster.expand` prop to `false` on the [App](https://nuxt.com/components/app#props) component to display stacked toasts.

::tip
You can hover over the toasts to expand them. This will also pause the timer of the toasts.
::

```vue [app.vue]
<script setup lang="ts">
const toaster = { expand: true }
</script>

<template>
  <UApp :toaster="toaster">
    <NuxtPage />
  </UApp>
</template>
```

::component-example
---
prettier: true
name: toast-example
---
#options
  :::toaster-expand-example
  :::
::

::note{to="https://github.com/nuxt/ui/blob/v3/docs/app/app.config.ts#L4"}
In this example, we use the `AppConfig` to configure the `expand` prop of the `Toaster` component globally.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Tooltip

## Usage

Use a [Button](https://nuxt.com/components/button) or any other component in the default slot of the Tooltip.

::warning
Make sure to wrap your app with the [`App`](https://nuxt.com/components/app) component which uses the [`TooltipProvider`](https://reka-ui.com/docs/components/tooltip#provider){rel="nofollow"} component from Reka UI.
::

::tip{to="https://nuxt.com/components/app#props"}
You can check the `App` component `tooltip` prop to see how to configure the Tooltip globally.
::

### Text

Use the `text` prop to set the content of the Tooltip.

::component-code
---
prettier: true
props:
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

### Kbds

Use the `kbds` prop to render [Kbd](https://nuxt.com/components/kbd) components in the Tooltip.

::component-code
---
ignore:
  - text
  - kbds
prettier: true
props:
  text: Open on GitHub
  kbds:
    - meta
    - G
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

::tip
You can use special keys like `meta` that displays as `⌘` on macOS and `Ctrl` on other platforms.
::

### Delay

Use the `delay-duration` prop to change the delay before the Tooltip appears. For example, you can make it appear instantly by setting it to `0`.

::component-code
---
ignore:
  - text
prettier: true
props:
  delayDuration: 0
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

::tip
This can be configured globally through the `tooltip.delayDuration` option in the [`App`](https://nuxt.com/components/app) component.
::

### Content

Use the `content` prop to control how the Tooltip content is rendered, like its `align` or `side` for example.

::component-code
---
ignore:
  - text
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  content:
    align: center
    side: bottom
    sideOffset: 8
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

### Arrow

Use the `arrow` prop to display an arrow on the Tooltip.

::component-code
---
ignore:
  - text
  - arrow
prettier: true
props:
  arrow: true
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

### Disabled

Use the `disabled` prop to disable the Tooltip.

::component-code
---
ignore:
  - text
prettier: true
props:
  disabled: true
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

## Examples

### Control open state

You can control the open state by using the `default-open` prop or the `v-model:open` directive.

::component-example{name="tooltip-open-example"}
::

::note
In this example, leveraging [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), you can toggle the Tooltip by pressing ``.
::

### With following cursor :badge{.align-text-top label="New"}

You can make the Tooltip follow the cursor when hovering over an element using the [`reference`](https://reka-ui.com/docs/components/tooltip#trigger){rel="nofollow"} prop:

::component-example{name="tooltip-cursor-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Tree

## Usage

### Items

Use the `items` prop as an array of objects with the following properties:

- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `trailingIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `defaultExpanded?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `children?: TreeItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onToggle?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e?: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, itemWithChildren?: ClassNameValue, link?: ClassNameValue, linkLeadingIcon?: ClassNameValue, linkLabel?: ClassNameValue, linkTrailing?: ClassNameValue, linkTrailingIcon?: ClassNameValue, listWithChildren?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::note
A unique identifier is required for each item. The component will use the `value` prop as identifier, falling back to `label` if `value` is not provided. One of these must be provided for the component to work properly.
::

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Multiple

Use the `multiple` prop to allow multiple item selections.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  multiple: true
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Color

Use the `color` prop to change the color of the Tree.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  color: neutral
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Size

Use the `size` prop to change the size of the Tree.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  size: xl
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Trailing Icon

Use the `trailing-icon` prop to customize the trailing [Icon](https://nuxt.com/components/icon) of a parent node. Defaults to `i-lucide-chevron-down`.

::note
If an icon is specified for an item, it will always take precedence over these props.
::

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  trailingIcon: i-lucide-arrow-down
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          trailingIcon: i-lucide-chevron-down
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize this icon globally in your `app.config.ts` under `ui.icons.chevronDown` key.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronDown` key.
  :::
::

### Expanded Icon

Use the `expanded-icon` and `collapsed-icon` props to customize the icons of a parent node when it is expanded or collapsed. Defaults to `i-lucide-folder-open` and `i-lucide-folder` respectively.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  expandedIcon: i-lucide-book-open
  collapsedIcon: i-lucide-book
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize these icons globally in your `app.config.ts` under `ui.icons.folder` and `ui.icons.folderOpen` keys.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize these icons globally in your `vite.config.ts` under `ui.icons.folder` and `ui.icons.folderOpen` keys.
  :::
::

### Disabled

Use the `disabled` prop to prevent any user interaction with the Tree.

::note
You can also disable individual items using `item.disabled`.
::

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  disabled: true
  items:
    - label: app
      icon: i-lucide-folder
      defaultExpanded: true
      children:
        - label: composables
          icon: i-lucide-folder
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components
          icon: i-lucide-folder
          children:
            - label: Home
              icon: i-lucide-folder
              children:
                - label: Card.vue
                  icon: i-vscode-icons-file-type-vue
                - label: Button.vue
                  icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

## Examples

### Control selected item(s)

You can control the selected item(s) by using the `default-value` prop or the `v-model` directive.

::component-example
---
collapse: true
props:
  class: w-60
name: tree-model-value-example
---
::

If you want to prevent an item from being selected, you can use the `item.onSelect()`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} property:

::component-example
---
collapse: true
props:
  class: w-60
name: tree-on-select-example
---
::

::note
This lets you expand or collapse a parent item without selecting it.
::

### Control expanded items

You can control the expanded items by using the `default-expanded` prop or the `v-model` directive.

::component-example
---
collapse: true
props:
  class: w-60
name: tree-expanded-example
---
::

If you want to prevent an item from being expanded, you can use the `item.onToggle()`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} property:

::component-example
---
collapse: true
props:
  class: w-60
name: tree-on-toggle-example
---
::

::note
This lets you select a parent item without expanding or collapsing its children.
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}-wrapper`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example
---
collapse: true
props:
  class: w-60
name: tree-custom-slot-example
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Conditions Générales de Vente de Nuxt UI Pro

## 1. Introduction

Les présentes conditions générales de vente (ci-après "CGV") régissent les relations contractuelles entre NuxtLabs (ci-après "nous" ou "l'Entreprise") et toute personne physique ou morale (ci-après "Client") souhaitant acquérir une licence pour le produit Nuxt UI Pro (ci-après "Produit").

## 2. Acceptation des Conditions Générales de Vente

En achetant une licence pour Nuxt UI Pro, le Client accepte sans réserve les présentes CGV. Toute condition contraire posée par le Client sera, sauf acceptation formelle et écrite de notre part, inopposable.

## 3. Description du Produit

Nuxt UI Pro est un ensemble d'outils et de composants pour le développement d'interfaces utilisateur avec le framework Nuxt. Le produit est accessible via un paiement unique, tel que décrit sur notre [page de tarification](https://nuxt.com/pro/pricing).

## 4. Modalités de paiement

Le paiement pour l'acquisition d'une licence Nuxt UI Pro est unique et doit être effectué en totalité au moment de l'achat. Les tarifs sont indiqués en dollars américains (USD) et n'incluent pas les taxes applicables. Le Client est responsable du paiement de toutes les taxes, droits ou autres charges imposés par les autorités fiscales compétentes.

## 5. Droit de rétractation et remboursement

Le Client dispose d'un droit de rétractation de 14 jours concernant la licence Nuxt UI Pro à compter de la date d'achat. Passé ce délai, aucun remboursement ne sera effectué.

Le Figma Pro Kit étant un produit numérique fourni sous forme de fichier ZIP, aucun remboursement ne pourra être effectué après l'achat.

## 6. Propriété intellectuelle

NuxtLabs reste propriétaire exclusif de tous les droits de propriété intellectuelle relatifs au Produit. La licence concédée au Client est non exclusive, non transférable, et strictement limitée à l'utilisation personnelle ou professionnelle du Produit.

## 7. Responsabilité

NuxtLabs s'engage à fournir un service de qualité, mais ne saurait être tenu responsable des dommages directs ou indirects résultant de l'utilisation du Produit. La responsabilité de NuxtLabs, en tout état de cause, sera limitée au montant payé par le Client pour l'achat du Produit.

## 8. Support technique

Un support technique est fourni aux Clients selon les modalités spécifiées sur notre site web. Pour toute assistance, le Client peut envoyer un email à l'adresse suivante : <ui-pro@nuxt.com>.

## 9. Modifications des CGV

NuxtLabs se réserve le droit de modifier les présentes CGV à tout moment. Les modifications entreront en vigueur dès leur publication sur notre site web.

## 10. Mentions Légales

- Nom de l'Entreprise : NuxtLabs
- Adresse : 10 rue Rolland 33000 Bordeaux
- Numéro d'Identification Fiscale : FR92828193722
- Contact : Vous pouvez nous contacter par email à l'adresse suivante : <legal@nuxtlabs.com>.

## 11. Loi applicable et juridiction compétente

Les présentes CGV sont soumises au droit français. En cas de litige, les parties s'efforceront de résoudre le différend à l'amiable. À défaut, les tribunaux compétents seront ceux du ressort de la Cour d'appel de Paris.


# Introduction

TEST TIẾNG VIỆT

:iframe{.rounded-md allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen="true" frameBorder="0" height="100%" referrerPolicy="strict-origin-when-cross-origin" src="https://www.youtube-nocookie.com/embed/_eQxomah-nA?si=pDSzchUBDKb2NQu7" style="aspect-ratio: 16/9;" title="YouTube video player" width="100%"}

## Reka UI

We've transitioned from [Headless UI](https://headlessui.com/){rel="nofollow"} to [Reka UI](https://reka-ui.com/){rel="nofollow"} as our core component foundation. This shift brings several key advantages:

- **Extensive Component Library**: With 55+ primitives, Reka UI significantly expands our component offerings.
- **Active Development**: Reka UI's growing popularity ensures ongoing improvements and updates.
- **Enhanced Accessibility**: Built-in accessibility features align with our commitment to inclusive design.
- **Vue 3 Optimization**: Seamless integration with Vue 3 and the Composition API.

This transition empowers Nuxt UI to become a more comprehensive and flexible UI library, offering developers greater power and customization options.

## Tailwind CSS v4

Nuxt UI integrates the latest Tailwind CSS v4, bringing significant improvements:

- **Built for performance**: Full builds in the new engine are up to 5x faster, and incremental builds are over 100x faster — and measured in microseconds.
- **Unified toolchain**: Built-in import handling, vendor prefixing, and syntax transforms, with no additional tooling required.
- **CSS-first configuration**: A reimagined developer experience where you customize and extend the framework directly in CSS instead of a JavaScript configuration file.
- **Designed for the modern web**: Built on native cascade layers, wide-gamut colors, and including first-class support for modern CSS features like container queries, @starting-style, popovers, and more.

::note
---
ariaLabel: Tailwind CSS v4 upgrade guide
target: _blank
to: https://tailwindcss.com/docs/upgrade-guide#changes-from-v3
---
Learn about all the breaking changes in Tailwind CSS v4.
::

## Tailwind Variants

We've adopted [Tailwind Variants](https://www.tailwind-variants.org/){rel="nofollow"} to manage our design system, offering:

- **Dynamic Styling**: Flexible component variants with a powerful API
- **Type Safety**: Full TypeScript support with auto-completion
- **Conflict Resolution**: Efficient merging of conflicting styles

This integration unifies the styling of components, ensuring consistency and code maintainability.

## TypeScript Integration

Nuxt UI offers significantly improved TypeScript integration, providing a superior developer experience:

- **Enhanced Auto-completion**:
  - Full auto-completion for component props based on your theme
  - Intelligent suggestions for `app.config.ts` theme configuration
- **Generic-based Components**:
  - Built using [Vue 3 Generics](https://vuejs.org/api/sfc-script-setup.html#generics){rel="nofollow"}
  - Improved type inference for slots and events
- **Type-safe Theming**:
  - Leveraging Tailwind Variants for type-safe styling options
  - Customizable types for extended theme configurations

::note
---
ariaLabel: Accordion component with custom slot
to: https://nuxt.com/components/accordion#with-custom-slot
---
Check out an example of the Accordion component with auto-completion for props and slots.
::

## Vue compatibility

You can now use Nuxt UI in any Vue project without Nuxt by adding the Vite and Vue plugins to your configuration. This provides:

- **Auto-imports**: Components and composables are automatically imported and available globally
- **Theming System**: Full theming support with customizable colors, sizes, variants and more
- **Developer Experience**: Complete TypeScript support with IntelliSense and auto-completion

::tip
---
ariaLabel: Vue installation guide
to: https://nuxt.com/getting-started/installation/vue
---
Learn how to install and configure Nuxt UI in a Vue project in the **Vue installation guide**.
::

## Nuxt DevTools Integration

You can play with Nuxt UI components as well as your app components directly from Nuxt Devtools with the [compodium](https://github.com/romhml/compodium){rel="nofollow"} module, providing a powerful development experience:

- **Component Inspector**: Inspect and analyze Nuxt UI components in real-time
- **Live Preview**: Modify component props and see changes instantly
- **Code Generation**: Get the corresponding code for your component configurations

::note
Install the module to your Nuxt application with one command:

```bash [Terminal]
npx nuxt module add compodium
```
::

:video{.w-full.h-auto.rounded controls controls="true" poster="https://res.cloudinary.com/nuxt/video/upload/so_0/v1740751953/nuxt-ui/nuxt-compodium_y2bvqw.jpg"}

## Migration

We want to be transparent: migrating from Nuxt UI v2 to v3 will require significant effort. While we've maintained core concepts and components, Nuxt UI v3 has been rebuilt from the ground up, resulting in a new library with enhanced capabilities.

Key points to consider:

- Read our [migration guide](https://nuxt.com/getting-started/migration) to upgrade your project from v2 to v3.
- Review the new documentation and components carefully before attempting to upgrade.
- If you encounter any issues, please report them on our [GitHub repository](https://github.com/nuxt/ui/issues){rel="nofollow"}.

## FAQ

::accordion
  :::accordion-item{label="Is Nuxt UI compatible with standalone Vue projects?"}
  Nuxt UI is now compatible with Vue! You can follow the [installation guide](https://nuxt.com/getting-started/installation/vue) to get started.
  :::

  :::accordion-item{label="What about Nuxt UI Pro?"}
  We've also rebuilt Nuxt UI Pro from scratch as v3 to match Nuxt UI version. The license you bought or will buy is valid for both Nuxt UI Pro v1 and v3, this is a **free update**. You can follow the [installation guide](https://nuxt.com/getting-started/installation/pro/nuxt) to get started.
  :::

  :::accordion-item
  ---
  label: Will Nuxt UI work with other CSS frameworks like UnoCSS?
  ---
  Nuxt UI is currently designed to work exclusively with Tailwind CSS. While there's interest in UnoCSS support, implementing it would require significant changes to the theme structure due to differences in class naming conventions. As a result, we don't have plans to add UnoCSS support.
  :::

  :::accordion-item{label="How does Nuxt UI handle accessibility?"}
  Nuxt UI enhances accessibility through Reka UI integration. This provides automatic ARIA attributes, keyboard navigation support, intelligent focus management, and screen reader announcements. While offering a strong foundation, proper implementation and testing in your specific use case remains crucial for full accessibility compliance. For more detailed information, refer to [Reka UI's accessibility documentation](https://reka-ui.com/docs/overview/accessibility){rel="nofollow"}.
  :::

  :::accordion-item{label="What is the testing approach for Nuxt UI?"}
  Nuxt UI ensures reliability with 1000+ Vitest tests, covering core functionality and accessibility. This robust testing suite supports the library's stability and serves as a reference for developers.
  :::
::

---

We're excited about the possibilities Nuxt UI v3 brings to your projects. Explore our documentation to learn more about new features, components, and best practices for building powerful, accessible user interfaces.


# Installation

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/installation/vue
---
Looking for the **Vue** version?
::

## Setup

### Add to a Nuxt project

::steps{level="4"}
#### Install the Nuxt UI package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add @nuxt/ui
  ```
  
  ```bash [yarn]
  yarn add @nuxt/ui
  ```
  
  ```bash [npm]
  npm install @nuxt/ui
  ```
  
  ```bash [bun]
  bun add @nuxt/ui
  ```
  :::

  :::warning
  If you're using **pnpm**, ensure that you either set [`shamefully-hoist=true`](https://pnpm.io/npmrc#shamefully-hoist){rel="nofollow"} in your `.npmrc` file or install `tailwindcss` in your project's root directory.
  :::

#### Add the Nuxt UI module in your `nuxt.config.ts`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui']
})
```

#### Import Tailwind CSS and Nuxt UI in your CSS

  :::code-group
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  ```
  
  ```ts [nuxt.config.ts] {3}
  export default defineNuxtConfig({
    modules: ['@nuxt/ui'],
    css: ['~/assets/css/main.css']
  })
  ```
  :::

  :::callout{icon="i-simple-icons-visualstudiocode"}
  It's recommended to install the [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss){rel="nofollow"} extension for VSCode and add the following settings:
  
  ```json [.vscode/settings.json]
  {
    "files.associations": {
      "*.css": "tailwindcss"
    },
    "editor.quickSuggestions": {
      "strings": "on"
    },
    "tailwindCSS.classAttributes": ["class", "ui"],
    "tailwindCSS.experimental.classRegex": [
      ["ui:\\s*{([^)]*)\\s*}", "(?:'|\"|`)([^']*)(?:'|\"|`)"]
    ]
  }
  ```
  :::

#### Wrap your app with App component

```vue [app.vue]
<template>
  <UApp>
    <NuxtPage />
  </UApp>
</template>
```

  :::note{to="https://nuxt.com/components/app"}
  The `App` component provides global configurations and is required for **Toast**, **Tooltip** components to work as well as **Programmatic Overlays**.
  :::
::

### Use our Nuxt Starter

Start your project using the [nuxt/starter#ui](https://github.com/nuxt/starter/tree/ui){rel="nofollow"} template with Nuxt UI pre-configured.

Create a new project locally by running the following command:

```bash [Terminal]
npm create nuxt@latest -- -t ui
```

::note
The `<my-app>` argument is the name of the directory where the project will be created, replace it with your project name.
::

Once the installation is complete, navigate into your project and start the development server:

```bash [Terminal]
cd <my-app>
npm run dev
```

## Options

You can customize Nuxt UI by providing options in your `nuxt.config.ts`.

### `prefix`

Use the `prefix` option to change the prefix of the components.

- Default: `U`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    prefix: 'Nuxt'
  }
})
```

### `fonts`

Use the `fonts` option to enable or disable the [`@nuxt/fonts`](https://github.com/nuxt/fonts){rel="nofollow"} module.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    fonts: false
  }
})
```

### `colorMode`

Use the `colorMode` option to enable or disable the [`@nuxt/color-mode`](https://github.com/nuxt-modules/color-mode){rel="nofollow"} module.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    colorMode: false
  }
})
```

### `theme.colors`

Use the `theme.colors` option to define the dynamic color aliases used to generate components theme.

- Default: `['primary', 'secondary', 'success', 'info', 'warning', 'error']`{.inline,language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    theme: {
      colors: ['primary', 'error']
    }
  }
})
```

::tip{to="https://nuxt.com/getting-started/theme#colors"}
Learn more about color customization and theming in the Theme section.
::

### `theme.transitions`

Use the `theme.transitions` option to enable or disable transitions on components.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    theme: {
      transitions: false
    }
  }
})
```

::note
This option adds the `transition-colors` class on components with hover or active states.
::

### `theme.defaultVariants` :badge{.align-text-top label="New"}

Use the `theme.defaultVariants` option to override the default `color` and `size` variants for components.

- Default: `{ color: 'primary', size: 'md' }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    theme: {
      defaultVariants: {
        color: 'neutral',
        size: 'sm'
      }
    }
  }
})
```

## Continuous Releases

Nuxt UI uses [pkg.pr.new](https://github.com/stackblitz-labs/pkg.pr.new){rel="nofollow"} for continuous preview releases, providing developers with instant access to the latest features and bug fixes without waiting for official releases.

Automatic preview releases are created for all commits and PRs to the `v3` branch. Use them by replacing your package version with the specific commit hash or PR number.

```diff [package.json]
{
  "dependencies": {
-   "@nuxt/ui": "^3.0.0",
+   "@nuxt/ui": "https://pkg.pr.new/@nuxt/ui@4c96909",
  }
}
```

::note
**pkg.pr.new** will automatically comment on PRs with the installation URL, making it easy to test changes.
::


# Installation

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/installation/nuxt
---
Looking for the **Nuxt** version?
::

## Setup

### Add to a Vue project

::steps{level="4"}
#### Install the Nuxt UI package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add @nuxt/ui
  ```
  
  ```bash [yarn]
  yarn add @nuxt/ui
  ```
  
  ```bash [npm]
  npm install @nuxt/ui
  ```
  
  ```bash [bun]
  bun add @nuxt/ui
  ```
  :::

  :::warning
  If you're using **pnpm**, ensure that you either set [`shamefully-hoist=true`](https://pnpm.io/npmrc#shamefully-hoist){rel="nofollow"} in your `.npmrc` file or install `tailwindcss`, `vue-router` and `@unhead/vue` in your project's root directory.
  :::

#### Add the Nuxt UI Vite plugin in your `vite.config.ts`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts] {3,8}
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui()
  ]
})
```

  :::tip
  Nuxt UI registers `unplugin-auto-import` and `unplugin-vue-components`, which will generate `auto-imports.d.ts` and `components.d.ts` type declaration files. You will likely want to gitignore these, and add them to your `tsconfig`.
  
  ```json [tsconfig.app.json]
  {
    "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "auto-imports.d.ts", "components.d.ts"]
  }
  ```
  
  ```bash [.gitignore]
  # Auto-generated type declarations
  auto-imports.d.ts
  components.d.ts
  ```
  :::

  :::tip
  Internally, Nuxt UI relies on custom alias to resolve the theme types. If you're using TypeScript, you should add an alias to your `tsconfig` to enable auto-completion in your `vite.config.ts`.
  
  ```json [tsconfig.node.json]
  {
    "compilerOptions": {
      "paths": {
        "#build/ui": [
          "./node_modules/@nuxt/ui/.nuxt/ui"
        ]
      }
    }
  }
  ```
  :::

#### Use the Nuxt UI Vue plugin in your `main.ts`

```ts [main.ts] {3,14}
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import ui from '@nuxt/ui/vue-plugin'
import App from './App.vue'

const app = createApp(App)

const router = createRouter({
  routes: [],
  history: createWebHistory()
})

app.use(router)
app.use(ui)

app.mount('#app')
```

  :::note{to="https://nuxt.com/#inertia"}
  If you're using [Inertia.js](https://inertiajs.com/){rel="nofollow"}, you can skip the `vue-router` setup as Inertia provides its own routing system.
  :::

#### Import Tailwind CSS and Nuxt UI in your CSS

```css [assets/main.css]
@import "tailwindcss";
@import "@nuxt/ui";
```

  :::tip
  Import the CSS file in your `main.ts`.
  
  ```ts [main.ts] {1}
  import './assets/main.css'
  
  import { createApp } from 'vue'
  import { createRouter, createWebHistory } from 'vue-router'
  import ui from '@nuxt/ui/vue-plugin'
  import App from './App.vue'
  
  const app = createApp(App)
  
  const router = createRouter({
    routes: [],
    history: createWebHistory()
  })
  
  app.use(router)
  app.use(ui)
  
  app.mount('#app')
  ```
  :::

  :::callout{icon="i-simple-icons-visualstudiocode"}
  It's recommended to install the [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss){rel="nofollow"} extension for VSCode and add the following settings:
  
  ```json [.vscode/settings.json]
  {
    "files.associations": {
      "*.css": "tailwindcss"
    },
    "editor.quickSuggestions": {
      "strings": "on"
    },
    "tailwindCSS.classAttributes": ["class", "ui"],
    "tailwindCSS.experimental.classRegex": [
      ["ui:\\s*{([^)]*)\\s*}", "(?:'|\"|`)([^']*)(?:'|\"|`)"]
    ]
  }
  ```
  :::

#### Wrap your app with App component

```vue [App.vue]
<template>
  <UApp>
    <RouterView />
  </UApp>
</template>
```

  :::note{to="https://nuxt.com/components/app"}
  The `App` component sets up global config and is required for **Toast**, **Tooltip** and **programmatic overlays**.
  :::

#### Add the `isolate` class to your root container

```html [index.html] {9}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nuxt UI</title>
  </head>
  <body>
    <div id="app" class="isolate"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

  :::note
  This ensures styles are scoped to your app and prevents issues with overlays and stacking contexts.
  :::
::

### Use our Vue starter

Start your project using the [nuxtlabs/nuxt-ui-vue-starter](https://github.com/nuxtlabs/nuxt-ui-vue-starter){rel="nofollow"} template with Nuxt UI pre-configured.

Create a new project locally by running the following command:

```bash [Terminal]
npm create nuxt@latest -- -t github:nuxtlabs/nuxt-ui-vue-starter
```

::note
The `<my-app>` argument is the name of the directory where the project will be created, replace it with your project name.
::

Once the installation is complete, navigate into your project and start the development server:

```bash [Terminal]
cd <my-app>
npm run dev
```

## Options

You can customize Nuxt UI by providing options in your `vite.config.ts`.

### `prefix`

Use the `prefix` option to change the prefix of the components.

- Default: `U`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      prefix: 'Nuxt'
    })
  ]
})
```

### `ui`

Use the `ui` option to provide configuration for Nuxt UI.

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      ui: {
        colors: {
          primary: 'green',
          neutral: 'slate'
        }
      }
    })
  ]
})
```

### `colorMode`

Use the `colorMode` option to enable or disable the color mode integration from `@vueuse/core`.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      colorMode: false
    })
  ]
})
```

### `theme.colors`

Use the `theme.colors` option to define the dynamic color aliases used to generate components theme.

- Default: `['primary', 'secondary', 'success', 'info', 'warning', 'error']`{.inline,language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      theme: {
        colors: ['primary', 'error']
      }
    })
  ]
})
```

::tip{to="https://nuxt.com/getting-started/theme#colors"}
Learn more about color customization and theming in the Theme section.
::

### `theme.transitions`

Use the `theme.transitions` option to enable or disable transitions on components.

- Default: `true`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      theme: {
        transitions: false
      }
    })
  ]
})
```

::note
This option adds the `transition-colors` class on components with hover or active states.
::

### `theme.defaultVariants` :badge{.align-text-top label="New"}

Use the `theme.defaultVariants` option to override the default `color` and `size` variants for components.

- Default: `{ color: 'primary', size: 'md' }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      theme: {
        defaultVariants: {
          color: 'neutral',
          size: 'sm'
        }
      }
    })
  ]
})
```

### `inertia`

Use the `inertia` option to enable compatibility with [Inertia.js](https://inertiajs.com/){rel="nofollow"}.

```ts [vite.config.ts]
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ui from '@nuxt/ui/vite'

export default defineConfig({
  plugins: [
    vue(),
    ui({
      inertia: true
    })
  ]
})
```

::note
When using this option, `vue-router` is not required as Inertia.js provides its own routing system. The components that would normally use `RouterLink` will automatically use Inertia's `InertiaLink` component instead.
::

## Continuous Releases

Nuxt UI uses [pkg.pr.new](https://github.com/stackblitz-labs/pkg.pr.new){rel="nofollow"} for continuous preview releases, providing developers with instant access to the latest features and bug fixes without waiting for official releases.

Automatic preview releases are created for all commits and PRs to the `v3` branch. Use them by replacing your package version with the specific commit hash or PR number.

```diff [package.json]
{
  "dependencies": {
-   "@nuxt/ui": "^3.0.0",
+   "@nuxt/ui": "https://pkg.pr.new/@nuxt/ui@4c96909",
  }
}
```

::note
**pkg.pr.new** will automatically comment on PRs with the installation URL, making it easy to test changes.
::


# Migration

Nuxt UI v3.0 is a new major version rebuilt from the ground up, introducing a modern architecture with significant performance improvements and an enhanced developer experience. This major release includes several breaking changes alongside powerful new features and capabilities:

- **Tailwind CSS v4**: Migration from JavaScript to CSS-based configuration
- **Reka UI**: Replacing Headless UI as the underlying component library
- **Tailwind Variants**: New styling API for component variants

This guide provides step by step instructions to migrate your application from v2 to v3.

## Migrate your project

::steps
### Update Tailwind CSS

Tailwind CSS v4 introduces significant changes to its configuration approach. The official Tailwind upgrade tool will help automate most of the migration process.

  :::note
  ---
  target: _blank
  to: https://tailwindcss.com/docs/upgrade-guide#changes-from-v3
  ---
  For a detailed walkthrough of all changes, refer to the official **Tailwind CSS v4 upgrade guide**.
  :::

1. Create a `main.css` file and import it in your `nuxt.config.ts` file:

  :::code-group
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  ```
  
  ```ts [nuxt.config.ts]
  export default defineNuxtConfig({
    css: ['~/assets/css/main.css']
  })
  ```
  :::

2. Run the Tailwind CSS upgrade tool:

```bash
npx @tailwindcss/upgrade
```

### Update Nuxt UI

3. Install the latest version of the package:

  :::module-only
  #ui
    ::::div
      :::::code-group{sync="pm"}
      ```bash [pnpm]
      pnpm add @nuxt/ui
      ```
      
      ```bash [yarn]
      yarn add @nuxt/ui
      ```
      
      ```bash [npm]
      npm install @nuxt/ui
      ```
      
      ```bash [bun]
      bun add @nuxt/ui
      ```
      :::::
    ::::
  
  #ui-pro
    ::::div
      :::::code-group{sync="pm"}
      ```bash [pnpm]
      pnpm add @nuxt/ui-pro
      ```
      
      ```bash [yarn]
      yarn add @nuxt/ui-pro
      ```
      
      ```bash [npm]
      npm install @nuxt/ui-pro
      ```
      
      ```bash [bun]
      bun add @nuxt/ui-pro
      ```
      :::::
    ::::
  :::

4. Import it in your CSS:

  :::module-only
  #ui
    ::::div
    ```css [app/assets/css/main.css] {2}
    @import "tailwindcss";
    @import "@nuxt/ui";
    ```
    ::::
  
  #ui-pro
    ::::div
    ```css [app/assets/css/main.css] {2}
    @import "tailwindcss";
    @import "@nuxt/ui-pro";
    ```
    ::::
  :::

  :::module-only
  #ui
    ::::div
    5. Wrap your app with the [App](https://nuxt.com/components/app) component:
    ::::
  
  #ui-pro
    ::::div
    5. Add the `@nuxt/ui-pro` module in your `nuxt.config.ts` file as it's no longer a layer:
    
    ```diff [nuxt.config.ts]
    export default defineNuxtConfig({
    -  extends: ['@nuxt/ui-pro'],
    -  modules: ['@nuxt/ui']
    +  modules: ['@nuxt/ui-pro']
    })
    ```
    
    6. Wrap your app with the [App](https://nuxt.com/components/app) component:
    ::::
  :::

```vue [app.vue] {2,4}
<template>
  <UApp>
    <NuxtPage />
  </UApp>
</template>
```
::

## Changes from v2

Now that you have updated your project, you can start migrating your code. Here's a comprehensive list of all the breaking changes in Nuxt UI v3.

### Updated design system

In Nuxt UI v2, we had a mix between a design system with `primary`, `gray`, `error` aliases and all the colors from Tailwind CSS. We've replaced it with a proper [design system](https://nuxt.com/getting-started/theme#design-system) with 7 color aliases:

| Color                          | Default  | Description                                                 |
| ------------------------------ | -------- | ----------------------------------------------------------- |
| `primary`{color="primary"}     | `green`  | Main brand color, used as the default color for components. |
| `secondary`{color="secondary"} | `blue`   | Secondary color to complement the primary color.            |
| `success`{color="success"}     | `green`  | Used for success states.                                    |
| `info`{color="info"}           | `blue`   | Used for informational states.                              |
| `warning`{color="warning"}     | `yellow` | Used for warning states.                                    |
| `error`{color="error"}         | `red`    | Used for form error validation states.                      |
| `neutral`                      | `slate`  | Neutral color for backgrounds, text, etc.                   |

This change introduces several breaking changes that you need to be aware of:

- The `gray` color has been renamed to `neutral`

```diff
<template>
- <p class="text-gray-500 dark:text-gray-400" />
+ <p class="text-neutral-500 dark:text-neutral-400" />
</template>
```

::note
You can also use the new [design tokens](https://nuxt.com/getting-started/theme#neutral-palette) to handle light and dark mode:

```diff
<template>
- <p class="text-gray-500 dark:text-gray-400" />
+ <p class="text-muted" />

- <p class="text-gray-900 dark:text-white" />
+ <p class="text-highlighted" />
</template>
```
::

- The `gray`, `black` and `white` in the `color` props have been removed in favor of `neutral`:

```diff
- <UButton color="black" />
+ <UButton color="neutral" />

- <UButton color="gray" />
+ <UButton color="neutral" variant="subtle" />

- <UButton color="white" />
+ <UButton color="neutral" variant="outline" />
```

- You can no longer use Tailwind CSS colors in the `color` props, use the new aliases instead:

```diff
- <UButton color="red" />
+ <UButton color="error" />
```

::note{to="https://nuxt.com/getting-started/theme#colors"}
Learn how to extend the design system to add new color aliases.
::

- The color configuration in `app.config.ts` has been moved into a `colors` object:

```diff
export default defineAppConfig({
  ui: {
-   primary: 'green',
-   gray: 'cool'
+   colors: {
+     primary: 'green',
+     neutral: 'slate'
+   }
  }
})
```

### Updated theming system

Nuxt UI components are now styled using the [Tailwind Variants API](https://nuxt.com/getting-started/theme#components-theme), which makes all the overrides you made using the `app.config.ts` and the `ui` prop obsolete.

- Update your [`app.config.ts`](https://nuxt.com/getting-started/theme#config) to override components with their new theme:

```diff
export default defineAppConfig({
   ui: {
     button: {
-       font: 'font-bold',
-       default: {
-         size: 'md',
-         color: 'primary'
-       }
+       slots: {
+         base: 'font-medium'
+       },
+       defaultVariants: {
+         size: 'md',
+         color: 'primary'
+       }
     }
   }
})
```

- Update your [`ui` props](https://nuxt.com/getting-started/theme#props) to override each component's slots using their new theme:

```diff
<template>
- <UButton :ui="{ font: 'font-bold' }" />
+ <UButton :ui="{ base: 'font-bold' }" />
</template>
```

::tip{to="https://nuxt.com/components/button#theme"}
We can't detail all the changes here but you can check each component's theme in the **Theme** section.
::

### Renamed components

We've renamed some Nuxt UI components to align with the Reka UI naming convention:

| v2                     | v3                                                                                              |
| ---------------------- | ----------------------------------------------------------------------------------------------- |
| `Divider`              | [`Separator`](https://nuxt.com/components/separator)                                            |
| `Dropdown`             | [`DropdownMenu`](https://nuxt.com/components/dropdown-menu)                                     |
| `FormGroup`            | [`FormField`](https://nuxt.com/components/form-field)                                           |
| `Range`                | [`Slider`](https://nuxt.com/components/slider)                                                  |
| `Toggle`               | [`Switch`](https://nuxt.com/components/switch)                                                  |
| `Notification`         | [`Toast`](https://nuxt.com/components/toast)                                                    |
| `VerticalNavigation`   | [`NavigationMenu`](https://nuxt.com/components/navigation-menu) with `orientation="vertical"`   |
| `HorizontalNavigation` | [`NavigationMenu`](https://nuxt.com/components/navigation-menu) with `orientation="horizontal"` |

::module-only
#ui-pro
  :::div
  Here are the Nuxt UI Pro components that have been renamed or removed:
  
  | v1                      | v3                                                                                                                 |
  | ----------------------- | ------------------------------------------------------------------------------------------------------------------ |
  | `BlogList`              | [`BlogPosts`](https://nuxt.com/components/blog-posts)                                                              |
  | `ColorModeToggle`       | [`ColorModeSwitch`](https://nuxt.com/components/color-mode-switch)                                                 |
  | `DashboardCard`         | Removed (use [`PageCard`](https://nuxt.com/components/page-card) instead)                                          |
  | `DashboardLayout`       | [`DashboardGroup`](https://nuxt.com/components/dashboard-group)                                                    |
  | `DashboardModal`        | Removed (use [`Modal`](https://nuxt.com/components/modal) instead)                                                 |
  | `DashboardNavbarToggle` | [`DashboardSidebarToggle`](https://nuxt.com/components/dashboard-sidebar-toggle)                                   |
  | `DashboardPage`         | Removed                                                                                                            |
  | `DashboardPanelContent` | Removed (use `#body` slot instead)                                                                                 |
  | `DashboardPanelHandle`  | [`DashboardResizeHandle`](https://nuxt.com/components/dashboard-resize-handle)                                     |
  | `DashboardSection`      | Removed (use [`PageCard`](https://nuxt.com/components/page-card) instead)                                          |
  | `DashboardSidebarLinks` | Removed (use [`NavigationMenu`](https://nuxt.com/components/navigation-menu) instead)                              |
  | `DashboardSlideover`    | Removed (use [`Slideover`](https://nuxt.com/components/slideover) instead)                                         |
  | `FooterLinks`           | Removed (use [`NavigationMenu`](https://nuxt.com/components/navigation-menu) instead)                              |
  | `HeaderLinks`           | Removed (use [`NavigationMenu`](https://nuxt.com/components/navigation-menu) instead)                              |
  | `LandingCard`           | Removed (use [`PageCard`](https://nuxt.com/components/page-card) instead)                                          |
  | `LandingCTA`            | [`PageCTA`](https://nuxt.com/components/page-cta)                                                                  |
  | `LandingFAQ`            | Removed (use [`PageAccordion`](https://nuxt.com/components/page-accordion) instead)                                |
  | `LandingGrid`           | Removed (use [`PageGrid`](https://nuxt.com/components/page-grid) instead)                                          |
  | `LandingHero`           | Removed (use [`PageHero`](https://nuxt.com/components/page-hero) instead)                                          |
  | `LandingLogos`          | [`PageLogos`](https://nuxt.com/components/page-logos)                                                              |
  | `LandingSection`        | [`PageSection`](https://nuxt.com/components/page-section)                                                          |
  | `LandingTestimonial`    | Removed (use [`PageCard`](https://nuxt.com/components/page-card#as-a-testimonial) instead)                         |
  | `NavigationAccordion`   | [`ContentNavigation`](https://nuxt.com/components/content-navigation)                                              |
  | `NavigationLinks`       | [`ContentNavigation`](https://nuxt.com/components/content-navigation)                                              |
  | `NavigationTree`        | [`ContentNavigation`](https://nuxt.com/components/content-navigation)                                              |
  | `PageError`             | [`Error`](https://nuxt.com/components/error)                                                                       |
  | `PricingCard`           | [`PricingPlan`](https://nuxt.com/components/pricing-plan)                                                          |
  | `PricingGrid`           | [`PricingPlans`](https://nuxt.com/components/pricing-plans)                                                        |
  | `PricingSwitch`         | Removed (use [`Switch`](https://nuxt.com/components/switch) or [`Tabs`](https://nuxt.com/components/tabs) instead) |
  :::
::

### Changed components

In addition to the renamed components, there are lots of changes to the components API. Let's detail the most important ones:

- The `links` and `options` props have been renamed to `items` for consistency:

```diff
<template>
- <USelect :options="countries" />
+ <USelect :items="countries" />

- <UHorizontalNavigation :links="links" />
+ <UNavigationMenu :items="links" />
</template>
```

::note
This change affects the following components: `Breadcrumb`, `HorizontalNavigation`, `InputMenu`, `RadioGroup`, `Select`, `SelectMenu`, `VerticalNavigation`.
::

- The `click` field in different components has been removed in favor of the native Vue `onClick` event:

```diff
<script setup lang="ts">
const items = [{
  label: 'Edit',
-  click: () => {
+  onClick: () => {
    console.log('Edit')
  }
}]
</script>
```

::note
This change affects the `Toast` component as well as all component that have `items` links like `NavigationMenu`, `DropdownMenu`, `CommandPalette`, etc.
::

- The global `Modals`, `Slideovers` and `Notifications` components have been removed in favor the [App](https://nuxt.com/components/app) component:

```diff [app.vue]
<template>
+  <UApp>
+    <NuxtPage />
+  </UApp>
-  <UModals />
-  <USlideovers />
-  <UNotifications />
</template>
```

- The `v-model:open` directive and `default-open` prop are now used to control visibility:

```diff
<template>
- <UModal v-model="open" />
+ <UModal v-model:open="open" />
</template>
```

::note
This change affects the following components: `ContextMenu`, `Modal` and `Slideover` and enables controlling visibility for `InputMenu`, `Select`, `SelectMenu` and `Tooltip`.
::

- The default slot is now used for the trigger and the content goes inside the `#content` slot (you don't need to use a `v-model:open` directive with this method):

```diff
<script setup lang="ts">
- const open = ref(false)
</script>

<template>
- <UButton label="Open" @click="open = true" />

- <UModal v-model="open">
+ <UModal>
+   <UButton label="Open" />

+   <template #content>
      <div class="p-4">
        <Placeholder class="h-48" />
      </div>
+   </template>
  </UModal>
</template>
```

::note
This change affects the following components: `Modal`, `Popover`, `Slideover`, `Tooltip`.
::

- A `#header`, `#body` and `#footer` slots have been added inside the `#content` slot like the `Card` component:

```diff
<template>
- <UModal>
+ <UModal title="Title" description="Description">
-   <div class="p-4">
+   <template #body>
      <Placeholder class="h-48" />
+   </template>
-   </div>
  </UModal>
</template>
```

::note
This change affects the following components: `Modal`, `Slideover`.
::

### Changed composables

- The `useToast()` composable `timeout` prop has been renamed to `duration`:

```diff
<script setup lang="ts">
const toast = useToast()

- toast.add({ title: 'Invitation sent', timeout: 0 })
+ toast.add({ title: 'Invitation sent', duration: 0 })
</script>
```

- The `useModal` and `useSlideover` composables have been removed in favor of a more generic `useOverlay` composable:

Some important differences:

- The `useOverlay` composable is now used to create overlay instances
- Overlays that are opened, can be awaited for their result
- Overlays can no longer be close using `modal.close()` or `slideover.close()`, rather, they close automatically: either when a `close` event is fired explicitly from the opened component OR when the overlay closes itself (clicking on backdrop, pressing the ESC key, etc)
- To capture the return value in the parent component you must explictly emit a `close` event with the desired value

```diff
<script setup lang="ts">
import { ModalExampleComponent } from '#components'

- const modal = useModal()
+ const overlay = useOverlay()

- modal.open(ModalExampleComponent)
+ const modal = overlay.create(ModalExampleComponent)
</script>
```

Props are now passed through a props attribute:

```diff
<script setup lang="ts">
import { ModalExampleComponent } from '#components'

- const modal = useModal()
+ const overlay = useOverlay()

const count = ref(0)

- modal.open(ModalExampleComponent, {
-   count: count.value
- })
+ const modal = overlay.create(ModalExampleComponent, {
+   props: {
+     count: count.value
+   }
+ })
</script>
```

Closing a modal is now done through the `close` event. The `modal.open` method now returns an instance that can be used to await for the result of the modal whenever the modal is closed:

```diff
<script setup lang="ts">
import { ModalExampleComponent } from '#components'

- const modal = useModal()
+ const overlay = useOverlay()

+ const modal = overlay.create(ModalExampleComponent)

- function openModal() {
-   modal.open(ModalExampleComponent, {
-     onSuccess() {
-       toast.add({ title: 'Success!' })
-     }
-   })
- }
+ async function openModal() {
+   const instance = modal.open(ModalExampleComponent, {
+     count: count.value
+   })
+
+   const result = await instance.result
+
+   if (result) {
+     toast.add({ title: 'Success!' })
+   }
+ }
</script>
```

### Changed form validation

- The error object property for targeting form fields has been renamed from `path` to `name`:

```diff
<script setup lang="ts">
const validate = (state: any): FormError[] => {
  const errors = []
  if (!state.email) {
    errors.push({ 
-     path: 'email', 
+     name: 'email',
      message: 'Required' 
    })
  }
  if (!state.password) {
    errors.push({ 
-     path: 'password', 
+     name: 'password',
      message: 'Required' 
    })
  }
  return errors
}
</script>
```

---

::warning
This page is a work in progress, we'll improve it regularly.
::


# Theme

## Tailwind CSS

Nuxt UI uses Tailwind CSS v4, you can read the official [upgrade guide](https://tailwindcss.com/docs/upgrade-guide#changes-from-v3){rel="nofollow"} to learn about all the breaking changes.

### `@theme`

Tailwind CSS v4 takes a CSS-first configuration approach, you now customize your theme with CSS variables inside a [`@theme`](https://tailwindcss.com/docs/functions-and-directives#theme-directive){rel="nofollow"} directive to define your project's custom design tokens, like fonts, colors, and breakpoints:

::module-only
#ui
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @theme static {
    --font-sans: 'Public Sans', sans-serif;
  
    --breakpoint-3xl: 1920px;
  
    --color-green-50: #EFFDF5;
    --color-green-100: #D9FBE8;
    --color-green-200: #B3F5D1;
    --color-green-300: #75EDAE;
    --color-green-400: #00DC82;
    --color-green-500: #00C16A;
    --color-green-600: #00A155;
    --color-green-700: #007F45;
    --color-green-800: #016538;
    --color-green-900: #0A5331;
    --color-green-950: #052E16;
  }
  ```
  :::

#ui-pro
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @theme static {
    --font-sans: 'Public Sans', sans-serif;
  
    --breakpoint-3xl: 1920px;
  
    --color-green-50: #EFFDF5;
    --color-green-100: #D9FBE8;
    --color-green-200: #B3F5D1;
    --color-green-300: #75EDAE;
    --color-green-400: #00DC82;
    --color-green-500: #00C16A;
    --color-green-600: #00A155;
    --color-green-700: #007F45;
    --color-green-800: #016538;
    --color-green-900: #0A5331;
    --color-green-950: #052E16;
  }
  ```
  :::
::

The `@theme` directive tells Tailwind to make new utilities and variants available based on these variables. It's the equivalent of the `theme.extend` key in Tailwind CSS v3 `tailwind.config.ts` file.

::note{target="_blank" to="https://tailwindcss.com/docs/theme"}
Learn more about customizing your theme in the theme variables documentation.
::

### `@source`

You can use the [`@source` directive](https://tailwindcss.com/docs/functions-and-directives#source-directive){rel="nofollow"} to explicitly specify source files that aren't picked up by Tailwind's automatic content detection:

This can be useful when writing Tailwind CSS classes in markdown files with [`@nuxt/content`](https://github.com/nuxt/content){rel="nofollow"} for example:

::module-only
#ui
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @source "../../../content";
  /* Use this if you're not using compatibilityVersion: 4: https://nuxt.com/docs/getting-started/upgrade#opting-in-to-nuxt-4 */
  @source "../../content";
  ```
  :::

#ui-pro
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @source "../../../content";
  /* Use this if you're not using compatibilityVersion: 4: https://nuxt.com/docs/getting-started/upgrade#opting-in-to-nuxt-4 */
  @source "../../content";
  ```
  :::
::

::note{to="https://tailwindcss.com/docs/detecting-classes-in-source-files"}
Learn more about automatic content detection in the detecting classes in source files documentation.
::

## Design system

Nuxt UI extends Tailwind CSS's theming capabilities, providing a flexible design system with pre-configured color aliases based on [Tailwind CSS colors](https://tailwindcss.com/docs/customizing-colors#color-palette-reference){rel="nofollow"}. This allows for easy customization and quick adaptation of the UI to your brand's aesthetic.

| Color                          | Default  | Description                                                 |
| ------------------------------ | -------- | ----------------------------------------------------------- |
| `primary`{color="primary"}     | `green`  | Main brand color, used as the default color for components. |
| `secondary`{color="secondary"} | `blue`   | Secondary color to complement the primary color.            |
| `success`{color="success"}     | `green`  | Used for success states.                                    |
| `info`{color="info"}           | `blue`   | Used for informational states.                              |
| `warning`{color="warning"}     | `yellow` | Used for warning states.                                    |
| `error`{color="error"}         | `red`    | Used for form error validation states.                      |
| `neutral`                      | `slate`  | Neutral color for backgrounds, text, etc.                   |

These colors are used to style the components but also to generate the `color` props:

::component-code
---
props:
  color: primary
slots:
  default: Button
slug: button
---
::

::note
Try the :prose-icon{.text-primary name="i-lucide-swatch-book"} theme picker in the header above to change `primary` and `neutral` colors.
::

### Configuration

::framework-only
#nuxt
  :::div
  You can configure these color aliases at runtime in your [`app.config.ts`](https://nuxt.com/docs/guide/directory-structure/app-config#app-config-file){rel="nofollow"} file under the `ui.colors` key, allowing for dynamic theme customization without requiring an application rebuild:
  
  ```ts [app.config.ts]
  export default defineAppConfig({
    ui: {
      colors: {
        primary: 'blue',
        neutral: 'zinc'
      }
    }
  })
  ```
  :::

#vue
  :::div
  You can configure these color aliases at runtime in your `vite.config.ts` file under the `ui.colors` key:
  
    ::::module-only
    #ui
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import ui from '@nuxt/ui/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          ui({
            ui: {
              colors: {
                primary: 'blue',
                neutral: 'zinc'
              }
            }
          })
        ]
      })
      ```
      :::::
    
    #ui-pro
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import uiPro from '@nuxt/ui-pro/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          uiPro({
            ui: {
              colors: {
                primary: 'blue',
                neutral: 'zinc'
              }
            }
          })
        ]
      })
      ```
      :::::
    ::::
  :::
::

::caution
When configuring your theme colors, you must use either color names from the [default Tailwind palette](https://tailwindcss.com/docs/colors){rel="nofollow"} (like 'blue', 'green', etc.) or reference custom colors that you've previously defined in your [CSS file](https://nuxt.com/#theme).
::

### Extend colors

::framework-only
#nuxt
  :::div
  You can add you own dynamic color aliases in your `app.config.ts`, you just have to make sure to define them in the [`ui.theme.colors`](https://nuxt.com/getting-started/installation/nuxt#themecolors) option in your `nuxt.config.ts` file:
  
  ```ts [app.config.ts] {4}
  export default defineAppConfig({
    ui: {
      colors: {
        tertiary: 'indigo'
      }
    }
  })
  ```
  
  ```ts [nuxt.config.ts] {7}
  export default defineNuxtConfig({
    ui: {
      theme: {
        colors: [
          'primary',
          'secondary',
          'tertiary',
          'info',
          'success',
          'warning',
          'error'
        ]
      }
    }
  })
  ```
  :::

#vue
  :::div
  You can add you own dynamic color aliases in your `vite.config.ts`, you just have to make sure to also define them in the [`theme.colors`](https://nuxt.com/getting-started/installation/vue#themecolors) option of the `ui` plugin:
  
    ::::module-only
    #ui
      :::::div
      ```ts [vite.config.ts] {11,18}
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import ui from '@nuxt/ui/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          ui({
            ui: {
              colors: {
                tertiary: 'indigo'
              }
            },
            theme: {
              colors: [
                'primary',
                'secondary',
                'tertiary',
                'info',
                'success',
                'warning',
                'error'
              ]
            }
          })
        ]
      })
      ```
      :::::
    
    #ui-pro
      :::::div
      ```ts [vite.config.ts] {11,18}
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import uiPro from '@nuxt/ui-pro/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          uiPro({
            ui: {
              colors: {
                tertiary: 'indigo'
              }
            },
            theme: {
              colors: [
                'primary',
                'secondary',
                'tertiary',
                'info',
                'success',
                'warning',
                'error'
              ]
            }
          })
        ]
      })
      ```
      :::::
    ::::
  :::
::

## CSS Variables

Nuxt UI leverages a robust system of CSS variables as design tokens to ensure consistent and flexible component styling. These tokens form the foundation of the theming system, offering smooth support for both light and dark modes.

### Colors

Nuxt UI provides a CSS variable for each color alias you define which represent the default shade used in both light and dark modes:

::code-group
```css [Light]
:root {
  --ui-primary: var(--ui-color-primary-500);
  --ui-secondary: var(--ui-color-secondary-500);
  --ui-success: var(--ui-color-success-500);
  --ui-info: var(--ui-color-info-500);
  --ui-warning: var(--ui-color-warning-500);
  --ui-error: var(--ui-color-error-500);
}
```

```css [Dark]
.dark {
  --ui-primary: var(--ui-color-primary-400);
  --ui-secondary: var(--ui-color-secondary-400);
  --ui-success: var(--ui-color-success-400);
  --ui-info: var(--ui-color-info-400);
  --ui-warning: var(--ui-color-warning-400);
  --ui-error: var(--ui-color-error-400);
}
```
::

These CSS variables are defined in Tailwind CSS's `@theme` so you can use them as classes:

::code-preview
[Primary]{.text-primary.text-sm.px-4}[Secondary]{.text-secondary.text-sm.px-4}[Success]{.text-success.text-sm.px-4}[Info]{.text-info.text-sm.px-4}[Warning]{.text-warning.text-sm.px-4}[Error]{.text-error.text-sm.px-4}

#code
```vue
<template>
  <span class="text-primary">Primary</span>
  <span class="text-secondary">Secondary</span>
  <span class="text-success">Success</span>
  <span class="text-info">Info</span>
  <span class="text-warning">Warning</span>
  <span class="text-error">Error</span>
</template>
```
::

::note
This is how the `@theme` is generated for each color alias:

  :::code-collapse{class="[&>div]:!my-0"}
  ```scss
  @theme default {
    --color-primary: var(--ui-primary);
    --color-primary-50: var(--ui-color-primary-50);
    --color-primary-100: var(--ui-color-primary-100);
    --color-primary-200: var(--ui-color-primary-200);
    --color-primary-300: var(--ui-color-primary-300);
    --color-primary-400: var(--ui-color-primary-400);
    --color-primary-500: var(--ui-color-primary-500);
    --color-primary-600: var(--ui-color-primary-600);
    --color-primary-700: var(--ui-color-primary-700);
    --color-primary-800: var(--ui-color-primary-800);
    --color-primary-900: var(--ui-color-primary-900);
    --color-primary-950: var(--ui-color-primary-950);
    --color-secondary: var(--ui-secondary);
    --color-secondary-50: var(--ui-color-secondary-50);
    --color-secondary-100: var(--ui-color-secondary-100);
    --color-secondary-200: var(--ui-color-secondary-200);
    --color-secondary-300: var(--ui-color-secondary-300);
    --color-secondary-400: var(--ui-color-secondary-400);
    --color-secondary-500: var(--ui-color-secondary-500);
    --color-secondary-600: var(--ui-color-secondary-600);
    --color-secondary-700: var(--ui-color-secondary-700);
    --color-secondary-800: var(--ui-color-secondary-800);
    --color-secondary-900: var(--ui-color-secondary-900);
    --color-secondary-950: var(--ui-color-secondary-950);
    --color-success: var(--ui-success);
    --color-success-50: var(--ui-color-success-50);
    --color-success-100: var(--ui-color-success-100);
    --color-success-200: var(--ui-color-success-200);
    --color-success-300: var(--ui-color-success-300);
    --color-success-400: var(--ui-color-success-400);
    --color-success-500: var(--ui-color-success-500);
    --color-success-600: var(--ui-color-success-600);
    --color-success-700: var(--ui-color-success-700);
    --color-success-800: var(--ui-color-success-800);
    --color-success-900: var(--ui-color-success-900);
    --color-success-950: var(--ui-color-success-950);
    --color-info: var(--ui-info);
    --color-info-50: var(--ui-color-info-50);
    --color-info-100: var(--ui-color-info-100);
    --color-info-200: var(--ui-color-info-200);
    --color-info-300: var(--ui-color-info-300);
    --color-info-400: var(--ui-color-info-400);
    --color-info-500: var(--ui-color-info-500);
    --color-info-600: var(--ui-color-info-600);
    --color-info-700: var(--ui-color-info-700);
    --color-info-800: var(--ui-color-info-800);
    --color-info-900: var(--ui-color-info-900);
    --color-info-950: var(--ui-color-info-950);
    --color-warning: var(--ui-warning);
    --color-warning-50: var(--ui-color-warning-50);
    --color-warning-100: var(--ui-color-warning-100);
    --color-warning-200: var(--ui-color-warning-200);
    --color-warning-300: var(--ui-color-warning-300);
    --color-warning-400: var(--ui-color-warning-400);
    --color-warning-500: var(--ui-color-warning-500);
    --color-warning-600: var(--ui-color-warning-600);
    --color-warning-700: var(--ui-color-warning-700);
    --color-warning-800: var(--ui-color-warning-800);
    --color-warning-900: var(--ui-color-warning-900);
    --color-warning-950: var(--ui-color-warning-950);
    --color-error: var(--ui-error);
    --color-error-50: var(--ui-color-error-50);
    --color-error-100: var(--ui-color-error-100);
    --color-error-200: var(--ui-color-error-200);
    --color-error-300: var(--ui-color-error-300);
    --color-error-400: var(--ui-color-error-400);
    --color-error-500: var(--ui-color-error-500);
    --color-error-600: var(--ui-color-error-600);
    --color-error-700: var(--ui-color-error-700);
    --color-error-800: var(--ui-color-error-800);
    --color-error-900: var(--ui-color-error-900);
    --color-error-950: var(--ui-color-error-950);
    --color-neutral-50: var(--ui-color-neutral-50);
    --color-neutral-100: var(--ui-color-neutral-100);
    --color-neutral-200: var(--ui-color-neutral-200);
    --color-neutral-300: var(--ui-color-neutral-300);
    --color-neutral-400: var(--ui-color-neutral-400);
    --color-neutral-500: var(--ui-color-neutral-500);
    --color-neutral-600: var(--ui-color-neutral-600);
    --color-neutral-700: var(--ui-color-neutral-700);
    --color-neutral-800: var(--ui-color-neutral-800);
    --color-neutral-900: var(--ui-color-neutral-900);
    --color-neutral-950: var(--ui-color-neutral-950);
  }
  ```
  :::
::

You can change which shade is used for each color on light and dark mode in your `main.css` file:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-primary: var(--ui-color-primary-700);
  }
  
  .dark {
    --ui-primary: var(--ui-color-primary-200);
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-primary: var(--ui-color-primary-700);
  }
  
  .dark {
    --ui-primary: var(--ui-color-primary-200);
  }
  ```
  :::
::

::framework-only
#nuxt
You cannot set `primary: 'black'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} in your [`app.config.ts`](https://nuxt.com/#config) because this color has no shade, instead you can override the primary color in your `main.css` file to create a black & white theme:

#vue
You cannot set `primary: 'black'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} in your [`vite.config.ts`](https://nuxt.com/#config) because this color has no shade, instead you can override the primary color in your `main.css` file to create a black & white theme:
::

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-primary: black;
  }
  
  .dark {
    --ui-primary: white;
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-primary: black;
  }
  
  .dark {
    --ui-primary: white;
  }
  ```
  :::
::

### Neutral

Nuxt UI provides a comprehensive set of design tokens for the `neutral` color palette, ensuring consistent and accessible UI styling across both light and dark modes. These tokens offer fine-grained control over text, background, and border colors:

::code-group
```css [Light]
:root {
  --ui-text-dimmed: var(--ui-color-neutral-400);
  --ui-text-muted: var(--ui-color-neutral-500);
  --ui-text-toned: var(--ui-color-neutral-600);
  --ui-text: var(--ui-color-neutral-700);
  --ui-text-highlighted: var(--ui-color-neutral-900);
  --ui-text-inverted: var(--color-white);

  --ui-bg: var(--color-white);
  --ui-bg-muted: var(--ui-color-neutral-50);
  --ui-bg-elevated: var(--ui-color-neutral-100);
  --ui-bg-accented: var(--ui-color-neutral-200);
  --ui-bg-inverted: var(--ui-color-neutral-900);

  --ui-border: var(--ui-color-neutral-200);
  --ui-border-muted: var(--ui-color-neutral-200);
  --ui-border-accented: var(--ui-color-neutral-300);
  --ui-border-inverted: var(--ui-color-neutral-900);
}
```

```css [Dark]
.dark {
  --ui-text-dimmed: var(--ui-color-neutral-500);
  --ui-text-muted: var(--ui-color-neutral-400);
  --ui-text-toned: var(--ui-color-neutral-300);
  --ui-text: var(--ui-color-neutral-200);
  --ui-text-highlighted: var(--color-white);
  --ui-text-inverted: var(--ui-color-neutral-900);

  --ui-bg: var(--ui-color-neutral-900);
  --ui-bg-muted: var(--ui-color-neutral-800);
  --ui-bg-elevated: var(--ui-color-neutral-800);
  --ui-bg-accented: var(--ui-color-neutral-700);
  --ui-bg-inverted: var(--color-white);

  --ui-border: var(--ui-color-neutral-800);
  --ui-border-muted: var(--ui-color-neutral-700);
  --ui-border-accented: var(--ui-color-neutral-700);
  --ui-border-inverted: var(--color-white);
}
```
::

These CSS variables are defined in Tailwind CSS's `@theme` so you can use them as classes:

::code-preview
[Dimmed]{.text-dimmed.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Muted]{.text-muted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Toned]{.text-toned.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Text]{.text-default.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Highlighted]{.text-highlighted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}[Inverted]{.text-inverted.bg-inverted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}

#code
```vue
<template>
  <span class="text-dimmed">Dimmed</span>
  <span class="text-muted">Muted</span>
  <span class="text-toned">Toned</span>
  <span class="text-default">Text</span>
  <span class="text-highlighted">Highlighted</span>
  <span class="text-inverted bg-inverted">Inverted</span>
</template>
```
::

::code-preview
[Default]{.bg-default.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Muted]{.bg-muted.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Elevated]{.bg-elevated.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Accented]{.bg-accented.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Inverted]{.bg-inverted.text-inverted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}

#code
```vue
<template>
  <div class="bg-default">Default</div>
  <div class="bg-muted">Muted</div>
  <div class="bg-elevated">Elevated</div>
  <div class="bg-accented">Accented</div>
  <div class="bg-inverted text-inverted">Inverted</div>
</template>
```
::

::code-preview
[Default]{.border-2.border-default.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Muted]{.border-2.border-muted.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Accented]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[Inverted]{.border-2.border-inverted.text-sm.px-4.inline-block.rounded-md class="py-1.5"}

#code
```vue
<template>
  <div class="border border-default">Default</div>
  <div class="border border-muted">Muted</div>
  <div class="border border-accented">Accented</div>
  <div class="border border-inverted">Inverted</div>
</template>
```
::

::note
This is how the `@theme` is generated for each design token:

  :::code-collapse{class="[&>div]:!my-0"}
  ```scss
  @theme default {
    --text-color-dimmed: var(--ui-text-dimmed);
    --text-color-muted: var(--ui-text-muted);
    --text-color-toned: var(--ui-text-toned);
    --text-color-default: var(--ui-text);
    --text-color-highlighted: var(--ui-text-highlighted);
    --text-color-inverted: var(--ui-text-inverted);
    --background-color-default: var(--ui-bg);
    --background-color-muted: var(--ui-bg-muted);
    --background-color-elevated: var(--ui-bg-elevated);
    --background-color-accented: var(--ui-bg-accented);
    --background-color-inverted: var(--ui-bg-inverted);
    --background-color-border: var(--ui-border);
    --border-color-default: var(--ui-border);
    --border-color-muted: var(--ui-border-muted);
    --border-color-accented: var(--ui-border-accented);
    --border-color-inverted: var(--ui-border-inverted);
    --border-color-bg: var(--ui-bg);
    --ring-color-default: var(--ui-border);
    --ring-color-muted: var(--ui-border-muted);
    --ring-color-accented: var(--ui-border-accented);
    --ring-color-inverted: var(--ui-border-inverted);
    --ring-color-bg: var(--ui-bg);
    --ring-offset-color-default: var(--ui-border);
    --ring-offset-color-muted: var(--ui-border-muted);
    --ring-offset-color-accented: var(--ui-border-accented);
    --ring-offset-color-inverted: var(--ui-border-inverted);
    --ring-offset-color-bg: var(--ui-bg);
    --divide-color-default: var(--ui-border);
    --divide-color-muted: var(--ui-border-muted);
    --divide-color-accented: var(--ui-border-accented);
    --divide-color-inverted: var(--ui-border-inverted);
    --divide-color-bg: var(--ui-bg);
    --outline-color-default: var(--ui-border);
    --outline-color-inverted: var(--ui-border-inverted);
    --stroke-color-default: var(--ui-border);
    --stroke-color-inverted: var(--ui-border-inverted);
    --fill-color-default: var(--ui-border);
    --fill-color-inverted: var(--ui-border-inverted);
  }
  ```
  :::
::

You can customize these CSS variables to tailor the appearance of your application in your `main.css` file:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-bg: var(--ui-color-neutral-50);
    --ui-text: var(--ui-color-neutral-900);
  }
  
  .dark {
    --ui-bg: var(--ui-color-neutral-950);
    --ui-border: var(--ui-color-neutral-900);
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-bg: var(--ui-color-neutral-50);
    --ui-text: var(--ui-color-neutral-900);
  }
  
  .dark {
    --ui-bg: var(--ui-color-neutral-950);
    --ui-border: var(--ui-color-neutral-900);
  }
  ```
  :::
::

::note
Nuxt UI applies a text and background color on the `<body>` element of your app:

```css
body {
  @apply antialiased text-default bg-default scheme-light dark:scheme-dark;
}
```
::

### Radius

Nuxt UI provides a centralized border radius system through the `--ui-radius` CSS variable.

```css
:root {
  --ui-radius: 0.25rem;
}
```

This CSS variable replaces Tailwind CSS's default `rounded-*` utilities so you can use the same class names:

::code-preview
[xs]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-xs.mr-2 class="py-1.5"}[sm]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-sm.mr-2 class="py-1.5"}[md]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-md.mr-2 class="py-1.5"}[lg]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-lg.mr-2 class="py-1.5"}[xl]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-xl.mr-2 class="py-1.5"}[2xl]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-2xl.mr-2 class="py-1.5"}[3xl]{.border-2.border-accented.text-sm.px-4.inline-block.rounded-3xl.mr-2 class="py-1.5"}

#code
```vue
<template>
  <div class="rounded-xs">xs</div>
  <div class="rounded-sm">sm</div>
  <div class="rounded-md">md</div>
  <div class="rounded-lg">lg</div>
  <div class="rounded-xl">xl</div>
  <div class="rounded-2xl">2xl</div>
  <div class="rounded-3xl">3xl</div>
</template>
```
::

::note
This is how the `@theme` is generated for each radius value:

  :::code-collapse{class="[&>div]:!my-0"}
  ```scss
  @theme default {
    --radius-xs: calc(var(--ui-radius) * 0.5);    /* 0.125rem */
    --radius-sm: var(--ui-radius);                /* 0.25rem */
    --radius-md: calc(var(--ui-radius) * 1.5);    /* 0.375rem */
    --radius-lg: calc(var(--ui-radius) * 2);      /* 0.5rem */
    --radius-xl: calc(var(--ui-radius) * 3);      /* 0.75rem */
    --radius-2xl: calc(var(--ui-radius) * 4);     /* 1rem */
    --radius-3xl: calc(var(--ui-radius) * 6);     /* 1.5rem */
  }
  ```
  :::
::

You can customize the base radius value in your `main.css` file:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  :root {
    --ui-radius: 0.5rem;
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  :root {
    --ui-radius: 0.5rem;
  }
  ```
  :::
::

::note
Try the :prose-icon{.text-primary name="i-lucide-swatch-book"} theme picker in the header above to change the base radius value.
::

### Container

Nuxt UI provides a `--ui-container` CSS variable that controls the maximum width of the [Container](https://nuxt.com/components/container) component.

```css
:root {
  --ui-container: var(--container-7xl);
}
```

You can customize this value in your `main.css` file to adjust container widths consistently throughout your application:

::module-only
#ui
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @theme {
    --container-8xl: 90rem;
  }
  
  :root {
    --ui-container: var(--container-8xl);
  }
  ```
  :::

#ui-pro
  :::div{.*:!mb-0 class="*:!mt-2.5"}
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @theme {
    --container-8xl: 90rem;
  }
  
  :root {
    --ui-container: var(--container-8xl);
  }
  ```
  :::
::

## Components theme

Nuxt UI components are styled using the [Tailwind Variants](https://www.tailwind-variants.org/){rel="nofollow"} API, which provides a powerful way to create variants and manage component styles. Let's explore the key features of this API:

### Slots

Components in Nuxt UI can have multiple `slots`, each representing a distinct HTML element or section within the component. These slots allow for flexible content insertion and styling. Let's take the [Card](https://nuxt.com/components/card) component as an example:

::code-group
```ts [src/theme/card.ts]
export default {
  slots: {
    root: 'bg-default ring ring-default divide-y divide-default rounded-lg',
    header: 'p-4 sm:px-6',
    body: 'p-4 sm:p-6',
    footer: 'p-4 sm:px-6'
  }
}
```

```vue [src/runtime/components/Card.vue]
<template>
  <div :class="ui.root({ class: [props.ui?.root, props.class] })">
    <div :class="ui.header({ class: props.ui?.header })">
      <slot name="header" />
    </div>

    <div :class="ui.body({ class: props.ui?.body })">
      <slot />
    </div>

    <div :class="ui.footer({ class: props.ui?.footer })">
      <slot name="footer" />
    </div>
  </div>
</template>
```
::

Some components don't have slots, they are just composed of a single root element. In this case, the theme only defines the `base` slot like the [Container](https://nuxt.com/components/container) component for example:

::code-group
```ts [src/theme/container.ts]
export default {
  base: 'max-w-(--ui-container) mx-auto px-4 sm:px-6 lg:px-8'
}
```

```vue [src/runtime/components/Container.vue]
<template>
  <div :class="container({ class: props.class })">
    <slot />
  </div>
</template>
```
::

::warning
Components without slots don't have a [`ui` prop](https://nuxt.com/#ui-prop), only the [`class` prop](https://nuxt.com/#class-prop) is available to override styles.
::

### Variants

Nuxt UI components use `variants` to change the `slots` styles based on props. Here's an example of the [Avatar](https://nuxt.com/components/avatar) component:

```ts [src/theme/avatar.ts]
export default {
  slots: {
    root: 'inline-flex items-center justify-center shrink-0 select-none overflow-hidden rounded-full align-middle bg-elevated',
    image: 'h-full w-full rounded-[inherit] object-cover'
  },
  variants: {
    size: {
      sm: {
        root: 'size-7 text-sm'
      },
      md: {
        root: 'size-8 text-base'
      },
      lg: {
        root: 'size-9 text-lg'
      }
    }
  },
  defaultVariants: {
    size: 'md'
  }
}
```

This way, the `size` prop will apply the corresponding styles to the `root` slot:

::component-code
---
ignore:
  - src
props:
  src: https://github.com/nuxt.png
  size: lg
slug: avatar
---
::

The `defaultVariants` property specifies the default values for each variant. It determines how a component looks and behaves when no prop is provided.

::framework-only
#nuxt
  :::tip
  These default values can be customized in your [`app.config.ts`](https://nuxt.com/#config) to adjust the standard appearance of components throughout your application.
  :::

#vue
  :::tip
  These default values can be customized in your [`vite.config.ts`](https://nuxt.com/#config) to adjust the standard appearance of components throughout your application.
  :::
::

## Customize theme

You have multiple ways to customize the appearance of Nuxt UI components, you can do it for all components at once or on a per-component basis.

::note
Tailwind Variants uses [`tailwind-merge`](https://github.com/dcastil/tailwind-merge){rel="nofollow"} under the hood to merge classes so you don't have to worry about conflicting classes.
::

::tip
You can explore the theme for each component in two ways:

- Check the `Theme` section in the documentation of each individual component.
- Browse the source code directly in the GitHub repository at [`v3/src/theme`](https://github.com/nuxt/ui/tree/v3/src/theme){rel="nofollow"}.
::

### Config

::framework-only
#nuxt
  :::div
  You can override the theme of components globally inside your `app.config.ts` by using the exact same structure as the theme object.
  
  Let's say you want to change the font weight of all your buttons, you can do it like this:
  
  ```ts [app.config.ts]
  export default defineAppConfig({
    ui: {
      button: {
        slots: {
          base: 'font-bold'
        }
      }
    }
  })
  ```
  :::

#vue
  :::div
  You can override the theme of components globally inside your `vite.config.ts` by using the exact same structure as the theme object.
  
  Let's say you want to change the font weight of all your buttons, you can do it like this:
  
    ::::module-only
    #ui
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import ui from '@nuxt/ui/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          ui({
            ui: {
              button: {
                slots: {
                  base: 'font-bold'
                }
              }
            }
          })
        ]
      })
      ```
      :::::
    
    #ui-pro
      :::::div
      ```ts [vite.config.ts]
      import { defineConfig } from 'vite'
      import vue from '@vitejs/plugin-vue'
      import uiPro from '@nuxt/ui-pro/vite'
      
      export default defineConfig({
        plugins: [
          vue(),
          uiPro({
            ui: {
              button: {
                slots: {
                  base: 'font-bold'
                }
              }
            }
          })
        ]
      })
      ```
      :::::
    ::::
  :::
::

::note
In this example, the `font-bold` class will override the default `font-medium` class on all buttons.
::

### Props

#### `ui` prop

You can also override a component's **slots** using the `ui` prop. This has priority over the global configuration and `variants` resolution.

::component-code
---
ignore:
  - ui.trailingIcon
  - color
  - variant
  - size
  - icon
prettier: true
props:
  trailingIcon: i-lucide-chevron-right
  size: md
  color: neutral
  variant: outline
  ui:
    trailingIcon: rotate-90 size-3
slots:
  default: |
    
    Button
slug: button
---
::

::note
In this example, the `trailingIcon` slot is overwritten with `size-3` even though the `md` size variant would apply a `size-5` class to it.
::

#### `class` prop

The `class` prop allows you to override the classes of the `root` or `base` slot. This has priority over the global configuration and `variants` resolution.

::component-code
---
props:
  class: font-bold rounded-full
slots:
  default: Button
slug: button
---
::

::note
In this example, the `font-bold` class will override the default `font-medium` class on this button.
::


# Icons

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/icons/vue
---
Looking for the **Vue** version?
::

## Usage

Nuxt UI automatically registers the [`@nuxt/icon`](https://github.com/nuxt/icon){rel="nofollow"} module for you, so there's no additional setup required.

### Icon Component

You can use the [Icon](https://nuxt.com/components/icon) component with a `name` prop to display an icon:

::component-code
---
props:
  name: i-lucide-lightbulb
  class: size-5
slug: icon
---
::

::note
You can use any name from the <https://icones.js.org>{rel="nofollow"} collection.
::

### Component Props

Some components also have an `icon` prop to display an icon, like the [Button](https://nuxt.com/components/button) for example:

::component-code
---
ignore:
  - color
  - variant
props:
  icon: i-lucide-sun
  variant: subtle
slots:
  default: Button
slug: button
---
::

## Collections

### Iconify Dataset

It's highly recommended to install the icon data locally with:

::code-group{sync="pm"}
```bash [pnpm]
pnpm i @iconify-json/{collection_name}
```

```bash [yarn]
yarn add @iconify-json/{collection_name}
```

```bash [npm]
npm install @iconify-json/{collection_name}
```
::

For example, to use the `i-uil-github` icon, install it's collection with `@iconify-json/uil`. This way the icons can be served locally or from your serverless functions, which is faster and more reliable on both SSR and client-side.

::note
---
target: _blank
to: https://github.com/nuxt/icon?tab=readme-ov-file#iconify-dataset
---
Read more about this in the `@nuxt/icon` documentation.
::

### Custom Local Collections

You can use local SVG files to create a custom Iconify collection.

For example, place your icons' SVG files under a folder of your choice, for example, `./app/assets/icons`:

```bash
assets/icons
├── add.svg
└── remove.svg
```

In your `nuxt.config.ts`, add an item in `icon.customCollections`:

```ts
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  icon: {
    customCollections: [{
      prefix: 'custom',
      dir: './app/assets/icons'
    }]
  }
})
```

Then you can use the icons like this:

```vue
<template>
  <UIcon name="i-custom-add" />
</template>
```

::note
---
target: _blank
to: https://github.com/nuxt/icon?tab=readme-ov-file#custom-local-collections
---
Read more about this in the `@nuxt/icon` documentation.
::

## Theme

You can change the default icons used by components in your `app.config.ts`:

::icons-theme
::


# Icons

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/icons/nuxt
---
Looking for the **Nuxt** version?
::

## Usage

### Icon Component

You can use the [Icon](https://nuxt.com/components/icon) component with a `name` prop to display an icon:

::component-code
---
props:
  name: i-lucide-lightbulb
  class: size-5
slug: icon
---
::

::note
You can use any name from the <https://icones.js.org>{rel="nofollow"} collection.
::

::warning
When using collections with a dash (`-`), you need to separate the icon name from the collection name with a colon (`:`) as `@iconify/vue` does not handle this case like `@nuxt/icon`. For example, instead of `i-simple-icons-github` you need to write `i-simple-icons:github` or `simple-icons:github`.

Learn more about the [Iconify naming convention](https://iconify.design/docs/icon-components/vue/#icon){rel="nofollow"}.
::

### Component Props

Some components also have an `icon` prop to display an icon, like the [Button](https://nuxt.com/components/button) for example:

::component-code
---
ignore:
  - color
  - variant
props:
  icon: i-lucide-sun
  variant: subtle
slots:
  default: Button
slug: button
---
::

## Theme

You can change the default icons used by Nuxt UI components in your `vite.config.ts`:

::icons-theme
::


# Fonts

## Usage

Nuxt UI automatically registers the [`@nuxt/fonts`](https://github.com/nuxt/fonts){rel="nofollow"} module for you, so there's no additional setup required. To use a font in your Nuxt UI application, you can simply declare it in your CSS. It will be automatically loaded and optimized for you.

::module-only
#ui
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui";
  
  @theme {
    --font-sans: 'Public Sans', sans-serif;
  }
  ```
  :::

#ui-pro
  :::div
  ```css [app/assets/css/main.css]
  @import "tailwindcss";
  @import "@nuxt/ui-pro";
  
  @theme {
    --font-sans: 'Public Sans', sans-serif;
  }
  ```
  :::
::

You can disable the `@nuxt/fonts` module with the `ui.fonts` option in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ui: {
    fonts: false
  }
})
```


# Color Mode

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/color-mode/vue
---
Looking for the **Vue** version?
::

## Usage

Nuxt UI automatically registers the [`@nuxtjs/color-mode`](https://github.com/nuxt-modules/color-mode){rel="nofollow"} module for you, so there's no additional setup required. You can simply use the `useColorMode` composable to switch between light and dark modes:

```vue [ColorModeButton.vue]
<script setup>
const colorMode = useColorMode()

const isDark = computed({
  get() {
    return colorMode.value === 'dark'
  },
  set(_isDark) {
    colorMode.preference = _isDark ? 'dark' : 'light'
  }
})
</script>

<template>
  <ClientOnly v-if="!colorMode?.forced">
    <UButton
      :icon="isDark ? 'i-lucide-moon' : 'i-lucide-sun'"
      color="neutral"
      variant="ghost"
      @click="isDark = !isDark"
    />

    <template #fallback>
      <div class="size-8" />
    </template>
  </ClientOnly>
</template>
```

You can disable the `@nuxtjs/color-mode` module with the `ui.colorMode` option in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['@nuxt/ui'],
  css: ['~/assets/css/main.css'],
  ui: {
    colorMode: false
  }
})
```


# Color Mode

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/color-mode/nuxt
---
Looking for the **Nuxt** version?
::

## Usage

Nuxt UI automatically registers the [useDark](https://vueuse.org/core/useDark){rel="nofollow"} composable as a Vue plugin, so there's no additional setup required. You can simply use it to switch between light and dark modes:

```vue [ColorModeButton.vue]
<script setup>
import { useColorMode } from '@vueuse/core'

const mode = useColorMode()
</script>

<template>
  <UButton
    :icon="mode === 'dark' ? 'i-lucide-moon' : 'i-lucide-sun'"
    color="neutral"
    variant="ghost"
    @click="mode = mode === 'dark' ? 'light' : 'dark'"
  />
</template>
```

You can disable this plugin with the `colorMode` option in your `vite.config.ts`:

::module-only
#ui
  :::div
  ```ts [vite.config.ts]
  import { defineConfig } from 'vite'
  import vue from '@vitejs/plugin-vue'
  import ui from '@nuxt/ui/vite'
  
  export default defineConfig({
    plugins: [
      vue(),
      ui({
        colorMode: false
      })
    ]
  })
  ```
  :::

#ui-pro
  :::div
  ```ts [vite.config.ts]
  import { defineConfig } from 'vite'
  import vue from '@vitejs/plugin-vue'
  import uiPro from '@nuxt/ui-pro/vite'
  
  export default defineConfig({
    plugins: [
      vue(),
      uiPro({
        colorMode: false
      })
    ]
  })
  ```
  :::
::


# Internationalization (i18n)

::callout
---
class: hidden
icon: i-logos-vue
to: https://nuxt.com/getting-started/i18n/vue
---
Looking for the **Vue** version?
::

## Usage

::note{to="https://nuxt.com/components/app"}
Nuxt UI provides an **App** component that wraps your app to provide global configurations.
::

### Locale

::module-only
#ui
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui/locale`:
  
  ```vue [app.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui-pro/locale`:
  
  ```vue [app.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui-pro/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

### Custom locale

You can create your own locale using the `defineLocale` composable:

::module-only
#ui
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui-pro'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

::tip
Look at the `code` parameter, there you need to pass the iso code of the language. Example:

- `hi` Hindi (language)
- `de-AT`: German (language) as used in Austria (region)
::

### Extend locale

You can customize an existing locale by overriding its `messages` or `code` using the `extendLocale` composable:

::module-only
#ui
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui/locale'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui-pro/locale'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

### Dynamic locale

To dynamically switch between languages, you can use the [Nuxt I18n](https://i18n.nuxtjs.org/){rel="nofollow"} module.

::steps{level="4"}
#### Install the Nuxt I18n package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add @nuxtjs/i18n
  ```
  
  ```bash [yarn]
  yarn add @nuxtjs/i18n
  ```
  
  ```bash [npm]
  npm install @nuxtjs/i18n
  ```
  
  ```bash [bun]
  bun add @nuxtjs/i18n
  ```
  :::

#### Add the Nuxt I18n module in your `nuxt.config.ts`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    '@nuxt/ui',
    '@nuxtjs/i18n'
  ],
  css: ['~/assets/css/main.css'],
  i18n: {
    locales: [{
      code: 'de',
      name: 'Deutsch'
    }, {
      code: 'en',
      name: 'English'
    }, {
      code: 'fr',
      name: 'Français'
    }]
  }
})
```

#### Set the `locale` prop using `useI18n`

  :::module-only
  #ui
    ::::div
    ```vue [app.vue]
    <script setup lang="ts">
    import * as locales from '@nuxt/ui/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <NuxtPage />
      </UApp>
    </template>
    ```
    ::::
  
  #ui-pro
    ::::div
    ```vue [app.vue]
    <script setup lang="ts">
    import * as locales from '@nuxt/ui-pro/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <NuxtPage />
      </UApp>
    </template>
    ```
    ::::
  :::
::

### Dynamic direction

Each locale has a `dir` property which will be used by the `App` component to set the directionality of all components.

In a multilingual application, you might want to set the `lang` and `dir` attributes on the `<html>` element dynamically based on the user's locale, which you can do with the [useHead](https://nuxt.com/docs/api/composables/use-head){rel="nofollow"} composable:

::module-only
#ui
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import * as locales from '@nuxt/ui/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [app.vue]
  <script setup lang="ts">
  import * as locales from '@nuxt/ui-pro/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <NuxtPage />
    </UApp>
  </template>
  ```
  :::
::

## Supported languages

::supported-languages
::


# Internationalization (i18n)

::callout
---
class: hidden
icon: i-logos-nuxt-icon
to: https://nuxt.com/getting-started/i18n/nuxt
---
Looking for the **Nuxt** version?
::

## Usage

::note{to="https://nuxt.com/components/app"}
Nuxt UI provides an **App** component that wraps your app to provide global configurations.
::

### Locale

::module-only
#ui
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui/locale`:
  
  ```vue [App.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  Use the `locale` prop with the locale you want to use from `@nuxt/ui-pro/locale`:
  
  ```vue [App.vue]
  <script setup lang="ts">
  import { fr } from '@nuxt/ui-pro/locale'
  </script>
  
  <template>
    <UApp :locale="fr">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

### Custom locale

You can create your own locale using the `defineLocale` composable:

::module-only
#ui
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui'
  import { defineLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import type { Messages } from '@nuxt/ui-pro'
  import { defineLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = defineLocale<Messages>({
    name: 'My custom locale',
    code: 'en',
    dir: 'ltr',
    messages: {
      // implement pairs
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

::tip
Look at the `code` parameter, there you need to pass the iso code of the language. Example:

- `hi` Hindi (language)
- `de-AT`: German (language) as used in Austria (region)
::

### Extend locale

You can customize an existing locale by overriding its `messages` or `code` using the `extendLocale` composable:

::module-only
#ui
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui/locale'
  import { extendLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { en } from '@nuxt/ui-pro/locale'
  import { extendLocale } from '@nuxt/ui/composables/defineLocale.js'
  
  const locale = extendLocale(en, {
    code: 'en-GB',
    messages: {
      commandPalette: {
        placeholder: 'Search a component...'
      }
    }
  })
  </script>
  
  <template>
    <UApp :locale="locale">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

### Dynamic locale

To dynamically switch between languages, you can use the [Vue I18n](https://vue-i18n.intlify.dev/){rel="nofollow"} plugin.

::steps{level="4"}
#### Install the Vue I18n package

  :::code-group{sync="pm"}
  ```bash [pnpm]
  pnpm add vue-i18n@11
  ```
  
  ```bash [yarn]
  yarn add vue-i18n@11
  ```
  
  ```bash [npm]
  npm install vue-i18n@11
  ```
  
  ```bash [bun]
  bun add vue-i18n@11
  ```
  :::

#### Use the Vue I18n plugin in your `main.ts`

```ts [main.ts] {3,14-26,29}
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import { createI18n } from 'vue-i18n'
import ui from '@nuxt/ui/vue-plugin'
import App from './App.vue'

const app = createApp(App)

const router = createRouter({
  routes: [],
  history: createWebHistory()
})

const i18n = createI18n({
  legacy: false,
  locale: 'en',
  availableLocales: ['en', 'de'],
  messages: {
    en: {
      // ...
    },
    de: {
      // ...
    }
  }
})

app.use(router)
app.use(i18n)
app.use(ui)

app.mount('#app')
```

#### Set the `locale` prop using `useI18n`

  :::module-only
  #ui
    ::::div
    ```vue [App.vue]
    <script setup lang="ts">
    import { useI18n } from 'vue-i18n'
    import * as locales from '@nuxt/ui/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <RouterView />
      </UApp>
    </template>
    ```
    ::::
  
  #ui-pro
    ::::div
    ```vue [App.vue]
    <script setup lang="ts">
    import { useI18n } from 'vue-i18n'
    import * as locales from '@nuxt/ui-pro/locale'
    
    const { locale } = useI18n()
    </script>
    
    <template>
      <UApp :locale="locales[locale]">
        <RouterView />
      </UApp>
    </template>
    ```
    ::::
  :::
::

### Dynamic direction

Each locale has a `dir` property which will be used by the `App` component to set the directionality of all components.

In a multilingual application, you might want to set the `lang` and `dir` attributes on the `<html>` element dynamically based on the user's locale, which you can do with the [useHead](https://unhead.unjs.io/usage/composables/use-head){rel="nofollow"} composable:

::module-only
#ui
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { computed } from 'vue'
  import { useI18n } from 'vue-i18n'
  import { useHead } from '@unhead/vue'
  import * as locales from '@nuxt/ui/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <RouterView />
    </UApp>
  </template>
  ```
  :::

#ui-pro
  :::div
  ```vue [App.vue]
  <script setup lang="ts">
  import { computed } from 'vue'
  import { useI18n } from 'vue-i18n'
  import { useHead } from '@unhead/vue'
  import * as locales from '@nuxt/ui-pro/locale'
  
  const { locale } = useI18n()
  
  const lang = computed(() => locales[locale.value].code)
  const dir = computed(() => locales[locale.value].dir)
  
  useHead({
    htmlAttrs: {
      lang,
      dir
    }
  })
  </script>
  
  <template>
    <UApp :locale="locales[locale]">
      <RouterView />
    </UApp>
  </template>
  ```
  :::
::

## Supported languages

::supported-languages
::


# Contribution Guide

Nuxt UI thrives thanks to its incredible community ❤️. We welcome all contributions through bug reports, pull requests, and feedback to help make this library even better.

::caution
Before reporting a bug or requesting a feature, make sure that you have read through our [documentation](https://ui.nuxt.com/){rel="nofollow"} and existing [issues](https://github.com/nuxt/ui/issues?q=is%3Aissue%20is%3Aopen%20sort%3Aupdated-desc%20label%3Av3){rel="nofollow"}.
::

## Project Structure

Here's an overview of the key directories and files in the Nuxt UI project structure:

### Documentation

The documentation lives in the `docs` folder as a Nuxt app using `@nuxt/content` v3 to generate pages from Markdown files. See the [Nuxt Content documentation](https://content.nuxt.com/docs/getting-started){rel="nofollow"} for details on how it works. Here's a breakdown of its structure:

```bash
├── app/
│   ├── assets/
│   ├── components/
│   │   └── content/
│   │       └── examples   # Components used in documentation as examples
│   ├── composables/
│   └── ...
├── content/
│   ├── 1.getting-started
│   ├── 2.composables
│   └── 3.components       # Components documentation
```

### Module

The module code resides in the `src` folder. Here's a breakdown of its structure:

```bash
├── plugins/
├── runtime/
│   ├── components/        # Where all the components are located
│   │   ├── Accordion.vue
│   │   ├── Alert.vue
│   │   └── ...
│   ├── composables/
│   ├── locale/
│   ├── plugins/
│   ├── types/
│   ├── utils/
│   └── vue/
│       ├── components/
│       └── plugins/
├── theme/                 # This where the theme for each component is located
│   ├── accordion.ts       # Theme for Accordion component
│   ├── alert.ts
│   └── ...
└── module.ts
```

## CLI

To make development easier, we've created a CLI that you can use to generate components and locales. You can access it using the `nuxt-ui make` command.

First, you need to link the CLI to your global environment:

```sh
npm link
```

### Components

You can create new components using the following command:

```sh
nuxt-ui make component <name> [options]
```

Available options:

- `--primitive` Create a primitive component
- `--pro` Create a pro component
- `--prose` Create a prose component (requires `--pro`)
- `--content` Create a content component (requires `--pro`)
- `--template` Only generate specific template (available templates: `playground`, `docs`, `test`, `theme`, `component`)

Example:

```sh
# Create a basic component
nuxt-ui make component my-component

# Create a pro component
nuxt-ui make component page-section --pro

# Create a pro prose component
nuxt-ui make component heading --pro --prose

# Create a pro content component
nuxt-ui make component block --pro --content

# Generate only documentation template
nuxt-ui make component my-component --template=docs
```

::note
When creating a new component, the CLI will automatically generate all the necessary files like the component itself, theme, tests, and documentation.
::

### Locales

You can create new locales using the following command:

```sh
nuxt-ui make locale --code <code> --name <name>
```

::note{to="https://nuxt.com/getting-started/i18n/nuxt#supported-languages"}
Learn more about **i18n** in the documentation.
::

## Submit a Pull Request (PR)

Before you start, check if there's an existing issue describing the problem or feature request you're working on. If there is, please leave a comment on the issue to let us know you're working on it.

If there isn't, open a new issue to discuss the problem or feature.

### Local Development

To begin local development, follow these steps:

::steps{level="4"}
#### Clone the `nuxt/ui` repository to your local machine

```sh
git clone -b v3 https://github.com/nuxt/ui.git
```

#### Enable [Corepack](https://github.com/nodejs/corepack){rel="nofollow"}

```sh
corepack enable
```

#### Install dependencies

```sh
pnpm install
```

#### Generate type stubs

```sh
pnpm run dev:prepare
```

#### Start development

- To work on the **documentation** located in the `docs` folder, run:

```sh
pnpm run docs
```

- To test the Nuxt components using the **playground**, run:

```sh
pnpm run dev
```

- To test the Vue components using the **playground**, run:

```sh
pnpm run dev:vue
```
::

::note{to="https://nuxt.com/#cli"}
If you're working on implementing a new component, check the **CLI** section to kickstart the process.
::

### IDE Setup

We recommend using VSCode alongside the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint){rel="nofollow"}. You can enable auto-fix and formatting when saving your code. Here's how:

```json
{
  "editor.codeActionsOnSave": {
    "source.fixAll": false,
    "source.fixAll.eslint": true
  }
}
```

::warning
Since ESLint is already configured to format the code, there's no need for duplicating functionality with **Prettier**. If you have it installed in your editor, we recommend disabling it to avoid conflicts.
::

### Linting

You can use the `lint` command to check for linting errors:

```sh
pnpm run lint # check for linting errors
pnpm run lint:fix # fix linting errors
```

### Type Checking

We use TypeScript for type checking. You can use the `typecheck` command to check for type errors:

```sh
pnpm run typecheck
```

### Testing

Before submitting a PR, ensure that you run the tests for both `nuxt` and `vue`:

```sh
pnpm run test # for Nuxt
pnpm run test:vue # for Vue
```

::tip
If you have to update the snapshots, press `u` after the tests have finished running.
::

### Commit Conventions

We use [Conventional Commits](https://www.conventionalcommits.org/){rel="nofollow"} for commit messages, which allows a changelog to be auto-generated based on the commits. Please read the [guide](https://www.conventionalcommits.org/en/v1.0.0/#summary){rel="nofollow"} through if you aren't familiar with it already.

- Use `fix` and `feat` for code changes that affect functionality or logic
- Use `docs` for documentation changes and `chore` for maintenance tasks

### Making a Pull Request

- Follow along the [instructions](https://github.com/nuxt/ui/blob/v3/.github/PULL_REQUEST_TEMPLATE.md?plain=1){rel="nofollow"} provided when creating a PR
- Ensure your PR's title adheres to the [Conventional Commits](https://www.conventionalcommits.org/){rel="nofollow"} since it will be used once the code is merged.
- Multiple commits are fine; no need to rebase or force push. We'll use `Squash and Merge` when merging.
- Ensure `lint`, `typecheck` and `tests` work before submitting the PR. Avoid making unrelated changes.

We'll review it promptly. If assigned to a maintainer, they'll review it carefully. Ignore the red text; it's for tracking purposes.

## Thanks

Thank you again for being interested in this project! You are awesome! ❤️


# defineShortcuts

## Usage

Sử dụng composable `defineShortcuts` được tự động nhập để định nghĩa các phím tắt bàn phím.

```vue
<script setup lang="ts">
const open = ref(false)

defineShortcuts({
  meta_k: () => {
    open.value = !open.value
  }
})
</script>
```

- Các phím tắt được tự động điều chỉnh cho các nền tảng không phải macOS, chuyển đổi `meta` thành `ctrl`.
- Composable sử dụng [`useEventListener`](https://vueuse.org/core/useEventListener/){rel="nofollow"} của VueUse để xử lý các sự kiện keydown.
- Để có danh sách đầy đủ các phím tắt có sẵn, hãy tham khảo tài liệu API [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values){rel="nofollow"}. Lưu ý rằng phím nên được viết bằng chữ thường.

::tip{to="https://nuxt.com/components/kbd"}
Tìm hiểu cách hiển thị các phím tắt trong các thành phần trong tài liệu thành phần **Kbd**.
::

## API

### `defineShortcuts(config: ShortcutsConfig, options?: ShortcutsOptions)`

Định nghĩa các phím tắt bàn phím cho ứng dụng của bạn.

- `config`: Một đối tượng nơi các khóa là định nghĩa phím tắt và các giá trị là các hàm xử lý hoặc đối tượng cấu hình phím tắt.
- `options`: Cấu hình tùy chọn cho hành vi của các phím tắt.

  - `chainDelay`: Độ trễ giữa các lần nhấn phím để xem xét phím tắt là được liên kết. Mặc định là `250`.

#### Shortcut Definition

Các phím tắt được định nghĩa bằng định dạng sau:

- Phím đơn: `'a'`, `'b'`, `'1'`, `'?'`, v.v.
- Sự kết hợp phím: Sử dụng `_` để tách các phím, ví dụ, `'meta_k'`, `'ctrl_shift_f'`
- Chuỗi phím: Sử dụng `-` để định nghĩa một chuỗi, ví dụ, `'g-d'`

#### Modifiers

- `meta`: Đại diện cho `⌘ Command` trên macOS và `Ctrl` trên các nền tảng khác
- `ctrl`: Đại diện cho `Ctrl` trên tất cả các nền tảng
- `shift`: Được sử dụng cho các phím chữ cái khi cần Shift

#### Special Keys

- `escape`: Kích hoạt trên phím Esc
- `enter`: Kích hoạt trên phím Enter
- `arrowleft`, `arrowright`, `arrowup`, `arrowdown`: Kích hoạt trên các phím mũi tên tương ứng

#### Shortcut Configuration

Mỗi phím tắt có thể được định nghĩa là một hàm hoặc một đối tượng với các thuộc tính sau:

```ts
interface ShortcutConfig {
  handler: () => void
  usingInput?: boolean | string
}
```

- `handler`: Hàm được thực thi khi phím tắt được kích hoạt
- `usingInput`:

  - `false` (mặc định): Phím tắt chỉ kích hoạt khi không có đầu vào nào được tập trung
  - `true`: Phím tắt kích hoạt ngay cả khi bất kỳ đầu vào nào được tập trung
  - `string`: Phím tắt chỉ kích hoạt khi đầu vào được chỉ định (theo tên) được tập trung

## Examples

### Basic usage

```vue
<script setup lang="ts">
defineShortcuts({
  '?': () => openHelpModal(),
  'meta_k': () => openCommandPalette(),
  'g-d': () => navigateToDashboard()
})
</script>
```

### With input focus handling

Tùy chọn `usingInput` cho phép bạn chỉ định rằng một phím tắt chỉ nên kích hoạt khi một đầu vào cụ thể được tập trung.

```vue
<template>
  <UInput v-model="query" name="queryInput" />
</template>

<script setup lang="ts">
const query = ref('')

defineShortcuts({
  enter: {
    usingInput: 'queryInput',
    handler: () => performSearch()
  },
  escape: {
    usingInput: true,
    handler: () => clearSearch()
  }
})
</script>
```

### Extracting shortcuts from menu items

Tiện ích `extractShortcuts` có thể được sử dụng để tự động định nghĩa các phím tắt từ các mục menu:

```vue
<script setup lang="ts">
const items = [{
  label: 'Save',
  icon: 'i-lucide-file-down',
  kbds: ['meta', 'S'],
  onSelect() {
    save()
  }
}, {
  label: 'Copy',
  icon: 'i-lucide-copy',
  kbds: ['meta', 'C'],
  onSelect() {
    copy()
  }
}]

defineShortcuts(extractShortcuts(items))
</script>
```


# useFormField

## Usage

Sử dụng composable `useFormField` được tự động nhập để tích hợp các đầu vào tùy chỉnh với một [Form](https://nuxt.com/components/form).

```vue
<script setup lang="ts">
const { id, emitFormBlur, emitFormInput, emitFormChange } = useFormField()
</script>
```


# useOverlay

## Usage

Sử dụng composable `useOverlay` được tự động nhập để kiểm soát theo chương trình các thành phần [Modal](https://nuxt.com/components/modal) và [Slideover](https://nuxt.com/components/slideover).

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const overlay = useOverlay()

const modal = overlay.create(LazyModalExample)

async function openModal() {
  modal.open()
}
</script>
```

- Composable `useOverlay` được tạo bằng `createSharedComposable`, đảm bảo rằng cùng một trạng thái overlay được chia sẻ trên toàn bộ ứng dụng của bạn.

::note
Để trả về một giá trị từ overlay, `overlay.open().instance` có thể được chờ đợi. Để điều này hoạt động, tuy nhiên, **thành phần overlay phải phát ra một sự kiện `close`**. Xem ví dụ bên dưới để biết chi tiết.
::

## API

### `create(component: T, options: OverlayOptions): OverlayInstance`

Tạo một overlay và trả về một instance factory.

- Parameters:

  - `component`: Thành phần overlay.
  - `options`:

    - `defaultOpen?: boolean` Mở overlay ngay sau khi được tạo. Mặc định là `false`.
    - `props?: ComponentProps`: Một đối tượng tùy chọn của props để truyền cho thành phần được render.
    - `destroyOnClose?: boolean` Loại bỏ overlay khỏi bộ nhớ khi đóng. Mặc định là `false`.

### `open(id: symbol, props?: ComponentProps<T>): OpenedOverlay<T>`

Mở một overlay theo `id` của nó.

- Parameters:

  - `id`: Mã định danh của overlay.
  - `props`: Một đối tượng tùy chọn của props để truyền cho thành phần được render.

### `close(id: symbol, value?: any): void`

Đóng một overlay theo `id` của nó.

- Parameters:

  - `id`: Mã định danh của overlay.
  - `value`: Một giá trị để giải quyết promise overlay.

### `patch(id: symbol, props: ComponentProps<T>): void`

Cập nhật một overlay theo `id` của nó.

- Parameters:

  - `id`: Mã định danh của overlay.
  - `props`: Một đối tượng của props để cập nhật trên thành phần được render.

### `unmount(id: symbol): void`

Loại bỏ một overlay khỏi DOM theo `id` của nó.

- Parameters:

  - `id`: Mã định danh của overlay.

### `isOpen(id: symbol): boolean`

Kiểm tra xem một overlay có mở không bằng `id` của nó.

- Parameters:

  - `id`: Mã định danh của overlay.

### `overlays: Overlay[]`

Danh sách trong bộ nhớ của tất cả các overlay đã được tạo.

## Instance API

### `open(props?: ComponentProps<T>): Promise<OpenedOverlay<T>>`

Mở overlay.

- Parameters:

  - `props`: Một đối tượng tùy chọn của props để truyền cho thành phần được render.

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const overlay = useOverlay()

const modal = overlay.create(LazyModalExample)

function openModal() {
  modal.open({
    title: 'Welcome'
  })
}
</script>
```

### `close(value?: any): void`

Đóng overlay.

- Parameters:

  - `value`: Một giá trị để giải quyết promise overlay.

### `patch(props: ComponentProps<T>)`

Cập nhật props của overlay.

- Parameters:

  - `props`: Một đối tượng của props để cập nhật trên thành phần được render.

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const overlay = useOverlay()

const modal = overlay.create(LazyModalExample, {
  title: 'Welcome'
})

function openModal() {
  modal.open()
}

function updateModalTitle() {
  modal.patch({ title: 'Updated Title' })
}
</script>
```

## Example

Đây là một ví dụ hoàn chỉnh về cách sử dụng composable `useOverlay`:

```vue
<script setup lang="ts">
import { ModalA, ModalB, SlideoverA } from '#components'

const overlay = useOverlay()

// Create with default props
const modalA = overlay.create(ModalA, { title: 'Welcome' })
const modalB = overlay.create(ModalB)

const slideoverA = overlay.create(SlideoverA)

const openModalA = () => {
  // Open modalA, but override the title prop
  modalA.open({ title: 'Hello' })
}

const openModalB = async () => {
  // Open modalB, and wait for its result
  const modalBInstance = modalB.open()

  const input = await modalBInstance

  // Pass the result from modalB to the slideover, and open it
  slideoverA.open({ input })
}
</script>

<template>
  <button @click="openModalA">Open Modal</button>
</template>
```

Trong ví dụ này, chúng ta đang sử dụng composable `useOverlay` để kiểm soát nhiều modal và slideover.

## Caveats

### Provide / Inject

Khi mở overlay theo chương trình (ví dụ: modal, slideover, v.v.), thành phần overlay chỉ có thể truy cập các giá trị được inject từ thành phần chứa `UApp` (thường là `app.vue` hoặc các thành phần layout). Điều này là vì overlay được mount bên ngoài ngữ cảnh trang bởi thành phần `UApp`.

Như vậy, sử dụng `provide()` trong các trang hoặc thành phần cha không được hỗ trợ trực tiếp. Để truyền các giá trị được provide cho overlay, cách tiếp cận được khuyến nghị là sử dụng props thay thế:

```vue
<script setup lang="ts">
import { LazyModalExample } from '#components'

const providedValue = inject('valueProvidedInPage')

const modal = overlay.create(LazyModalExample, {
  props: {
    providedValue,
    otherData: someValue
  }
})
</script>
```


# useToast

## Usage

Sử dụng composable `useToast` được tự động nhập để hiển thị thông báo [Toast](https://nuxt.com/components/toast).

```vue
<script setup lang="ts">
const toast = useToast()
</script>
```

- Composable `useToast` sử dụng `useState` của Nuxt để quản lý trạng thái toast, đảm bảo tính phản ứng trên toàn bộ ứng dụng của bạn.
- Tối đa 5 toast được hiển thị cùng lúc. Khi thêm một toast mới vượt quá giới hạn này, toast cũ nhất sẽ được tự động loại bỏ.
- Khi loại bỏ một toast, có độ trễ 200ms trước khi nó thực sự được loại bỏ khỏi trạng thái, cho phép các animation thoát.

::warning
Đảm bảo bọc ứng dụng của bạn với thành phần [`App`](https://nuxt.com/components/app) sử dụng thành phần [`Toaster`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/Toaster.vue){rel="nofollow"} của chúng tôi sử dụng thành phần [`ToastProvider`](https://reka-ui.com/docs/components/toast#provider){rel="nofollow"} từ Reka UI.
::

::tip{to="https://nuxt.com/components/toast"}
Tìm hiểu cách tùy chỉnh giao diện và hành vi của toast trong tài liệu thành phần **Toast**.
::

## API

### `add(toast: Partial<Toast>): Toast`

Thêm một thông báo toast mới.

- Parameters:

  - `toast`: Một đối tượng `Toast` một phần với các thuộc tính sau:

    - `id` (tùy chọn): Một mã định danh duy nhất cho toast. Nếu không được cung cấp, một timestamp sẽ được sử dụng.
    - `open` (tùy chọn): Toast có mở hay không. Mặc định là `true`.
    - Các thuộc tính khác từ interface `Toast`.
- Returns: Đối tượng `Toast` hoàn chỉnh đã được thêm.

```vue
<script setup lang="ts">
const toast = useToast()

function showToast() {
  toast.add({
    title: 'Success',
    description: 'Your action was completed successfully.',
    color: 'success'
  })
}
</script>
```

### `update(id: string | number, toast: Partial<Toast>)`

Cập nhật một thông báo toast hiện có.

- Parameters:

  - `id`: Mã định danh duy nhất của toast để cập nhật.
  - `toast`: Một đối tượng `Toast` một phần với các thuộc tính để cập nhật.

```vue
<script setup lang="ts">
const toast = useToast()

function updateToast(id: string | number) {
  toast.update(id, {
    title: 'Updated Toast',
    description: 'This toast has been updated.'
  })
}
</script>
```

### `remove(id: string | number)`

Loại bỏ một thông báo toast.

- Parameters:

  - `id`: Mã định danh duy nhất của toast để loại bỏ.

```vue
<script setup lang="ts">
const toast = useToast()

function removeToast(id: string | number) {
  toast.remove(id)
}
</script>
```

### `clear()`

Loại bỏ tất cả thông báo toast.

```vue
<script setup lang="ts">
const toast = useToast()

function clearAllToasts() {
  toast.clear()
}
</script>
```

### `toasts`

- Type: `Ref<Toast[]>`
- Description: Một mảng phản ứng chứa tất cả thông báo toast hiện tại.


# App

## Usage

Thành phần này triển khai Reka UI [ConfigProvider](https://reka-ui.com/docs/utilities/config-provider){rel="nofollow"} để cung cấp cấu hình toàn cục cho tất cả các thành phần:

- Cho phép tất cả các nguyên thủy kế thừa hướng đọc toàn cục.
- Cho phép thay đổi hành vi cuộn thân khi thiết lập khóa thân.
- Nhiều điều khiển hơn để ngăn chặn sự thay đổi bố cục.

Nó cũng sử dụng [ToastProvider](https://reka-ui.com/docs/components/toast#provider){rel="nofollow"} và [TooltipProvider](https://reka-ui.com/docs/components/tooltip#provider){rel="nofollow"} để cung cấp bánh mì nướng và chú giải công cụ toàn cục, cũng như các modal và slideover theo chương trình.

Sử dụng nó ở gốc của ứng dụng của bạn:

```vue [app.vue]
<template>
  <UApp>
    <NuxtPage />
  </UApp>
</template>
```

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/i18n/nuxt#locale"}
  Tìm hiểu cách sử dụng prop `locale` để thay đổi ngôn ngữ của ứng dụng của bạn.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/i18n/vue#locale"}
  Tìm hiểu cách sử dụng prop `locale` để thay đổi ngôn ngữ của ứng dụng của bạn.
  :::
::

## API

### Props

::component-props
::

### Slots

::component-slots
::


# Accordion

## Usage

### Items

Sử dụng prop `items` dưới dạng một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `trailingIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `content?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, header?: ClassNameValue, trigger?: ClassNameValue, leadingIcon?: ClassNameValue, label?: ClassNameValue, trailingIcon?: ClassNameValue, content?: ClassNameValue, body?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Multiple

Đặt prop `type` thành `multiple` để cho phép nhiều mục hoạt động cùng lúc. Mặc định là `single`.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - type
  - items
props:
  class: px-4
  type: multiple
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Collapsible

Khi `type` là `single`, bạn có thể đặt prop `collapsible` thành `false` để ngăn mục hoạt động thu gọn.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - collapsible
  - items
props:
  class: px-4
  collapsible: false
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Unmount

Sử dụng prop `unmount-on-hide` để ngăn nội dung bị gỡ bỏ khi accordion bị thu gọn. Mặc định là `true`.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  unmountOnHide: false
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

::note
Bạn có thể kiểm tra DOM để xem nội dung của mỗi mục đang được hiển thị.
::

### Disabled

Sử dụng thuộc tính `disabled` để vô hiệu hóa Accordion.

Bạn cũng có thể vô hiệu hóa một mục cụ thể bằng cách sử dụng thuộc tính `disabled` trong đối tượng mục.

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  disabled: true
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
      disabled: true
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

### Trailing Icon

Sử dụng prop `trailing-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) theo sau của mỗi mục. Mặc định là `i-lucide-chevron-down`.

::tip
Bạn cũng có thể đặt biểu tượng cho một mục cụ thể bằng cách sử dụng thuộc tính `trailingIcon` trong đối tượng mục.
::

::component-code
---
external:
  - items
externalTypes:
  - AccordionItem[]
hide:
  - class
ignore:
  - items
props:
  class: px-4
  trailingIcon: i-lucide-arrow-down
  items:
    - label: Icons
      icon: i-lucide-smile
      content: You have nothing to do, @nuxt/icon will handle it automatically.
      trailingIcon: i-lucide-plus
    - label: Colors
      icon: i-lucide-swatch-book
      content: Choose a primary and a neutral color from your Tailwind CSS theme.
    - label: Components
      icon: i-lucide-box
      content: You can customize components by using the `class` / `ui` props or in
        your app.config.ts.
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` dưới khóa `ui.icons.chevronDown`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` dưới khóa `ui.icons.chevronDown`.
  :::
::

## Examples

### Control active item(s)

Bạn có thể kiểm soát mục hoạt động bằng cách sử dụng prop `default-value` hoặc chỉ thị `v-model` với chỉ số của mục.

::component-example
---
props:
  class: px-4
name: accordion-model-value-example
---
::

::tip
Bạn cũng có thể truyền `value` của một trong các mục nếu được cung cấp.
::

::caution
Khi `type="multiple"`, đảm bảo truyền một mảng cho prop `default-value` hoặc chỉ thị `v-model`.
::

### With drag and drop

Sử dụng composable [`useSortable`](https://vueuse.org/integrations/useSortable/){rel="nofollow"} từ [`@vueuse/integrations`](https://vueuse.org/integrations/README.html){rel="nofollow"} để bật chức năng kéo và thả trên Accordion. Tích hợp này bao bọc [Sortable.js](https://sortablejs.github.io/Sortable/){rel="nofollow"} để cung cấp trải nghiệm kéo và thả liền mạch.

::component-example{name="accordion-drag-and-drop-example"}
::

### With body slot

Sử dụng slot `#body` để tùy chỉnh thân của mỗi mục.

::component-example
---
props:
  class: px-4
name: accordion-body-slot-example
---
::

::tip
Slot `#body` bao gồm một số kiểu được định nghĩa trước, sử dụng slot [`#content`](https://nuxt.com/#with-content-slot) nếu bạn muốn bắt đầu từ đầu.
::

### With content slot

Sử dụng slot `#content` để tùy chỉnh nội dung của mỗi mục.

::component-example
---
props:
  class: px-4
name: accordion-content-slot-example
---
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example
---
props:
  class: px-4
name: accordion-custom-slot-example
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Alert

## Usage

### Title

Sử dụng prop `title` để đặt tiêu đề của Alert.

::component-code{:props='{"title":"Heads up!"}'}
::

### Description

Sử dụng prop `description` để đặt mô tả của Alert.

::component-code
---
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
---
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon).

::component-code
---
ignore:
  - title
  - description
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-terminal
---
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar).

::component-code
---
ignore:
  - title
  - description
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  avatar:
    src: https://github.com/nuxt.png
---
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của Alert.

::component-code
---
ignore:
  - title
  - description
  - icon
prettier: true
props:
  color: neutral
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-terminal
---
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Alert.

::component-code
---
ignore:
  - title
  - description
  - icon
prettier: true
props:
  color: neutral
  variant: subtle
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-terminal
---
::

### Close

Sử dụng prop `close` để hiển thị một [Button](https://nuxt.com/components/button) để đóng Alert.

::tip
Một sự kiện `update:open` sẽ được phát ra khi nút đóng được nhấp.
::

::component-code
---
ignore:
  - title
  - description
  - close
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  close: true
---
::

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Button](https://nuxt.com/components/button) để tùy chỉnh nó.

::component-code
---
ignore:
  - title
  - description
  - close.color
  - close.variant
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  close:
    color: primary
    variant: outline
    class: rounded-full
---
::

### Close Icon

Sử dụng prop `close-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) của nút đóng. Mặc định là `i-lucide-x`.

::component-code
---
ignore:
  - title
  - description
  - close
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  close: true
  closeIcon: i-lucide-arrow-right
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` dưới khóa `ui.icons.close`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` dưới khóa `ui.icons.close`.
  :::
::

### Actions

Sử dụng prop `actions` để thêm một số hành động [Button](https://nuxt.com/components/button) vào Alert.

::component-code
---
ignore:
  - title
  - actions
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  actions:
    - label: Action 1
    - label: Action 2
      color: neutral
      variant: subtle
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của Alert.

::component-code
---
ignore:
  - title
  - actions
  - color
  - variant
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  color: neutral
  variant: outline
  orientation: horizontal
  actions:
    - label: Action 1
    - label: Action 2
      color: neutral
      variant: subtle
---
::

## Examples

### `class` prop

Sử dụng prop `class` để ghi đè các kiểu cơ sở của Alert.

::component-code
---
ignore:
  - title
  - description
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  class: rounded-none
---
::

### `ui` prop

Sử dụng prop `ui` để ghi đè các kiểu slot của Alert.

::component-code
---
ignore:
  - ui
  - title
  - description
  - icon
prettier: true
props:
  title: Heads up!
  description: You can change the primary color in your app config.
  icon: i-lucide-rocket
  ui:
    icon: size-11
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Avatar

## Usage

Avatar sử dụng thành phần `<NuxtImg>` khi [`@nuxt/image`](https://github.com/nuxt/image){rel="nofollow"} được cài đặt, quay lại `img` nếu không.

::note
Bạn có thể truyền bất kỳ thuộc tính nào từ phần tử HTML `<img>` như `alt`, `loading`, v.v.
::

### Src

Sử dụng prop `src` để đặt URL hình ảnh.

::component-code{:props='{"src":"https://github.com/benjamincanac.png"}'}
::

### Size

Sử dụng prop `size` để đặt kích thước của Avatar.

::component-code
---
ignore:
  - src
props:
  src: https://github.com/benjamincanac.png
  size: xl
---
::

::note
`width` và `height` của phần tử `<img>` được tự động đặt dựa trên prop `size`.
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) dự phòng.

::component-code{:props='{"icon":"i-lucide-image","size":"md"}'}
::

### Text

Sử dụng prop `text` để hiển thị văn bản dự phòng.

::component-code{:props='{"text":"+1","size":"md"}'}
::

### Alt

Khi không có biểu tượng hoặc văn bản nào được cung cấp, **chữ cái đầu** của prop `alt` được sử dụng làm dự phòng.

::component-code{:props='{"alt":"Benjamin Canac","size":"md"}'}
::

::note
Prop `alt` được truyền cho phần tử `img` dưới dạng thuộc tính `alt`.
::

## Examples

### With tooltip

Bạn có thể sử dụng thành phần [Tooltip](https://nuxt.com/components/tooltip) để hiển thị chú giải khi di chuột lên Avatar.

::component-example{name="avatar-tooltip-example"}
::

### With chip

Bạn có thể sử dụng thành phần [Chip](https://nuxt.com/components/chip) để hiển thị chip xung quanh Avatar.

::component-example{name="avatar-chip-example"}
::

## API

### Props

::component-props
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# AvatarGroup

## Usage

Bao bọc nhiều [Avatar](https://nuxt.com/components/avatar) trong một AvatarGroup để xếp chồng chúng.

::component-code
---
prettier: true
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" alt="Benjamin Canac" />
    <UAvatar src="https://github.com/romhml.png" alt="Romain Hamel" />
    <UAvatar src="https://github.com/noook.png" alt="Neil Richter" />
---
  :::u-avatar{alt="Benjamin Canac" src="https://github.com/benjamincanac.png"}
  :::

  :::u-avatar{alt="Romain Hamel" src="https://github.com/romhml.png"}
  :::

  :::u-avatar{alt="Neil Richter" src="https://github.com/noook.png"}
  :::
::

### Size

Sử dụng prop `size` để thay đổi kích thước của tất cả các avatar.

::component-code
---
prettier: true
props:
  size: xl
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" alt="Benjamin Canac" />
    <UAvatar src="https://github.com/romhml.png" alt="Romain Hamel" />
    <UAvatar src="https://github.com/noook.png" alt="Neil Richter" />
---
  :::u-avatar{alt="Benjamin Canac" src="https://github.com/benjamincanac.png"}
  :::

  :::u-avatar{alt="Romain Hamel" src="https://github.com/romhml.png"}
  :::

  :::u-avatar{alt="Neil Richter" src="https://github.com/noook.png"}
  :::
::

### Max

Sử dụng prop `max` để giới hạn số lượng avatar được hiển thị. Phần còn lại được hiển thị dưới dạng avatar `+X`.

::component-code
---
prettier: true
props:
  max: 2
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" alt="Benjamin Canac" />
    <UAvatar src="https://github.com/romhml.png" alt="Romain Hamel" />
    <UAvatar src="https://github.com/noook.png" alt="Neil Richter" />
---
  :::u-avatar{alt="Benjamin Canac" src="https://github.com/benjamincanac.png"}
  :::

  :::u-avatar{alt="Romain Hamel" src="https://github.com/romhml.png"}
  :::

  :::u-avatar{alt="Neil Richter" src="https://github.com/noook.png"}
  :::
::

## Examples

### With tooltip

Bao bọc mỗi avatar với một [Tooltip](https://nuxt.com/components/tooltip) để hiển thị chú giải khi di chuột.

::component-example{name="avatar-group-tooltip-example"}
::

### With chip

Bao bọc mỗi avatar với một [Chip](https://nuxt.com/components/chip) để hiển thị chip xung quanh avatar.

::component-example{name="avatar-group-chip-example"}
::

### With link

Bao bọc mỗi avatar với một [Link](https://nuxt.com/components/link) để làm cho chúng có thể nhấp.

::component-example{name="avatar-group-link-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Badge

## Usage

### Label

Sử dụng slot mặc định để đặt nhãn của Badge.

::component-code{:slots='{"default":"Badge"}'}
::

Bạn có thể đạt được kết quả tương tự bằng cách sử dụng prop `label`.

::component-code{:props='{"label":"Badge"}'}
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của Badge.

::component-code{:props='{"color":"neutral"}' :slots='{"default":"Badge"}'}
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Badge.

::component-code
---
props:
  color: neutral
  variant: outline
slots:
  default: Badge
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Badge.

::component-code{:props='{"size":"xl"}' :slots='{"default":"Badge"}'}
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong Badge.

::component-code
---
props:
  icon: i-lucide-rocket
  size: md
  color: primary
  variant: solid
slots:
  default: Badge
---
::

Sử dụng prop `leading` và `trailing` để đặt vị trí biểu tượng hoặc prop `leading-icon` và `trailing-icon` để đặt biểu tượng khác nhau cho mỗi vị trí.

::component-code
---
props:
  trailingIcon: i-lucide-arrow-right
  size: md
slots:
  default: Badge
---
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong Badge.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  color: neutral
  variant: outline
slots:
  default: |
    
    Badge
---
::

## Examples

### `class` prop

Sử dụng prop `class` để ghi đè các kiểu cơ sở của Badge.

::component-code
---
props:
  class: font-bold rounded-full
slots:
  default: Badge
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Breadcrumb

## Usage

### Items

Sử dụng prop `items` dưới dạng một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, link?: ClassNameValue, linkLeadingIcon?: ClassNameValue, linkLeadingAvatar?: ClassNameValue, linkLabel?: ClassNameValue, separator?: ClassNameValue, separatorIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Link](https://nuxt.com/components/link#props) như `to`, `target`, v.v.

::component-code
---
external:
  - items
externalTypes:
  - BreadcrumbItem[]
ignore:
  - items
props:
  items:
    - label: Home
      icon: i-lucide-house
    - label: Components
      icon: i-lucide-box
      to: /components
    - label: Breadcrumb
      icon: i-lucide-link
      to: /components/breadcrumb
---
::

::note
Một `span` được hiển thị thay vì liên kết khi thuộc tính `to` không được định nghĩa.
::

### Separator Icon

Sử dụng prop `separator-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) giữa mỗi mục. Mặc định là `i-lucide-chevron-right`.

::component-code
---
external:
  - items
externalTypes:
  - BreadcrumbItem[]
ignore:
  - items
props:
  separatorIcon: i-lucide-arrow-right
  items:
    - label: Home
      icon: i-lucide-house
    - label: Components
      icon: i-lucide-box
      to: /components
    - label: Breadcrumb
      icon: i-lucide-link
      to: /components/breadcrumb
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` dưới khóa `ui.icons.chevronRight`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` dưới khóa `ui.icons.chevronRight`.
  :::
::

## Examples

### With separator slot

Sử dụng slot `#separator` để tùy chỉnh dấu phân cách giữa mỗi mục.

::component-example{name="breadcrumb-separator-slot-example"}
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="breadcrumb-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
Bạn cũng có thể sử dụng slot `#item`, `#item-leading`, `#item-label` và `#item-trailing` để tùy chỉnh tất cả các mục.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Button

## Usage

### Label

Sử dụng slot mặc định để đặt nhãn của Button.

::component-code{:slots='{"default":"Button"}'}
::

Bạn có thể đạt được kết quả tương tự bằng cách sử dụng prop `label`.

::component-code{:props='{"label":"Button"}'}
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của Button.

::component-code{:props='{"color":"neutral"}' :slots='{"default":"Button"}'}
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Button.

::component-code
---
props:
  color: neutral
  variant: outline
slots:
  default: Button
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Button.

::component-code{:props='{"size":"xl"}' :slots='{"default":"Button"}'}
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong Button.

::component-code
---
props:
  icon: i-lucide-rocket
  size: md
  color: primary
  variant: solid
slots:
  default: Button
---
::

Sử dụng prop `leading` và `trailing` để đặt vị trí biểu tượng hoặc prop `leading-icon` và `trailing-icon` để đặt biểu tượng khác nhau cho mỗi vị trí.

::component-code
---
props:
  trailingIcon: i-lucide-arrow-right
  size: md
slots:
  default: Button
---
::

Phần tử `label` dưới dạng prop hoặc slot là tùy chọn nên bạn có thể sử dụng Button dưới dạng nút chỉ biểu tượng.

::component-code
---
props:
  icon: i-lucide-search
  size: md
  color: primary
  variant: solid
---
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong Button.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  color: neutral
  variant: outline
slots:
  default: |
    
    Button
---
::

Phần tử `label` dưới dạng prop hoặc slot là tùy chọn nên bạn có thể sử dụng Button dưới dạng nút chỉ avatar.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  color: neutral
  variant: outline
---
::

### Link

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Link](https://nuxt.com/components/link#props) như `to`, `target`, v.v.

::component-code
---
ignore:
  - target
props:
  to: https://github.com/nuxt/ui
  target: _blank
slots:
  default: Button
---
::

Khi Button là liên kết hoặc khi sử dụng prop `active`, bạn có thể sử dụng prop `active-color` và `active-variant` để tùy chỉnh trạng thái hoạt động.

::component-code
---
ignore:
  - color
  - variant
items:
  activeColor:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  activeVariant:
    - solid
    - outline
    - soft
    - subtle
    - ghost
    - link
prettier: true
props:
  active: true
  color: neutral
  variant: outline
  activeColor: primary
  activeVariant: solid
slots:
  default: |
    
    Button
---
Button
::

Bạn cũng có thể sử dụng prop `active-class` và `inactive-class` để tùy chỉnh trạng thái hoạt động.

::component-code
---
props:
  active: true
  activeClass: font-bold
  inactiveClass: font-light
slots:
  default: Button
---
Button
::

::tip
Bạn có thể cấu hình các kiểu này toàn cục trong tệp `app.config.ts` của bạn dưới khóa `ui.button.variants.active`.

```ts
export default defineAppConfig({
  ui: {
    button: {
      variants: {
        active: {
          true: {
            base: 'font-bold'
          }
        }
      }
    }
  }
})
```
::

### Loading

Sử dụng prop `loading` để hiển thị biểu tượng tải và vô hiệu hóa Button.

::component-code
---
props:
  loading: true
  trailing: false
slots:
  default: Button
---
Button
::

Sử dụng prop `loading-auto` để hiển thị biểu tượng tải tự động trong khi promise `@click` đang chờ.

::component-example{name="button-loading-auto-example"}
::

Điều này cũng hoạt động với thành phần [Form](https://nuxt.com/components/form).

::component-example{name="button-loading-auto-form-example"}
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh biểu tượng tải. Mặc định là `i-lucide-loader-circle`.

::component-code
---
props:
  loading: true
  loadingIcon: i-lucide-loader
slots:
  default: Button
---
Button
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` dưới khóa `ui.icons.loading`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Button.

::component-code{:props='{"disabled":true}' :slots='{"default":"Button"}'}
Button
::

## Examples

### `class` prop

Sử dụng prop `class` để ghi đè các kiểu cơ sở của Button.

::component-code
---
props:
  class: font-bold rounded-full
slots:
  default: Button
---
::

### `ui` prop

Sử dụng prop `ui` để ghi đè các kiểu slot của Button.

::component-code
---
ignore:
  - ui
  - color
  - variant
  - icon
prettier: true
props:
  icon: i-lucide-rocket
  color: neutral
  variant: outline
  ui:
    leadingIcon: text-primary
slots:
  default: |
    
    Button
---
::

## API

### Props

::component-props
::

::callout
---
icon: i-simple-icons-github
to: https://github.com/nuxt/ui/blob/v3/src/runtime/components/Link.vue#L13
---
Thành phần `Button` mở rộng thành phần `Link`. Kiểm tra mã nguồn trên GitHub.
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# ButtonGroup

## Usage

Bao bọc nhiều [Button](https://nuxt.com/components/button) trong một ButtonGroup để nhóm chúng lại.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton color="neutral" variant="subtle" label="Button" />
    <UButton color="neutral" variant="outline" icon="i-lucide-chevron-down" />
---
  :::u-button{color="neutral" label="Button" variant="subtle"}
  :::

  :::u-button{color="neutral" icon="i-lucide-chevron-down" variant="outline"}
  :::
::

### Size

Sử dụng prop `size` để thay đổi kích thước của tất cả các nút.

::component-code
---
prettier: true
props:
  size: xl
slots:
  default: |
    
    <UButton color="neutral" variant="subtle" label="Button" />
    <UButton color="neutral" variant="outline" icon="i-lucide-chevron-down" />
---
  :::u-button{color="neutral" label="Button" variant="subtle"}
  :::

  :::u-button{color="neutral" icon="i-lucide-chevron-down" variant="outline"}
  :::
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của các nút. Mặc định là `horizontal`.

::component-code
---
prettier: true
props:
  orientation: vertical
slots:
  default: |
    
    <UButton color="neutral" variant="subtle" label="Submit" />
    <UButton color="neutral" variant="outline" label="Cancel" />
---
  :::u-button{color="neutral" label="Submit" variant="subtle"}
  :::

  :::u-button{color="neutral" label="Cancel" variant="outline"}
  :::
::

## Examples

### With input

Bạn có thể sử dụng các thành phần như [Input](https://nuxt.com/components/input), [InputMenu](https://nuxt.com/components/input-menu), [Select](https://nuxt.com/components/select) [SelectMenu](https://nuxt.com/components/select-menu), v.v. trong một nhóm nút.

::component-code
---
prettier: true
slots:
  default: |
    
    <UInput color="neutral" variant="outline" placeholder="Enter token" />

    <UButton color="neutral" variant="subtle" icon="i-lucide-clipboard" />
---
  :::u-input{color="neutral" placeholder="Enter token" variant="outline"}
  :::

  :::u-button{color="neutral" icon="i-lucide-clipboard" variant="subtle"}
  :::
::

### With tooltip

Bạn có thể sử dụng một [Tooltip](https://nuxt.com/components/tooltip) trong một nhóm nút.

::component-example{name="button-group-tooltip-example"}
::

### With dropdown

Bạn có thể sử dụng một [DropdownMenu](https://nuxt.com/components/dropdown-menu) trong một nhóm nút.

::component-example{name="button-group-dropdown-example"}
::

### With badge

Bạn có thể sử dụng một [Badge](https://nuxt.com/components/badge) trong một nhóm nút.

::component-example{name="button-group-badge-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Calendar

::note
Thành phần này dựa vào gói [`@internationalized/date`](https://react-spectrum.adobe.com/internationalized/date/index.html){rel="nofollow"} cung cấp các đối tượng và hàm để biểu diễn và thao tác ngày tháng theo cách nhận biết ngôn ngữ.
::

## Usage

Sử dụng chỉ thị `v-model` để kiểm soát ngày đã chọn.

::component-code
---
cast:
  modelValue: DateValue
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue:
    - 2022
    - 2
    - 3
---
::

Sử dụng prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::component-code
---
cast:
  defaultValue: DateValue
external:
  - defaultValue
ignore:
  - defaultValue
props:
  defaultValue:
    - 2022
    - 2
    - 6
---
::

### Multiple

Sử dụng prop `multiple` để cho phép chọn nhiều.

::component-code
---
cast:
  modelValue: DateValue[]
external:
  - modelValue
ignore:
  - multiple
  - modelValue
prettier: true
props:
  multiple: true
  modelValue:
    - - 2022
      - 2
      - 4
    - - 2022
      - 2
      - 6
    - - 2022
      - 2
      - 8
---
::

### Range

Sử dụng prop `range` để chọn một phạm vi ngày.

::component-code
---
cast:
  modelValue: DateRange
external:
  - modelValue
ignore:
  - range
  - modelValue.start
  - modelValue.end
prettier: true
props:
  range: true
  modelValue:
    start:
      - 2022
      - 2
      - 3
    end:
      - 2022
      - 2
      - 20
---
::

### Color

Sử dụng prop `color` để thay đổi màu của lịch.

::component-code{:props='{"color":"neutral"}'}
::

### Size

Sử dụng prop `size` để thay đổi kích thước của lịch.

::component-code{:props='{"size":"xl"}'}
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa lịch.

::component-code{:props='{"disabled":true}'}
::

### Number Of Months

Sử dụng prop `numberOfMonths` để thay đổi số tháng trong lịch.

::component-code{:props='{"numberOfMonths":3}'}
::

### Month Controls

Sử dụng prop `month-controls` để hiển thị các điều khiển tháng. Mặc định là `true`.

::component-code{:props='{"monthControls":false}'}
::

### Year Controls

Sử dụng prop `year-controls` để hiển thị các điều khiển năm. Mặc định là `true`.

::component-code{:props='{"yearControls":false}'}
::

### Fixed Weeks

Sử dụng prop `fixed-weeks` để hiển thị lịch với tuần cố định.

::component-code{:props='{"fixedWeeks":false}'}
::

## Examples

### With chip events

Sử dụng thành phần [Chip](https://nuxt.com/components/chip) để thêm sự kiện vào các ngày cụ thể.

::component-example{name="calendar-events-example"}
::

### With disabled dates

Sử dụng prop `is-date-disabled` với một hàm để đánh dấu các ngày cụ thể là bị vô hiệu hóa.

::component-example{name="calendar-disabled-dates-example"}
::

### With unavailable dates

Sử dụng prop `is-date-unavailable` với một hàm để đánh dấu các ngày cụ thể là không khả dụng.

::component-example{name="calendar-unavailable-dates-example"}
::

### With min/max dates

Sử dụng các prop `min-value` và `max-value` để giới hạn các ngày.

::component-example{name="calendar-min-max-dates-example"}
::

### With other calendar systems

Bạn có thể sử dụng các lịch khác từ `@internationalized/date` để triển khai hệ thống lịch khác.

::component-example{name="calendar-other-system-example"}
::

::note
---
to: https://react-spectrum.adobe.com/internationalized/date/Calendar.html#implementations
---
Bạn có thể kiểm tra tất cả các lịch khả dụng trên tài liệu `@internationalized/date`.
::

### With external controls

Bạn có thể kiểm soát lịch với các điều khiển bên ngoài bằng cách thao tác ngày được truyền trong `v-model`.

::component-example{name="calendar-external-controls-example"}
::

### As a DatePicker

Sử dụng thành phần [Button](https://nuxt.com/components/button) và [Popover](https://nuxt.com/components/popover) để tạo một bộ chọn ngày.

::component-example{name="calendar-date-picker-example"}
::

### As a DateRangePicker

Sử dụng thành phần [Button](https://nuxt.com/components/button) và [Popover](https://nuxt.com/components/popover) để tạo một bộ chọn phạm vi ngày.

::component-example{name="calendar-date-range-picker-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Card

## Usage

::component-example{:props='{"class":"w-full"}' name="card-example"}
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Card.

::component-code
---
hide:
  - class
prettier: true
props:
  variant: subtle
  class: w-full
slots:
  header: |
    
    <Placeholder class="h-8" />
  default: |
    
    <Placeholder class="h-32" />
  footer: |
    
    <Placeholder class="h-8" />
---
  :::placeholder{.h-32}
  :::

#header
  :::placeholder{.h-8}
  :::

#footer
  :::placeholder{.h-8}
  :::
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Carousel

## Usage

### Items

Sử dụng prop `items` dưới dạng mảng và hiển thị từng mục bằng slot mặc định:

::note
Sử dụng chuột để kéo carousel theo chiều ngang trên desktop.
::

::component-example{.p-8 name="carousel-items-example"}
::

Bạn cũng có thể truyền một mảng các đối tượng với các thuộc tính sau:

- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

Bạn có thể kiểm soát số lượng mục hiển thị bằng cách sử dụng các lớp tiện ích [`basis`](https://tailwindcss.com/docs/flex-basis){rel="nofollow"} / [`width`](https://tailwindcss.com/docs/width){rel="nofollow"} trên `item`:

::component-example{.p-8.px-16 name="carousel-items-multiple-example"}
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của Carousel. Mặc định là `horizontal`.

::note
Sử dụng chuột để kéo carousel theo chiều dọc trên desktop.
::

::component-example{.p-8 name="carousel-orientation-example"}
::

::caution
Bạn cần chỉ định `height` trên container trong hướng dọc.
::

### Arrows

Sử dụng prop `arrows` để hiển thị các nút prev và next.

::component-example{.p-8 name="carousel-arrows-example"}
::

### Prev / Next

Sử dụng các prop `prev` và `next` để tùy chỉnh các nút prev và next với bất kỳ prop [Button](https://nuxt.com/components/button) nào.

::component-example{.p-8 name="carousel-prev-next-example"}
::

### Prev / Next Icons

Sử dụng các prop `prev-icon` và `next-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) của các nút. Mặc định là `i-lucide-arrow-left` / `i-lucide-arrow-right`.

::component-example
---
options:
  - name: prevIcon
    label: prevIcon
    default: i-lucide-chevron-left
  - name: nextIcon
    label: nextIcon
    default: i-lucide-chevron-right
class: p-8
name: carousel-prev-next-icon-example
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh các biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.arrowLeft` / `ui.icons.arrowRight`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh các biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.arrowLeft` / `ui.icons.arrowRight`.
  :::
::

### Dots

Sử dụng prop `dots` để hiển thị danh sách các chấm để cuộn đến slide cụ thể.

::component-example{.p-8.pb-12 name="carousel-dots-example"}
::

Số lượng chấm dựa trên số lượng slide được hiển thị trong view:

::component-example{.p-8.px-16.pb-12 name="carousel-dots-multiple-example"}
::

## Plugins

Thành phần Carousel triển khai các plugin [Embla Carousel](https://www.embla-carousel.com/plugins/){rel="nofollow"} chính thức.

### Autoplay

Plugin này được sử dụng để mở rộng Embla Carousel với chức năng **tự động phát**.

Sử dụng prop `autoplay` dưới dạng boolean hoặc đối tượng để cấu hình [Autoplay plugin](https://www.embla-carousel.com/plugins/autoplay/){rel="nofollow"}.

::component-example{.p-8.px-16.pb-12 name="carousel-autoplay-example"}
::

::note
Trong ví dụ này, chúng tôi đang sử dụng prop `loop` cho carousel vô hạn.
::

### Auto Scroll

Plugin này được sử dụng để mở rộng Embla Carousel với chức năng **tự động cuộn**.

Sử dụng prop `auto-scroll` dưới dạng boolean hoặc đối tượng để cấu hình [Auto Scroll plugin](https://www.embla-carousel.com/plugins/auto-scroll/){rel="nofollow"}.

::component-example{.p-8.px-16.pb-12 name="carousel-auto-scroll-example"}
::

::note
Trong ví dụ này, chúng tôi đang sử dụng prop `loop` cho carousel vô hạn.
::

### Auto Height

Plugin này được sử dụng để mở rộng Embla Carousel với chức năng **tự động chiều cao**. Nó thay đổi chiều cao của container carousel để phù hợp với chiều cao của slide cao nhất trong view.

Sử dụng prop `auto-height` dưới dạng boolean hoặc đối tượng để cấu hình [Auto Height plugin](https://www.embla-carousel.com/plugins/auto-height/){rel="nofollow"}.

::component-example{.p-8.pt-16 name="carousel-auto-height-example"}
::

::note
Trong ví dụ này, chúng tôi thêm lớp `transition-[height]` trên container để tạo hiệu ứng chuyển đổi chiều cao.
::

### Class Names

Class Names là plugin tiện ích **chuyển đổi tên lớp** cho Embla Carousel cho phép bạn tự động chuyển đổi tên lớp trên carousel của bạn.

Sử dụng prop `class-names` dưới dạng boolean hoặc đối tượng để cấu hình [Class Names plugin](https://www.embla-carousel.com/plugins/class-names/){rel="nofollow"}.

::component-example{.p-8 name="carousel-class-names-example"}
::

::note
Trong ví dụ này, chúng tôi thêm các lớp `transition-opacity [&:not(.is-snapped)]:opacity-10` trên `item` để tạo hiệu ứng chuyển đổi độ mờ.
::

### Fade

Plugin này được sử dụng để thay thế chức năng cuộn Embla Carousel bằng **chuyển đổi mờ**.

Sử dụng prop `fade` dưới dạng boolean hoặc đối tượng để cấu hình [Fade plugin](https://www.embla-carousel.com/plugins/fade/){rel="nofollow"}.

::component-example{.p-8.pb-12 name="carousel-fade-example"}
::

### Wheel Gestures

Plugin này được sử dụng để mở rộng Embla Carousel với khả năng **sử dụng bánh xe chuột/trackpad** để điều hướng carousel.

Sử dụng prop `wheel-gestures` dưới dạng boolean hoặc đối tượng để cấu hình [Wheel Gestures plugin](https://www.embla-carousel.com/plugins/wheel-gestures/){rel="nofollow"}.

::note
Sử dụng bánh xe chuột để cuộn carousel.
::

::component-example{.p-8.px-16 name="carousel-wheel-gestures-example"}
::

## Examples

### With thumbnails

Bạn có thể sử dụng hàm [`emblaApi`](https://nuxt.com/#expose) [scrollTo](https://www.embla-carousel.com/api/methods/#scrollto){rel="nofollow"} để hiển thị hình thu nhỏ dưới carousel cho phép bạn điều hướng đến slide cụ thể.

::component-example{.p-8.px-16 name="carousel-thumbnails-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

Bạn có thể truy cập instance thành phần đã nhập bằng [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const carousel = useTemplateRef('carousel')
</script>

<template>
  <UCarousel ref="carousel" />
</template>
```

Điều này sẽ cho bạn quyền truy cập vào những thứ sau:

| Name                                                                                                                                   | Type                                                                                                                                                                                                                                  |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `emblaRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                 |
| `emblaApi`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | [`Ref<EmblaCarouselType | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://www.embla-carousel.com/api/methods/#typescript){rel="nofollow"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Checkbox

## Usage

Sử dụng chỉ thị `v-model` để kiểm soát trạng thái đã kiểm tra của Checkbox.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: true
---
::

Sử dụng prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":true}'}
::

### Indeterminate

Sử dụng giá trị `indeterminate` trong chỉ thị `v-model` hoặc prop `default-value` để đặt Checkbox ở trạng thái không xác định.

::component-code
---
ignore:
  - defaultValue
props:
  defaultValue: indeterminate
---
::

### Indeterminate Icon

Sử dụng prop `indeterminate-icon` để tùy chỉnh biểu tượng không xác định. Mặc định là `i-lucide-minus`.

::component-code
---
ignore:
  - defaultValue
props:
  defaultValue: indeterminate
  indeterminateIcon: i-lucide-plus
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.minus`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.minus`.
  :::
::

### Label

Sử dụng prop `label` để đặt nhãn của Checkbox.

::component-code{:props='{"label":"Check me"}'}
::

Khi sử dụng prop `required`, một dấu hoa thị được thêm bên cạnh nhãn.

::component-code
---
ignore:
  - label
props:
  required: true
  label: Check me
---
::

### Description

Sử dụng prop `description` để đặt mô tả của Checkbox.

::component-code
---
ignore:
  - label
props:
  label: Check me
  description: This is a checkbox.
---
::

### Icon

Sử dụng prop `icon` để đặt biểu tượng của Checkbox khi nó được kiểm tra. Mặc định là `i-lucide-check`.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  icon: i-lucide-heart
  defaultValue: true
  label: Check me
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của Checkbox.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  color: neutral
  defaultValue: true
  label: Check me
---
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Checkbox.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  color: primary
  variant: card
  defaultValue: true
  label: Check me
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Checkbox.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  size: xl
  variant: list
  defaultValue: true
  label: Check me
---
::

### Indicator

Sử dụng prop `indicator` để thay đổi vị trí hoặc ẩn chỉ báo. Mặc định là `start`.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  indicator: end
  variant: card
  defaultValue: true
  label: Check me
---
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Checkbox.

::component-code
---
ignore:
  - label
props:
  disabled: true
  label: Check me
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# CheckboxGroup

## Usage

Sử dụng chỉ thị `v-model` để kiểm soát giá trị của CheckboxGroup hoặc prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

### Items

Sử dụng prop `items` dưới dạng mảng các chuỗi hoặc số:

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - CheckboxGroupItem[]
  - CheckboxGroupValue[]
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

Bạn cũng có thể truyền một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#value-key)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, base?: ClassNameValue, 'indicator'?: ClassNameValue, icon?: ClassNameValue, wrapper?: ClassNameValue, label?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - CheckboxGroupItem[]
  - CheckboxGroupValue[]
ignore:
  - modelValue
  - items
props:
  modelValue:
    - system
  items:
    - label: System
      description: This is the first option.
      value: system
    - label: Light
      description: This is the second option.
      value: light
    - label: Dark
      description: This is the third option.
      value: dark
---
::

::caution
Khi sử dụng đối tượng, bạn cần tham chiếu thuộc tính `value` của đối tượng trong chỉ thị `v-model` hoặc prop `default-value`.
::

### Value Key

Bạn có thể thay đổi thuộc tính được sử dụng để đặt giá trị bằng cách sử dụng prop `value-key`. Mặc định là `value`.

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - CheckboxGroupItem[]
  - CheckboxGroupValue[]
ignore:
  - modelValue
  - items
  - valueKey
props:
  modelValue:
    - light
  valueKey: id
  items:
    - label: System
      description: This is the first option.
      id: system
    - label: Light
      description: This is the second option.
      id: light
    - label: Dark
      description: This is the third option.
      id: dark
---
::

### Legend

Sử dụng prop `legend` để đặt chú thích của CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  legend: Theme
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
prettier: true
props:
  color: neutral
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  variant:
    - list
    - card
    - table
prettier: true
props:
  color: primary
  variant: card
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  variant:
    - list
    - card
    - table
prettier: true
props:
  size: xl
  variant: list
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của CheckboxGroup. Mặc định là `vertical`.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  variant:
    - list
    - card
    - table
prettier: true
props:
  orientation: horizontal
  variant: list
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Indicator

Sử dụng prop `indicator` để thay đổi vị trí hoặc ẩn chỉ báo. Mặc định là `start`.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
items:
  indicator:
    - start
    - end
    - hidden
  variant:
    - list
    - card
    - table
prettier: true
props:
  indicator: end
  variant: card
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa CheckboxGroup.

::component-code
---
external:
  - items
externalTypes:
  - CheckboxGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  disabled: true
  defaultValue:
    - System
  items:
    - System
    - Light
    - Dark
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Chip

## Usage

Bao bọc bất kỳ thành phần nào với Chip để hiển thị chỉ báo.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của Chip.

::component-code
---
prettier: true
props:
  color: neutral
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Chip.

::component-code
---
prettier: true
props:
  size: 3xl
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Text

Sử dụng prop `text` để đặt văn bản của Chip.

::component-code
---
prettier: true
props:
  text: 5
  size: 3xl
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Position

Sử dụng prop `position` để thay đổi vị trí của Chip.

::component-code
---
prettier: true
props:
  position: bottom-left
slots:
  default: |
    
    <UButton icon="i-lucide-mail" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" icon="i-lucide-mail" variant="subtle"}
  :::
::

### Inset

Sử dụng prop `inset` để hiển thị Chip bên trong thành phần. Điều này hữu ích khi xử lý các thành phần bo tròn.

::component-code
---
prettier: true
props:
  inset: true
slots:
  default: |
    
    <UAvatar src="https://github.com/benjamincanac.png" />
---
  :::u-avatar{src="https://github.com/benjamincanac.png"}
  :::
::

### Standalone

Sử dụng prop `standalone` cùng với prop `inset` để hiển thị Chip nội tuyến.

::component-code{:props='{"standalone":true,"inset":true}'}
::

::note
Nó được sử dụng theo cách này trong các thành phần [`CommandPalette`](https://nuxt.com/components/command-palette), [`InputMenu`](https://nuxt.com/components/input-menu), [`Select`](https://nuxt.com/components/select) hoặc [`SelectMenu`](https://nuxt.com/components/select-menu) chẳng hạn.
::

## Examples

### Control visibility

Bạn có thể kiểm soát khả năng hiển thị của Chip bằng cách sử dụng prop `show`.

::component-example{name="chip-show-example"}
::

::note
Trong ví dụ này, Chip có màu cho mỗi trạng thái và được hiển thị khi trạng thái không phải là `offline`.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Collapsible

## Usage

Sử dụng một [Button](https://nuxt.com/components/button) hoặc bất kỳ thành phần nào khác trong slot mặc định của Collapsible.

Sau đó, sử dụng slot `#content` để thêm nội dung được hiển thị khi Collapsible mở.

::component-code
---
ignore:
  - class
prettier: true
props:
  class: flex flex-col gap-2 w-48
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-down" block />
  content: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  block: true
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-down
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48}
  :::
::

### Unmount

Sử dụng prop `unmount-on-hide` để ngăn nội dung bị gỡ bỏ khi Collapsible bị thu gọn. Mặc định là `true`.

::component-code
---
ignore:
  - class
prettier: true
props:
  unmountOnHide: false
  class: flex flex-col gap-2 w-48
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-down" block />
  content: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  block: true
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-down
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48}
  :::
::

::note
Bạn có thể kiểm tra DOM để xem nội dung đang được hiển thị.
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Collapsible.

::component-code
---
ignore:
  - class
prettier: true
props:
  class: flex flex-col gap-2 w-48
  disabled: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-down" block />
  content: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  block: true
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-down
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48}
  :::
::

## Examples

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc chỉ thị `v-model:open`.

::component-example{name="collapsible-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi Collapsible bằng cách nhấn ``.
::

::tip
Điều này cho phép bạn di chuyển trigger bên ngoài Collapsible hoặc loại bỏ nó hoàn toàn.
::

### With rotating icon

Đây là một ví dụ với biểu tượng xoay trong Button cho biết trạng thái mở của Collapsible.

::component-example{name="collapsible-icon-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# ColorPicker

## Usage

Sử dụng chỉ thị `v-model` để kiểm soát giá trị của ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: "#00C16A"
---
::

Sử dụng prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":"#00BCD4"}'}
::

### RGB Format

Sử dụng prop `format` để đặt giá trị `rgb` của ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: rgb
  modelValue: rgb(0, 193, 106)
---
::

### HSL Format

Sử dụng prop `format` để đặt giá trị `hsl` của ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: hsl
  modelValue: hsl(153, 100%, 37.8%)
---
::

### CMYK Format

Sử dụng prop `format` để đặt giá trị `cmyk` của ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: cmyk
  modelValue: cmyk(100%, 0%, 45.08%, 24.31%)
---
::

### CIELab Format

Sử dụng prop `format` để đặt giá trị `lab` của ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - format
props:
  format: lab
  modelValue: lab(68.88% -60.41% 32.55%)
---
::

### Throttle

Sử dụng prop `throttle` để đặt giá trị throttle của ColorPicker.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  throttle: 100
  modelValue: "#00C16A"
---
::

### Size

Sử dụng prop `size` để đặt kích thước của ColorPicker.

::component-code{:props='{"size":"xl"}'}
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa ColorPicker.

::component-code{:props='{"disabled":true}'}
::

## Examples

### As a Color chooser

Sử dụng một thành phần [Button](https://nuxt.com/components/button) và [Popover](https://nuxt.com/components/popover) để tạo một bộ chọn màu.

::component-example{name="color-picker-chooser-example"}
::

## API

### Props

::component-props
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# CommandPalette

## Usage

Sử dụng chỉ thị `v-model` để kiểm soát giá trị của CommandPalette hoặc prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::tip{to="https://nuxt.com/#control-selected-items"}
Bạn cũng có thể sử dụng sự kiện `@update:model-value` để lắng nghe mục đã chọn.
::

### Groups

Thành phần CommandPalette lọc các nhóm và xếp hạng các lệnh khớp theo mức độ liên quan khi người dùng nhập. Nó cung cấp kết quả tìm kiếm động, tức thì để khám phá lệnh hiệu quả. Sử dụng prop `groups` dưới dạng mảng các đối tượng với các thuộc tính sau:

- `id: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `items?: CommandPaletteItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`ignoreFilter?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-ignore-filter)
- [`postFilter?: (searchTerm: string, items: T[]) => T[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-post-filtered-items)
- `highlightedIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::caution
Bạn phải cung cấp `id` cho mỗi nhóm nếu không nhóm sẽ bị bỏ qua.
::

Mỗi nhóm chứa mảng `items` các đối tượng định nghĩa các lệnh. Mỗi mục có thể có các thuộc tính sau:

- `prefix?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `suffix?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `kbds?: string[] | KbdProps[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `active?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `loading?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `placeholder?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `children?: CommandPaletteItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e?: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLabel?: ClassNameValue, itemLabelPrefix?: ClassNameValue, itemLabelBase?: ClassNameValue, itemLabelSuffix?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingKbds?: ClassNameValue, itemTrailingKbdsSize?: ClassNameValue, itemTrailingHighlightedIcon?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Link](https://nuxt.com/components/link#props) như `to`, `target`, v.v.

::component-code
---
collapse: true
external:
  - groups
  - modelValue
hide:
  - autofocus
ignore:
  - groups
  - modelValue
  - class
props:
  modelValue: {}
  autofocus: false
  groups:
    - id: users
      label: Users
      items:
        - label: Benjamin Canac
          suffix: benjamincanac
          avatar:
            src: https://github.com/benjamincanac.png
        - label: Sylvain Marroufin
          suffix: smarroufin
          avatar:
            src: https://github.com/smarroufin.png
        - label: Sébastien Chopin
          suffix: atinux
          avatar:
            src: https://github.com/atinux.png
        - label: Romain Hamel
          suffix: romhml
          avatar:
            src: https://github.com/romhml.png
        - label: Haytham A. Salama
          suffix: Haythamasalama
          avatar:
            src: https://github.com/Haythamasalama.png
        - label: Daniel Roe
          suffix: danielroe
          avatar:
            src: https://github.com/danielroe.png
        - label: Neil Richter
          suffix: noook
          avatar:
            src: https://github.com/noook.png
  class: flex-1
class: "!p-0"
---
::

::tip{to="https://nuxt.com/#with-children-in-items"}
Mỗi mục có thể lấy mảng `children` các đối tượng với các thuộc tính sau để tạo menu con:
::

### Multiple

Sử dụng prop `multiple` để cho phép nhiều lựa chọn.

::component-code
---
collapse: true
external:
  - groups
  - modelValue
hide:
  - autofocus
ignore:
  - groups
  - modelValue
  - multiple
  - class
props:
  multiple: true
  autofocus: false
  modelValue: []
  groups:
    - id: users
      label: Users
      items:
        - label: Benjamin Canac
          suffix: benjamincanac
          avatar:
            src: https://github.com/benjamincanac.png
        - label: Sylvain Marroufin
          suffix: smarroufin
          avatar:
            src: https://github.com/smarroufin.png
        - label: Sébastien Chopin
          suffix: atinux
          avatar:
            src: https://github.com/atinux.png
        - label: Romain Hamel
          suffix: romhml
          avatar:
            src: https://github.com/romhml.png
        - label: Haytham A. Salama
          suffix: Haythamasalama
          avatar:
            src: https://github.com/Haythamasalama.png
        - label: Daniel Roe
          suffix: danielroe
          avatar:
            src: https://github.com/danielroe.png
        - label: Neil Richter
          suffix: noook
          avatar:
            src: https://github.com/noook.png
  class: flex-1
class: "!p-0"
---
::

::caution
Đảm bảo truyền một mảng cho prop `default-value` hoặc chỉ thị `v-model`.
::

### Placeholder

Sử dụng prop `placeholder` để thay đổi văn bản placeholder.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  placeholder: Search an app...
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

### Icon

Sử dụng prop `icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) đầu vào. Mặc định là `i-lucide-search`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  icon: i-lucide-box
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.search`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.search`.
  :::
::

### Selected Icon

Sử dụng prop `selected-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) mục đã chọn. Mặc định là `i-lucide-check`.

::component-code
---
collapse: true
external:
  - groups
  - modelValue
hide:
  - autofocus
ignore:
  - groups
  - modelValue
  - multiple
  - class
props:
  multiple: true
  autofocus: false
  modelValue:
    - label: Benjamin Canac
      suffix: benjamincanac
      avatar:
        src: https://github.com/benjamincanac.png
  selectedIcon: i-lucide-circle-check
  groups:
    - id: users
      label: Users
      items:
        - label: Benjamin Canac
          suffix: benjamincanac
          avatar:
            src: https://github.com/benjamincanac.png
        - label: Sylvain Marroufin
          suffix: smarroufin
          avatar:
            src: https://github.com/smarroufin.png
        - label: Sébastien Chopin
          suffix: atinux
          avatar:
            src: https://github.com/atinux.png
        - label: Romain Hamel
          suffix: romhml
          avatar:
            src: https://github.com/romhml.png
        - label: Haytham A. Salama
          suffix: Haythamasalama
          avatar:
            src: https://github.com/Haythamasalama.png
        - label: Daniel Roe
          suffix: danielroe
          avatar:
            src: https://github.com/danielroe.png
        - label: Neil Richter
          suffix: noook
          avatar:
            src: https://github.com/noook.png
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::
::

### Trailing Icon

Sử dụng prop `trailing-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) theo sau khi một mục có con. Mặc định là `i-lucide-chevron-right`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - groups
  - class
prettier: true
props:
  autofocus: false
  trailingIcon: i-lucide-arrow-right
  groups:
    - id: actions
      items:
        - label: Share
          icon: i-lucide-share
          children:
            - label: Email
              icon: i-lucide-mail
            - label: Copy
              icon: i-lucide-copy
            - label: Link
              icon: i-lucide-link
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.chevronRight`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.chevronRight`.
  :::
::

### Loading

Sử dụng prop `loading` để hiển thị biểu tượng tải trên CommandPalette.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  loading: true
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh biểu tượng tải. Mặc định là `i-lucide-loader-circle`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
props:
  autofocus: false
  loading: true
  loadingIcon: i-lucide-loader
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Close

Sử dụng prop `close` để hiển thị [Button](https://nuxt.com/components/button) để đóng CommandPalette.

::tip
Sự kiện `update:open` sẽ được phát ra khi nút đóng được nhấp.
::

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
  - close
props:
  autofocus: false
  close: true
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Button](https://nuxt.com/components/button) để tùy chỉnh nó.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - close.color
  - close.variant
  - groups
  - class
prettier: true
props:
  autofocus: false
  close:
    color: primary
    variant: outline
    class: rounded-full
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

### Close Icon

Sử dụng prop `close-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) nút đóng. Mặc định là `i-lucide-x`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
  - close
props:
  autofocus: false
  close: true
  closeIcon: i-lucide-arrow-right
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::
::

### Back

Sử dụng prop `back` để tùy chỉnh hoặc ẩn nút quay lại (với giá trị `false`) được hiển thị khi điều hướng vào menu con.

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Button](https://nuxt.com/components/button) để tùy chỉnh nó.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - back.color
  - groups
  - class
prettier: true
props:
  autofocus: false
  back:
    color: primary
  groups:
    - id: actions
      items:
        - label: Share
          icon: i-lucide-share
          children:
            - label: Email
              icon: i-lucide-mail
            - label: Copy
              icon: i-lucide-copy
            - label: Link
              icon: i-lucide-link
  class: flex-1
class: "!p-0"
---
::

### Back Icon

Sử dụng prop `back-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) nút quay lại. Mặc định là `i-lucide-arrow-left`.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - class
  - groups
  - back
props:
  autofocus: false
  back: true
  backIcon: i-lucide-house
  groups:
    - id: actions
      items:
        - label: Share
          icon: i-lucide-share
          children:
            - label: Email
              icon: i-lucide-mail
            - label: Copy
              icon: i-lucide-copy
            - label: Link
              icon: i-lucide-link
  class: flex-1
class: "!p-0"
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.arrowLeft`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.arrowLeft`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa CommandPalette.

::component-code
---
collapse: true
external:
  - groups
hide:
  - autofocus
ignore:
  - groups
  - class
props:
  autofocus: false
  disabled: true
  groups:
    - id: apps
      items:
        - label: Calendar
          icon: i-lucide-calendar
        - label: Music
          icon: i-lucide-music
        - label: Maps
          icon: i-lucide-map
  class: flex-1
class: "!p-0"
---
::

## Examples

### Control selected item(s)

Bạn có thể kiểm soát mục đã chọn bằng cách sử dụng prop `default-value` hoặc chỉ thị `v-model`, bằng cách sử dụng trường `onSelect` trên mỗi mục hoặc bằng cách sử dụng sự kiện `@update:model-value`.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-select-example
---
::

### Control search term

Sử dụng chỉ thị `v-model:search-term` để kiểm soát thuật ngữ tìm kiếm.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-search-term-example
---
::

::note
Ví dụ này sử dụng sự kiện `@update:model-value` để đặt lại thuật ngữ tìm kiếm khi một mục được chọn.
::

### With children in items

Bạn có thể tạo menu phân cấp bằng cách sử dụng thuộc tính `children` trong các mục. Khi một mục có con, nó sẽ tự động hiển thị biểu tượng chevron và cho phép điều hướng vào menu con.

::component-example
---
collapse: true
prettier: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-items-children-example
---
::

::note
Khi điều hướng vào menu con:

- Thuật ngữ tìm kiếm được đặt lại
- Nút quay lại xuất hiện trong đầu vào
- Bạn có thể quay lại nhóm trước bằng cách nhấn phím ``
::

### With fetched items

Bạn có thể lấy các mục từ API và sử dụng chúng trong CommandPalette.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-fetch-example
---
::

### With ignore filter

Bạn có thể đặt trường `ignoreFilter` thành `true` trên một nhóm để vô hiệu hóa tìm kiếm nội bộ và sử dụng logic tìm kiếm của riêng bạn.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-ignore-filter-example
---
::

::note
Ví dụ này sử dụng [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} để debounce các cuộc gọi API.
::

### With post-filtered items

Bạn có thể sử dụng trường `postFilter` trên một nhóm để lọc các mục sau khi tìm kiếm xảy ra.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-post-filter-example
---
::

::note
Bắt đầu nhập để xem các mục có mức độ cao hơn xuất hiện.
::

### With custom fuse search

Bạn có thể sử dụng prop `fuse` để ghi đè các tùy chọn của [useFuse](https://vueuse.org/integrations/useFuse){rel="nofollow"} mặc định là:

```ts
{
  fuseOptions: {
    ignoreLocation: true,
    threshold: 0.1,
    keys: ['label', 'suffix']
  },
  resultLimit: 12,
  matchAllWhenSearchEmpty: true
}
```

::tip
`fuseOptions` là các tùy chọn của [Fuse.js](https://www.fusejs.io/api/options.html){rel="nofollow"}, `resultLimit` là số lượng kết quả tối đa để trả về và `matchAllWhenSearchEmpty` là boolean để khớp tất cả các mục khi thuật ngữ tìm kiếm trống.
::

Ví dụ, bạn có thể đặt `{ fuseOptions: { includeMatches: true } }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} để làm nổi bật thuật ngữ tìm kiếm trong các mục.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-fuse-example
---
::

### Within a Popover

Bạn có thể sử dụng thành phần CommandPalette bên trong nội dung của [Popover](https://nuxt.com/components/popover).

::component-example
---
collapse: true
props:
  autofocus: false
name: popover-command-palette-example
---
::

### Within a Modal

Bạn có thể sử dụng thành phần CommandPalette bên trong nội dung của [Modal](https://nuxt.com/components/modal).

::component-example
---
collapse: true
props:
  autofocus: false
name: modal-command-palette-example
---
::

### Within a Drawer

Bạn có thể sử dụng thành phần CommandPalette bên trong nội dung của [Drawer](https://nuxt.com/components/drawer).

::component-example
---
collapse: true
props:
  autofocus: false
name: drawer-command-palette-example
---
::

### Listen open state

Khi sử dụng prop `close`, bạn có thể lắng nghe sự kiện `update:open` khi nút được nhấp.

::component-example
---
collapse: true
props:
  autofocus: false
name: command-palette-open-example
---
::

::note
Điều này có thể hữu ích khi sử dụng CommandPalette bên trong [`Modal`](https://nuxt.com/components/modal) chẳng hạn.
::

### With footer slot :badge{.align-text-top label="New"}

Sử dụng slot `#footer` để thêm nội dung tùy chỉnh ở cuối CommandPalette, chẳng hạn như trợ giúp phím tắt hoặc hành động bổ sung.

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-footer-slot-example
---
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục hoặc nhóm cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ group.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example
---
collapse: true
props:
  autofocus: false
class: "!p-0"
name: command-palette-custom-slot-example
---
::

::tip{to="https://nuxt.com/#slots"}
Bạn cũng có thể sử dụng các slot `#item`, `#item-leading`, `#item-label` và `#item-trailing` để tùy chỉnh tất cả các mục.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Container

## Usage

::component-example{:props='{"class":"w-full"}' name="container-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# ContextMenu

## Usage

Sử dụng bất kỳ thứ gì bạn thích trong slot mặc định của ContextMenu, và nhấp chuột phải vào nó để hiển thị menu.

### Items

Sử dụng prop `items` dưới dạng mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `kbds?: string[] | KbdProps[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "link" | "label" | "separator" | "checkbox"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- [`color?: "error" | "primary" | "secondary" | "success" | "info" | "warning" | "neutral"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-color-items)
- [`checked?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`onUpdateChecked?(checked: boolean): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `children?: ContextMenuItem[] | ContextMenuItem[][]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, label?: ClassNameValue, separator?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLabel?: ClassNameValue, itemLabelExternalIcon?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue, itemTrailingKbds?: ClassNameValue, itemTrailingKbdsSize?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Link](https://nuxt.com/components/link#props) như `to`, `target`, v.v.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - ContextMenuItem[][]
ignore:
  - items
  - ui.content
prettier: true
props:
  items:
    - - label: Appearance
        children:
          - label: System
            icon: i-lucide-monitor
          - label: Light
            icon: i-lucide-sun
          - label: Dark
            icon: i-lucide-moon
    - - label: Show Sidebar
        kbds:
          - meta
          - s
      - label: Show Toolbar
        kbds:
          - shift
          - meta
          - d
      - label: Collapse Pinned Tabs
        disabled: true
    - - label: Refresh the Page
      - label: Clear Cookies and Refresh
      - label: Clear Cache and Refresh
      - type: separator
      - label: Developer
        children:
          - - label: View Source
              kbds:
                - meta
                - shift
                - u
            - label: Developer Tools
              kbds:
                - option
                - meta
                - i
            - label: Inspect Elements
              kbds:
                - option
                - meta
                - c
          - - label: JavaScript Console
              kbds:
                - option
                - meta
                - j
  ui:
    content: w-48
slots:
  default: >
    
    <div class="flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72">
      Right click here
    </div>
---
  :::div
  ---
  class: flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72
  ---
  Right click here
  :::
::

::note
Bạn cũng có thể truyền một mảng các mảng cho prop `items` để tạo các nhóm mục được tách biệt.
::

::tip
Mỗi mục có thể lấy mảng `children` các đối tượng với các thuộc tính giống như prop `items` để tạo menu lồng nhau có thể được kiểm soát bằng cách sử dụng các thuộc tính `open`, `defaultOpen` và `content`.
::

### Size

Sử dụng prop `size` để thay đổi kích thước của ContextMenu.

::component-code
---
external:
  - items
externalTypes:
  - ContextMenuItem[]
ignore:
  - items
  - ui.content
prettier: true
props:
  size: xl
  items:
    - label: System
      icon: i-lucide-monitor
    - label: Light
      icon: i-lucide-sun
    - label: Dark
      icon: i-lucide-moon
  ui:
    content: w-48
slots:
  default: >
    
    <div class="flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72">
      Right click here
    </div>
---
  :::div
  ---
  class: flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72
  ---
  Right click here
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa ContextMenu.

::component-code
---
external:
  - items
externalTypes:
  - ContextMenuItem[]
ignore:
  - items
  - ui.content
prettier: true
props:
  disabled: true
  items:
    - label: System
      icon: i-lucide-monitor
    - label: Light
      icon: i-lucide-sun
    - label: Dark
      icon: i-lucide-moon
  ui:
    content: w-48
slots:
  default: >
    
    <div class="flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72">
      Right click here
    </div>
---
  :::div
  ---
  class: flex items-center justify-center rounded-md border border-dashed
    border-accented text-sm aspect-video w-72
  ---
  Right click here
  :::
::

## Examples

### With checkbox items

Bạn có thể sử dụng thuộc tính `type` với `checkbox` và sử dụng các thuộc tính `checked` / `onUpdateChecked` để kiểm soát trạng thái đã kiểm tra của mục.

::component-example{collapse name="context-menu-checkbox-items-example"}
::

::note
Để đảm bảo tính phản ứng cho trạng thái `checked` của các mục, bạn nên bao bọc mảng `items` của bạn bên trong một `computed`.
::

### With color items

Bạn có thể sử dụng thuộc tính `color` để làm nổi bật một số mục với màu sắc.

::component-example{name="context-menu-color-items-example"}
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="context-menu-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
Bạn cũng có thể sử dụng các slot `#item`, `#item-leading`, `#item-label` và `#item-trailing` để tùy chỉnh tất cả các mục.
::

### Extract shortcuts

Khi bạn có một số mục với thuộc tính `kbds` (hiển thị một số [Kbd](https://nuxt.com/components/kbd)), bạn có thể dễ dàng làm cho chúng hoạt động với composable [defineShortcuts](https://nuxt.com/composables/define-shortcuts).

Bên trong composable `defineShortcuts`, có một tiện ích `extractShortcuts` sẽ trích xuất các phím tắt đệ quy từ các mục và trả về một đối tượng mà bạn có thể truyền cho `defineShortcuts`. Nó sẽ tự động gọi hàm `select` của mục khi phím tắt được nhấn.

```vue
<script setup lang="ts">
const items = [
  [{
    label: 'Show Sidebar',
    kbds: ['meta', 'S'],
    onSelect() {
      console.log('Show Sidebar clicked')
    }
  }, {
    label: 'Show Toolbar',
    kbds: ['shift', 'meta', 'D'],
    onSelect() {
      console.log('Show Toolbar clicked')
    }
  }, {
    label: 'Collapse Pinned Tabs',
    disabled: true
  }], [{
    label: 'Refresh the Page'
  }, {
    label: 'Clear Cookies and Refresh'
  }, {
    label: 'Clear Cache and Refresh'
  }, {
    type: 'separator' as const
  }, {
    label: 'Developer',
    children: [[{
      label: 'View Source',
      kbds: ['option', 'meta', 'U'],
      onSelect() {
        console.log('View Source clicked')
      }
    }, {
      label: 'Developer Tools',
      kbds: ['option', 'meta', 'I'],
      onSelect() {
        console.log('Developer Tools clicked')
      }
    }], [{
      label: 'Inspect Elements',
      kbds: ['option', 'meta', 'C'],
      onSelect() {
        console.log('Inspect Elements clicked')
      }
    }], [{
      label: 'JavaScript Console',
      kbds: ['option', 'meta', 'J'],
      onSelect() {
        console.log('JavaScript Console clicked')
      }
    }]]
  }]
]

defineShortcuts(extractShortcuts(items))
</script>
```

::note
Trong ví dụ này, `` ``, `` `` ``, `` `` ``, `` `` ``, `` `` `` và `` `` `` sẽ kích hoạt hàm `select` của mục tương ứng.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Drawer

## Usage

Sử dụng một [Button](https://nuxt.com/components/button) hoặc bất kỳ thành phần nào khác trong slot mặc định của Drawer.

Sau đó, sử dụng slot `#content` để thêm nội dung hiển thị khi Drawer mở.

::component-code
---
prettier: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

Bạn cũng có thể sử dụng các slot `#header`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}, `#body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} và `#footer`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} để tùy chỉnh nội dung của Drawer.

### Title

Sử dụng prop `title` để đặt tiêu đề cho header của Drawer.

::component-code
---
prettier: true
props:
  title: Drawer with title
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Description

Sử dụng prop `description` để đặt mô tả cho header của Drawer.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Drawer with description
  description: Lorem ipsum dolor sit amet, consectetur adipiscing elit.
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Direction

Sử dụng prop `direction` để kiểm soát hướng của Drawer. Mặc định là `bottom`.

::component-code
---
prettier: true
props:
  direction: right
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="min-w-96 min-h-96 size-full m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.min-w-96.min-h-96.size-full.m-4}
  :::
::

### Inset

Sử dụng prop `inset` để chèn Drawer từ các cạnh.

::component-code
---
prettier: true
props:
  direction: right
  inset: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="min-w-96 min-h-96 size-full m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.min-w-96.min-h-96.size-full.m-4}
  :::
::

### Handle

Sử dụng prop `handle` để kiểm soát xem Drawer có tay nắm hay không. Mặc định là `true`.

::component-code
---
prettier: true
props:
  handle: false
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

### Handle Only

Sử dụng prop `handle-only` để chỉ cho phép kéo Drawer bằng tay nắm.

::component-code
---
prettier: true
props:
  handleOnly: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

### Overlay

Sử dụng prop `overlay` để kiểm soát xem Drawer có overlay hay không. Mặc định là `true`.

::component-code
---
prettier: true
props:
  overlay: false
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

### Scale background

Sử dụng prop `should-scale-background` để thu nhỏ nền khi Drawer mở, tạo hiệu ứng chiều sâu thị giác. Bạn có thể đặt prop `set-background-color-on-scale` thành `false` để ngăn thay đổi màu nền.

::component-code
---
prettier: true
props:
  shouldScaleBackground: true
  setBackgroundColorOnScale: true
slots:
  default: >
    
    <UButton label="Open" color="neutral" variant="subtle"
    trailing-icon="i-lucide-chevron-up" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button
  ---
  color: neutral
  label: Open
  trailing-icon: i-lucide-chevron-up
  variant: subtle
  ---
  :::

#content
  :::placeholder{.h-screen.m-4}
  :::
::

::warning
Hãy đảm bảo thêm directive `data-vaul-drawer-wrapper` vào một phần tử cha của ứng dụng của bạn để điều này hoạt động.

```vue [app.vue]
<template>
  <UApp>
    <div class="bg-default" data-vaul-drawer-wrapper>
      <NuxtLayout>
        <NuxtPage />
      </NuxtLayout>
    </div>
  </UApp>
</template>
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    rootAttrs: {
      'data-vaul-drawer-wrapper': '',
      'class': 'bg-default'
    }
  }
})
```
::

## Examples

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{prettier name="drawer-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi Drawer bằng cách nhấn ``.
::

::tip
Điều này cho phép bạn di chuyển trigger ra ngoài Drawer hoặc loại bỏ nó hoàn toàn.
::

### Disable dismissal

Đặt prop `dismissible` thành `false` để ngăn Drawer bị đóng khi nhấp bên ngoài hoặc nhấn escape.

::component-example{prettier name="drawer-dismissible-example"}
::

::note
Trong ví dụ này, slot `header` được sử dụng để thêm nút đóng mà không được thực hiện theo mặc định.
::

### With interactive background

Đặt prop `overlay` và `modal` thành `false` cùng với prop `dismissible` để làm cho nền của Drawer tương tác mà không đóng Drawer.

::component-example{prettier name="drawer-modal-example"}
::

### Responsive drawer

Bạn có thể render một thành phần [Modal](https://nuxt.com/components/modal) trên desktop và một Drawer trên mobile ví dụ.

::component-example{prettier name="drawer-responsive-example"}
::

### Nested drawers :badge{.align-text-top label="New"}

Bạn có thể lồng các drawer vào nhau bằng cách sử dụng prop `nested`.

::component-example{prettier name="drawer-nested-example"}
::

### With footer slot

Sử dụng slot `#footer` để thêm nội dung sau body của Drawer.

::component-example{collapse prettier name="drawer-footer-slot-example"}
::

### With command palette

Bạn có thể sử dụng một thành phần [CommandPalette](https://nuxt.com/components/command-palette) bên trong nội dung của Drawer.

::component-example{collapse name="drawer-command-palette-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# DropdownMenu

## Usage

Sử dụng một [Button](https://nuxt.com/components/button) hoặc bất kỳ thành phần nào khác trong slot mặc định của DropdownMenu.

### Items

Sử dụng prop `items` dưới dạng một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `kbds?: string[] | KbdProps[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "link" | "label" | "separator" | "checkbox"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- [`color?: "error" | "primary" | "secondary" | "success" | "info" | "warning" | "neutral"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-color-items)
- [`checked?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`onUpdateChecked?(checked: boolean): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-checkbox-items)
- `children?: DropdownMenuItem[] | DropdownMenuItem[][]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, label?: ClassNameValue, separator?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLabel?: ClassNameValue, itemLabelExternalIcon?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue, itemTrailingKbds?: ClassNameValue, itemTrailingKbdsSize?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Link](https://nuxt.com/components/link#props) như `to`, `target`, v.v.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - DropdownMenuItem[][]
ignore:
  - items
  - ui.content
prettier: true
props:
  items:
    - - label: Benjamin
        avatar:
          src: https://github.com/benjamincanac.png
        type: label
    - - label: Profile
        icon: i-lucide-user
      - label: Billing
        icon: i-lucide-credit-card
      - label: Settings
        icon: i-lucide-cog
        kbds:
          - ","
      - label: Keyboard shortcuts
        icon: i-lucide-monitor
    - - label: Team
        icon: i-lucide-users
      - label: Invite users
        icon: i-lucide-user-plus
        children:
          - - label: Email
              icon: i-lucide-mail
            - label: Message
              icon: i-lucide-message-square
          - - label: More
              icon: i-lucide-circle-plus
      - label: New team
        icon: i-lucide-plus
        kbds:
          - meta
          - n
    - - label: GitHub
        icon: i-simple-icons-github
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Support
        icon: i-lucide-life-buoy
        to: /components/dropdown-menu
      - label: API
        icon: i-lucide-cloud
        disabled: true
    - - label: Logout
        icon: i-lucide-log-out
        kbds:
          - shift
          - meta
          - q
  ui:
    content: w-48
slots:
  default: |
    
    <UButton icon="i-lucide-menu" color="neutral" variant="outline" />
---
  :::u-button{color="neutral" icon="i-lucide-menu" variant="outline"}
  :::
::

::note
Bạn cũng có thể truyền một mảng các mảng cho prop `items` để tạo các nhóm mục được tách biệt.
::

::tip
Mỗi mục có thể nhận một mảng `children` các đối tượng với các thuộc tính giống như prop `items` để tạo một menu lồng nhau có thể được kiểm soát bằng các thuộc tính `open`, `defaultOpen` và `content`.
::

### Content

Sử dụng prop `content` để kiểm soát cách nội dung DropdownMenu được render, như `align` hoặc `side` của nó ví dụ.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - items
  - ui.content
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  content:
    align: start
    side: bottom
    sideOffset: 8
  ui:
    content: w-48
slots:
  default: >
    
    <UButton label="Open" icon="i-lucide-menu" color="neutral" variant="outline"
    />
---
  :::u-button{color="neutral" icon="i-lucide-menu" label="Open" variant="outline"}
  :::
::

### Arrow

Sử dụng prop `arrow` để hiển thị một mũi tên trên DropdownMenu.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - arrow
  - items
  - ui.content
prettier: true
props:
  arrow: true
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  ui:
    content: w-48
slots:
  default: >
    
    <UButton label="Open" icon="i-lucide-menu" color="neutral" variant="outline"
    />
---
  :::u-button{color="neutral" icon="i-lucide-menu" label="Open" variant="outline"}
  :::
::

### Size

Sử dụng prop `size` để kiểm soát kích thước của DropdownMenu.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - items
  - content.align
  - ui.content
prettier: true
props:
  size: xl
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  content:
    align: start
  ui:
    content: w-48
slots:
  default: >
    
    <UButton size="xl" label="Open" icon="i-lucide-menu" color="neutral"
    variant="outline" />
---
  :::u-button
  ---
  color: neutral
  icon: i-lucide-menu
  label: Open
  size: xl
  variant: outline
  ---
  :::
::

::warning
Prop `size` sẽ không được ủy quyền cho Button, bạn cần đặt nó tự mình.
::

::note
Khi sử dụng cùng kích thước, các mục DropdownMenu sẽ được căn chỉnh hoàn hảo với Button.
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa DropdownMenu.

::component-code
---
external:
  - items
externalTypes:
  - DropdownMenuItem[]
ignore:
  - items
  - ui.content
prettier: true
props:
  disabled: true
  items:
    - label: Profile
      icon: i-lucide-user
    - label: Billing
      icon: i-lucide-credit-card
    - label: Settings
      icon: i-lucide-cog
  ui:
    content: w-48
slots:
  default: >
    
    <UButton label="Open" icon="i-lucide-menu" color="neutral" variant="outline"
    />
---
  :::u-button{color="neutral" icon="i-lucide-menu" label="Open" variant="outline"}
  :::
::

## Examples

### With checkbox items

Bạn có thể sử dụng thuộc tính `type` với `checkbox` và sử dụng các thuộc tính `checked` / `onUpdateChecked` để kiểm soát trạng thái đã kiểm tra của mục.

::component-example{collapse name="dropdown-menu-checkbox-items-example"}
::

::note
Để đảm bảo tính phản ứng cho trạng thái `checked` của các mục, nên bọc mảng `items` của bạn bên trong một `computed`.
::

### With color items

Bạn có thể sử dụng thuộc tính `color` để làm nổi bật một số mục với một màu sắc.

::component-example{name="dropdown-menu-color-items-example"}
::

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="dropdown-menu-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi DropdownMenu bằng cách nhấn ``.
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="dropdown-menu-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
Bạn cũng có thể sử dụng các slot `#item`, `#item-leading`, `#item-label` và `#item-trailing` để tùy chỉnh tất cả các mục.
::

### Extract shortcuts

Khi bạn có một số mục với thuộc tính `kbds` (hiển thị một số [Kbd](https://nuxt.com/components/kbd)), bạn có thể dễ dàng làm cho chúng hoạt động với composable [defineShortcuts](https://nuxt.com/composables/define-shortcuts).

Bên trong composable `defineShortcuts`, có một tiện ích `extractShortcuts` sẽ trích xuất các phím tắt một cách đệ quy từ các mục và trả về một đối tượng mà bạn có thể truyền cho `defineShortcuts`. Nó sẽ tự động gọi hàm `select` của mục khi phím tắt được nhấn.

```vue
<script setup lang="ts">
import type { DropdownMenuItem } from '@nuxt/ui'

const items: DropdownMenuItem[] = [{
  label: 'Invite users',
  icon: 'i-lucide-user-plus',
  children: [{
    label: 'Invite by email',
    icon: 'i-lucide-send-horizontal',
    kbds: ['meta', 'e'],
    onSelect() {
      console.log('Invite by email clicked')
    }
  }, {
    label: 'Invite by link',
    icon: 'i-lucide-link',
    kbds: ['meta', 'i'],
    onSelect() {
      console.log('Invite by link clicked')
    }
  }]
}, {
  label: 'New team',
  icon: 'i-lucide-plus',
  kbds: ['meta', 'n'],
  onSelect() {
    console.log('New team clicked')
  }
}]

defineShortcuts(extractShortcuts(items))
</script>
```

::note
Trong ví dụ này, `` ``, `` `` và `` `` sẽ kích hoạt hàm `select` của mục tương ứng.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# FileUpload

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của FileUpload.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - class
props:
  modelValue: null
  class: w-96 min-h-48
---
::

### Multiple

Sử dụng prop `multiple` để cho phép chọn nhiều tệp.

::component-code
---
ignore:
  - class
props:
  multiple: true
  class: w-96 min-h-48
---
::

### Dropzone

Sử dụng prop `dropzone` để bật/tắt khu vực thả. Mặc định là `true`.

::component-code
---
ignore:
  - class
props:
  dropzone: false
  class: w-96 min-h-48
---
::

### Interactive

Sử dụng prop `interactive` để bật/tắt khu vực có thể nhấp. Mặc định là `true`.

::tip{to="https://nuxt.com/#with-files-bottom-slot"}
Điều này có thể hữu ích khi thêm một thành phần [`Button`](https://nuxt.com/components/button) trong slot `#actions`.
::

::component-code
---
ignore:
  - class
props:
  interactive: false
  class: w-96 min-h-48
---
::

### Accept

Sử dụng prop `accept` để chỉ định các loại tệp được phép cho input. Cung cấp một danh sách được phân tách bằng dấu phẩy của [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/MIME_types){rel="nofollow"} hoặc phần mở rộng tệp (ví dụ: `image/png,application/pdf,.jpg`). Mặc định là `*` (tất cả loại tệp).

::component-code
---
ignore:
  - accept
  - class
props:
  accept: image/*
  class: w-96 min-h-48
---
::

### Label

Sử dụng prop `label` để đặt nhãn của FileUpload.

::component-code
---
ignore:
  - class
prettier: true
props:
  label: Drop your image here
  class: w-96 min-h-48
---
::

### Description

Sử dụng prop `description` để đặt mô tả của FileUpload.

::component-code
---
ignore:
  - label
  - class
prettier: true
props:
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96 min-h-48
---
::

### Icon

Sử dụng prop `icon` để đặt biểu tượng của FileUpload. Mặc định là `i-lucide-upload`.

::component-code
---
ignore:
  - label
  - description
  - class
prettier: true
props:
  icon: i-lucide-image
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96 min-h-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.upload`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.upload`.
  :::
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của FileUpload.

::component-code
---
ignore:
  - label
  - description
  - class
prettier: true
props:
  color: neutral
  highlight: true
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96 min-h-48
---
::

::note
Prop `highlight` được sử dụng ở đây để hiển thị trạng thái focus. Nó được sử dụng nội bộ khi xảy ra lỗi xác thực.
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của FileUpload.

::component-code{:ignore='["class"]' :props='{"variant":"button"}'}
::

### Size

Sử dụng prop `size` để thay đổi kích thước của FileUpload.

::component-code
---
ignore:
  - label
  - description
  - class
prettier: true
props:
  size: xl
  variant: area
  label: Drop your image here
  description: SVG, PNG, JPG or GIF (max. 2MB)
---
::

### Layout

Sử dụng prop `layout` để thay đổi cách các tệp được hiển thị trong FileUpload. Mặc định là `grid`.

::warning
Prop này chỉ hoạt động khi `variant` là `area`.
::

::component-code
---
ignore:
  - label
  - description
  - multiple
  - class
  - ui.base
prettier: true
props:
  layout: list
  multiple: true
  label: Drop your images here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96
  ui:
    base: min-h-48
---
::

### Position

Sử dụng prop `position` để thay đổi vị trí của các tệp trong FileUpload. Mặc định là `outside`.

::warning
Prop này chỉ hoạt động khi `variant` là `area` và khi `layout` là `list`.
::

::component-code
---
ignore:
  - label
  - description
  - multiple
  - layout
  - class
  - ui.base
prettier: true
props:
  position: inside
  layout: list
  multiple: true
  label: Drop your images here
  description: SVG, PNG, JPG or GIF (max. 2MB)
  class: w-96
  ui:
    base: min-h-48
---
::

## Examples

### With Form validation

Bạn có thể sử dụng FileUpload trong các thành phần [Form](https://nuxt.com/components/form) và [FormField](https://nuxt.com/components/form-field) để xử lý xác thực và xử lý lỗi.

::component-example
---
collapse: true
prettier: true
name: file-upload-form-validation-example
---
::

### With default slot

Bạn có thể sử dụng slot mặc định để tạo thành phần FileUpload của riêng bạn.

::component-example{collapse prettier name="file-upload-default-slot-example"}
::

### With files-bottom slot

Bạn có thể sử dụng slot `files-bottom` để thêm một [Button](https://nuxt.com/components/button) dưới danh sách tệp để xóa tất cả tệp ví dụ.

::component-example
---
collapse: true
prettier: true
name: file-upload-files-bottom-slot-example
---
::

::note{to="https://nuxt.com/#interactive"}
Prop `interactive` được đặt thành `false` trong ví dụ này để ngăn khu vực có thể nhấp mặc định.
::

### With files-top slot

Bạn có thể sử dụng slot `files-top` để thêm một [Button](https://nuxt.com/components/button) trên danh sách tệp để thêm tệp mới ví dụ.

::component-example{collapse prettier name="file-upload-files-top-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                      | Type                                                                                                                                                       |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}    | `Ref<HTMLInputElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |
| `dropzoneRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLDivElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}   |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Form

## Usage

Sử dụng thành phần Form để xác thực dữ liệu form bằng cách sử dụng các thư viện xác thực như [Valibot](https://github.com/fabian-hiller/valibot){rel="nofollow"}, [Zod](https://github.com/colinhacks/zod){rel="nofollow"}, [Yup](https://github.com/jquense/yup){rel="nofollow"}, [Joi](https://github.com/hapijs/joi){rel="nofollow"}, [Superstruct](https://github.com/ianstormtaylor/superstruct){rel="nofollow"} hoặc logic xác thực của riêng bạn.

Nó hoạt động với thành phần [FormField](https://nuxt.com/components/form-field) để hiển thị thông báo lỗi xung quanh các phần tử form tự động.

### Schema Validation

Nó yêu cầu hai prop:

- `state` - một đối tượng reactive chứa trạng thái của form.
- `schema` - bất kỳ [Standard Schema](https://standardschema.dev/){rel="nofollow"} nào hoặc một schema từ [Yup](https://github.com/jquense/yup){rel="nofollow"}, [Joi](https://github.com/hapijs/joi){rel="nofollow"} hoặc [Superstruct](https://github.com/ianstormtaylor/superstruct){rel="nofollow"}.

::warning
**Không có thư viện xác thực nào được bao gồm** theo mặc định, đảm bảo bạn **cài đặt thư viện bạn cần**.
::

::tabs{.gap-0}
  :::component-example
  ---
  props:
    class: w-60
  label: Valibot
  name: form-example-valibot
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Zod
  name: form-example-zod
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Yup
  name: form-example-yup
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Joi
  name: form-example-joi
  ---
  :::

  :::component-example
  ---
  props:
    class: w-60
  label: Superstruct
  name: form-example-superstruct
  ---
  :::
::

Lỗi được báo cáo trực tiếp cho thành phần [FormField](https://nuxt.com/components/form-field) dựa trên prop `name` hoặc `error-pattern`. Điều này có nghĩa là các quy tắc xác thực được định nghĩa cho thuộc tính `email` trong schema của bạn sẽ được áp dụng cho `<FormField name="email">`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="vue"}.

Các quy tắc xác thực lồng nhau được xử lý bằng cách sử dụng ký hiệu chấm. Ví dụ, một quy tắc như `{ user: z.object({ email: z.string() }) }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts"} sẽ được áp dụng cho `<FormField name="user.email">`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="vue"}.

### Custom Validation

Sử dụng prop `validate` để áp dụng logic xác thực của riêng bạn.

Hàm xác thực phải trả về một danh sách lỗi với các thuộc tính sau:

- `message` - thông báo lỗi để hiển thị.
- `name` - `name` của `FormField` để gửi lỗi đến.

::tip
Nó có thể được sử dụng cùng với prop `schema` để xử lý các trường hợp phức tạp.
::

::component-example{:props='{"class":"w-60"}' name="form-example-basic"}
::

### Input Events

Thành phần Form tự động kích hoạt xác thực khi một input phát ra sự kiện `input`, `change`, hoặc `blur`.

- Xác thực trên `input` xảy ra **khi bạn gõ**.
- Xác thực trên `change` xảy ra khi bạn **cam kết với một giá trị**.
- Xác thực trên `blur` xảy ra khi một input **mất focus**.

Bạn có thể kiểm soát khi nào xác thực xảy ra bằng cách sử dụng prop `validate-on`.

::tip
Form luôn xác thực khi submit.
::

::component-example
---
options:
  - name: validate-on
    label: validate-on
    items:
      - input
      - change
      - blur
    default:
      - input
      - change
      - blur
    multiple: true
source: false
label: Default
name: form-example-elements
---
::

::tip
Bạn có thể sử dụng composable [`useFormField`](https://nuxt.com/composables/use-form-field) để triển khai điều này bên trong các thành phần của riêng bạn.
::

### Error Event

Bạn có thể lắng nghe sự kiện `@error` để xử lý lỗi. Sự kiện này được kích hoạt khi form được submit và chứa một mảng các đối tượng `FormError` với các trường sau:

- `id` - `id` của input.
- `name` - `name` của `FormField`
- `message` - thông báo lỗi để hiển thị.

Đây là một ví dụ tập trung vào phần tử input đầu tiên có lỗi sau khi form được submit:

::component-example
---
collapse: true
props:
  class: w-60
name: form-example-on-error
---
::

### Nesting Forms

Lồng các thành phần form cho phép bạn quản lý các cấu trúc dữ liệu phức tạp, chẳng hạn như danh sách hoặc các trường có điều kiện, hiệu quả hơn.

Ví dụ, nó có thể được sử dụng để thêm động các trường dựa trên input của người dùng:

::component-example{collapse name="form-example-nested"}
::

Hoặc để xác thực các input danh sách:

::component-example{collapse name="form-example-nested-list"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

You can access the typed component instance using [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const form = useTemplateRef('form')
</script>

<template>
  <UForm ref="form" />
</template>
```

This will give you access to the following:

| Name                                                                                                                                                                                                                                    | Type                                                                                                                                                                                                                                                                                         |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `submit()`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                  | `Promise<void>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} :br ::div{.text-toned.mt-1}
Triggers form submission.
::                                                                                         |
| `validate(opts: { name?: keyof T | (keyof T)[], silent?: boolean, nested?: boolean, transform?: boolean })`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Promise<T>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} :br ::div{.text-toned.mt-1}
Triggers form validation. Will raise any errors unless `opts.silent` is set to true.
::                                 |
| \`clear(path?: keyof T                                                                                                                                                                                                                  | RegExp)\`{lang="ts-type"}                                                                                                                                                                                                                                                                    |
| \`getErrors(path?: keyof T                                                                                                                                                                                                              | RegExp)\`{lang="ts-type"}                                                                                                                                                                                                                                                                    |
| \`setErrors(errors: FormError [], name?: keyof T                                                                                                                                                                                        | RegExp)\`{lang="ts-type"}                                                                                                                                                                                                                                                                    |
| `errors`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                    | `Ref<FormError[]>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} :br ::div{.text-toned.mt-1}
A reference to the array containing validation errors. Use this to access or manipulate the error information.
:: |
| `disabled`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                  | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                                                                   |
| `dirty`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                                     | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} `true` if at least one form field has been updated by the user.                                                                                   |
| `dirtyFields`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                               | `DeepReadonly<Set<keyof T>>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} Tracks fields that have been modified by the user.                                                                                  |
| `touchedFields`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                             | `DeepReadonly<Set<keyof T>>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} Tracks fields that the user interacted with.                                                                                        |
| `blurredFields`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                                             | `DeepReadonly<Set<keyof T>>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} Tracks fields blurred by the user.                                                                                                  |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# FormField

## Usage

Bao bọc bất kỳ thành phần form nào với FormField. Được sử dụng trong một [Form](https://nuxt.com/components/form), nó cung cấp xác thực và xử lý lỗi.

### Label

Sử dụng prop `label` để đặt nhãn cho điều khiển form.

::component-code
---
prettier: true
props:
  label: Email
slots:
  default: |
    
    <UInput placeholder="Enter your email" />
---
  :::u-input{placeholder="Enter your email"}
  :::
::

::note
Thuộc tính `for` của nhãn và điều khiển form được liên kết với một `id` duy nhất nếu không được cung cấp.
::

Khi sử dụng prop `required`, một dấu hoa thị được thêm bên cạnh nhãn.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  required: true
slots:
  default: |
    
    <UInput placeholder="Enter your email" />
---
  :::u-input{placeholder="Enter your email"}
  :::
::

### Description

Sử dụng prop `description` để cung cấp thông tin bổ sung dưới nhãn.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  description: We'll never share your email with anyone else.
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

### Hint

Sử dụng prop `hint` để hiển thị thông báo gợi ý bên cạnh nhãn.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  hint: Optional
slots:
  default: |
    
    <UInput placeholder="Enter your email" />
---
  :::u-input{placeholder="Enter your email"}
  :::
::

### Help

Sử dụng prop `help` để hiển thị thông báo trợ giúp dưới điều khiển form.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  help: Please enter a valid email address.
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

### Error

Sử dụng prop `error` để hiển thị thông báo lỗi dưới điều khiển form. Khi được sử dụng cùng với prop `help`, prop `error` có ưu tiên.

Khi được sử dụng bên trong một [Form](https://nuxt.com/components/form), điều này được đặt tự động khi xảy ra lỗi xác thực.

::component-code
---
ignore:
  - label
prettier: true
props:
  label: Email
  error: Please enter a valid email address.
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

::tip{to="https://nuxt.com/getting-started/theme#colors"}
Điều này đặt `color` thành `error` trên điều khiển form. Bạn có thể thay đổi nó toàn cục trong `app.config.ts` của bạn.
::

### Size

Sử dụng prop `size` để thay đổi kích thước của FormField, `size` được ủy quyền cho điều khiển form.

::component-code
---
ignore:
  - label
  - description
  - hint
  - help
prettier: true
props:
  label: Email
  description: We'll never share your email with anyone else.
  hint: Optional
  help: Please enter a valid email address.
  size: xl
slots:
  default: |
    
    <UInput placeholder="Enter your email" class="w-full" />
---
  :::u-input{.w-full placeholder="Enter your email"}
  :::
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Icon

## Usage

Sử dụng prop `name` để hiển thị một biểu tượng:

::component-code{:props='{"name":"i-lucide-lightbulb","class":"size-5"}'}
::

::framework-only
#nuxt
  :::caution{to="https://nuxt.com/getting-started/icons/nuxt#collections"}
  Khuyến nghị cao là cài đặt các bộ sưu tập biểu tượng bạn cần, đọc thêm về điều này.
  :::
::

## API

### Props

::component-props
::

## Changelog

::component-changelog
::


# Input

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của Input.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: ""
---
::

### Type

Sử dụng prop `type` để thay đổi loại input. Mặc định là `text`.

Một số loại đã được triển khai trong các thành phần riêng của chúng như [Checkbox](https://nuxt.com/components/checkbox), [Radio](https://nuxt.com/components/radio-group), [InputNumber](https://nuxt.com/components/input-number) v.v. và những loại khác đã được tạo kiểu như `file` ví dụ.

::component-code
---
items:
  type:
    - text
    - number
    - password
    - search
    - file
props:
  type: file
---
::

::callout
---
icon: i-simple-icons-mdnwebdocs
target: _blank
to: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types
---
Bạn có thể kiểm tra tất cả các loại có sẵn trên MDN Web Docs.
::

### Placeholder

Sử dụng prop `placeholder` để đặt văn bản placeholder.

::component-code{:props='{"placeholder":"Search..."}'}
::

### Color

Sử dụng prop `color` để thay đổi màu vòng khi Input được focus.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  highlight: true
  placeholder: Search...
---
::

::note
Prop `highlight` được sử dụng ở đây để hiển thị trạng thái focus. Nó được sử dụng nội bộ khi xảy ra lỗi xác thực.
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Input.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  variant: subtle
  highlight: false
  placeholder: Search...
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Input.

::component-code
---
ignore:
  - placeholder
props:
  size: xl
  placeholder: Search...
---
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong Input.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  icon: i-lucide-search
  size: md
  variant: outline
  placeholder: Search...
---
::

Sử dụng prop `leading` và `trailing` để đặt vị trí biểu tượng hoặc prop `leading-icon` và `trailing-icon` để đặt biểu tượng khác cho mỗi vị trí.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  trailingIcon: i-lucide-at-sign
  placeholder: Enter your email
  size: md
---
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong Input.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  variant: outline
  placeholder: Search...
---
::

### Loading

Sử dụng prop `loading` để hiển thị biểu tượng loading trên Input.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  trailing: false
  placeholder: Search...
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh biểu tượng loading. Mặc định là `i-lucide-loader-circle`.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  loadingIcon: i-lucide-loader
  placeholder: Search...
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Input.

::component-code
---
ignore:
  - placeholder
props:
  disabled: true
  placeholder: Search...
---
::

## Examples

### With clear button

Bạn có thể đặt một [Button](https://nuxt.com/components/button) bên trong slot `#trailing` để xóa Input.

::component-example{name="input-clear-button-example"}
::

### With copy button

Bạn có thể đặt một [Button](https://nuxt.com/components/button) bên trong slot `#trailing` để sao chép giá trị vào clipboard.

::component-example{name="input-copy-button-example"}
::

### With password toggle

Bạn có thể đặt một [Button](https://nuxt.com/components/button) bên trong slot `#trailing` để chuyển đổi khả năng hiển thị mật khẩu.

::component-example{name="input-password-toggle-example"}
::

### With password strength indicator

Bạn có thể sử dụng thành phần [Progress](https://nuxt.com/components/progress) để hiển thị chỉ báo độ mạnh mật khẩu.

::component-example{collapse name="input-password-strength-indicator-example"}
::

### With character limit

Bạn có thể sử dụng slot `#trailing` để thêm giới hạn ký tự cho Input.

::component-example{name="input-character-limit-example"}
::

### With keyboard shortcut

Bạn có thể sử dụng thành phần [Kbd](https://nuxt.com/components/kbd) bên trong slot `#trailing` để thêm phím tắt bàn phím cho Input.

::component-example{name="input-kbd-example"}
::

::note{to="https://nuxt.com/composables/define-shortcuts"}
Ví dụ này sử dụng composable `defineShortcuts` để focus Input khi phím `` được nhấn.
::

### With mask

Không có hỗ trợ tích hợp cho mặt nạ, nhưng bạn có thể sử dụng các thư viện như [maska](https://github.com/beholdr/maska){rel="nofollow"} để che Input.

::component-example{name="input-mask-example"}
::

### With floating label

Bạn có thể sử dụng slot `#default` để thêm nhãn nổi cho Input.

::component-example{name="input-floating-label-example"}
::

### Within a FormField

Bạn có thể sử dụng Input trong thành phần [FormField](https://nuxt.com/components/form-field) để hiển thị nhãn, văn bản trợ giúp, chỉ báo bắt buộc, v.v.

::component-example{name="input-form-field-example"}
::

::tip{to="https://nuxt.com/components/form"}
Nó cũng cung cấp xác thực và xử lý lỗi khi được sử dụng trong thành phần **Form**.
::

### Within a ButtonGroup

Bạn có thể sử dụng Input trong thành phần [ButtonGroup](https://nuxt.com/components/button-group) để nhóm nhiều phần tử lại với nhau.

::component-example{name="input-button-group-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                       |
| -------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLInputElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# InputMenu

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của InputMenu hoặc prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::tip
Sử dụng điều này thay cho [`Input`](https://nuxt.com/components/input) để tận dụng thành phần [`Combobox`](https://reka-ui.com/docs/components/combobox){rel="nofollow"} của Reka UI cung cấp khả năng tự động hoàn thành.
::

::note
Thành phần này tương tự như [`SelectMenu`](https://nuxt.com/components/select-menu) nhưng nó sử dụng Input thay vì Select.
::

### Items

Sử dụng prop `items` dưới dạng một mảng các chuỗi, số hoặc boolean:

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue: Backlog
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

Bạn cũng có thể truyền một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "label" | "separator" | "item"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-items-type)
- [`icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-icons-in-items)
- [`avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-avatar-in-items)
- [`chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-chip-in-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { tagsItem?: ClassNameValue, tagsItemText?: ClassNameValue, tagsItemDelete?: ClassNameValue, tagsItemDeleteIcon?: ClassNameValue, label?: ClassNameValue, separator?: ClassNameValue, item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLabel?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue.label
  - items
props:
  modelValue:
    label: Todo
  items:
    - label: Backlog
    - label: Todo
    - label: In Progress
    - label: Done
---
::

Bạn cũng có thể truyền một mảng các mảng cho prop `items` để hiển thị các nhóm mục được tách biệt.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue: Apple
  items:
    - - Apple
      - Banana
      - Blueberry
      - Grapes
      - Pineapple
    - - Aubergine
      - Broccoli
      - Carrot
      - Courgette
      - Leek
---
::

### Value Key

Bạn có thể chọn ràng buộc một thuộc tính duy nhất của đối tượng thay vì toàn bộ đối tượng bằng cách sử dụng prop `value-key`. Mặc định là `undefined`.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - valueKey
  - items
props:
  modelValue: todo
  valueKey: id
  items:
    - label: Backlog
      id: backlog
    - label: Todo
      id: todo
    - label: In Progress
      id: in_progress
    - label: Done
      id: done
---
::

### Multiple

Sử dụng prop `multiple` để cho phép chọn nhiều mục, các mục đã chọn sẽ được hiển thị dưới dạng thẻ.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::caution
Đảm bảo truyền một mảng cho prop `default-value` hoặc directive `v-model`.
::

### Delete Icon

Với `multiple`, sử dụng prop `delete-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) xóa trong các thẻ. Mặc định là `i-lucide-x`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  deleteIcon: i-lucide-trash
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::
::

### Placeholder

Sử dụng prop `placeholder` để đặt văn bản placeholder.

::component-code
---
external:
  - items
ignore:
  - items
prettier: true
props:
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Content

Sử dụng prop `content` để kiểm soát cách nội dung InputMenu được render, như `align` hoặc `side` của nó ví dụ.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  modelValue: Backlog
  content:
    align: center
    side: bottom
    sideOffset: 8
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Arrow

Sử dụng prop `arrow` để hiển thị một mũi tên trên InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - arrow
prettier: true
props:
  modelValue: Backlog
  arrow: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Color

Sử dụng prop `color` để thay đổi màu vòng khi InputMenu được focus.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  color: neutral
  highlight: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::note
Prop `highlight` được sử dụng ở đây để hiển thị trạng thái focus. Nó được sử dụng nội bộ khi xảy ra lỗi xác thực.
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  color: neutral
  variant: subtle
  highlight: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  size: xl
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  icon: i-lucide-search
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Trailing Icon

Sử dụng prop `trailing-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) trailing. Mặc định là `i-lucide-chevron-down`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  trailingIcon: i-lucide-arrow-down
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.chevronDown`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.chevronDown`.
  :::
::

### Selected Icon

Sử dụng prop `selected-icon` để tùy chỉnh biểu tượng khi một mục được chọn. Mặc định là `i-lucide-check`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  selectedIcon: i-lucide-flame
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Nuxt
  avatar:
    src: https://github.com/nuxt.png
  items:
    - Nuxt
    - NuxtHub
    - NuxtLabs
    - Nuxt Modules
    - Nuxt Community
---
::

### Loading

Sử dụng prop `loading` để hiển thị biểu tượng loading trên InputMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  loading: true
  trailing: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh biểu tượng loading. Mặc định là `i-lucide-loader-circle`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
prettier: true
props:
  modelValue: Backlog
  loading: true
  loadingIcon: i-lucide-loader
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa InputMenu.

::component-code
---
external:
  - items
ignore:
  - items
  - placeholder
prettier: true
props:
  disabled: true
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
---
::

## Examples

### With items type

Bạn có thể sử dụng thuộc tính `type` với `separator` để hiển thị một dấu phân cách giữa các mục hoặc `label` để hiển thị một nhãn.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
props:
  modelValue: Apple
  items:
    - type: label
      label: Fruits
    - Apple
    - Banana
    - Blueberry
    - Grapes
    - Pineapple
    - type: separator
    - type: label
      label: Vegetables
    - Aubergine
    - Broccoli
    - Carrot
    - Courgette
    - Leek
---
::

### With icon in items

Bạn có thể sử dụng thuộc tính `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong các mục.

::component-example{collapse name="input-menu-items-icon-example"}
::

::tip
Bạn cũng có thể sử dụng slot `#leading` để hiển thị biểu tượng đã chọn.
::

### With avatar in items

Bạn có thể sử dụng thuộc tính `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong các mục.

::component-example{collapse name="input-menu-items-avatar-example"}
::

::tip
Bạn cũng có thể sử dụng slot `#leading` để hiển thị avatar đã chọn.
::

### With chip in items

Bạn có thể sử dụng thuộc tính `chip` để hiển thị một [Chip](https://nuxt.com/components/chip) bên trong các mục.

::component-example{collapse name="input-menu-items-chip-example"}
::

::note
Trong ví dụ này, slot `#leading` được sử dụng để hiển thị chip đã chọn.
::

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="input-menu-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi InputMenu bằng cách nhấn ``.
::

### Control open state on focus

Bạn có thể sử dụng prop `open-on-focus` hoặc `open-on-click` để mở menu khi input được focus hoặc nhấp.

::component-example{name="input-menu-open-focus-example"}
::

### Control search term

Sử dụng directive `v-model:search-term` để kiểm soát thuật ngữ tìm kiếm.

::component-example{name="input-menu-search-term-example"}
::

### With rotating icon

Đây là một ví dụ với biểu tượng xoay chỉ ra trạng thái mở của InputMenu.

::component-example{name="input-menu-icon-example"}
::

### With create item

Sử dụng prop `create-item` để cho phép người dùng thêm các giá trị tùy chỉnh không có trong các tùy chọn định sẵn.

::component-example{collapse name="input-menu-create-item-example"}
::

::note
Tùy chọn tạo hiển thị khi không tìm thấy khớp theo mặc định. Đặt thành `always` để hiển thị ngay cả khi có giá trị tương tự tồn tại.
::

::tip{to="https://nuxt.com/#emits"}
Sử dụng sự kiện `@create` để xử lý việc tạo mục. Bạn sẽ nhận được sự kiện và mục dưới dạng đối số.
::

### With fetched items

Bạn có thể lấy các mục từ API và sử dụng chúng trong InputMenu.

::component-example{collapse name="input-menu-fetch-example"}
::

### With ignore filter

Đặt prop `ignore-filter` thành `true` để vô hiệu hóa tìm kiếm nội bộ và sử dụng logic tìm kiếm của riêng bạn.

::component-example{collapse name="input-menu-ignore-filter-example"}
::

::note
Ví dụ này sử dụng [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} để debounce các cuộc gọi API.
::

### With filter fields

Sử dụng prop `filter-fields` với một mảng các trường để lọc. Mặc định là `[labelKey]`.

::component-example{collapse name="input-menu-filter-fields-example"}
::

### With full content width

Bạn có thể mở rộng nội dung đến chiều rộng đầy đủ của các mục của nó bằng cách sử dụng khóa `ui.content`.

::component-example{collapse name="input-menu-content-width-example"}
::

::tip
Bạn cũng có thể thay đổi chiều rộng nội dung toàn cục trong `app.config.ts` của bạn:

```text
export default defineAppConfig({
  ui: {
    inputMenu: {
      slots: {
        content: 'min-w-fit'
      }
    }
  }
})
```
::

### As a CountryPicker

Ví dụ này minh họa việc sử dụng InputMenu làm bộ chọn quốc gia với lazy loading - các quốc gia chỉ được lấy khi menu được mở.

::component-example{collapse name="input-menu-countries-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                                           |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof ComboboxTrigger> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# InputNumber

::note
Thành phần này dựa vào gói [`@internationalized/number`](https://react-spectrum.adobe.com/internationalized/number/index.html){rel="nofollow"} cung cấp tiện ích để định dạng và phân tích số trên các locale và hệ thống đánh số.
::

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
---
::

Sử dụng prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":5}'}
::

### Min / Max

Sử dụng prop `min` và `max` để đặt giá trị tối thiểu và tối đa của InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  min: 0
  max: 10
---
::

### Step

Sử dụng prop `step` để đặt giá trị bước của InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  step: 2
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  orientation: vertical
---
::

### Placeholder

Sử dụng prop `placeholder` để đặt văn bản placeholder.

::component-code{:props='{"placeholder":"Enter a number"}'}
::

### Color

Sử dụng prop `color` để thay đổi màu vòng khi InputNumber được focus.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  color: neutral
  highlight: true
---
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  variant: subtle
  color: neutral
  highlight: false
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  size: xl
---
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa InputNumber.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: 5
  disabled: true
---
::

### Increment / Decrement

Sử dụng prop `increment` và `decrement` để tùy chỉnh các nút tăng và giảm với bất kỳ prop [Button](https://nuxt.com/components/button) nào. Mặc định là `{ variant: 'link' }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
  - increment.size
  - increment.color
  - increment.variant
  - decrement.size
  - decrement.color
  - decrement.variant
prettier: true
props:
  modelValue: 5
  increment:
    color: neutral
    variant: solid
    size: xs
  decrement:
    color: neutral
    variant: solid
    size: xs
---
::

### Increment / Decrement Icons

Sử dụng prop `increment-icon` và `decrement-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) của các nút. Mặc định là `i-lucide-plus` / `i-lucide-minus`.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue: 5
  incrementIcon: i-lucide-arrow-right
  decrementIcon: i-lucide-arrow-left
---
::

## Examples

### With decimal format

Sử dụng prop `format-options` để tùy chỉnh định dạng của giá trị.

::component-example{name="input-number-decimal-example"}
::

### With percentage format

Sử dụng prop `format-options` với `style: 'percent'` để tùy chỉnh định dạng của giá trị.

::component-example{name="input-number-percentage-example"}
::

### With currency format

Sử dụng prop `format-options` với `style: 'currency'` để tùy chỉnh định dạng của giá trị.

::component-example{name="input-number-currency-example"}
::

### Within a FormField

Bạn có thể sử dụng InputNumber trong thành phần [FormField](https://nuxt.com/components/form-field) để hiển thị nhãn, văn bản trợ giúp, chỉ báo bắt buộc, v.v.

::component-example{name="input-number-form-field-example"}
::

### With slots

Sử dụng slot `#increment` và `#decrement` để tùy chỉnh các nút.

::component-example{name="input-number-slots-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                                            |
| -------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof NumberFieldInput> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# InputTags

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
---
::

Sử dụng prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::component-code
---
ignore:
  - defaultValue
prettier: true
props:
  defaultValue:
    - Vue
---
::

### Placeholder

Sử dụng prop `placeholder` để đặt văn bản placeholder.

::component-code{:props='{"placeholder":"Enter tags..."}'}
::

### Max Length :badge{.align-text-top label="New"}

Sử dụng prop `max-length` để đặt số ký tự tối đa được phép trong một thẻ.

::component-code{:props='{"maxLength":4}'}
::

### Color

Sử dụng prop `color` để thay đổi màu vòng khi InputTags được focus.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  color: neutral
  highlight: true
---
::

::note
Prop `highlight` được sử dụng ở đây để hiển thị trạng thái focus. Nó được sử dụng nội bộ khi xảy ra lỗi xác thực.
::

### Variants

Sử dụng prop `variant` để thay đổi giao diện của InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  variant: subtle
  color: neutral
  highlight: false
---
::

### Sizes

Sử dụng prop `size` để điều chỉnh kích thước của InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  size: xl
---
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  icon: i-lucide-search
  size: md
  variant: outline
---
::

::note
Sử dụng prop `leading` và `trailing` để đặt vị trí biểu tượng hoặc prop `leading-icon` và `trailing-icon` để đặt biểu tượng khác cho mỗi vị trí.
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  avatar:
    src: https://github.com/vuejs.png
  size: md
  variant: outline
---
::

### Delete Icon

Sử dụng prop `delete-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) xóa trong các thẻ. Mặc định là `i-lucide-x`.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  deleteIcon: i-lucide-trash
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::
::

### Loading

Sử dụng prop `loading` để hiển thị biểu tượng loading trên InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  loading: true
  trailing: false
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh biểu tượng loading. Mặc định là `i-lucide-loader-circle`.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  loading: true
  loadingIcon: i-lucide-loader
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa InputTags.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue:
    - Vue
  disabled: true
---
::

## Examples

### Within a FormField

Bạn có thể sử dụng InputTags trong thành phần [FormField](https://nuxt.com/components/form-field) để hiển thị nhãn, văn bản trợ giúp, chỉ báo bắt buộc, v.v.

::component-example{name="input-tags-form-field-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

When accessing the component via a template ref, you can use the following:

| Name                                                                                                                                   | Type                                                                                                                                                                          |
| -------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `inputRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof TagsInputInput> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Kbd

## Usage

### Value

Sử dụng slot mặc định để đặt giá trị của Kbd.

::component-code{:slots='{"default":"K"}'}
::

Bạn có thể đạt được kết quả tương tự bằng cách sử dụng prop `value`.

::component-code{:props='{"value":"K"}'}
::

Bạn có thể truyền các phím đặc biệt vào prop `value` mà đi qua composable [`useKbd`](https://github.com/nuxt/ui/blob/v3/src/runtime/composables/useKbd.ts){rel="nofollow"}. Ví dụ, phím `meta` hiển thị là `⌘` trên macOS và `Ctrl` trên các nền tảng khác.

::component-code
---
items:
  value:
    - meta
    - win
    - command
    - shift
    - ctrl
    - option
    - alt
    - enter
    - delete
    - backspace
    - escape
    - tab
    - capslock
    - arrowup
    - arrowright
    - arrowdown
    - arrowleft
    - pageup
    - pagedown
    - home
    - end
props:
  value: meta
---
::

### Color :badge{.align-text-top label="New"}

Sử dụng prop `color` để thay đổi màu của Kbd.

::component-code{:props='{"color":"neutral"}' :slots='{"default":"K"}'}
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Kbd.

::component-code
---
props:
  color: neutral
  variant: solid
slots:
  default: K
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Kbd.

::component-code{:props='{"size":"lg"}' :slots='{"default":"K"}'}
::

## Examples

### `class` prop

Sử dụng prop `class` để ghi đè các kiểu cơ sở của Badge.

::component-code
---
props:
  class: font-bold rounded-full
  variant: subtle
slots:
  default: K
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Link

## Usage

Link component là một wrapper xung quanh [`<NuxtLink>`](https://nuxt.com/docs/api/components/nuxt-link){rel="nofollow"} sử dụng prop [`custom`](https://router.vuejs.org/api/interfaces/RouterLinkProps.html#Properties-custom){rel="nofollow"}. Nó cung cấp một số prop bổ sung:

- `inactive-class` prop để đặt một class khi link không hoạt động, `active-class` được sử dụng khi hoạt động.
- `exact` prop để style với `active-class` khi link hoạt động và route giống hệt với route hiện tại.
- `exact-query` và `exact-hash` props để style với `active-class` khi link hoạt động và query hoặc hash giống hệt với query hoặc hash hiện tại.

  - sử dụng `exact-query="partial"` để style với `active-class` khi link hoạt động và query khớp một phần với query hiện tại.

Lý do đằng sau là cung cấp cùng API như NuxtLink trở lại trong Nuxt 2 / Vue 2. Bạn có thể đọc thêm về nó trong hướng dẫn migration từ Vue 2 của Vue Router [migration from Vue 2](https://router.vuejs.org/guide/migration/#removal-of-the-exact-prop-in-router-link){rel="nofollow"}.

::note
Nó được sử dụng bởi các component [`Breadcrumb`](https://nuxt.com/components/breadcrumb), [`Button`](https://nuxt.com/components/button), [`ContextMenu`](https://nuxt.com/components/context-menu), [`DropdownMenu`](https://nuxt.com/components/dropdown-menu) và [`NavigationMenu`](https://nuxt.com/components/navigation-menu).
::

### Tag

Component Link hiển thị thẻ `<a>` khi prop `to` được cung cấp, nếu không thì hiển thị thẻ `<button>`. Bạn có thể sử dụng prop `as` để thay đổi thẻ fallback.

::component-code{:props='{"to":"","as":"button"}' :slots='{"default":"Link"}'}
::

::note
Bạn có thể kiểm tra HTML được hiển thị bằng cách thay đổi prop `to`.
::

### Style

Theo mặc định, link có style active và inactive mặc định, kiểm tra phần [#theme](https://nuxt.com/#theme).

::component-code{:props='{"to":"/components/link"}' :slots='{"default":"Link"}'}
::

::note
Thử thay đổi prop `to` để xem các trạng thái active và inactive.
::

Bạn có thể override hành vi này bằng cách sử dụng prop `raw` và cung cấp style riêng của bạn sử dụng `class`, `active-class` và `inactive-class`.

::component-code
---
ignore:
  - raw
props:
  raw: true
  to: /components/link
  activeClass: font-bold
  inactiveClass: text-muted
slots:
  default: Link
---
Link
::

## IntelliSense

Nếu bạn đang sử dụng VSCode và muốn có autocompletion cho các class `active-class` và `inactive-class`, bạn có thể thêm cài đặt sau vào `.vscode/settings.json`:

```json [.vscode/settings.json]
{
  "tailwindCSS.classAttributes": [
    "active-class",
    "inactive-class"
  ]
}
```

## API

### Props

::component-props{:ignore='["custom"]'}
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Modal

## Usage

Sử dụng một [Button](https://nuxt.com/components/button) hoặc bất kỳ component nào khác trong slot mặc định của Modal.

Sau đó, sử dụng slot `#content` để thêm nội dung được hiển thị khi Modal mở.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="h-48 m-4" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.h-48.m-4}
  :::
::

Bạn cũng có thể sử dụng các slot `#header`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}, `#body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} và `#footer`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} để tùy chỉnh nội dung của Modal.

### Title

Sử dụng prop `title` để đặt tiêu đề của header Modal.

::component-code
---
prettier: true
props:
  title: Modal with title
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Description

Sử dụng prop `description` để đặt mô tả của header Modal.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Modal with description
  description: Lorem ipsum dolor sit amet, consectetur adipiscing elit.
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Close

Sử dụng prop `close` để tùy chỉnh hoặc ẩn nút đóng (với giá trị `false`) được hiển thị trong header Modal.

Bạn có thể truyền bất kỳ thuộc tính nào từ component [Button](https://nuxt.com/components/button) để tùy chỉnh nó.

::component-code
---
ignore:
  - title
  - close.color
  - close.variant
prettier: true
props:
  title: Modal with close button
  close:
    color: primary
    variant: outline
    class: rounded-full
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

::tip
Nút đóng không được hiển thị nếu slot `#content` được sử dụng vì nó là một phần của header.
::

### Close Icon

Sử dụng prop `close-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) của nút đóng. Mặc định là `i-lucide-x`.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Modal with close button
  closeIcon: i-lucide-arrow-right
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` dưới key `ui.icons.close`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` dưới key `ui.icons.close`.
  :::
::

### Overlay

Sử dụng prop `overlay` để kiểm soát xem Modal có overlay hay không. Mặc định là `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  overlay: false
  title: Modal without overlay
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Transition

Sử dụng prop `transition` để kiểm soát xem Modal có được animate hay không. Mặc định là `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  transition: false
  title: Modal without transition
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Fullscreen

Sử dụng prop `fullscreen` để làm cho Modal fullscreen.

::component-code
---
ignore:
  - title
  - fullscreen
prettier: true
props:
  fullscreen: true
  title: Modal fullscreen
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

## Examples

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="modal-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể toggle Modal bằng cách nhấn ``.
::

::tip
Điều này cho phép bạn di chuyển trigger bên ngoài Modal hoặc loại bỏ nó hoàn toàn.
::

### Disable dismissal

Đặt prop `dismissible` thành `false` để ngăn Modal bị đóng khi click bên ngoài hoặc nhấn escape. Sự kiện `close:prevent` sẽ được emit khi người dùng cố gắng đóng nó.

::component-code
---
ignore:
  - title
  - dismissible
prettier: true
props:
  dismissible: false
  title: Modal non-dismissible
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-48}
  :::
::

### Programmatic usage

Bạn có thể sử dụng composable [`useOverlay`](https://nuxt.com/composables/use-overlay) để mở Modal theo chương trình.

::warning
Đảm bảo wrap app của bạn với component [`App`](https://nuxt.com/components/app) sử dụng component [`OverlayProvider`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/OverlayProvider.vue){rel="nofollow"}.
::

Đầu tiên, tạo một component modal sẽ được mở theo chương trình:

::component-example{prettier :preview='false' name="modal-example"}
::

::note
Chúng tôi đang emit sự kiện `close` khi modal bị đóng hoặc dismissed ở đây. Bạn có thể emit bất kỳ dữ liệu nào thông qua sự kiện `close`, tuy nhiên, sự kiện phải được emit để capture giá trị trả về.
::

Sau đó, sử dụng nó trong app của bạn:

::component-example{name="modal-programmatic-example"}
::

::tip
Bạn có thể đóng modal trong component modal bằng cách emit `emit('close')`.
::

### Nested modals

Bạn có thể lồng các modal trong nhau.

::component-example{name="modal-nested-example"}
::

### With footer slot

Sử dụng slot `#footer` để thêm nội dung sau body của Modal.

::component-example{name="modal-footer-slot-example"}
::

### With command palette

Bạn có thể sử dụng component [CommandPalette](https://nuxt.com/components/command-palette) bên trong nội dung của Modal.

::component-example{collapse name="modal-command-palette-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# NavigationMenu

## Usage

### Items

Sử dụng prop `items` như một mảng các object với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `badge?: string | number | BadgeProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `tooltip?: TooltipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `trailingIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `type?: 'label' | 'trigger' | 'link'`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `defaultOpen?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `open?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `children?: NavigationMenuChildItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { linkLeadingAvatarSize?: ClassNameValue, linkLeadingAvatar?: ClassNameValue, linkLeadingIcon?: ClassNameValue, linkLabel?: ClassNameValue, linkLabelExternalIcon?: ClassNameValue, linkTrailing?: ClassNameValue, linkTrailingBadgeSize?: ClassNameValue, linkTrailingBadge?: ClassNameValue, linkTrailingIcon?: ClassNameValue, label?: ClassNameValue, link?: ClassNameValue, content?: ClassNameValue, childList?: ClassNameValue, childLabel?: ClassNameValue, childItem?: ClassNameValue, childLink?: ClassNameValue, childLinkIcon?: ClassNameValue, childLinkWrapper?: ClassNameValue, childLinkLabel?: ClassNameValue, childLinkLabelExternalIcon?: ClassNameValue, childLinkDescription?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

Bạn có thể truyền bất kỳ thuộc tính nào từ component [Link](https://nuxt.com/components/link#props) như `to`, `target`, etc.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - class
props:
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
    - label: GitHub
      icon: i-simple-icons-github
      badge: 3.8k
      to: https://github.com/nuxt/ui
      target: _blank
    - label: Help
      icon: i-lucide-circle-help
      disabled: true
  class: w-full justify-center
---
::

::note
Bạn cũng có thể truyền một mảng các mảng vào prop `items` để hiển thị các nhóm item.
::

::tip
Mỗi item có thể có một mảng `children` với các object có các thuộc tính sau để tạo submenu:

- `label: string`
- `description?: string`
- `icon?: string`
- `onSelect?(e: Event): void`
- `class?: any`
::

### Orientation

Sử dụng prop `orientation` để thay đổi orientation của NavigationMenu.

::note
Khi orientation là `vertical`, một component [Accordion](https://nuxt.com/components/accordion) được sử dụng để hiển thị mỗi nhóm. Bạn có thể kiểm soát trạng thái mở của mỗi item bằng cách sử dụng các thuộc tính `open` và `defaultOpen` và thay đổi hành vi bằng cách sử dụng các prop [`collapsible`](https://nuxt.com/components/accordion#collapsible) và [`type`](https://nuxt.com/components/accordion#multiple).
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
props:
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        defaultOpen: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
  class: data-[orientation=vertical]:w-48
---
::

::note
Các nhóm sẽ được spaced khi orientation là `horizontal` và separated khi orientation là `vertical`.
::

### Collapsed

Trong `vertical` orientation, sử dụng prop `collapsed` để collapse NavigationMenu, điều này có thể hữu ích trong một sidebar ví dụ.

::note
Bạn có thể sử dụng các prop [`tooltip`](https://nuxt.com/#with-tooltip-in-items) và [`popover`](https://nuxt.com/#with-popover-in-items) để hiển thị thêm thông tin trên các item collapsed.
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - orientation
  - class
items:
  tooltip:
    - true
    - false
  popover:
    - true
    - false
props:
  collapsed: true
  tooltip: false
  popover: false
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
---
::

### Highlight

Sử dụng prop `highlight` để hiển thị một border highlighted cho item active.

Sử dụng prop `highlight-color` để thay đổi màu của border. Nó mặc định là prop `color`.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
prettier: true
props:
  highlight: true
  highlightColor: primary
  orientation: horizontal
  items:
    - - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        defaultOpen: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
  class: data-[orientation=horizontal]:border-b border-default
    data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-48
---
::

::note
Trong ví dụ này, class `border-b` được áp dụng để hiển thị một border trong `horizontal` orientation, điều này không được làm theo mặc định để để bạn có một clean slate để làm việc với.
::

::caution
Trong `vertical` orientation, prop `highlight` chỉ highlight border của children active.
::

### Color

Sử dụng prop `color` để thay đổi màu của NavigationMenu.

::component-code
---
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
props:
  color: neutral
  items:
    - - label: Guide
        icon: i-lucide-book-open
        to: /getting-started
      - label: Composables
        icon: i-lucide-database
        to: /composables
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
  class: w-full
---
::

### Variant

Sử dụng prop `variant` để thay đổi variant của NavigationMenu.

::component-code
---
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - class
props:
  color: neutral
  variant: link
  highlight: false
  items:
    - - label: Guide
        icon: i-lucide-book-open
        to: /getting-started
      - label: Composables
        icon: i-lucide-database
        to: /composables
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
  class: w-full
---
::

::note
Prop `highlight` thay đổi style item active của `pill` variant. Hãy thử nó để xem sự khác biệt.
::

### Trailing Icon

Sử dụng prop `trailing-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) trailing của mỗi item. Mặc định là `i-lucide-chevron-down`. Icon này chỉ được hiển thị khi một item có children.

::tip
Bạn cũng có thể đặt một icon cho một item cụ thể bằng cách sử dụng thuộc tính `trailingIcon` trong object item.
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - class
props:
  trailingIcon: i-lucide-arrow-down
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
  class: w-full justify-center
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` dưới key `ui.icons.chevronDown`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` dưới key `ui.icons.chevronDown`.
  :::
::

### Arrow

Sử dụng prop `arrow` để hiển thị một arrow trên content NavigationMenu khi items có children.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - arrow
  - class
props:
  arrow: true
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
  class: w-full justify-center
---
::

::note
Arrow được animate để follow item active.
::

### Content Orientation

Sử dụng prop `content-orientation` để thay đổi orientation của content.

::warning
Prop này chỉ hoạt động khi `orientation` là `horizontal`.
::

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - arrow
  - class
props:
  arrow: true
  contentOrientation: vertical
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
  class: w-full justify-center
---
::

### Unmount

Sử dụng prop `unmount-on-hide` để kiểm soát hành vi unmounting content. Mặc định là `true`.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[]
ignore:
  - items
  - arrow
  - class
props:
  unmountOnHide: false
  items:
    - label: Guide
      icon: i-lucide-book-open
      to: /getting-started
      children:
        - label: Introduction
          description: Fully styled and customizable components for Nuxt.
          icon: i-lucide-house
        - label: Installation
          description: Learn how to install and configure Nuxt UI in your application.
          icon: i-lucide-cloud-download
        - label: Icons
          icon: i-lucide-smile
          description: You have nothing to do, @nuxt/icon will handle it automatically.
        - label: Colors
          icon: i-lucide-swatch-book
          description: Choose a primary and a neutral color from your Tailwind CSS theme.
        - label: Theme
          icon: i-lucide-cog
          description: You can customize components by using the `class` / `ui` props or
            in your app.config.ts.
    - label: Composables
      icon: i-lucide-database
      to: /composables
      children:
        - label: defineShortcuts
          icon: i-lucide-file-text
          description: Define shortcuts for your application.
          to: /composables/define-shortcuts
        - label: useOverlay
          icon: i-lucide-file-text
          description: Display a modal/slideover within your application.
          to: /composables/use-overlay
        - label: useToast
          icon: i-lucide-file-text
          description: Display a toast within your application.
          to: /composables/use-toast
    - label: Components
      icon: i-lucide-box
      to: /components
      active: true
      children:
        - label: Link
          icon: i-lucide-file-text
          description: Use NuxtLink with superpowers.
          to: /components/link
        - label: Modal
          icon: i-lucide-file-text
          description: Display a modal within your application.
          to: /components/modal
        - label: NavigationMenu
          icon: i-lucide-file-text
          description: Display a list of links.
          to: /components/navigation-menu
        - label: Pagination
          icon: i-lucide-file-text
          description: Display a list of pages.
          to: /components/pagination
        - label: Popover
          icon: i-lucide-file-text
          description: Display a non-modal dialog that floats around a trigger element.
          to: /components/popover
        - label: Progress
          icon: i-lucide-file-text
          description: Show a horizontal bar to indicate task progression.
          to: /components/progress
  class: w-full justify-center
---
::

::note
Bạn có thể inspect DOM để xem content của mỗi item được render.
::

## Examples

### With tooltip in items

Khi orientation là `vertical` và menu là `collapsed`, bạn có thể đặt prop `tooltip` thành `true` để hiển thị một [Tooltip](https://nuxt.com/components/tooltip) xung quanh items với label của chúng nhưng bạn cũng có thể sử dụng thuộc tính `tooltip` trên mỗi item để override tooltip mặc định.

Bạn có thể truyền bất kỳ thuộc tính nào từ component [Tooltip](https://nuxt.com/components/tooltip) toàn cục hoặc trên mỗi item.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - orientation
  - class
items:
  tooltip:
    - true
    - false
props:
  tooltip: true
  collapsed: true
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
        tooltip:
          text: Open on GitHub
          kbds:
            - 3.8k
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
---
::

### With popover in items

Khi orientation là `vertical` và menu là `collapsed`, bạn có thể đặt prop `popover` thành `true` để hiển thị một [Popover](https://nuxt.com/components/popover) xung quanh items với children của chúng nhưng bạn cũng có thể sử dụng thuộc tính `popover` trên mỗi item để override popover mặc định.

Bạn có thể truyền bất kỳ thuộc tính nào từ component [Popover](https://nuxt.com/components/popover) toàn cục hoặc trên mỗi item.

::component-code
---
collapse: true
external:
  - items
externalTypes:
  - NavigationMenuItem[][]
ignore:
  - items
  - orientation
  - class
items:
  popover:
    - true
    - false
props:
  popover: true
  collapsed: true
  orientation: vertical
  items:
    - - label: Links
        type: label
      - label: Guide
        icon: i-lucide-book-open
        children:
          - label: Introduction
            description: Fully styled and customizable components for Nuxt.
            icon: i-lucide-house
          - label: Installation
            description: Learn how to install and configure Nuxt UI in your application.
            icon: i-lucide-cloud-download
          - label: Icons
            icon: i-lucide-smile
            description: You have nothing to do, @nuxt/icon will handle it automatically.
          - label: Colors
            icon: i-lucide-swatch-book
            description: Choose a primary and a neutral color from your Tailwind CSS theme.
          - label: Theme
            icon: i-lucide-cog
            description: You can customize components by using the `class` / `ui` props or
              in your app.config.ts.
      - label: Composables
        icon: i-lucide-database
        popover:
          mode: click
        children:
          - label: defineShortcuts
            icon: i-lucide-file-text
            description: Define shortcuts for your application.
            to: /composables/define-shortcuts
          - label: useOverlay
            icon: i-lucide-file-text
            description: Display a modal/slideover within your application.
            to: /composables/use-overlay
          - label: useToast
            icon: i-lucide-file-text
            description: Display a toast within your application.
            to: /composables/use-toast
      - label: Components
        icon: i-lucide-box
        to: /components
        active: true
        children:
          - label: Link
            icon: i-lucide-file-text
            description: Use NuxtLink with superpowers.
            to: /components/link
          - label: Modal
            icon: i-lucide-file-text
            description: Display a modal within your application.
            to: /components/modal
          - label: NavigationMenu
            icon: i-lucide-file-text
            description: Display a list of links.
            to: /components/navigation-menu
          - label: Pagination
            icon: i-lucide-file-text
            description: Display a list of pages.
            to: /components/pagination
          - label: Popover
            icon: i-lucide-file-text
            description: Display a non-modal dialog that floats around a trigger element.
            to: /components/popover
          - label: Progress
            icon: i-lucide-file-text
            description: Show a horizontal bar to indicate task progression.
            to: /components/progress
    - - label: GitHub
        icon: i-simple-icons-github
        badge: 3.8k
        to: https://github.com/nuxt/ui
        target: _blank
        tooltip:
          text: Open on GitHub
          kbds:
            - 3.8k
      - label: Help
        icon: i-lucide-circle-help
        disabled: true
---
::

::tip{to="https://nuxt.com/#with-content-slot"}
Bạn có thể sử dụng slot `#content` để tùy chỉnh content của popover trong `vertical` orientation.
::

### Control active item

Bạn có thể kiểm soát item active bằng cách sử dụng prop `default-value` hoặc directive `v-model` với index của item.

::component-example{collapse name="navigation-menu-model-value-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể switch item active bằng cách nhấn ``, ``, hoặc ``.
::

::tip
Bạn cũng có thể truyền `value` của một trong các items nếu được cung cấp.
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một item cụ thể.

Bạn sẽ có access đến các slots sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-content`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="navigation-menu-custom-slot-example"}
::

::tip{to="https://nuxt.com/#slots"}
Bạn cũng có thể sử dụng slots `#item`, `#item-leading`, `#item-label`, `#item-trailing` và `#item-content` để tùy chỉnh tất cả items.
::

### With content slot

Sử dụng slot `#item-content` hoặc thuộc tính `slot` (`#{{ item.slot }}-content`) để tùy chỉnh content của một item cụ thể.

::component-example{collapse name="navigation-menu-content-slot-example"}
::

::note
Trong ví dụ này, chúng tôi thêm class `sm:w-(--reka-navigation-menu-viewport-width)` trên `viewport` để có width động. Điều này yêu cầu đặt width trên first child của content.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Pagination

## Usage

Sử dụng prop `default-page` hoặc directive `v-model:page` để kiểm soát page hiện tại.

::note
Component Pagination sử dụng một số [Button](https://nuxt.com/components/button) để hiển thị các pages, sử dụng props [`color`](https://nuxt.com/#color), [`variant`](https://nuxt.com/#variant) và [`size`](https://nuxt.com/#size) để style chúng.
::

### Total

Sử dụng prop `total` để đặt tổng số items trong list.

::component-code
---
external:
  - page
model:
  - page
props:
  page: 5
  total: 100
---
::

### Items Per Page

Sử dụng prop `items-per-page` để đặt số items per page. Mặc định là `10`.

::component-code
---
external:
  - page
ignore:
  - page
model:
  - page
props:
  page: 5
  itemsPerPage: 20
  total: 100
---
::

### Sibling Count

Sử dụng prop `sibling-count` để đặt số siblings để show. Mặc định là `2`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  siblingCount: 1
  total: 100
---
::

### Show Edges

Sử dụng prop `show-edges` để luôn show ellipsis, first và last pages. Mặc định là `false`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  showEdges: true
  siblingCount: 1
  total: 100
---
::

### Show Controls

Sử dụng prop `show-controls` để show các buttons first, prev, next và last. Mặc định là `true`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  showControls: false
  showEdges: true
  total: 100
---
::

### Color

Sử dụng prop `color` để đặt màu của inactive controls. Mặc định là `neutral`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
model:
  - page
props:
  page: 5
  color: primary
  total: 100
---
::

### Variant

Sử dụng prop `variant` để đặt variant của inactive controls. Mặc định là `outline`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  color:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  variant:
    - solid
    - outline
    - soft
    - subtle
    - ghost
    - link
model:
  - page
props:
  page: 5
  color: neutral
  variant: subtle
  total: 100
---
::

### Active Color

Sử dụng prop `active-color` để đặt màu của active control. Mặc định là `primary`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  activeColor:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
model:
  - page
props:
  page: 5
  activeColor: neutral
  total: 100
---
::

### Active Variant

Sử dụng prop `active-variant` để đặt variant của active control. Mặc định là `solid`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  activeColor:
    - primary
    - secondary
    - success
    - info
    - warning
    - error
    - neutral
  activeVariant:
    - solid
    - outline
    - soft
    - subtle
    - ghost
    - link
model:
  - page
props:
  page: 5
  activeColor: primary
  activeVariant: subtle
  total: 100
---
::

### Size

Sử dụng prop `size` để đặt size của controls. Mặc định là `md`.

::component-code
---
external:
  - page
ignore:
  - page
  - total
items:
  size:
    - xs
    - sm
    - md
    - lg
    - xl
model:
  - page
props:
  page: 5
  size: xl
  total: 100
---
::

### Disabled

Sử dụng prop `disabled` để disable pagination controls.

::component-code
---
external:
  - page
ignore:
  - page
  - total
model:
  - page
props:
  page: 5
  total: 100
  disabled: true
---
::

## Examples

### With links

Sử dụng prop `to` để transform buttons thành links. Truyền một function nhận page number và trả về destination route.

::component-example{name="pagination-links-example"}
::

::note
Trong ví dụ này chúng tôi thêm hash `#with-links` để tránh đi đến top của page.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# PinInput

## Usage

Sử dụng directive `v-model` để kiểm soát value của PinInput.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
prettier: true
props:
  modelValue: []
---
::

Sử dụng prop `default-value` để đặt initial value khi bạn không cần kiểm soát state của nó.

::component-code
---
ignore:
  - defaultValue
prettier: true
props:
  defaultValue:
    - "1"
    - "2"
    - "3"
---
::

### Type

Sử dụng prop `type` để thay đổi input type. Mặc định là `text`.

::component-code{:items='{"type":["text","number"]}' :props='{"type":"number"}'}
::

::note
Khi `type` được đặt thành `number`, nó sẽ chỉ accept numeric characters.
::

### Mask

Sử dụng prop `mask` để treat input như một password.

::component-code
---
ignore:
  - placeholder
  - defaultValue
prettier: true
props:
  mask: true
  defaultValue:
    - "1"
    - "2"
    - "3"
    - "4"
    - "5"
---
::

### OTP

Sử dụng prop `otp` để enable One-Time Password functionality. Khi enabled, mobile devices có thể automatically detect và fill OTP codes từ SMS messages hoặc clipboard content, với autocomplete support.

::component-code{:props='{"otp":true}'}
::

### Length

Sử dụng prop `length` để thay đổi amount of inputs.

::component-code{:props='{"length":6}'}
::

### Placeholder

Sử dụng prop `placeholder` để đặt placeholder text.

::component-code{:props='{"placeholder":"○"}'}
::

### Color

Sử dụng prop `color` để thay đổi ring color khi PinInput được focused.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  highlight: true
  placeholder: ○
---
::

::note
Prop `highlight` được sử dụng ở đây để show focus state. Nó được sử dụng internally khi có validation error.
::

### Variant

Sử dụng prop `variant` để thay đổi variant của PinInput.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  variant: subtle
  highlight: false
  placeholder: ○
---
::

### Size

Sử dụng prop `size` để thay đổi size của PinInput.

::component-code
---
ignore:
  - placeholder
props:
  size: xl
  placeholder: ○
---
::

### Disabled

Sử dụng prop `disabled` để disable PinInput.

::component-code
---
ignore:
  - placeholder
props:
  disabled: true
  placeholder: ○
---
::

## API

### Props

::component-props
::

### Emits

::component-emits
::

### Expose

Khi accessing component via template ref, bạn có thể sử dụng:

| Name                                                                                                                                    | Type                                                                                                                                                         |
| --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `inputsRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<ComponentPublicInstance[]>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Popover

## Usage

Sử dụng một [Button](https://nuxt.com/components/button) hoặc bất kỳ component nào khác trong slot mặc định của Popover.

Sau đó, sử dụng slot `#content` để thêm content được hiển thị khi Popover mở.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
::

::u-button{color="neutral" label="Open" variant="subtle"}
::

\#content

::placeholder{.size-48.m-4.inline-flex}
::

\::

### Mode

Sử dụng prop `mode` để thay đổi mode của Popover. Mặc định là `click`.

::component-code
---
items:
  mode:
    - click
    - hover
prettier: true
props:
  mode: hover
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
::

::u-button{color="neutral" label="Open" variant="subtle"}
::

\#content

::placeholder{.size-48.m-4.inline-flex}
::

\::

::note
Khi sử dụng `hover` mode, Reka UI [`HoverCard`](https://reka-ui.com/docs/components/hover-card){rel="nofollow"} component được sử dụng thay vì [`Popover`](https://reka-ui.com/docs/components/popover){rel="nofollow"}.
::

### Delay

Khi sử dụng `hover` mode, bạn có thể sử dụng props `open-delay` và `close-delay` để kiểm soát delay trước khi Popover được mở hoặc đóng.

::component-code
---
ignore:
  - mode
prettier: true
props:
  mode: hover
  openDelay: 500
  closeDelay: 300
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
::

::u-button{color="neutral" label="Open" variant="subtle"}
::

\#content

::placeholder{.size-48.m-4.inline-flex}
::

\::

### Content

Sử dụng prop `content` để kiểm soát cách Popover content được render, như `align` hoặc `side` của nó ví dụ.

::component-code
---
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  content:
    align: center
    side: bottom
    sideOffset: 8
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
::

::u-button{color="neutral" label="Open" variant="subtle"}
::

\#content

::placeholder{.size-48.m-4.inline-flex}
::

\::

### Arrow

Sử dụng prop `arrow` để hiển thị một arrow trên Popover.

::component-code
---
ignore:
  - arrow
prettier: true
props:
  arrow: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="size-48 m-4 inline-flex" />
---
::

::u-button{color="neutral" label="Open" variant="subtle"}
::

\#content

::placeholder{.size-48.m-4.inline-flex}
::

\::

## Examples

### Control open state

Bạn có thể kiểm soát open state bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="popover-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể toggle Popover bằng cách nhấn ``.
::

### Disable dismissal

Đặt prop `dismissible` thành `false` để ngăn Popover bị đóng khi click bên ngoài hoặc nhấn escape. Sự kiện `close:prevent` sẽ được emit khi người dùng cố gắng đóng nó.

::component-example{name="popover-dismissible-example"}
::

### With command palette

Bạn có thể sử dụng component [CommandPalette](https://nuxt.com/components/command-palette) bên trong content của Popover.

::component-example{collapse name="popover-command-palette-example"}
::

### With following cursor :badge{.align-text-top label="New"}

Bạn có thể làm cho Popover follow cursor khi hovering over một element bằng cách sử dụng prop [`reference`](https://reka-ui.com/docs/components/tooltip#trigger){rel="nofollow"}:

::component-example{name="popover-cursor-example"}
::

### With anchor slot

Bạn có thể sử dụng slot `#anchor` để position Popover against một custom element.

::warning
Slot này chỉ hoạt động khi `mode` là `click`.
::

::component-example{collapse name="popover-anchor-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Progress

## Usage

Sử dụng directive `v-model` để kiểm soát value của Progress.

::component-code{:external='["modelValue"]' :props='{"modelValue":50}'}
::

### Max

Sử dụng prop `max` để đặt maximum value của Progress.

::component-code{:external='["modelValue"]' :props='{"modelValue":3,"max":4}'}
::

Sử dụng prop `max` với một array of strings để hiển thị active step dưới bar, maximum value của Progress là length của array.

::component-code
---
external:
  - modelValue
ignore:
  - max
prettier: true
props:
  modelValue: 3
  max:
    - Waiting...
    - Cloning...
    - Migrating...
    - Deploying...
    - Done!
---
::

### Status

Sử dụng prop `status` để hiển thị current Progress value above the bar.

::component-code
---
external:
  - modelValue
props:
  modelValue: 50
  status: true
---
::

### Indeterminate

Khi no `v-model` được set hoặc value là `null`, Progress trở thành *indeterminate*. Progress bar được animated như một `carousel`, nhưng bạn có thể thay đổi nó bằng prop [`animation`](https://nuxt.com/#animation).

::component-code{:external='["modelValue"]' :props='{"modelValue":null}'}
::

### Animation

Sử dụng prop `animation` để thay đổi animation của Progress thành inverse carousel, swinging bar hoặc elastic bar. Mặc định là `carousel`.

::component-code{:props='{"animation":"swing"}'}
::

### Orientation

Sử dụng prop `orientation` để thay đổi orientation của Progress. Mặc định là `horizontal`.

::component-code
---
ignore:
  - class
props:
  orientation: vertical
  class: h-48
---
::

### Color

Sử dụng prop `color` để thay đổi color của Slider.

::component-code{:props='{"color":"neutral"}'}
::

### Size

Sử dụng prop `size` để thay đổi size của Slider.

::component-code{:props='{"size":"xl"}'}
::

### Inverted

Sử dụng prop `inverted` để visually invert Progress.

::component-code{:props='{"inverted":true,"modelValue":25}'}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# RadioGroup

## Usage

Sử dụng directive `v-model` để kiểm soát value của RadioGroup hoặc prop `default-value` để đặt initial value khi bạn không cần kiểm soát state của nó.

### Items

Sử dụng prop `items` như một mảng of strings hoặc numbers:

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - RadioGroupItem[]
  - RadioGroupValue
ignore:
  - modelValue
  - items
prettier: true
props:
  modelValue: System
  items:
    - System
    - Light
    - Dark
---
::

Bạn cũng có thể truyền một mảng of objects với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#value-key)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, base?: ClassNameValue, 'indicator'?: ClassNameValue, wrapper?: ClassNameValue, label?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - RadioGroupItem[]
  - RadioGroupValue
ignore:
  - modelValue
  - items
props:
  modelValue: system
  items:
    - label: System
      description: This is the first option.
      value: system
    - label: Light
      description: This is the second option.
      value: light
    - label: Dark
      description: This is the third option.
      value: dark
---
::

::caution
Khi sử dụng objects, bạn cần reference thuộc tính `value` của object trong directive `v-model` hoặc prop `default-value`.
::

### Value Key

Bạn có thể thay đổi property được sử dụng để set value bằng cách sử dụng prop `value-key`. Mặc định là `value`.

::component-code
---
external:
  - items
  - modelValue
externalTypes:
  - RadioGroupItem[]
  - RadioGroupValue
ignore:
  - modelValue
  - items
  - valueKey
props:
  modelValue: light
  valueKey: id
  items:
    - label: System
      description: This is the first option.
      id: system
    - label: Light
      description: This is the second option.
      id: light
    - label: Dark
      description: This is the third option.
      id: dark
---
::

### Legend

Sử dụng prop `legend` để đặt legend của RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  legend: Theme
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Color

Sử dụng prop `color` để thay đổi color của RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  color: neutral
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Variant

Sử dụng prop `variant` để thay đổi variant của RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  color: primary
  variant: table
  defaultValue: pro
  items:
    - label: Pro
      value: pro
      description: Tailored for indie hackers, freelancers and solo founders.
    - label: Startup
      value: startup
      description: Best suited for small teams, startups and agencies.
    - label: Enterprise
      value: enterprise
      description: Ideal for larger teams and organizations.
---
::

### Size

Sử dụng prop `size` để thay đổi size của RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  size: xl
  variant: list
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi orientation của RadioGroup. Mặc định là `vertical`.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  orientation: horizontal
  variant: list
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Indicator

Sử dụng prop `indicator` để thay đổi position hoặc hide indicator. Mặc định là `start`.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  indicator: end
  variant: card
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

### Disabled

Sử dụng prop `disabled` để disable RadioGroup.

::component-code
---
external:
  - items
externalTypes:
  - RadioGroupItem[]
ignore:
  - defaultValue
  - items
prettier: true
props:
  disabled: true
  defaultValue: System
  items:
    - System
    - Light
    - Dark
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Select

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của Select hoặc prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

### Items

Sử dụng prop `items` dưới dạng mảng các chuỗi, số hoặc boolean:

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Backlog
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

Bạn cũng có thể truyền một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#value-key)
- [`type?: "label" | "separator" | "item"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-items-type)
- [`icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-icons-in-items)
- [`avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-avatar-in-items)
- [`chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-chip-in-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { label?: ClassNameValue, separator?: ClassNameValue, item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLabel?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
props:
  modelValue: backlog
  items:
    - label: Backlog
      value: backlog
    - label: Todo
      value: todo
    - label: In Progress
      value: in_progress
    - label: Done
      value: done
  class: w-48
---
::

::caution
Khi sử dụng đối tượng, bạn cần tham chiếu thuộc tính `value` của đối tượng trong directive `v-model` hoặc prop `default-value`.
::

Bạn cũng có thể truyền một mảng các mảng để hiển thị các nhóm mục được phân tách.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Apple
  items:
    - - Apple
      - Banana
      - Blueberry
      - Grapes
      - Pineapple
    - - Aubergine
      - Broccoli
      - Carrot
      - Courgette
      - Leek
  class: w-48
---
::

### Value Key

Bạn có thể thay đổi thuộc tính được sử dụng để đặt giá trị bằng cách sử dụng prop `value-key`. Mặc định là `value`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - valueKey
  - items
  - class
props:
  modelValue: backlog
  valueKey: id
  items:
    - label: Backlog
      id: backlog
    - label: Todo
      id: todo
    - label: In Progress
      id: in_progress
    - label: Done
      id: done
  class: w-48
---
::

### Multiple

Sử dụng prop `multiple` để cho phép lựa chọn nhiều, các mục đã chọn sẽ được phân tách bằng dấu phẩy trong trigger.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
  - class
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::caution
Đảm bảo truyền một mảng đến prop `default-value` hoặc directive `v-model`.
::

### Placeholder

Sử dụng prop `placeholder` để đặt văn bản placeholder.

::component-code
---
external:
  - items
ignore:
  - items
  - class
prettier: true
props:
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Content

Sử dụng prop `content` để kiểm soát cách nội dung Select được hiển thị, như `align` hoặc `side` của nó.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  modelValue: Backlog
  content:
    align: center
    side: bottom
    sideOffset: 8
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Arrow

Sử dụng prop `arrow` để hiển thị mũi tên trên Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
  - arrow
prettier: true
props:
  modelValue: Backlog
  arrow: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Color

Sử dụng prop `color` để thay đổi màu vòng khi Select được focus.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  highlight: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::note
Prop `highlight` được sử dụng ở đây để hiển thị trạng thái focus. Nó được sử dụng nội bộ khi có lỗi xác thực.
::

### Variant

Sử dụng prop `variant` để thay đổi variant của Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  variant: subtle
  highlight: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  size: xl
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  icon: i-lucide-search
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Trailing Icon

Sử dụng prop `trailing-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) trailing. Mặc định là `i-lucide-chevron-down`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  trailingIcon: i-lucide-arrow-down
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.chevronDown`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.chevronDown`.
  :::
::

### Selected Icon

Sử dụng prop `selected-icon` để tùy chỉnh icon khi một mục được chọn. Mặc định là `i-lucide-check`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  selectedIcon: i-lucide-flame
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Nuxt
  avatar:
    src: https://github.com/nuxt.png
  items:
    - Nuxt
    - NuxtHub
    - NuxtLabs
    - Nuxt Modules
    - Nuxt Community
  class: w-48
---
::

### Loading

Sử dụng prop `loading` để hiển thị icon loading trên Select.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  trailing: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh icon loading. Mặc định là `i-lucide-loader-circle`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  loadingIcon: i-lucide-loader
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Select.

::component-code
---
external:
  - items
ignore:
  - items
  - placeholder
  - class
prettier: true
props:
  disabled: true
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

## Examples

### With items type

Bạn có thể sử dụng thuộc tính `type` với `separator` để hiển thị một separator giữa các mục hoặc `label` để hiển thị một label.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
props:
  modelValue: Apple
  items:
    - type: label
      label: Fruits
    - Apple
    - Banana
    - Blueberry
    - Grapes
    - Pineapple
    - type: separator
    - type: label
      label: Vegetables
    - Aubergine
    - Broccoli
    - Carrot
    - Courgette
    - Leek
  class: w-48
---
::

### With icon in items

Bạn có thể sử dụng thuộc tính `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong các mục.

::component-example{collapse name="select-items-icon-example"}
::

::note
Trong ví dụ này, icon được tính toán từ thuộc tính `value` của mục đã chọn.
::

::tip
Bạn cũng có thể sử dụng slot `#leading` để hiển thị icon đã chọn.
::

### With avatar in items

Bạn có thể sử dụng thuộc tính `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong các mục.

::component-example{collapse name="select-items-avatar-example"}
::

::note
Trong ví dụ này, avatar được tính toán từ thuộc tính `value` của mục đã chọn.
::

::tip
Bạn cũng có thể sử dụng slot `#leading` để hiển thị avatar đã chọn.
::

### With chip in items

Bạn có thể sử dụng thuộc tính `chip` để hiển thị một [Chip](https://nuxt.com/components/chip) bên trong các mục.

::component-example{collapse name="select-items-chip-example"}
::

::note
Trong ví dụ này, slot `#leading` được sử dụng để hiển thị chip đã chọn.
::

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="select-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi Select bằng cách nhấn ``.
::

### With rotating icon

Đây là một ví dụ với icon xoay chỉ ra trạng thái mở của Select.

::component-example{name="select-icon-example"}
::

### With fetched items

Bạn có thể lấy các mục từ một API và sử dụng chúng trong Select.

::component-example{collapse name="select-fetch-example"}
::

### With full content width

Bạn có thể mở rộng nội dung đến chiều rộng đầy đủ của các mục của nó bằng cách sử dụng khóa `ui.content`.

::component-example{collapse name="select-content-width-example"}
::

::tip
Bạn cũng có thể thay đổi chiều rộng nội dung toàn cục trong `app.config.ts` của bạn:

```text
export default defineAppConfig({
  ui: {
    select: {
      slots: {
        content: 'min-w-fit'
      }
    }
  }
})
```
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

Khi truy cập thành phần qua template ref, bạn có thể sử dụng những thứ sau:

| Name                                                                                                                                     | Type                                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `triggerRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof SelectTrigger> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# SelectMenu

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của SelectMenu hoặc prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::tip
Sử dụng điều này thay vì [`Select`](https://nuxt.com/components/select) để tận dụng thành phần [`Combobox`](https://reka-ui.com/docs/components/combobox){rel="nofollow"} của Reka UI cung cấp khả năng tìm kiếm và lựa chọn nhiều.
::

::note
Thành phần này tương tự như [`InputMenu`](https://nuxt.com/components/input-menu) nhưng sử dụng Select thay vì Input với tìm kiếm bên trong menu.
::

### Items

Sử dụng prop `items` dưới dạng mảng các chuỗi, số hoặc boolean:

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Backlog
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

Bạn cũng có thể truyền một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`type?: "label" | "separator" | "item"`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-items-type)
- [`icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-icons-in-items)
- [`avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-avatar-in-items)
- [`chip?: ChipProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-chip-in-items)
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { label?: ClassNameValue, separator?: ClassNameValue, item?: ClassNameValue, itemLeadingIcon?: ClassNameValue, itemLeadingAvatarSize?: ClassNameValue, itemLeadingAvatar?: ClassNameValue, itemLeadingChipSize?: ClassNameValue, itemLeadingChip?: ClassNameValue, itemLabel?: ClassNameValue, itemTrailing?: ClassNameValue, itemTrailingIcon?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue.label
  - items
  - class
props:
  modelValue:
    label: Todo
  items:
    - label: Backlog
    - label: Todo
    - label: In Progress
    - label: Done
  class: w-48
---
::

::caution
Không giống như thành phần [`Select`](https://nuxt.com/components/select), SelectMenu mong đợi toàn bộ đối tượng được truyền đến directive `v-model` hoặc prop `default-value` theo mặc định.
::

Bạn cũng có thể truyền một mảng các mảng để hiển thị các nhóm mục được phân tách.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
prettier: true
props:
  modelValue: Apple
  items:
    - - Apple
      - Banana
      - Blueberry
      - Grapes
      - Pineapple
    - - Aubergine
      - Broccoli
      - Carrot
      - Courgette
      - Leek
  class: w-48
---
::

### Value Key

Bạn có thể chọn ràng buộc một thuộc tính duy nhất của đối tượng thay vì toàn bộ đối tượng bằng cách sử dụng prop `value-key`. Mặc định là `undefined`.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - valueKey
  - items
  - class
props:
  modelValue: todo
  valueKey: id
  items:
    - label: Backlog
      id: backlog
    - label: Todo
      id: todo
    - label: In Progress
      id: in_progress
    - label: Done
      id: done
  class: w-48
---
::

### Multiple

Sử dụng prop `multiple` để cho phép lựa chọn nhiều, các mục đã chọn sẽ được phân tách bằng dấu phẩy trong trigger.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - multiple
  - class
prettier: true
props:
  modelValue:
    - Backlog
    - Todo
  multiple: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::caution
Đảm bảo truyền một mảng đến prop `default-value` hoặc directive `v-model`.
::

### Placeholder

Sử dụng prop `placeholder` để đặt văn bản placeholder.

::component-code
---
external:
  - items
ignore:
  - items
  - class
prettier: true
props:
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Search Input

Sử dụng prop `search-input` để tùy chỉnh hoặc ẩn input tìm kiếm (với giá trị `false`).

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Input](https://nuxt.com/components/input) để tùy chỉnh nó.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - modelValue.label
  - modelValue.icon
  - items
  - class
prettier: true
props:
  modelValue:
    label: Backlog
    icon: i-lucide-circle-help
  searchInput:
    placeholder: Filter...
    icon: i-lucide-search
  items:
    - label: Backlog
      icon: i-lucide-circle-help
    - label: Todo
      icon: i-lucide-circle-plus
    - label: In Progress
      icon: i-lucide-circle-arrow-up
    - label: Done
      icon: i-lucide-circle-check
  class: w-48
---
::

::tip
Bạn có thể đặt prop `search-input` thành `false` để ẩn input tìm kiếm.
::

### Content

Sử dụng prop `content` để kiểm soát cách nội dung SelectMenu được hiển thị, như `align` hoặc `side` của nó.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  modelValue: Backlog
  content:
    align: center
    side: bottom
    sideOffset: 8
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Arrow

Sử dụng prop `arrow` để hiển thị mũi tên trên SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
  - arrow
prettier: true
props:
  modelValue: Backlog
  arrow: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Color

Sử dụng prop `color` để thay đổi màu vòng khi SelectMenu được focus.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  highlight: true
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::note
Prop `highlight` được sử dụng ở đây để hiển thị trạng thái focus. Nó được sử dụng nội bộ khi có lỗi xác thực.
::

### Variant

Sử dụng prop `variant` để thay đổi variant của SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  color: neutral
  variant: subtle
  highlight: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  size: xl
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  icon: i-lucide-search
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Trailing Icon

Sử dụng prop `trailing-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) trailing. Mặc định là `i-lucide-chevron-down`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  trailingIcon: i-lucide-arrow-down
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.chevronDown`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.chevronDown`.
  :::
::

### Selected Icon

Sử dụng prop `selected-icon` để tùy chỉnh icon khi một mục được chọn. Mặc định là `i-lucide-check`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  selectedIcon: i-lucide-flame
  size: md
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.check`.
  :::
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Nuxt
  avatar:
    src: https://github.com/nuxt.png
  items:
    - Nuxt
    - NuxtHub
    - NuxtLabs
    - Nuxt Modules
    - Nuxt Community
  class: w-48
---
::

### Loading

Sử dụng prop `loading` để hiển thị icon loading trên SelectMenu.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  trailing: false
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh icon loading. Mặc định là `i-lucide-loader-circle`.

::component-code
---
external:
  - items
  - modelValue
ignore:
  - items
  - modelValue
  - class
prettier: true
props:
  modelValue: Backlog
  loading: true
  loadingIcon: i-lucide-loader
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa SelectMenu.

::component-code
---
external:
  - items
ignore:
  - items
  - placeholder
  - class
prettier: true
props:
  disabled: true
  placeholder: Select status
  items:
    - Backlog
    - Todo
    - In Progress
    - Done
  class: w-48
---
::

## Examples

### With items type

Bạn có thể sử dụng thuộc tính `type` với `separator` để hiển thị một separator giữa các mục hoặc `label` để hiển thị một label.

::component-code
---
collapse: true
external:
  - items
  - modelValue
ignore:
  - modelValue
  - items
  - class
props:
  modelValue: Apple
  items:
    - type: label
      label: Fruits
    - Apple
    - Banana
    - Blueberry
    - Grapes
    - Pineapple
    - type: separator
    - type: label
      label: Vegetables
    - Aubergine
    - Broccoli
    - Carrot
    - Courgette
    - Leek
  class: w-48
---
::

### With icon in items

Bạn có thể sử dụng thuộc tính `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong các mục.

::component-example{collapse name="select-menu-items-icon-example"}
::

::tip
Bạn cũng có thể sử dụng slot `#leading` để hiển thị icon đã chọn.
::

### With avatar in items

Bạn có thể sử dụng thuộc tính `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong các mục.

::component-example{collapse name="select-menu-items-avatar-example"}
::

::tip
Bạn cũng có thể sử dụng slot `#leading` để hiển thị avatar đã chọn.
::

### With chip in items

Bạn có thể sử dụng thuộc tính `chip` để hiển thị một [Chip](https://nuxt.com/components/chip) bên trong các mục.

::component-example{collapse name="select-menu-items-chip-example"}
::

::note
Trong ví dụ này, slot `#leading` được sử dụng để hiển thị chip đã chọn.
::

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="select-menu-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi SelectMenu bằng cách nhấn ``.
::

### Control search term

Sử dụng directive `v-model:search-term` để kiểm soát từ khóa tìm kiếm.

::component-example{name="select-menu-search-term-example"}
::

### With rotating icon

Đây là một ví dụ với icon xoay chỉ ra trạng thái mở của SelectMenu.

::component-example{name="select-menu-icon-example"}
::

### With create item

Sử dụng prop `create-item` để cho phép người dùng thêm giá trị tùy chỉnh không có trong các tùy chọn được định sẵn.

::component-example{collapse name="select-menu-create-item-example"}
::

::note
Tùy chọn tạo hiển thị khi không tìm thấy kết quả phù hợp theo mặc định. Đặt nó thành `always` để hiển thị ngay cả khi có giá trị tương tự tồn tại.
::

::tip{to="https://nuxt.com/#emits"}
Sử dụng sự kiện `@create` để xử lý việc tạo mục. Bạn sẽ nhận được sự kiện và mục dưới dạng đối số.
::

### With fetched items

Bạn có thể lấy các mục từ một API và sử dụng chúng trong SelectMenu.

::component-example{collapse name="select-menu-fetch-example"}
::

### With ignore filter

Đặt prop `ignore-filter` thành `true` để vô hiệu hóa tìm kiếm nội bộ và sử dụng logic tìm kiếm của riêng bạn.

::component-example{collapse name="select-menu-ignore-filter-example"}
::

::note
Ví dụ này sử dụng [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} để debounce các cuộc gọi API.
::

### With filter fields

Sử dụng prop `filter-fields` với một mảng các trường để lọc trên. Mặc định là `[labelKey]`.

::component-example{collapse name="select-menu-filter-fields-example"}
::

### With full content width

Bạn có thể mở rộng nội dung đến chiều rộng đầy đủ của các mục của nó bằng cách sử dụng khóa `ui.content`.

::component-example{collapse name="select-menu-content-width-example"}
::

::tip
Bạn cũng có thể thay đổi chiều rộng nội dung toàn cục trong `app.config.ts` của bạn:

```text
export default defineAppConfig({
  ui: {
    selectMenu: {
      slots: {
        content: 'min-w-fit'
      }
    }
  }
})
```
::

### As a CountryPicker

Ví dụ này minh họa việc sử dụng SelectMenu làm country picker với lazy loading - các quốc gia chỉ được lấy khi menu được mở.

::component-example{collapse name="select-menu-countries-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

Khi truy cập thành phần qua template ref, bạn có thể sử dụng những thứ sau:

| Name                                                                                                                                     | Type                                                                                                                                                                           |
| ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `triggerRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<InstanceType<typeof ComboboxTrigger> | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Separator

## Usage

Sử dụng Separator component as-is để phân tách nội dung.

::component-code{.p-8}
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của Separator. Mặc định là `horizontal`.

::component-code
---
ignore:
  - class
props:
  orientation: vertical
  class: h-48
class: p-8
---
::

### Label

Sử dụng prop `label` để hiển thị một label ở giữa Separator.

::component-code{.p-8 :props='{"label":"Hello World"}'}
::

### Icon

Sử dụng prop `icon` để hiển thị một icon ở giữa Separator.

::component-code{.p-8 :props='{"icon":"i-simple-icons-nuxtdotjs"}'}
::

### Avatar

Sử dụng prop `avatar` để hiển thị một avatar ở giữa Separator.

::component-code
---
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
class: p-8
---
::

### Color

Sử dụng prop `color` để thay đổi màu của Separator. Mặc định là `neutral`.

::component-code{.p-8 :props='{"color":"primary","type":"solid"}'}
::

### Type

Sử dụng prop `type` để thay đổi loại của Separator. Mặc định là `solid`.

::component-code{.p-8 :props='{"type":"dashed"}'}
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Separator. Mặc định là `xs`.

::component-code{.p-8 :props='{"size":"lg"}'}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Skeleton

## Usage

::component-example{name="skeleton-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Slideover

## Usage

Sử dụng một [Button](https://nuxt.com/components/button) hoặc bất kỳ component nào khác trong slot default của Slideover.

Sau đó, sử dụng slot `#content` để thêm nội dung hiển thị khi Slideover được mở.

::component-code
---
prettier: true
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  content: |
    
    <Placeholder class="h-full m-4" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#content
  :::placeholder{.h-full.m-4}
  :::
::

Bạn cũng có thể sử dụng các slot `#header`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}, `#body`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} và `#footer`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} để tùy chỉnh nội dung của Slideover.

### Title

Sử dụng prop `title` để đặt tiêu đề của header Slideover's.

::component-code
---
prettier: true
props:
  title: Slideover with title
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Description

Sử dụng prop `description` để đặt mô tả của header Slideover's.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Slideover with description
  description: Lorem ipsum dolor sit amet, consectetur adipiscing elit.
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Close

Sử dụng prop `close` để tùy chỉnh hoặc ẩn nút close (với giá trị `false`) được hiển thị trong header Slideover's.

Bạn có thể truyền bất kỳ thuộc tính nào từ thành phần [Button](https://nuxt.com/components/button) để tùy chỉnh nó.

::component-code
---
ignore:
  - title
  - close.color
  - close.variant
prettier: true
props:
  title: Slideover with close button
  close:
    color: primary
    variant: outline
    class: rounded-full
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

::note
Nút close không được hiển thị nếu slot `#content` được sử dụng vì nó là một phần của header.
::

### Close Icon

Sử dụng prop `close-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) của nút close. Mặc định là `i-lucide-x`.

::component-code
---
ignore:
  - title
prettier: true
props:
  title: Slideover with close button
  closeIcon: i-lucide-arrow-right
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::
::

### Side

Sử dụng prop `side` để đặt bên của màn hình mà Slideover sẽ trượt vào từ đó. Mặc định là `right`.

::component-code
---
ignore:
  - title
prettier: true
props:
  side: left
  title: Slideover with side
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full min-h-48" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full.min-h-48}
  :::
::

### Overlay

Sử dụng prop `overlay` để kiểm soát xem Slideover có overlay hay không. Mặc định là `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  overlay: false
  title: Slideover without overlay
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Transition

Sử dụng prop `transition` để kiểm soát xem Slideover có được animate hay không. Mặc định là `true`.

::component-code
---
ignore:
  - title
prettier: true
props:
  transition: false
  title: Slideover without transition
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

## Examples

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="slideover-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi Slideover bằng cách nhấn ``.
::

::tip
Điều này cho phép bạn di chuyển trigger ra ngoài Slideover hoặc loại bỏ nó hoàn toàn.
::

### Disable dismissal

Đặt prop `dismissible` thành `false` để ngăn Slideover bị đóng khi nhấp bên ngoài hoặc nhấn escape. Sự kiện `close:prevent` sẽ được emit khi người dùng cố gắng đóng nó.

::component-code
---
ignore:
  - title
  - dismissible
prettier: true
props:
  dismissible: false
  title: Slideover non-dismissible
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
  body: |
    
    <Placeholder class="h-full" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::

#body
  :::placeholder{.h-full}
  :::
::

### Programmatic usage

Bạn có thể sử dụng composable [`useOverlay`](https://nuxt.com/composables/use-overlay) để mở Slideover theo chương trình.

::warning
Hãy đảm bảo wrap app của bạn với thành phần [`App`](https://nuxt.com/components/app) sử dụng thành phần [`OverlayProvider`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/OverlayProvider.vue){rel="nofollow"}.
::

Đầu tiên, tạo một slideover component sẽ được mở theo chương trình:

::component-example{prettier :preview='false' name="slideover-example"}
::

::note
Chúng tôi đang emit sự kiện `close` khi slideover được đóng hoặc dismissed ở đây. Bạn có thể emit bất kỳ dữ liệu nào thông qua sự kiện `close`, tuy nhiên, sự kiện phải được emit để capture giá trị trả về.
::

Sau đó, sử dụng nó trong app của bạn:

::component-example{name="slideover-programmatic-example"}
::

::tip
Bạn có thể đóng slideover trong slideover component bằng cách emit `emit('close')`.
::

### Nested slideovers

Bạn có thể lồng slideovers trong nhau.

::component-example{name="slideover-nested-example"}
::

### With footer slot

Sử dụng slot `#footer` để thêm nội dung sau body của Slideover.

::component-example{name="slideover-footer-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Slider

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của Slider.

::component-code{:external='["modelValue"]' :props='{"modelValue":50}'}
::

Sử dụng prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":50}'}
::

### Min / Max

Sử dụng prop `min` và `max` để đặt giá trị tối thiểu và tối đa của Slider. Mặc định là `0` và `100`.

::component-code
---
ignore:
  - defaultValue
props:
  min: 0
  max: 50
  defaultValue: 50
---
::

### Step

Sử dụng prop `step` để đặt giá trị tăng của Slider. Mặc định là `1`.

::component-code
---
ignore:
  - defaultValue
props:
  step: 10
  defaultValue: 50
---
::

### Multiple

Sử dụng directive `v-model` hoặc prop `default-value` với một mảng giá trị để tạo một range Slider.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue:
    - 25
    - 75
---
::

Sử dụng prop `min-steps-between-thumbs` để giới hạn khoảng cách tối thiểu giữa các thumbs.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue:
    - 25
    - 50
    - 75
  minStepsBetweenThumbs: 10
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của Slider. Mặc định là `horizontal`.

::component-code
---
ignore:
  - defaultValue
  - class
props:
  orientation: vertical
  defaultValue: 50
  class: h-48
---
::

### Color

Sử dụng prop `color` để thay đổi màu của Slider.

::component-code
---
ignore:
  - defaultValue
props:
  color: neutral
  defaultValue: 50
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Slider.

::component-code
---
ignore:
  - defaultValue
props:
  size: xl
  defaultValue: 50
---
::

### Tooltip

Sử dụng prop `tooltip` để hiển thị một [Tooltip](https://nuxt.com/components/tooltip) xung quanh các thumbs của Slider với giá trị hiện tại. Bạn có thể đặt nó thành `true` cho hành vi mặc định hoặc truyền một object để tùy chỉnh với bất kỳ thuộc tính nào từ thành phần [Tooltip](https://nuxt.com/components/tooltip#props).

::component-code
---
ignore:
  - defaultValue
  - tooltip
props:
  defaultValue: 50
  tooltip: true
---
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Slider.

::component-code
---
ignore:
  - defaultValue
props:
  disabled: true
  defaultValue: 50
---
::

### Inverted

Sử dụng prop `inverted` để đảo ngược trực quan Slider.

::component-code
---
ignore:
  - defaultValue
props:
  inverted: true
  defaultValue: 25
---
::

## API

### Props

::component-props
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Stepper

## Usage

### Items

Sử dụng prop `items` dưới dạng mảng các đối tượng với các thuộc tính sau:

- `title?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `content?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string | number`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, trigger?: ClassNameValue, indicator?: ClassNameValue, icon?: ClassNameValue, separator?: ClassNameValue, wrapper?: ClassNameValue, title?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - items
  - class
props:
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

::note
Nhấp vào các mục để điều hướng qua các bước.
::

### Color

Sử dụng prop `color` để thay đổi màu của Stepper.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  color: neutral
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Stepper.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  size: xl
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của Stepper. Mặc định là `horizontal`.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  orientation: vertical
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
  class: w-full
---
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa điều hướng qua các bước.

::component-code
---
external:
  - items
externalTypes:
  - StepperItem[]
ignore:
  - content
  - items
  - class
props:
  disabled: true
  items:
    - title: Address
      description: Add your address here
      icon: i-lucide-house
    - title: Shipping
      description: Set your preferred shipping method
      icon: i-lucide-truck
    - title: Checkout
      description: Confirm your order
---
::

::note{to="https://nuxt.com/#with-controls"}
Điều này có thể hữu ích khi bạn muốn buộc điều hướng với controls.
::

## Examples

### With controls

Bạn có thể thêm các controls bổ sung cho stepper bằng buttons.

::component-example{name="stepper-with-controls-example"}
::

### Control active item

Bạn có thể kiểm soát mục active bằng cách sử dụng prop `default-value` hoặc directive `v-model` với index của mục.

::component-example{name="stepper-model-value-example"}
::

::tip
Bạn cũng có thể truyền `value` của một trong các mục nếu được cung cấp.
::

### With content slot

Sử dụng slot `#content` để tùy chỉnh nội dung của mỗi mục.

::component-example{name="stepper-content-slot-example"}
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="stepper-custom-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

Bạn có thể truy cập instance thành phần typed bằng cách sử dụng [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const stepper = useTemplateRef('stepper')
</script>

<template>
  <UStepper ref="stepper" />
</template>
```

Điều này sẽ cung cấp cho bạn quyền truy cập vào những thứ sau:

| Name                                                                                                                                  | Type                                                                                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `next`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}    | `() => void`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}   |
| `prev`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}    | `() => void`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}   |
| `hasNext`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |
| `hasPrev`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<boolean>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Switch

## Usage

Sử dụng directive `v-model` để kiểm soát trạng thái checked của Switch.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: true
---
::

Sử dụng prop `default-value` để đặt giá trị ban đầu khi bạn không cần kiểm soát trạng thái của nó.

::component-code{:ignore='["defaultValue"]' :props='{"defaultValue":true}'}
::

### Label

Sử dụng prop `label` để đặt label của Switch.

::component-code{:props='{"label":"Check me"}'}
::

Khi sử dụng prop `required`, một dấu hoa thị được thêm vào bên cạnh label.

::component-code
---
ignore:
  - label
props:
  required: true
  label: Check me
---
::

### Description

Sử dụng prop `description` để đặt mô tả của Switch.

::component-code
---
ignore:
  - label
props:
  label: Check me
  description: This is a checkbox.
---
::

### Icon

Sử dụng prop `checked-icon` và `unchecked-icon` để đặt icons của Switch khi checked và unchecked.

::component-code
---
ignore:
  - label
  - defaultValue
prettier: true
props:
  uncheckedIcon: i-lucide-x
  checkedIcon: i-lucide-check
  defaultValue: true
  label: Check me
---
::

### Loading

Sử dụng prop `loading` để hiển thị icon loading trên Switch.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  loading: true
  defaultValue: true
  label: Check me
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh icon loading. Mặc định là `i-lucide-loader-circle`.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  loading: true
  loadingIcon: i-lucide-loader
  defaultValue: true
  label: Check me
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh icon này toàn cục trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Color

Sử dụng prop `color` để thay đổi màu của Switch.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  color: neutral
  defaultValue: true
  label: Check me
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Switch.

::component-code
---
ignore:
  - label
  - defaultValue
props:
  size: xl
  defaultValue: true
  label: Check me
---
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Switch.

::component-code
---
ignore:
  - label
props:
  disabled: true
  label: Check me
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Table

## Usage

The Table component is built on top of [TanStack Table](https://tanstack.com/table/latest){rel="nofollow"} and is powered by the [useVueTable](https://tanstack.com/table/latest/docs/framework/vue/vue-table#usevuetable){rel="nofollow"} composable to provide a flexible and fully type-safe API. &#x2A;Some features of TanStack Table are not supported yet, we'll add more over time.*

::component-example{.!p-0 :source='false' name="table-example"}
::

::callout
---
ariaLabel: View source code
icon: i-simple-icons-github
to: https://github.com/nuxt/ui/tree/v3/docs/app/components/content/examples/table/TableExample.vue
---
This example demonstrates the most common use case of the `Table` component. Check out the source code on GitHub.
::

### Data

Use the `data` prop as an array of objects, the columns will be generated based on the keys of the objects.

::component-code
---
collapse: true
external:
  - data
ignore:
  - data
  - class
props:
  data:
    - id: "4600"
      date: 2024-03-11T15:30:00
      status: paid
      email: james.anderson@example.com
      amount: 594
    - id: "4599"
      date: 2024-03-11T10:10:00
      status: failed
      email: mia.white@example.com
      amount: 276
    - id: "4598"
      date: 2024-03-11T08:50:00
      status: refunded
      email: william.brown@example.com
      amount: 315
    - id: "4597"
      date: 2024-03-10T19:45:00
      status: paid
      email: emma.davis@example.com
      amount: 529
    - id: "4596"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
  class: flex-1
class: "!p-0"
---
::

### Columns

Use the `columns` prop as an array of [ColumnDef](https://tanstack.com/table/latest/docs/api/core/column-def){rel="nofollow"} objects with properties like:

- `accessorKey`: [The key of the row object to use when extracting the value for the column.]{.text-muted}
- `header`: [The header to display for the column. If a string is passed, it can be used as a default for the column ID. If a function is passed, it will be passed a props object for the header and should return the rendered header value (the exact type depends on the adapter being used).]{.text-muted}
- `footer`: [The footer to display for the column. Works exactly like header, but is displayed under the table.]{.text-muted}
- `cell`: [The cell to display each row for the column. If a function is passed, it will be passed a props object for the cell and should return the rendered cell value (the exact type depends on the adapter being used).]{.text-muted}
- `meta`: [Extra properties for the column.]{.text-muted}
  - `class`:

    - `td`: [The classes to apply to the `td` element.]{.text-muted}
    - `th`: [The classes to apply to the `th` element.]{.text-muted}
  - `style`:

    - `td`: [The style to apply to the `td` element.]{.text-muted}
    - `th`: [The style to apply to the `th` element.]{.text-muted}

In order to render components or other HTML elements, you will need to use the Vue [`h` function](https://vuejs.org/api/render-function.html#h){rel="nofollow"} inside the `header` and `cell` props. This is different from other components that use slots but allows for more flexibility.

::tip{ariaLabel="Table columns with slots" to="https://nuxt.com/#with-slots"}
You can also use slots to customize the header and data cells of the table.
::

::component-example
---
collapse: true
highlights:
  - 53
  - 105
prettier: true
class: "!p-0"
name: table-columns-example
---
::

::note
When rendering components with `h`, you can either use the `resolveComponent` function or import from `#components`.
::

### Meta

Use the `meta` prop as an object ([TableMeta](https://tanstack.com/table/latest/docs/api/core/table#meta){rel="nofollow"}) to pass properties like:

- `class`:

  - `tr`: [The classes to apply to the `tr` element.]{.text-muted}
- `style`:

  - `tr`: [The style to apply to the `tr` element.]{.text-muted}

### Loading

Use the `loading` prop to display a loading state, the `loading-color` prop to change its color and the `loading-animation` prop to change its animation.

::component-code
---
collapse: true
external:
  - data
ignore:
  - data
  - class
props:
  loading: true
  loadingColor: primary
  loadingAnimation: carousel
  data:
    - id: "4600"
      date: 2024-03-11T15:30:00
      status: paid
      email: james.anderson@example.com
      amount: 594
    - id: "4599"
      date: 2024-03-11T10:10:00
      status: failed
      email: mia.white@example.com
      amount: 276
    - id: "4598"
      date: 2024-03-11T08:50:00
      status: refunded
      email: william.brown@example.com
      amount: 315
    - id: "4597"
      date: 2024-03-10T19:45:00
      status: paid
      email: emma.davis@example.com
      amount: 529
    - id: "4596"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
  class: flex-1
class: "!p-0"
---
::

### Sticky

Use the `sticky` prop to make the header or footer sticky.

::component-code
---
collapse: true
external:
  - data
ignore:
  - data
  - class
items:
  sticky:
    - true
    - false
props:
  sticky: true
  data:
    - id: "4600"
      date: 2024-03-11T15:30:00
      status: paid
      email: james.anderson@example.com
      amount: 594
    - id: "4599"
      date: 2024-03-11T10:10:00
      status: failed
      email: mia.white@example.com
      amount: 276
    - id: "4598"
      date: 2024-03-11T08:50:00
      status: refunded
      email: william.brown@example.com
      amount: 315
    - id: "4597"
      date: 2024-03-10T19:45:00
      status: paid
      email: emma.davis@example.com
      amount: 529
    - id: "4596"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
    - id: "4595"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
    - id: "4594"
      date: 2024-03-10T15:55:00
      status: paid
      email: ethan.harris@example.com
      amount: 639
  class: flex-1 max-h-[312px]
class: "!p-0"
---
::

## Examples

### With row actions

You can add a new column that renders a [DropdownMenu](https://nuxt.com/components/dropdown-menu) component inside the `cell` to render row actions.

::component-example
---
collapse: true
highlights:
  - 110
  - 134
prettier: true
class: "!p-0"
name: table-row-actions-example
---
::

### With expandable rows

You can add a new column that renders a [Button](https://nuxt.com/components/button) component inside the `cell` to toggle the expandable state of a row using the TanStack Table [Expanding APIs](https://tanstack.com/table/latest/docs/api/features/expanding){rel="nofollow"}.

::caution
You need to define the `#expanded` slot to render the expanded content which will receive the row as a parameter.
::

::component-example
---
collapse: true
highlights:
  - 55
  - 71
prettier: true
class: "!p-0"
name: table-row-expandable-example
---
::

::tip
You can use the `expanded` prop to control the expandable state of the rows (can be binded with `v-model`).
::

::note
You could also add this action to the [`DropdownMenu`](https://nuxt.com/components/dropdown-menu) component inside the `actions` column.
::

### With grouped rows

You can group rows based on a given column value and show/hide sub rows via some button added to the cell using the TanStack Table [Grouping APIs](https://tanstack.com/table/latest/docs/api/features/grouping){rel="nofollow"}.

#### Important parts:

- Add `grouping` prop with an array of column ids you want to group by.
- Add `grouping-options` prop. It must include `getGroupedRowModel`, you can import it from `@tanstack/vue-table` or implement your own.
- Expand rows via `row.toggleExpanded()` method on any cell of the row. Keep in mind, it also toggles `#expanded` slot.
- Use `aggregateFn` on column definition to define how to aggregate the rows.
- `agregatedCell` renderer on column definition only works if there is no `cell` renderer.

::component-example
---
collapse: true
highlights:
  - 159
  - 169
prettier: true
class: "!p-0"
name: table-grouped-rows-example
---
::

### With row selection

You can add a new column that renders a [Checkbox](https://nuxt.com/components/checkbox) component inside the `header` and `cell` to select rows using the TanStack Table [Row Selection APIs](https://tanstack.com/table/latest/docs/api/features/row-selection){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 55
  - 72
prettier: true
class: "!p-0"
name: table-row-selection-example
---
::

::tip
You can use the `row-selection` prop to control the selection state of the rows (can be binded with `v-model`).
::

### With row select event

You can add a `@select` listener to make rows clickable with or without a checkbox column.

::note
The handler function receives the `TableRow` instance as the first argument and an optional `Event` as the second argument.
::

::component-example
---
collapse: true
highlights:
  - 123
  - 130
prettier: true
class: "!p-0"
name: table-row-select-event-example
---
::

::tip
You can use this to navigate to a page, open a modal or even to select the row manually.
::

### With row context menu event :badge{.align-text-top label="New"}

You can add a `@contextmenu` listener to make rows right clickable and wrap the Table in a [ContextMenu](https://nuxt.com/components/context-menu) component to display row actions for example.

::note
The handler function receives the `Event` and `TableRow` instance as the first and second arguments respectively.
::

::component-example
---
collapse: true
highlights:
  - 130
  - 170
prettier: true
class: "!p-0"
name: table-row-context-menu-event-example
---
::

### With row hover event :badge{.align-text-top label="New"}

You can add a `@hover` listener to make rows hoverable and use a [Popover](https://nuxt.com/components/popover) or a [Tooltip](https://nuxt.com/components/tooltip) component to display row details for example.

::note
The handler function receives the `Event` and `TableRow` instance as the first and second arguments respectively.
::

::component-example
---
collapse: true
highlights:
  - 126
  - 149
prettier: true
class: "!p-0"
name: table-row-hover-event-example
---
::

::note
This example is similar as the Popover [with following cursor example](https://nuxt.com/components/popover#with-following-cursor) and uses a [`refDebounced`](https://vueuse.org/shared/refDebounced/#refdebounced){rel="nofollow"} to prevent the Popover from opening and closing too quickly when moving the cursor from one row to another.
::

### With column footer :badge{.align-text-top label="New"}

You can add a `footer` property to the column definition to render a footer for the column.

::component-example
---
collapse: true
highlights:
  - 94
  - 108
prettier: true
class: "!p-0"
name: table-column-footer-example
---
::

### With column sorting

You can update a column `header` to render a [Button](https://nuxt.com/components/button) component inside the `header` to toggle the sorting state using the TanStack Table [Sorting APIs](https://tanstack.com/table/latest/docs/api/features/sorting){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 90
  - 105
prettier: true
class: "!p-0"
name: table-column-sorting-example
---
::

::tip
You can use the `sorting` prop to control the sorting state of the columns (can be binded with `v-model`).
::

You can also create a reusable component to make any column header sortable.

::component-example
---
collapse: true
highlights:
  - 110
  - 161
prettier: true
class: "!p-0"
name: table-column-sorting-reusable-example
---
::

::note
In this example, we use a function to define the column header but you can also create an actual component.
::

### With column pinning

You can update a column `header` to render a [Button](https://nuxt.com/components/button) component inside the `header` to toggle the pinning state using the TanStack Table [Pinning APIs](https://tanstack.com/table/latest/docs/api/features/row-pinning){rel="nofollow"}.

::note
A pinned column will become sticky on the left or right side of the table.
::

::component-example
---
collapse: true
highlights:
  - 100
  - 113
prettier: true
class: "!p-0 overflow-clip"
name: table-column-pinning-example
---
::

::tip
You can use the `column-pinning` prop to control the pinning state of the columns (can be binded with `v-model`).
::

### With column visibility

You can use a [DropdownMenu](https://nuxt.com/components/dropdown-menu) component to toggle the visibility of the columns using the TanStack Table [Column Visibility APIs](https://tanstack.com/table/latest/docs/api/features/column-visibility){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 135
  - 142
prettier: true
class: "!p-0"
name: table-column-visibility-example
---
::

::tip
You can use the `column-visibility` prop to control the visibility state of the columns (can be binded with `v-model`).
::

### With column filters

You can use an [Input](https://nuxt.com/components/input) component to filter per column the rows using the TanStack Table [Column Filtering APIs](https://tanstack.com/table/latest/docs/api/features/column-filtering){rel="nofollow"}.

::component-example
---
collapse: true
highlights:
  - 135
  - 142
prettier: true
class: "!p-0"
name: table-column-filters-example
---
::

::tip
You can use the `column-filters` prop to control the filters state of the columns (can be binded with `v-model`).
::

### With global filter

You can use an [Input](https://nuxt.com/components/input) component to filter the rows using the TanStack Table [Global Filtering APIs](https://tanstack.com/table/latest/docs/api/features/global-filtering){rel="nofollow"}.

::component-example{.!p-0 collapse prettier name="table-global-filter-example"}
::

::tip
You can use the `global-filter` prop to control the global filter state (can be binded with `v-model`).
::

### With pagination

You can use a [Pagination](https://nuxt.com/components/pagination) component to control the pagination state using the [Pagination APIs](https://tanstack.com/table/latest/docs/api/features/pagination){rel="nofollow"}.

There are different pagination approaches as explained in [Pagination Guide](https://tanstack.com/table/latest/docs/guide/pagination#pagination-guide){rel="nofollow"}. In this example, we use client-side pagination so we need to manually pass `getPaginationRowModel()`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} function.

::component-example{.!p-0 collapse prettier name="table-pagination-example"}
::

::tip
You can use the `pagination` prop to control the pagination state (can be binded with `v-model`).
::

### With fetched data

You can fetch data from an API and use them in the Table.

::component-example{.!p-0 collapse prettier name="table-fetch-example"}
::

### With infinite scroll

If you use server-side pagination, you can use the [`useInfiniteScroll`](https://vueuse.org/core/useInfiniteScroll/#useinfinitescroll){rel="nofollow"} composable to load more data when scrolling.

::component-example
---
collapse: true
overflowHidden: true
prettier: true
class: "!p-0"
name: table-infinite-scroll-example
---
::

### With drag and drop

Use the [`useSortable`](https://vueuse.org/integrations/useSortable/){rel="nofollow"} composable from [`@vueuse/integrations`](https://vueuse.org/integrations/README.html){rel="nofollow"} to enable drag and drop functionality on the Table. This integration wraps [Sortable.js](https://sortablejs.github.io/Sortable/){rel="nofollow"} to provide a seamless drag and drop experience.

::note
Since the table ref doesn't expose the tbody element, add a unique class to it via the `:ui` prop to target it with `useSortable` (e.g. `:ui="{ tbody: 'my-table-tbody' }"`).
::

::component-example{.!p-0 collapse prettier name="table-drag-and-drop-example"}
::

### With slots

You can use slots to customize the header and data cells of the table.

Use the `#<column>-header` slot to customize the header of a column. You will have access to the `column`, `header` and `table` properties in the slot scope.

Use the `#<column>-cell` slot to customize the cell of a column. You will have access to the `cell`, `column`, `getValue`, `renderValue`, `row`, and `table` properties in the slot scope.

::component-example{.!p-0 collapse prettier name="table-slots-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Expose

You can access the typed component instance using [`useTemplateRef`](https://vuejs.org/api/composition-api-helpers.html#usetemplateref){rel="nofollow"}.

```vue
<script setup lang="ts">
const table = useTemplateRef('table')
</script>

<template>
  <UTable ref="table" />
</template>
```

This will give you access to the following:

| Name                                                                                                                                   | Type                                                                                                                                                                                                                               |
| -------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `tableRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLTableElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}                                                                         |
| `tableApi`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | [`Ref<Table | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://tanstack.com/table/latest/docs/api/core/table#table-api){rel="nofollow"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Tabs

## Usage

### Items

Sử dụng prop `items` dưới dạng một mảng các đối tượng với các thuộc tính sau:

- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `badge?: string | number | BadgeProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `content?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string | number`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { trigger?: ClassNameValue, leadingIcon?: ClassNameValue, leadingAvatar?: ClassNameValue, leadingAvatarSize?: ClassNameValue, label?: ClassNameValue, trailingBadge?: ClassNameValue, trailingBadgeSize?: ClassNameValue, content?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - items
  - class
props:
  items:
    - label: Account
      icon: i-lucide-user
      content: This is the account content.
    - label: Password
      icon: i-lucide-lock
      content: This is the password content.
  class: w-full
---
::

### Content

Đặt prop `content` thành `false` để biến Tabs thành một điều khiển chỉ chuyển đổi mà không hiển thị nội dung. Mặc định là `true`.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  content: false
  items:
    - label: Account
      icon: i-lucide-user
      content: This is the account content.
    - label: Password
      icon: i-lucide-lock
      content: This is the password content.
  class: w-full
---
::

### Unmount

Sử dụng prop `unmount-on-hide` để ngăn nội dung bị gỡ bỏ khi Tabs bị thu gọn. Mặc định là `true`.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  unmountOnHide: false
  items:
    - label: Account
      icon: i-lucide-user
      content: This is the account content.
    - label: Password
      icon: i-lucide-lock
      content: This is the password content.
  class: w-full
---
::

::note
Bạn có thể kiểm tra DOM để xem nội dung của mỗi mục đang được hiển thị.
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của Tabs.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  color: neutral
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Tabs.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  color: neutral
  variant: link
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Tabs.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  size: md
  variant: pill
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của Tabs. Mặc định là `horizontal`.

::component-code
---
external:
  - items
externalTypes:
  - TabsItem[]
ignore:
  - content
  - items
  - class
props:
  orientation: vertical
  variant: pill
  content: false
  items:
    - label: Account
    - label: Password
  class: w-full
---
::

## Examples

### Control active item

Bạn có thể kiểm soát mục hoạt động bằng cách sử dụng prop `default-value` hoặc directive `v-model` với chỉ số của mục.

::component-example{name="tabs-model-value-example"}
::

### With content slot

Sử dụng slot `#content` để tùy chỉnh nội dung của mỗi mục.

::component-example{name="tabs-content-slot-example"}
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{name="tabs-custom-slot-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

Khi truy cập thành phần qua template ref, bạn có thể sử dụng như sau:

| Name                                                                                                                                      | Type                                                                                                                                                         |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `triggersRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<ComponentPublicInstance[]>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Textarea

## Usage

Sử dụng directive `v-model` để kiểm soát giá trị của Textarea.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: ""
---
::

### Rows

Sử dụng prop `rows` để đặt số lượng hàng. Mặc định là `3`.

::component-code{:props='{"rows":12}'}
::

### Placeholder

Sử dụng prop `placeholder` để đặt văn bản giữ chỗ.

::component-code{:props='{"placeholder":"Type something..."}'}
::

### Autoresize

Sử dụng prop `autoresize` để bật tự động điều chỉnh kích thước chiều cao của Textarea.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: This is a long text that will autoresize the height of the Textarea.
  autoresize: true
---
::

Sử dụng prop `maxrows` để đặt số lượng hàng tối đa khi tự động điều chỉnh. Nếu đặt thành `0`, Textarea sẽ tăng vô hạn.

::component-code
---
external:
  - modelValue
ignore:
  - modelValue
props:
  modelValue: This is a long text that will autoresize the height of the Textarea
    with a maximum of 4 rows.
  maxrows: 4
  autoresize: true
---
::

### Color

Sử dụng prop `color` để thay đổi màu vòng khi Textarea được tập trung.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  highlight: true
  placeholder: Type something...
---
::

::note
Prop `highlight` được sử dụng ở đây để hiển thị trạng thái tập trung. Nó được sử dụng nội bộ khi xảy ra lỗi xác thực.
::

### Variant

Sử dụng prop `variant` để thay đổi biến thể của Textarea.

::component-code
---
ignore:
  - placeholder
props:
  color: neutral
  variant: subtle
  highlight: false
  placeholder: Type something...
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Textarea.

::component-code
---
ignore:
  - placeholder
props:
  size: xl
  placeholder: Type something...
---
::

### Icon

Sử dụng prop `icon` để hiển thị một [Icon](https://nuxt.com/components/icon) bên trong Textarea.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  icon: i-lucide-search
  size: md
  variant: outline
  placeholder: Search...
  rows: 1
---
::

Sử dụng prop `leading` và `trailing` để đặt vị trí biểu tượng hoặc prop `leading-icon` và `trailing-icon` để đặt biểu tượng khác cho mỗi vị trí.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  trailingIcon: i-lucide-at-sign
  placeholder: Enter your email
  size: md
  rows: 1
---
::

### Avatar

Sử dụng prop `avatar` để hiển thị một [Avatar](https://nuxt.com/components/avatar) bên trong Textarea.

::component-code
---
ignore:
  - placeholder
prettier: true
props:
  avatar:
    src: https://github.com/nuxt.png
  size: md
  variant: outline
  placeholder: Search...
  rows: 1
---
::

### Loading

Sử dụng prop `loading` để hiển thị biểu tượng tải trên Textarea.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  trailing: false
  placeholder: Search...
  rows: 1
---
::

### Loading Icon

Sử dụng prop `loading-icon` để tùy chỉnh biểu tượng tải. Mặc định là `i-lucide-loader-circle`.

::component-code
---
ignore:
  - placeholder
props:
  loading: true
  loadingIcon: i-lucide-loader
  placeholder: Search...
  rows: 1
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cầu trong `app.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cầu trong `vite.config.ts` của bạn dưới khóa `ui.icons.loading`.
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Textarea.

::component-code
---
ignore:
  - placeholder
props:
  disabled: true
  placeholder: Type something...
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

### Expose

Khi truy cập thành phần qua template ref, bạn có thể sử dụng như sau:

| Name                                                                                                                                      | Type                                                                                                                                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `textareaRef`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} | `Ref<HTMLTextAreaElement | null>`{.language-ts-type.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} |

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Timeline

## Usage

### Items

Sử dụng prop `items` dưới dạng một mảng các đối tượng với các thuộc tính sau:

- `date?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `title?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `description?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `avatar?: AvatarProps`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string | number`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- [`slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}](https://nuxt.com/#with-custom-slot)
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, container?: ClassNameValue, indicator?: ClassNameValue, separator?: ClassNameValue, wrapper?: ClassNameValue, date?: ClassNameValue, title?: ClassNameValue, description?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment. Set up project
        milestones and allocated resources.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops. Created wireframes and
        prototypes for user testing.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development. Implemented core features and
        integrated with APIs.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization. Deployed the application
        to production.
      icon: i-lucide-check-circle
  class: w-96
---
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của các mục hoạt động trong Timeline.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  color: neutral
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment. Set up project
        milestones and allocated resources.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops. Created wireframes and
        prototypes for user testing.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development. Implemented core features and
        integrated with APIs.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization. Deployed the application
        to production.
      icon: i-lucide-check-circle
  class: w-96
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Timeline.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  size: xs
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment. Set up project
        milestones and allocated resources.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops. Created wireframes and
        prototypes for user testing.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development. Implemented core features and
        integrated with APIs.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization. Deployed the application
        to production.
      icon: i-lucide-check-circle
  class: w-96
---
::

### Orientation

Sử dụng prop `orientation` để thay đổi hướng của Timeline. Mặc định là `vertical`.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  orientation: horizontal
  defaultValue: 2
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization.
      icon: i-lucide-check-circle
  class: w-full
class: overflow-x-auto
---
::

### Reverse

Sử dụng prop reverse để đảo ngược hướng của Timeline.

::component-code
---
external:
  - items
externalTypes:
  - TimelineItem[]
ignore:
  - items
  - class
  - defaultValue
props:
  reverse: true
  modelValue: 2
  orientation: vertical
  items:
    - date: Mar 15, 2025
      title: Project Kickoff
      description: Kicked off the project with team alignment.
      icon: i-lucide-rocket
    - date: Mar 22 2025
      title: Design Phase
      description: User research and design workshops.
      icon: i-lucide-palette
    - date: Mar 29 2025
      title: Development Sprint
      description: Frontend and backend development.
      icon: i-lucide-code
    - date: Apr 5 2025
      title: Testing & Deployment
      description: QA testing and performance optimization.
      icon: i-lucide-check-circle
  class: w-full
class: overflow-x-auto
---
::

## Examples

### Control active item

Bạn có thể kiểm soát mục hoạt động bằng cách sử dụng prop `default-value` hoặc directive `v-model` với chỉ số của mục.

::component-example{prettier name="timeline-model-value-example"}
::

::tip
Bạn cũng có thể truyền `value` của một trong các mục nếu được cung cấp.
::

### With alternating layout

Sử dụng prop `ui` để tạo Timeline với bố cục xen kẽ.

::component-example{prettier name="timeline-alternating-layout-example"}
::

### With custom slot

Sử dụng thuộc tính `slot` để tùy chỉnh một mục cụ thể.

Bạn sẽ có quyền truy cập vào các slot sau:

- `#{{ item.slot }}-indicator`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-date`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-title`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-description`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example{prettier name="timeline-custom-slot-example"}
::

### With slots

Sử dụng các slot có sẵn để tạo Timeline phức tạp hơn.

::component-example{prettier name="timeline-slots-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Toast

## Usage

Sử dụng composable [useToast](https://nuxt.com/composables/use-toast) để hiển thị toast trong ứng dụng của bạn.

::warning
Đảm bảo bao bọc ứng dụng của bạn với thành phần [`App`](https://nuxt.com/components/app) sử dụng thành phần [`Toaster`](https://github.com/nuxt/ui/blob/v3/src/runtime/components/Toaster.vue){rel="nofollow"} của chúng tôi sử dụng thành phần [`ToastProvider`](https://reka-ui.com/docs/components/toast#provider){rel="nofollow"} từ Reka UI.
::

::tip{to="https://nuxt.com/components/app#props"}
Bạn có thể kiểm tra prop `toaster` của thành phần `App` để xem cách cấu hình Toaster toàn cầu.
::

### Title

Truyền trường `title` cho phương thức `toast.add` để hiển thị tiêu đề.

::component-example
---
options:
  - name: title
    label: title
    default: Uh oh! Something went wrong.
name: toast-title-example
---
::

### Description

Truyền trường `description` cho phương thức `toast.add` để hiển thị mô tả.

::component-example
---
options:
  - name: title
    label: title
    default: Uh oh! Something went wrong.
  - name: description
    label: description
    default: There was a problem with your request.
name: toast-description-example
---
::

### Icon

Truyền trường `icon` cho phương thức `toast.add` để hiển thị một [Icon](https://nuxt.com/components/icon).

::component-example
---
options:
  - name: icon
    label: icon
    default: i-lucide-wifi
name: toast-icon-example
---
::

### Avatar

Truyền trường `avatar` cho phương thức `toast.add` để hiển thị một [Avatar](https://nuxt.com/components/avatar).

::component-example
---
options:
  - name: avatar.src
    alias: avatar
    label: avatar.src
    default:
      src: https://github.com/benjamincanac.png
name: toast-avatar-example
---
::

### Color

Truyền trường `color` cho phương thức `toast.add` để thay đổi màu sắc của Toast.

::component-example
---
options:
  - name: color
    label: color
    default: neutral
    items:
      - primary
      - secondary
      - success
      - info
      - warning
      - error
      - neutral
name: toast-color-example
---
::

### Close

Truyền trường `close` để tùy chỉnh hoặc ẩn [Button](https://nuxt.com/components/button) đóng (với giá trị `false`).

::component-example{name="toast-close-example"}
::

### Close Icon

Truyền trường `closeIcon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) của nút đóng. Mặc định là `i-lucide-x`.

::component-example
---
options:
  - name: closeIcon
    label: closeIcon
    default: i-lucide-arrow-right
name: toast-close-icon-example
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cầu trong `app.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cầu trong `vite.config.ts` của bạn dưới khóa `ui.icons.close`.
  :::
::

### Actions

Truyền trường `actions` để thêm một số hành động [Button](https://nuxt.com/components/button) vào Toast.

::component-example
---
options:
  - name: description
    label: description
    default: There was a problem with your request.
name: toast-actions-example
---
::

### Progress :badge{.align-text-top label="New"}

Truyền trường `progress` để tùy chỉnh hoặc ẩn thanh [Progress](https://nuxt.com/components/progress) (với giá trị `false`).

::tip
Thanh Progress kế thừa màu Toast theo mặc định, nhưng bạn có thể ghi đè bằng trường `progress.color`.
::

::component-example{name="toast-progress-example"}
::

### Orientation

Truyền trường `orientation` cho phương thức `toast.add` để thay đổi hướng của Toast.

::component-example
---
options:
  - name: orientation
    label: orientation
    default: horizontal
    items:
      - horizontal
      - vertical
name: toast-orientation-example
---
::

## Examples

### Change global position

Thay đổi prop `toaster.position` trên thành phần [App](https://nuxt.com/components/app#props) để thay đổi vị trí của các toast.

::component-example
---
prettier: true
name: toast-example
---
#options
  :::toaster-position-example
  :::
::

::note{to="https://github.com/nuxt/ui/blob/v3/docs/app/app.config.ts#L3"}
Trong ví dụ này, chúng tôi sử dụng `AppConfig` để cấu hình prop `position` của thành phần `Toaster` toàn cầu.
::

### Change global duration

Thay đổi prop `toaster.duration` trên thành phần [App](https://nuxt.com/components/app#props) để thay đổi thời lượng của các toast.

::component-example
---
prettier: true
name: toast-example
---
#options
  :::toaster-duration-example
  :::
::

::note{to="https://github.com/nuxt/ui/blob/v3/docs/app/app.config.ts#L5"}
Trong ví dụ này, chúng tôi sử dụng `AppConfig` để cấu hình prop `duration` của thành phần `Toaster` toàn cầu.
::

### Stacked toasts

Đặt prop `toaster.expand` thành `false` trên thành phần [App](https://nuxt.com/components/app#props) để hiển thị các toast xếp chồng.

::tip
Bạn có thể di chuột qua các toast để mở rộng chúng. Điều này cũng sẽ tạm dừng bộ đếm thời gian của các toast.
::

::component-example
---
prettier: true
name: toast-example
---
#options
  :::toaster-expand-example
  :::
::

::note{to="https://github.com/nuxt/ui/blob/v3/docs/app/app.config.ts#L4"}
Trong ví dụ này, chúng tôi sử dụng `AppConfig` để cấu hình prop `expand` của thành phần `Toaster` toàn cầu.
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Tooltip

## Usage

Sử dụng [Button](https://nuxt.com/components/button) hoặc bất kỳ thành phần nào khác trong slot mặc định của Tooltip.

::warning
Đảm bảo bao bọc ứng dụng của bạn với thành phần [`App`](https://nuxt.com/components/app) sử dụng thành phần [`TooltipProvider`](https://reka-ui.com/docs/components/tooltip#provider){rel="nofollow"} từ Reka UI.
::

::tip{to="https://nuxt.com/components/app#props"}
Bạn có thể kiểm tra prop `tooltip` của thành phần `App` để xem cách cấu hình Tooltip toàn cầu.
::

### Text

Sử dụng prop `text` để đặt nội dung của Tooltip.

::component-code
---
prettier: true
props:
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

### Kbds

Sử dụng prop `kbds` để hiển thị các thành phần [Kbd](https://nuxt.com/components/kbd) trong Tooltip.

::component-code
---
ignore:
  - text
  - kbds
prettier: true
props:
  text: Open on GitHub
  kbds:
    - meta
    - G
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

::tip
Bạn có thể sử dụng các phím đặc biệt như `meta` hiển thị dưới dạng `⌘` trên macOS và `Ctrl` trên các nền tảng khác.
::

### Delay

Sử dụng prop `delay-duration` để thay đổi độ trễ trước khi Tooltip xuất hiện. Ví dụ, bạn có thể làm cho nó xuất hiện ngay lập tức bằng cách đặt thành `0`.

::component-code
---
ignore:
  - text
prettier: true
props:
  delayDuration: 0
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

::tip
Điều này có thể được cấu hình toàn cầu thông qua tùy chọn `tooltip.delayDuration` trong thành phần [`App`](https://nuxt.com/components/app).
::

### Content

Sử dụng prop `content` để kiểm soát cách nội dung Tooltip được hiển thị, như `align` hoặc `side` chẳng hạn.

::component-code
---
ignore:
  - text
items:
  content:
    align:
      - start
      - center
      - end
    side:
      - right
      - left
      - top
      - bottom
prettier: true
props:
  content:
    align: center
    side: bottom
    sideOffset: 8
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

### Arrow

Sử dụng prop `arrow` để hiển thị mũi tên trên Tooltip.

::component-code
---
ignore:
  - text
  - arrow
prettier: true
props:
  arrow: true
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

### Disabled

Sử dụng prop `disabled` để vô hiệu hóa Tooltip.

::component-code
---
ignore:
  - text
prettier: true
props:
  disabled: true
  text: Open on GitHub
slots:
  default: |
    
    <UButton label="Open" color="neutral" variant="subtle" />
---
  :::u-button{color="neutral" label="Open" variant="subtle"}
  :::
::

## Examples

### Control open state

Bạn có thể kiểm soát trạng thái mở bằng cách sử dụng prop `default-open` hoặc directive `v-model:open`.

::component-example{name="tooltip-open-example"}
::

::note
Trong ví dụ này, tận dụng [`defineShortcuts`](https://nuxt.com/composables/define-shortcuts), bạn có thể chuyển đổi Tooltip bằng cách nhấn ``.
::

### With following cursor :badge{.align-text-top label="New"}

Bạn có thể làm cho Tooltip theo dõi con trỏ khi di chuột qua một phần tử bằng cách sử dụng prop [`reference`](https://reka-ui.com/docs/components/tooltip#trigger){rel="nofollow"}:

::component-example{name="tooltip-cursor-example"}
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::


# Tree

## Usage

### Items

Sử dụng prop `items` dưới dạng một mảng các đối tượng với các thuộc tính sau:

- `icon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `label?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `trailingIcon?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `defaultExpanded?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `disabled?: boolean`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `value?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `slot?: string`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `children?: TreeItem[]`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onToggle?(e: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `onSelect?(e?: Event): void`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `class?: any`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `ui?: { item?: ClassNameValue, itemWithChildren?: ClassNameValue, link?: ClassNameValue, linkLeadingIcon?: ClassNameValue, linkLabel?: ClassNameValue, linkTrailing?: ClassNameValue, linkTrailingIcon?: ClassNameValue, listWithChildren?: ClassNameValue }`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::note
Một định danh duy nhất là bắt buộc cho mỗi mục. Thành phần sẽ sử dụng prop `value` làm định danh, quay lại `label` nếu `value` không được cung cấp. Một trong những cái này phải được cung cấp để thành phần hoạt động đúng cách.
::

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Multiple

Sử dụng prop `multiple` để cho phép chọn nhiều mục.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  multiple: true
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Color

Sử dụng prop `color` để thay đổi màu sắc của Tree.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  color: neutral
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Size

Sử dụng prop `size` để thay đổi kích thước của Tree.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  size: xl
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

### Trailing Icon

Sử dụng prop `trailing-icon` để tùy chỉnh [Icon](https://nuxt.com/components/icon) theo sau của một nút cha. Mặc định là `i-lucide-chevron-down`.

::note
Nếu một biểu tượng được chỉ định cho một mục, nó sẽ luôn ưu tiên hơn các prop này.
::

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  trailingIcon: i-lucide-arrow-down
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          trailingIcon: i-lucide-chevron-down
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  Bạn có thể tùy chỉnh biểu tượng này toàn cầu trong `app.config.ts` của bạn dưới khóa `ui.icons.chevronDown`.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize this icon globally in your `vite.config.ts` under `ui.icons.chevronDown` key.
  :::
::

### Expanded Icon

Sử dụng prop `expanded-icon` và `collapsed-icon` để tùy chỉnh biểu tượng của một nút cha khi nó được mở rộng hoặc thu gọn. Mặc định là `i-lucide-folder-open` và `i-lucide-folder` tương ứng.

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  expandedIcon: i-lucide-book-open
  collapsedIcon: i-lucide-book
  items:
    - label: app/
      defaultExpanded: true
      children:
        - label: composables/
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components/
          defaultExpanded: true
          children:
            - label: Card.vue
              icon: i-vscode-icons-file-type-vue
            - label: Button.vue
              icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

::framework-only
#nuxt
  :::tip{to="https://nuxt.com/getting-started/icons/nuxt#theme"}
  You can customize these icons globally in your `app.config.ts` under `ui.icons.folder` and `ui.icons.folderOpen` keys.
  :::

#vue
  :::tip{to="https://nuxt.com/getting-started/icons/vue#theme"}
  You can customize these icons globally in your `vite.config.ts` under `ui.icons.folder` and `ui.icons.folderOpen` keys.
  :::
::

### Disabled

Use the `disabled` prop to prevent any user interaction with the Tree.

::note
You can also disable individual items using `item.disabled`.
::

::component-code
---
collapse: true
external:
  - items
hide:
  - class
ignore:
  - items
props:
  disabled: true
  items:
    - label: app
      icon: i-lucide-folder
      defaultExpanded: true
      children:
        - label: composables
          icon: i-lucide-folder
          children:
            - label: useAuth.ts
              icon: i-vscode-icons-file-type-typescript
            - label: useUser.ts
              icon: i-vscode-icons-file-type-typescript
        - label: components
          icon: i-lucide-folder
          children:
            - label: Home
              icon: i-lucide-folder
              children:
                - label: Card.vue
                  icon: i-vscode-icons-file-type-vue
                - label: Button.vue
                  icon: i-vscode-icons-file-type-vue
    - label: app.vue
      icon: i-vscode-icons-file-type-vue
    - label: nuxt.config.ts
      icon: i-vscode-icons-file-type-nuxt
  class: w-60
---
::

## Examples

### Control selected item(s)

You can control the selected item(s) by using the `default-value` prop or the `v-model` directive.

::component-example
---
collapse: true
props:
  class: w-60
name: tree-model-value-example
---
::

If you want to prevent an item from being selected, you can use the `item.onSelect()`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} property:

::component-example
---
collapse: true
props:
  class: w-60
name: tree-on-select-example
---
::

::note
This lets you expand or collapse a parent item without selecting it.
::

### Control expanded items

You can control the expanded items by using the `default-expanded` prop or the `v-model` directive.

::component-example
---
collapse: true
props:
  class: w-60
name: tree-expanded-example
---
::

If you want to prevent an item from being expanded, you can use the `item.onToggle()`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"} property:

::component-example
---
collapse: true
props:
  class: w-60
name: tree-on-toggle-example
---
::

::note
This lets you select a parent item without expanding or collapsing its children.
::

### With custom slot

Use the `slot` property to customize a specific item.

You will have access to the following slots:

- `#{{ item.slot }}-wrapper`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-leading`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-label`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}
- `#{{ item.slot }}-trailing`{.shiki.shiki-themes.material-theme-lighter.material-theme-lighter.material-theme-palenight lang="ts-type"}

::component-example
---
collapse: true
props:
  class: w-60
name: tree-custom-slot-example
---
::

## API

### Props

::component-props
::

### Slots

::component-slots
::

### Emits

::component-emits
::

## Theme

::component-theme
::

## Changelog

::component-changelog
::
