{"version":3,"file":"5xxKFxIN.js","names":["node","child","key","promise","chunk","conditions","options","results","query","boosts","data"],"sources":["../../node_modules/.cache/.pnpm/minisearch@7.1.2/node_modules/minisearch/dist/es/index.js","../../node_modules/app/components/example/ExampleFulltextMiniSearch.vue","../../node_modules/app/components/example/ExampleFulltextMiniSearch.vue"],"sourcesContent":["/** @ignore */\nconst ENTRIES = 'ENTRIES';\n/** @ignore */\nconst KEYS = 'KEYS';\n/** @ignore */\nconst VALUES = 'VALUES';\n/** @ignore */\nconst LEAF = '';\n/**\n * @private\n */\nclass TreeIterator {\n    constructor(set, type) {\n        const node = set._tree;\n        const keys = Array.from(node.keys());\n        this.set = set;\n        this._type = type;\n        this._path = keys.length > 0 ? [{ node, keys }] : [];\n    }\n    next() {\n        const value = this.dive();\n        this.backtrack();\n        return value;\n    }\n    dive() {\n        if (this._path.length === 0) {\n            return { done: true, value: undefined };\n        }\n        const { node, keys } = last$1(this._path);\n        if (last$1(keys) === LEAF) {\n            return { done: false, value: this.result() };\n        }\n        const child = node.get(last$1(keys));\n        this._path.push({ node: child, keys: Array.from(child.keys()) });\n        return this.dive();\n    }\n    backtrack() {\n        if (this._path.length === 0) {\n            return;\n        }\n        const keys = last$1(this._path).keys;\n        keys.pop();\n        if (keys.length > 0) {\n            return;\n        }\n        this._path.pop();\n        this.backtrack();\n    }\n    key() {\n        return this.set._prefix + this._path\n            .map(({ keys }) => last$1(keys))\n            .filter(key => key !== LEAF)\n            .join('');\n    }\n    value() {\n        return last$1(this._path).node.get(LEAF);\n    }\n    result() {\n        switch (this._type) {\n            case VALUES: return this.value();\n            case KEYS: return this.key();\n            default: return [this.key(), this.value()];\n        }\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nconst last$1 = (array) => {\n    return array[array.length - 1];\n};\n\n/* eslint-disable no-labels */\n/**\n * @ignore\n */\nconst fuzzySearch = (node, query, maxDistance) => {\n    const results = new Map();\n    if (query === undefined)\n        return results;\n    // Number of columns in the Levenshtein matrix.\n    const n = query.length + 1;\n    // Matching terms can never be longer than N + maxDistance.\n    const m = n + maxDistance;\n    // Fill first matrix row and column with numbers: 0 1 2 3 ...\n    const matrix = new Uint8Array(m * n).fill(maxDistance + 1);\n    for (let j = 0; j < n; ++j)\n        matrix[j] = j;\n    for (let i = 1; i < m; ++i)\n        matrix[i * n] = i;\n    recurse(node, query, maxDistance, results, matrix, 1, n, '');\n    return results;\n};\n// Modified version of http://stevehanov.ca/blog/?id=114\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\nconst recurse = (node, query, maxDistance, results, matrix, m, n, prefix) => {\n    const offset = m * n;\n    key: for (const key of node.keys()) {\n        if (key === LEAF) {\n            // We've reached a leaf node. Check if the edit distance acceptable and\n            // store the result if it is.\n            const distance = matrix[offset - 1];\n            if (distance <= maxDistance) {\n                results.set(prefix, [node.get(key), distance]);\n            }\n        }\n        else {\n            // Iterate over all characters in the key. Update the Levenshtein matrix\n            // and check if the minimum distance in the last row is still within the\n            // maximum edit distance. If it is, we can recurse over all child nodes.\n            let i = m;\n            for (let pos = 0; pos < key.length; ++pos, ++i) {\n                const char = key[pos];\n                const thisRowOffset = n * i;\n                const prevRowOffset = thisRowOffset - n;\n                // Set the first column based on the previous row, and initialize the\n                // minimum distance in the current row.\n                let minDistance = matrix[thisRowOffset];\n                const jmin = Math.max(0, i - maxDistance - 1);\n                const jmax = Math.min(n - 1, i + maxDistance);\n                // Iterate over remaining columns (characters in the query).\n                for (let j = jmin; j < jmax; ++j) {\n                    const different = char !== query[j];\n                    // It might make sense to only read the matrix positions used for\n                    // deletion/insertion if the characters are different. But we want to\n                    // avoid conditional reads for performance reasons.\n                    const rpl = matrix[prevRowOffset + j] + +different;\n                    const del = matrix[prevRowOffset + j + 1] + 1;\n                    const ins = matrix[thisRowOffset + j] + 1;\n                    const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);\n                    if (dist < minDistance)\n                        minDistance = dist;\n                }\n                // Because distance will never decrease, we can stop. There will be no\n                // matching child nodes.\n                if (minDistance > maxDistance) {\n                    continue key;\n                }\n            }\n            recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);\n        }\n    }\n};\n\n/* eslint-disable no-labels */\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nclass SearchableMap {\n    /**\n     * The constructor is normally called without arguments, creating an empty\n     * map. In order to create a {@link SearchableMap} from an iterable or from an\n     * object, check {@link SearchableMap.from} and {@link\n     * SearchableMap.fromObject}.\n     *\n     * The constructor arguments are for internal use, when creating derived\n     * mutable views of a map at a prefix.\n     */\n    constructor(tree = new Map(), prefix = '') {\n        this._size = undefined;\n        this._tree = tree;\n        this._prefix = prefix;\n    }\n    /**\n     * Creates and returns a mutable view of this {@link SearchableMap},\n     * containing only entries that share the given prefix.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set(\"unicorn\", 1)\n     * map.set(\"universe\", 2)\n     * map.set(\"university\", 3)\n     * map.set(\"unique\", 4)\n     * map.set(\"hello\", 5)\n     *\n     * let uni = map.atPrefix(\"uni\")\n     * uni.get(\"unique\") // => 4\n     * uni.get(\"unicorn\") // => 1\n     * uni.get(\"hello\") // => undefined\n     *\n     * let univer = map.atPrefix(\"univer\")\n     * univer.get(\"unique\") // => undefined\n     * univer.get(\"universe\") // => 2\n     * univer.get(\"university\") // => 3\n     * ```\n     *\n     * @param prefix  The prefix\n     * @return A {@link SearchableMap} representing a mutable view of the original\n     * Map at the given prefix\n     */\n    atPrefix(prefix) {\n        if (!prefix.startsWith(this._prefix)) {\n            throw new Error('Mismatched prefix');\n        }\n        const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length));\n        if (node === undefined) {\n            const [parentNode, key] = last(path);\n            for (const k of parentNode.keys()) {\n                if (k !== LEAF && k.startsWith(key)) {\n                    const node = new Map();\n                    node.set(k.slice(key.length), parentNode.get(k));\n                    return new SearchableMap(node, prefix);\n                }\n            }\n        }\n        return new SearchableMap(node, prefix);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n     */\n    clear() {\n        this._size = undefined;\n        this._tree.clear();\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n     * @param key  Key to delete\n     */\n    delete(key) {\n        this._size = undefined;\n        return remove(this._tree, key);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n     * @return An iterator iterating through `[key, value]` entries.\n     */\n    entries() {\n        return new TreeIterator(this, ENTRIES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n     * @param fn  Iteration function\n     */\n    forEach(fn) {\n        for (const [key, value] of this) {\n            fn(key, value, this);\n        }\n    }\n    /**\n     * Returns a Map of all the entries that have a key within the given edit\n     * distance from the search key. The keys of the returned Map are the matching\n     * keys, while the values are two-element arrays where the first element is\n     * the value associated to the key, and the second is the edit distance of the\n     * key to the search key.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set('hello', 'world')\n     * map.set('hell', 'yeah')\n     * map.set('ciao', 'mondo')\n     *\n     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n     * map.fuzzyGet('hallo', 2)\n     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n     *\n     * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n     * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n     * // (change \"e\" to \"a\", delete \"o\")\n     * ```\n     *\n     * @param key  The search key\n     * @param maxEditDistance  The maximum edit distance (Levenshtein)\n     * @return A Map of the matching keys to their value and edit distance\n     */\n    fuzzyGet(key, maxEditDistance) {\n        return fuzzySearch(this._tree, key, maxEditDistance);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n     * @param key  Key to get\n     * @return Value associated to the key, or `undefined` if the key is not\n     * found.\n     */\n    get(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined ? node.get(LEAF) : undefined;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n     * @param key  Key\n     * @return True if the key is in the map, false otherwise\n     */\n    has(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined && node.has(LEAF);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n     * @return An `Iterable` iterating through keys\n     */\n    keys() {\n        return new TreeIterator(this, KEYS);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n     * @param key  Key to set\n     * @param value  Value to associate to the key\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    set(key, value) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, value);\n        return this;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n     */\n    get size() {\n        if (this._size) {\n            return this._size;\n        }\n        /** @ignore */\n        this._size = 0;\n        const iter = this.entries();\n        while (!iter.next().done)\n            this._size += 1;\n        return this._size;\n    }\n    /**\n     * Updates the value at the given key using the provided function. The function\n     * is called with the current value at the key, and its return value is used as\n     * the new value to be set.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * // Increment the current value by one\n     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n     * ```\n     *\n     * If the value at the given key is or will be an object, it might not require\n     * re-assignment. In that case it is better to use `fetch()`, because it is\n     * faster.\n     *\n     * @param key  The key to update\n     * @param fn  The function used to compute the new value from the current one\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    update(key, fn) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, fn(node.get(LEAF)));\n        return this;\n    }\n    /**\n     * Fetches the value of the given key. If the value does not exist, calls the\n     * given function to create a new value, which is inserted at the given key\n     * and subsequently returned.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * const map = searchableMap.fetch('somekey', () => new Map())\n     * map.set('foo', 'bar')\n     * ```\n     *\n     * @param key  The key to update\n     * @param initial  A function that creates a new value if the key does not exist\n     * @return The existing or new value at the given key\n     */\n    fetch(key, initial) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        let value = node.get(LEAF);\n        if (value === undefined) {\n            node.set(LEAF, value = initial());\n        }\n        return value;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n     * @return An `Iterable` iterating through values.\n     */\n    values() {\n        return new TreeIterator(this, VALUES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Creates a {@link SearchableMap} from an `Iterable` of entries\n     *\n     * @param entries  Entries to be inserted in the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static from(entries) {\n        const tree = new SearchableMap();\n        for (const [key, value] of entries) {\n            tree.set(key, value);\n        }\n        return tree;\n    }\n    /**\n     * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n     *\n     * @param object  Object of entries for the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static fromObject(object) {\n        return SearchableMap.from(Object.entries(object));\n    }\n}\nconst trackDown = (tree, key, path = []) => {\n    if (key.length === 0 || tree == null) {\n        return [tree, path];\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            path.push([tree, k]); // performance: update in place\n            return trackDown(tree.get(k), key.slice(k.length), path);\n        }\n    }\n    path.push([tree, key]); // performance: update in place\n    return trackDown(undefined, '', path);\n};\nconst lookup = (tree, key) => {\n    if (key.length === 0 || tree == null) {\n        return tree;\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            return lookup(tree.get(k), key.slice(k.length));\n        }\n    }\n};\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = (node, key) => {\n    const keyLength = key.length;\n    outer: for (let pos = 0; node && pos < keyLength;) {\n        for (const k of node.keys()) {\n            // Check whether this key is a candidate: the first characters must match.\n            if (k !== LEAF && key[pos] === k[0]) {\n                const len = Math.min(keyLength - pos, k.length);\n                // Advance offset to the point where key and k no longer match.\n                let offset = 1;\n                while (offset < len && key[pos + offset] === k[offset])\n                    ++offset;\n                const child = node.get(k);\n                if (offset === k.length) {\n                    // The existing key is shorter than the key we need to create.\n                    node = child;\n                }\n                else {\n                    // Partial match: we need to insert an intermediate node to contain\n                    // both the existing subtree and the new node.\n                    const intermediate = new Map();\n                    intermediate.set(k.slice(offset), child);\n                    node.set(key.slice(pos, pos + offset), intermediate);\n                    node.delete(k);\n                    node = intermediate;\n                }\n                pos += offset;\n                continue outer;\n            }\n        }\n        // Create a final child node to contain the final suffix of the key.\n        const child = new Map();\n        node.set(key.slice(pos), child);\n        return child;\n    }\n    return node;\n};\nconst remove = (tree, key) => {\n    const [node, path] = trackDown(tree, key);\n    if (node === undefined) {\n        return;\n    }\n    node.delete(LEAF);\n    if (node.size === 0) {\n        cleanup(path);\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        merge(path, key, value);\n    }\n};\nconst cleanup = (path) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, key] = last(path);\n    node.delete(key);\n    if (node.size === 0) {\n        cleanup(path.slice(0, -1));\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        if (key !== LEAF) {\n            merge(path.slice(0, -1), key, value);\n        }\n    }\n};\nconst merge = (path, key, value) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, nodeKey] = last(path);\n    node.set(nodeKey + key, value);\n    node.delete(nodeKey);\n};\nconst last = (array) => {\n    return array[array.length - 1];\n};\n\nconst OR = 'or';\nconst AND = 'and';\nconst AND_NOT = 'and_not';\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nclass MiniSearch {\n    /**\n     * @param options  Configuration options\n     *\n     * ### Examples:\n     *\n     * ```javascript\n     * // Create a search engine that indexes the 'title' and 'text' fields of your\n     * // documents:\n     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * ```\n     *\n     * ### ID Field:\n     *\n     * ```javascript\n     * // Your documents are assumed to include a unique 'id' field, but if you want\n     * // to use a different field for document identification, you can set the\n     * // 'idField' option:\n     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n     * ```\n     *\n     * ### Options and defaults:\n     *\n     * ```javascript\n     * // The full set of options (here with their default value) is:\n     * const miniSearch = new MiniSearch({\n     *   // idField: field that uniquely identifies a document\n     *   idField: 'id',\n     *\n     *   // extractField: function used to get the value of a field in a document.\n     *   // By default, it assumes the document is a flat object with field names as\n     *   // property keys and field values as string property values, but custom logic\n     *   // can be implemented by setting this option to a custom extractor function.\n     *   extractField: (document, fieldName) => document[fieldName],\n     *\n     *   // tokenize: function used to split fields into individual terms. By\n     *   // default, it is also used to tokenize search queries, unless a specific\n     *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n     *   // the field name is passed as the second argument.\n     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n     *\n     *   // processTerm: function used to process each tokenized term before\n     *   // indexing. It can be used for stemming and normalization. Return a falsy\n     *   // value in order to discard a term. By default, it is also used to process\n     *   // search queries, unless a specific `processTerm` option is supplied as a\n     *   // search option. When processing a term from a indexed field, the field\n     *   // name is passed as the second argument.\n     *   processTerm: (term, _fieldName) => term.toLowerCase(),\n     *\n     *   // searchOptions: default search options, see the `search` method for\n     *   // details\n     *   searchOptions: undefined,\n     *\n     *   // fields: document fields to be indexed. Mandatory, but not set by default\n     *   fields: undefined\n     *\n     *   // storeFields: document fields to be stored and returned as part of the\n     *   // search results.\n     *   storeFields: []\n     * })\n     * ```\n     */\n    constructor(options) {\n        if ((options === null || options === void 0 ? void 0 : options.fields) == null) {\n            throw new Error('MiniSearch: option \"fields\" must be provided');\n        }\n        const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;\n        this._options = {\n            ...defaultOptions,\n            ...options,\n            autoVacuum,\n            searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n            autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n        };\n        this._index = new SearchableMap();\n        this._documentCount = 0;\n        this._documentIds = new Map();\n        this._idToShortId = new Map();\n        // Fields are defined during initialization, don't change, are few in\n        // number, rarely need iterating over, and have string keys. Therefore in\n        // this case an object is a better candidate than a Map to store the mapping\n        // from field key to ID.\n        this._fieldIds = {};\n        this._fieldLength = new Map();\n        this._avgFieldLength = [];\n        this._nextId = 0;\n        this._storedFields = new Map();\n        this._dirtCount = 0;\n        this._currentVacuum = null;\n        this._enqueuedVacuum = null;\n        this._enqueuedVacuumConditions = defaultVacuumConditions;\n        this.addFields(this._options.fields);\n    }\n    /**\n     * Adds a document to the index\n     *\n     * @param document  The document to be indexed\n     */\n    add(document) {\n        const { extractField, tokenize, processTerm, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        if (this._idToShortId.has(id)) {\n            throw new Error(`MiniSearch: duplicate ID ${id}`);\n        }\n        const shortDocumentId = this.addDocumentId(id);\n        this.saveStoredFields(shortDocumentId, document);\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(fieldValue.toString(), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.addTerm(fieldId, shortDocumentId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.addTerm(fieldId, shortDocumentId, processedTerm);\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the given documents to the index\n     *\n     * @param documents  An array of documents to be indexed\n     */\n    addAll(documents) {\n        for (const document of documents)\n            this.add(document);\n    }\n    /**\n     * Adds all the given documents to the index asynchronously.\n     *\n     * Returns a promise that resolves (to `undefined`) when the indexing is done.\n     * This method is useful when index many documents, to avoid blocking the main\n     * thread. The indexing is performed asynchronously and in chunks.\n     *\n     * @param documents  An array of documents to be indexed\n     * @param options  Configuration options\n     * @return A promise resolving to `undefined` when the indexing is done\n     */\n    addAllAsync(documents, options = {}) {\n        const { chunkSize = 10 } = options;\n        const acc = { chunk: [], promise: Promise.resolve() };\n        const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n            chunk.push(document);\n            if ((i + 1) % chunkSize === 0) {\n                return {\n                    chunk: [],\n                    promise: promise\n                        .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n                        .then(() => this.addAll(chunk))\n                };\n            }\n            else {\n                return { chunk, promise };\n            }\n        }, acc);\n        return promise.then(() => this.addAll(chunk));\n    }\n    /**\n     * Removes the given document from the index.\n     *\n     * The document to remove must NOT have changed between indexing and removal,\n     * otherwise the index will be corrupted.\n     *\n     * This method requires passing the full document to be removed (not just the\n     * ID), and immediately removes the document from the inverted index, allowing\n     * memory to be released. A convenient alternative is {@link\n     * MiniSearch#discard}, which needs only the document ID, and has the same\n     * visible effect, but delays cleaning up the index until the next vacuuming.\n     *\n     * @param document  The document to be removed\n     */\n    remove(document) {\n        const { tokenize, processTerm, extractField, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`);\n        }\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(fieldValue.toString(), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.removeTerm(fieldId, shortId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.removeTerm(fieldId, shortId, processedTerm);\n                }\n            }\n        }\n        this._storedFields.delete(shortId);\n        this._documentIds.delete(shortId);\n        this._idToShortId.delete(id);\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n    }\n    /**\n     * Removes all the given documents from the index. If called with no arguments,\n     * it removes _all_ documents from the index.\n     *\n     * @param documents  The documents to be removed. If this argument is omitted,\n     * all documents are removed. Note that, for removing all documents, it is\n     * more efficient to call this method with no arguments than to pass all\n     * documents.\n     */\n    removeAll(documents) {\n        if (documents) {\n            for (const document of documents)\n                this.remove(document);\n        }\n        else if (arguments.length > 0) {\n            throw new Error('Expected documents to be present. Omit the argument to remove all documents.');\n        }\n        else {\n            this._index = new SearchableMap();\n            this._documentCount = 0;\n            this._documentIds = new Map();\n            this._idToShortId = new Map();\n            this._fieldLength = new Map();\n            this._avgFieldLength = [];\n            this._storedFields = new Map();\n            this._nextId = 0;\n        }\n    }\n    /**\n     * Discards the document with the given ID, so it won't appear in search results\n     *\n     * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n     * document to stop appearing in searches), but a different effect on the\n     * internal data structures:\n     *\n     *   - {@link MiniSearch#remove} requires passing the full document to be\n     *   removed as argument, and removes it from the inverted index immediately.\n     *\n     *   - {@link MiniSearch#discard} instead only needs the document ID, and\n     *   works by marking the current version of the document as discarded, so it\n     *   is immediately ignored by searches. This is faster and more convenient\n     *   than {@link MiniSearch#remove}, but the index is not immediately\n     *   modified. To take care of that, vacuuming is performed after a certain\n     *   number of documents are discarded, cleaning up the index and allowing\n     *   memory to be released.\n     *\n     * After discarding a document, it is possible to re-add a new version, and\n     * only the new version will appear in searches. In other words, discarding\n     * and re-adding a document works exactly like removing and re-adding it. The\n     * {@link MiniSearch.replace} method can also be used to replace a document\n     * with a new version.\n     *\n     * #### Details about vacuuming\n     *\n     * Repetite calls to this method would leave obsolete document references in\n     * the index, invisible to searches. Two mechanisms take care of cleaning up:\n     * clean up during search, and vacuuming.\n     *\n     *   - Upon search, whenever a discarded ID is found (and ignored for the\n     *   results), references to the discarded document are removed from the\n     *   inverted index entries for the search terms. This ensures that subsequent\n     *   searches for the same terms do not need to skip these obsolete references\n     *   again.\n     *\n     *   - In addition, vacuuming is performed automatically by default (see the\n     *   `autoVacuum` field in {@link Options}) after a certain number of\n     *   documents are discarded. Vacuuming traverses all terms in the index,\n     *   cleaning up all references to discarded documents. Vacuuming can also be\n     *   triggered manually by calling {@link MiniSearch#vacuum}.\n     *\n     * @param id  The ID of the document to be discarded\n     */\n    discard(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`);\n        }\n        this._idToShortId.delete(id);\n        this._documentIds.delete(shortId);\n        this._storedFields.delete(shortId);\n        (this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n            this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength);\n        });\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n        this._dirtCount += 1;\n        this.maybeAutoVacuum();\n    }\n    maybeAutoVacuum() {\n        if (this._options.autoVacuum === false) {\n            return;\n        }\n        const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum;\n        this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });\n    }\n    /**\n     * Discards the documents with the given IDs, so they won't appear in search\n     * results\n     *\n     * It is equivalent to calling {@link MiniSearch#discard} for all the given\n     * IDs, but with the optimization of triggering at most one automatic\n     * vacuuming at the end.\n     *\n     * Note: to remove all documents from the index, it is faster and more\n     * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n     * of passing all IDs to this method.\n     */\n    discardAll(ids) {\n        const autoVacuum = this._options.autoVacuum;\n        try {\n            this._options.autoVacuum = false;\n            for (const id of ids) {\n                this.discard(id);\n            }\n        }\n        finally {\n            this._options.autoVacuum = autoVacuum;\n        }\n        this.maybeAutoVacuum();\n    }\n    /**\n     * It replaces an existing document with the given updated version\n     *\n     * It works by discarding the current version and adding the updated one, so\n     * it is functionally equivalent to calling {@link MiniSearch#discard}\n     * followed by {@link MiniSearch#add}. The ID of the updated document should\n     * be the same as the original one.\n     *\n     * Since it uses {@link MiniSearch#discard} internally, this method relies on\n     * vacuuming to clean up obsolete document references from the index, allowing\n     * memory to be released (see {@link MiniSearch#discard}).\n     *\n     * @param updatedDocument  The updated document to replace the old version\n     * with\n     */\n    replace(updatedDocument) {\n        const { idField, extractField } = this._options;\n        const id = extractField(updatedDocument, idField);\n        this.discard(id);\n        this.add(updatedDocument);\n    }\n    /**\n     * Triggers a manual vacuuming, cleaning up references to discarded documents\n     * from the inverted index\n     *\n     * Vacuuming is only useful for applications that use the {@link\n     * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n     *\n     * By default, vacuuming is performed automatically when needed (controlled by\n     * the `autoVacuum` field in {@link Options}), so there is usually no need to\n     * call this method, unless one wants to make sure to perform vacuuming at a\n     * specific moment.\n     *\n     * Vacuuming traverses all terms in the inverted index in batches, and cleans\n     * up references to discarded documents from the posting list, allowing memory\n     * to be released.\n     *\n     * The method takes an optional object as argument with the following keys:\n     *\n     *   - `batchSize`: the size of each batch (1000 by default)\n     *\n     *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n     *   default)\n     *\n     * On large indexes, vacuuming could have a non-negligible cost: batching\n     * avoids blocking the thread for long, diluting this cost so that it is not\n     * negatively affecting the application. Nonetheless, this method should only\n     * be called when necessary, and relying on automatic vacuuming is usually\n     * better.\n     *\n     * It returns a promise that resolves (to undefined) when the clean up is\n     * completed. If vacuuming is already ongoing at the time this method is\n     * called, a new one is enqueued immediately after the ongoing one, and a\n     * corresponding promise is returned. However, no more than one vacuuming is\n     * enqueued on top of the ongoing one, even if this method is called more\n     * times (enqueuing multiple ones would be useless).\n     *\n     * @param options  Configuration options for the batch size and delay. See\n     * {@link VacuumOptions}.\n     */\n    vacuum(options = {}) {\n        return this.conditionalVacuum(options);\n    }\n    conditionalVacuum(options, conditions) {\n        // If a vacuum is already ongoing, schedule another as soon as it finishes,\n        // unless there's already one enqueued. If one was already enqueued, do not\n        // enqueue another on top, but make sure that the conditions are the\n        // broadest.\n        if (this._currentVacuum) {\n            this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;\n            if (this._enqueuedVacuum != null) {\n                return this._enqueuedVacuum;\n            }\n            this._enqueuedVacuum = this._currentVacuum.then(() => {\n                const conditions = this._enqueuedVacuumConditions;\n                this._enqueuedVacuumConditions = defaultVacuumConditions;\n                return this.performVacuuming(options, conditions);\n            });\n            return this._enqueuedVacuum;\n        }\n        if (this.vacuumConditionsMet(conditions) === false) {\n            return Promise.resolve();\n        }\n        this._currentVacuum = this.performVacuuming(options);\n        return this._currentVacuum;\n    }\n    async performVacuuming(options, conditions) {\n        const initialDirtCount = this._dirtCount;\n        if (this.vacuumConditionsMet(conditions)) {\n            const batchSize = options.batchSize || defaultVacuumOptions.batchSize;\n            const batchWait = options.batchWait || defaultVacuumOptions.batchWait;\n            let i = 1;\n            for (const [term, fieldsData] of this._index) {\n                for (const [fieldId, fieldIndex] of fieldsData) {\n                    for (const [shortId] of fieldIndex) {\n                        if (this._documentIds.has(shortId)) {\n                            continue;\n                        }\n                        if (fieldIndex.size <= 1) {\n                            fieldsData.delete(fieldId);\n                        }\n                        else {\n                            fieldIndex.delete(shortId);\n                        }\n                    }\n                }\n                if (this._index.get(term).size === 0) {\n                    this._index.delete(term);\n                }\n                if (i % batchSize === 0) {\n                    await new Promise((resolve) => setTimeout(resolve, batchWait));\n                }\n                i += 1;\n            }\n            this._dirtCount -= initialDirtCount;\n        }\n        // Make the next lines always async, so they execute after this function returns\n        await null;\n        this._currentVacuum = this._enqueuedVacuum;\n        this._enqueuedVacuum = null;\n    }\n    vacuumConditionsMet(conditions) {\n        if (conditions == null) {\n            return true;\n        }\n        let { minDirtCount, minDirtFactor } = conditions;\n        minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;\n        minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;\n        return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;\n    }\n    /**\n     * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n     */\n    get isVacuuming() {\n        return this._currentVacuum != null;\n    }\n    /**\n     * The number of documents discarded since the most recent vacuuming\n     */\n    get dirtCount() {\n        return this._dirtCount;\n    }\n    /**\n     * A number between 0 and 1 giving an indication about the proportion of\n     * documents that are discarded, and can therefore be cleaned up by vacuuming.\n     * A value close to 0 means that the index is relatively clean, while a higher\n     * value means that the index is relatively dirty, and vacuuming could release\n     * memory.\n     */\n    get dirtFactor() {\n        return this._dirtCount / (1 + this._documentCount + this._dirtCount);\n    }\n    /**\n     * Returns `true` if a document with the given ID is present in the index and\n     * available for search, `false` otherwise\n     *\n     * @param id  The document ID\n     */\n    has(id) {\n        return this._idToShortId.has(id);\n    }\n    /**\n     * Returns the stored fields (as configured in the `storeFields` constructor\n     * option) for the given document ID. Returns `undefined` if the document is\n     * not present in the index.\n     *\n     * @param id  The document ID\n     */\n    getStoredFields(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            return undefined;\n        }\n        return this._storedFields.get(shortId);\n    }\n    /**\n     * Search for documents matching the given search query.\n     *\n     * The result is a list of scored document IDs matching the query, sorted by\n     * descending score, and each including data about which terms were matched and\n     * in which fields.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Search for \"zen art motorcycle\" with default options: terms have to match\n     * // exactly, and individual terms are joined with OR\n     * miniSearch.search('zen art motorcycle')\n     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n     * ```\n     *\n     * ### Restrict search to specific fields:\n     *\n     * ```javascript\n     * // Search only in the 'title' field\n     * miniSearch.search('zen', { fields: ['title'] })\n     * ```\n     *\n     * ### Field boosting:\n     *\n     * ```javascript\n     * // Boost a field\n     * miniSearch.search('zen', { boost: { title: 2 } })\n     * ```\n     *\n     * ### Prefix search:\n     *\n     * ```javascript\n     * // Search for \"moto\" with prefix search (it will match documents\n     * // containing terms that start with \"moto\" or \"neuro\")\n     * miniSearch.search('moto neuro', { prefix: true })\n     * ```\n     *\n     * ### Fuzzy search:\n     *\n     * ```javascript\n     * // Search for \"ismael\" with fuzzy search (it will match documents containing\n     * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n     * // (rounded to nearest integer)\n     * miniSearch.search('ismael', { fuzzy: 0.2 })\n     * ```\n     *\n     * ### Combining strategies:\n     *\n     * ```javascript\n     * // Mix of exact match, prefix search, and fuzzy search\n     * miniSearch.search('ismael mob', {\n     *  prefix: true,\n     *  fuzzy: 0.2\n     * })\n     * ```\n     *\n     * ### Advanced prefix and fuzzy search:\n     *\n     * ```javascript\n     * // Perform fuzzy and prefix search depending on the search term. Here\n     * // performing prefix and fuzzy search only on terms longer than 3 characters\n     * miniSearch.search('ismael mob', {\n     *  prefix: term => term.length > 3\n     *  fuzzy: term => term.length > 3 ? 0.2 : null\n     * })\n     * ```\n     *\n     * ### Combine with AND:\n     *\n     * ```javascript\n     * // Combine search terms with AND (to match only documents that contain both\n     * // \"motorcycle\" and \"art\")\n     * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n     * ```\n     *\n     * ### Combine with AND_NOT:\n     *\n     * There is also an AND_NOT combinator, that finds documents that match the\n     * first term, but do not match any of the other terms. This combinator is\n     * rarely useful with simple queries, and is meant to be used with advanced\n     * query combinations (see later for more details).\n     *\n     * ### Filtering results:\n     *\n     * ```javascript\n     * // Filter only results in the 'fiction' category (assuming that 'category'\n     * // is a stored field)\n     * miniSearch.search('motorcycle art', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Wildcard query\n     *\n     * Searching for an empty string (assuming the default tokenizer) returns no\n     * results. Sometimes though, one needs to match all documents, like in a\n     * \"wildcard\" search. This is possible by passing the special value\n     * {@link MiniSearch.wildcard} as the query:\n     *\n     * ```javascript\n     * // Return search results for all documents\n     * miniSearch.search(MiniSearch.wildcard)\n     * ```\n     *\n     * Note that search options such as `filter` and `boostDocument` are still\n     * applied, influencing which results are returned, and their order:\n     *\n     * ```javascript\n     * // Return search results for all documents in the 'fiction' category\n     * miniSearch.search(MiniSearch.wildcard, {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Advanced combination of queries:\n     *\n     * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n     * and even with different search options, by passing a query expression\n     * tree object as the first argument, instead of a string.\n     *\n     * ```javascript\n     * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n     * miniSearch.search({\n     *   combineWith: 'AND',\n     *   queries: [\n     *     'zen',\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['motorcycle', 'archery']\n     *     }\n     *   ]\n     * })\n     *\n     * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n     * // not \"tree\"\n     * miniSearch.search({\n     *   combineWith: 'AND_NOT',\n     *   queries: [\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['apple', 'pear']\n     *     },\n     *     'juice',\n     *     'tree'\n     *   ]\n     * })\n     * ```\n     *\n     * Each node in the expression tree can be either a string, or an object that\n     * supports all {@link SearchOptions} fields, plus a `queries` array field for\n     * subqueries.\n     *\n     * Note that, while this can become complicated to do by hand for complex or\n     * deeply nested queries, it provides a formalized expression tree API for\n     * external libraries that implement a parser for custom query languages.\n     *\n     * @param query  Search query\n     * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n     */\n    search(query, searchOptions = {}) {\n        const { searchOptions: globalSearchOptions } = this._options;\n        const searchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions };\n        const rawResults = this.executeQuery(query, searchOptions);\n        const results = [];\n        for (const [docId, { score, terms, match }] of rawResults) {\n            // terms are the matched query terms, which will be returned to the user\n            // as queryTerms. The quality is calculated based on them, as opposed to\n            // the matched terms in the document (which can be different due to\n            // prefix and fuzzy match)\n            const quality = terms.length || 1;\n            const result = {\n                id: this._documentIds.get(docId),\n                score: score * quality,\n                terms: Object.keys(match),\n                queryTerms: terms,\n                match\n            };\n            Object.assign(result, this._storedFields.get(docId));\n            if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n                results.push(result);\n            }\n        }\n        // If it's a wildcard query, and no document boost is applied, skip sorting\n        // the results, as all results have the same score of 1\n        if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n            return results;\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Provide suggestions for the given search query\n     *\n     * The result is a list of suggested modified search queries, derived from the\n     * given search query, each with a relevance score, sorted by descending score.\n     *\n     * By default, it uses the same options used for search, except that by\n     * default it performs prefix search on the last term of the query, and\n     * combine terms with `'AND'` (requiring all query terms to match). Custom\n     * options can be passed as a second argument. Defaults can be changed upon\n     * calling the {@link MiniSearch} constructor, by passing a\n     * `autoSuggestOptions` option.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Get suggestions for 'neuro':\n     * miniSearch.autoSuggest('neuro')\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n     * ```\n     *\n     * ### Multiple words:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar':\n     * miniSearch.autoSuggest('zen ar')\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * ### Fuzzy suggestions:\n     *\n     * ```javascript\n     * // Correct spelling mistakes using fuzzy search:\n     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n     * ```\n     *\n     * ### Filtering:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar', but only within the 'fiction' category\n     * // (assuming that 'category' is a stored field):\n     * miniSearch.autoSuggest('zen ar', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * @param queryString  Query string to be expanded into suggestions\n     * @param options  Search options. The supported options and default values\n     * are the same as for the {@link MiniSearch#search} method, except that by\n     * default prefix search is performed on the last term in the query, and terms\n     * are combined with `'AND'`.\n     * @return  A sorted array of suggestions sorted by relevance score.\n     */\n    autoSuggest(queryString, options = {}) {\n        options = { ...this._options.autoSuggestOptions, ...options };\n        const suggestions = new Map();\n        for (const { score, terms } of this.search(queryString, options)) {\n            const phrase = terms.join(' ');\n            const suggestion = suggestions.get(phrase);\n            if (suggestion != null) {\n                suggestion.score += score;\n                suggestion.count += 1;\n            }\n            else {\n                suggestions.set(phrase, { score, terms, count: 1 });\n            }\n        }\n        const results = [];\n        for (const [suggestion, { score, terms, count }] of suggestions) {\n            results.push({ suggestion, terms, score: score / count });\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Total number of documents available to search\n     */\n    get documentCount() {\n        return this._documentCount;\n    }\n    /**\n     * Number of terms in the index\n     */\n    get termCount() {\n        return this._index.size;\n    }\n    /**\n     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n     * and instantiates a MiniSearch instance. It should be given the same options\n     * originally used when serializing the index.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // If the index was serialized with:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     *\n     * const json = JSON.stringify(miniSearch)\n     * // It can later be deserialized like this:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return An instance of MiniSearch deserialized from the given JSON.\n     */\n    static loadJSON(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJS(JSON.parse(json), options);\n    }\n    /**\n     * Async equivalent of {@link MiniSearch.loadJSON}\n     *\n     * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n     * a promise, and loads the index in batches, leaving pauses between them to avoid\n     * blocking the main thread. It tends to be slower than the synchronous\n     * version, but does not block the main thread, so it can be a better choice\n     * when deserializing very large indexes.\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n     */\n    static async loadJSONAsync(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJSAsync(JSON.parse(json), options);\n    }\n    /**\n     * Returns the default value of an option. It will throw an error if no option\n     * with the given name exists.\n     *\n     * @param optionName  Name of the option\n     * @return The default value of the given option\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Get default tokenizer\n     * MiniSearch.getDefault('tokenize')\n     *\n     * // Get default term processor\n     * MiniSearch.getDefault('processTerm')\n     *\n     * // Unknown options will throw an error\n     * MiniSearch.getDefault('notExisting')\n     * // => throws 'MiniSearch: unknown option \"notExisting\"'\n     * ```\n     */\n    static getDefault(optionName) {\n        if (defaultOptions.hasOwnProperty(optionName)) {\n            return getOwnProperty(defaultOptions, optionName);\n        }\n        else {\n            throw new Error(`MiniSearch: unknown option \"${optionName}\"`);\n        }\n    }\n    /**\n     * @ignore\n     */\n    static loadJS(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = objectToNumericMap(documentIds);\n        miniSearch._fieldLength = objectToNumericMap(fieldLength);\n        miniSearch._storedFields = objectToNumericMap(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));\n            }\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static async loadJSAsync(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = await objectToNumericMapAsync(documentIds);\n        miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength);\n        miniSearch._storedFields = await objectToNumericMapAsync(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        let count = 0;\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry));\n            }\n            if (++count % 1000 === 0)\n                await wait(0);\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static instantiateMiniSearch(js, options) {\n        const { documentCount, nextId, fieldIds, averageFieldLength, dirtCount, serializationVersion } = js;\n        if (serializationVersion !== 1 && serializationVersion !== 2) {\n            throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');\n        }\n        const miniSearch = new MiniSearch(options);\n        miniSearch._documentCount = documentCount;\n        miniSearch._nextId = nextId;\n        miniSearch._idToShortId = new Map();\n        miniSearch._fieldIds = fieldIds;\n        miniSearch._avgFieldLength = averageFieldLength;\n        miniSearch._dirtCount = dirtCount || 0;\n        miniSearch._index = new SearchableMap();\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    executeQuery(query, searchOptions = {}) {\n        if (query === MiniSearch.wildcard) {\n            return this.executeWildcardQuery(searchOptions);\n        }\n        if (typeof query !== 'string') {\n            const options = { ...searchOptions, ...query, queries: undefined };\n            const results = query.queries.map((subquery) => this.executeQuery(subquery, options));\n            return this.combineResults(results, options.combineWith);\n        }\n        const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options;\n        const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions };\n        const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options;\n        const terms = searchTokenize(query)\n            .flatMap((term) => searchProcessTerm(term))\n            .filter((term) => !!term);\n        const queries = terms.map(termToQuerySpec(options));\n        const results = queries.map(query => this.executeQuerySpec(query, options));\n        return this.combineResults(results, options.combineWith);\n    }\n    /**\n     * @ignore\n     */\n    executeQuerySpec(query, searchOptions) {\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        const boosts = (options.fields || this._options.fields).reduce((boosts, field) => ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {});\n        const { boostDocument, weights, maxFuzzy, bm25: bm25params } = options;\n        const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights };\n        const data = this._index.get(query.term);\n        const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params);\n        let prefixMatches;\n        let fuzzyMatches;\n        if (query.prefix) {\n            prefixMatches = this._index.atPrefix(query.term);\n        }\n        if (query.fuzzy) {\n            const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;\n            const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;\n            if (maxDistance)\n                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);\n        }\n        if (prefixMatches) {\n            for (const [term, data] of prefixMatches) {\n                const distance = term.length - query.term.length;\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Delete the term from fuzzy results (if present) if it is also a\n                // prefix result. This entry will always be scored as a prefix result.\n                fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to prefixWeight.\n                // The rate of change is much lower than that of fuzzy matches to\n                // account for the fact that prefix matches stay more relevant than\n                // fuzzy matches for longer distances.\n                const weight = prefixWeight * term.length / (term.length + 0.3 * distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        if (fuzzyMatches) {\n            for (const term of fuzzyMatches.keys()) {\n                const [data, distance] = fuzzyMatches.get(term);\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n                const weight = fuzzyWeight * term.length / (term.length + distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    executeWildcardQuery(searchOptions) {\n        const results = new Map();\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        for (const [shortId, id] of this._documentIds) {\n            const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;\n            results.set(shortId, {\n                score,\n                terms: [],\n                match: {}\n            });\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    combineResults(results, combineWith = OR) {\n        if (results.length === 0) {\n            return new Map();\n        }\n        const operator = combineWith.toLowerCase();\n        const combinator = combinators[operator];\n        if (!combinator) {\n            throw new Error(`Invalid combination operator: ${combineWith}`);\n        }\n        return results.reduce(combinator) || new Map();\n    }\n    /**\n     * Allows serialization of the index to JSON, to possibly store it and later\n     * deserialize it with {@link MiniSearch.loadJSON}.\n     *\n     * Normally one does not directly call this method, but rather call the\n     * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n     * instance, and JavaScript will internally call this method. Upon\n     * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n     * options used to create the original instance that was serialized.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Serialize the index:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     * const json = JSON.stringify(miniSearch)\n     *\n     * // Later, to deserialize it:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @return A plain-object serializable representation of the search index.\n     */\n    toJSON() {\n        const index = [];\n        for (const [term, fieldIndex] of this._index) {\n            const data = {};\n            for (const [fieldId, freqs] of fieldIndex) {\n                data[fieldId] = Object.fromEntries(freqs);\n            }\n            index.push([term, data]);\n        }\n        return {\n            documentCount: this._documentCount,\n            nextId: this._nextId,\n            documentIds: Object.fromEntries(this._documentIds),\n            fieldIds: this._fieldIds,\n            fieldLength: Object.fromEntries(this._fieldLength),\n            averageFieldLength: this._avgFieldLength,\n            storedFields: Object.fromEntries(this._storedFields),\n            dirtCount: this._dirtCount,\n            index,\n            serializationVersion: 2\n        };\n    }\n    /**\n     * @ignore\n     */\n    termResults(sourceTerm, derivedTerm, termWeight, termBoost, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results = new Map()) {\n        if (fieldTermData == null)\n            return results;\n        for (const field of Object.keys(fieldBoosts)) {\n            const fieldBoost = fieldBoosts[field];\n            const fieldId = this._fieldIds[field];\n            const fieldTermFreqs = fieldTermData.get(fieldId);\n            if (fieldTermFreqs == null)\n                continue;\n            let matchingFields = fieldTermFreqs.size;\n            const avgFieldLength = this._avgFieldLength[fieldId];\n            for (const docId of fieldTermFreqs.keys()) {\n                if (!this._documentIds.has(docId)) {\n                    this.removeTerm(fieldId, docId, derivedTerm);\n                    matchingFields -= 1;\n                    continue;\n                }\n                const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;\n                if (!docBoost)\n                    continue;\n                const termFreq = fieldTermFreqs.get(docId);\n                const fieldLength = this._fieldLength.get(docId)[fieldId];\n                // NOTE: The total number of fields is set to the number of documents\n                // `this._documentCount`. It could also make sense to use the number of\n                // documents where the current field is non-blank as a normalization\n                // factor. This will make a difference in scoring if the field is rarely\n                // present. This is currently not supported, and may require further\n                // analysis to see if it is a valid use case.\n                const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);\n                const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore;\n                const result = results.get(docId);\n                if (result) {\n                    result.score += weightedScore;\n                    assignUniqueTerm(result.terms, sourceTerm);\n                    const match = getOwnProperty(result.match, derivedTerm);\n                    if (match) {\n                        match.push(field);\n                    }\n                    else {\n                        result.match[derivedTerm] = [field];\n                    }\n                }\n                else {\n                    results.set(docId, {\n                        score: weightedScore,\n                        terms: [sourceTerm],\n                        match: { [derivedTerm]: [field] }\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    addTerm(fieldId, documentId, term) {\n        const indexData = this._index.fetch(term, createMap);\n        let fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null) {\n            fieldIndex = new Map();\n            fieldIndex.set(documentId, 1);\n            indexData.set(fieldId, fieldIndex);\n        }\n        else {\n            const docs = fieldIndex.get(documentId);\n            fieldIndex.set(documentId, (docs || 0) + 1);\n        }\n    }\n    /**\n     * @ignore\n     */\n    removeTerm(fieldId, documentId, term) {\n        if (!this._index.has(term)) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n            return;\n        }\n        const indexData = this._index.fetch(term, createMap);\n        const fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n        }\n        else if (fieldIndex.get(documentId) <= 1) {\n            if (fieldIndex.size <= 1) {\n                indexData.delete(fieldId);\n            }\n            else {\n                fieldIndex.delete(documentId);\n            }\n        }\n        else {\n            fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);\n        }\n        if (this._index.get(term).size === 0) {\n            this._index.delete(term);\n        }\n    }\n    /**\n     * @ignore\n     */\n    warnDocumentChanged(shortDocumentId, fieldId, term) {\n        for (const fieldName of Object.keys(this._fieldIds)) {\n            if (this._fieldIds[fieldName] === fieldId) {\n                this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict');\n                return;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    addDocumentId(documentId) {\n        const shortDocumentId = this._nextId;\n        this._idToShortId.set(documentId, shortDocumentId);\n        this._documentIds.set(shortDocumentId, documentId);\n        this._documentCount += 1;\n        this._nextId += 1;\n        return shortDocumentId;\n    }\n    /**\n     * @ignore\n     */\n    addFields(fields) {\n        for (let i = 0; i < fields.length; i++) {\n            this._fieldIds[fields[i]] = i;\n        }\n    }\n    /**\n     * @ignore\n     */\n    addFieldLength(documentId, fieldId, count, length) {\n        let fieldLengths = this._fieldLength.get(documentId);\n        if (fieldLengths == null)\n            this._fieldLength.set(documentId, fieldLengths = []);\n        fieldLengths[fieldId] = length;\n        const averageFieldLength = this._avgFieldLength[fieldId] || 0;\n        const totalFieldLength = (averageFieldLength * count) + length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);\n    }\n    /**\n     * @ignore\n     */\n    removeFieldLength(documentId, fieldId, count, length) {\n        if (count === 1) {\n            this._avgFieldLength[fieldId] = 0;\n            return;\n        }\n        const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);\n    }\n    /**\n     * @ignore\n     */\n    saveStoredFields(documentId, doc) {\n        const { storeFields, extractField } = this._options;\n        if (storeFields == null || storeFields.length === 0) {\n            return;\n        }\n        let documentFields = this._storedFields.get(documentId);\n        if (documentFields == null)\n            this._storedFields.set(documentId, documentFields = {});\n        for (const fieldName of storeFields) {\n            const fieldValue = extractField(doc, fieldName);\n            if (fieldValue !== undefined)\n                documentFields[fieldName] = fieldValue;\n        }\n    }\n}\n/**\n * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n * to match all documents\n */\nMiniSearch.wildcard = Symbol('*');\nconst getOwnProperty = (object, property) => Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\nconst combinators = {\n    [OR]: (a, b) => {\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null) {\n                a.set(docId, b.get(docId));\n            }\n            else {\n                const { score, terms, match } = b.get(docId);\n                existing.score = existing.score + score;\n                existing.match = Object.assign(existing.match, match);\n                assignUniqueTerms(existing.terms, terms);\n            }\n        }\n        return a;\n    },\n    [AND]: (a, b) => {\n        const combined = new Map();\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null)\n                continue;\n            const { score, terms, match } = b.get(docId);\n            assignUniqueTerms(existing.terms, terms);\n            combined.set(docId, {\n                score: existing.score + score,\n                terms: existing.terms,\n                match: Object.assign(existing.match, match)\n            });\n        }\n        return combined;\n    },\n    [AND_NOT]: (a, b) => {\n        for (const docId of b.keys())\n            a.delete(docId);\n        return a;\n    }\n};\nconst defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };\nconst calcBM25Score = (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) => {\n    const { k, b, d } = bm25params;\n    const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));\n    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));\n};\nconst termToQuerySpec = (options) => (term, i, terms) => {\n    const fuzzy = (typeof options.fuzzy === 'function')\n        ? options.fuzzy(term, i, terms)\n        : (options.fuzzy || false);\n    const prefix = (typeof options.prefix === 'function')\n        ? options.prefix(term, i, terms)\n        : (options.prefix === true);\n    const termBoost = (typeof options.boostTerm === 'function')\n        ? options.boostTerm(term, i, terms)\n        : 1;\n    return { term, fuzzy, prefix, termBoost };\n};\nconst defaultOptions = {\n    idField: 'id',\n    extractField: (document, fieldName) => document[fieldName],\n    tokenize: (text) => text.split(SPACE_OR_PUNCTUATION),\n    processTerm: (term) => term.toLowerCase(),\n    fields: undefined,\n    searchOptions: undefined,\n    storeFields: [],\n    logger: (level, message) => {\n        if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')\n            console[level](message);\n    },\n    autoVacuum: true\n};\nconst defaultSearchOptions = {\n    combineWith: OR,\n    prefix: false,\n    fuzzy: false,\n    maxFuzzy: 6,\n    boost: {},\n    weights: { fuzzy: 0.45, prefix: 0.375 },\n    bm25: defaultBM25params\n};\nconst defaultAutoSuggestOptions = {\n    combineWith: AND,\n    prefix: (term, i, terms) => i === terms.length - 1\n};\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions };\nconst assignUniqueTerm = (target, term) => {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term))\n        target.push(term);\n};\nconst assignUniqueTerms = (target, source) => {\n    for (const term of source) {\n        // Avoid adding duplicate terms.\n        if (!target.includes(term))\n            target.push(term);\n    }\n};\nconst byScore = ({ score: a }, { score: b }) => b - a;\nconst createMap = () => new Map();\nconst objectToNumericMap = (object) => {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n    }\n    return map;\n};\nconst objectToNumericMapAsync = async (object) => {\n    const map = new Map();\n    let count = 0;\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n        if (++count % 1000 === 0) {\n            await wait(0);\n        }\n    }\n    return map;\n};\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u;\n\nexport { MiniSearch as default };\n//# sourceMappingURL=index.js.map\n","<script setup lang=\"ts\">\nimport MiniSearch from 'minisearch'\nconst { version } = useDocsVersion()\nconst query = ref('')\nconst { data } = await useAsyncData('minisearch-data', () =>\n  queryCollectionSearchSections('nuxtcontent').then(data => data.filter(item => item.id.startsWith(version.value.path)))\n)\n\nconst miniSearch = new MiniSearch({\n  fields: ['title', 'content'],\n  storeFields: ['title', 'content'],\n  searchOptions: {\n    prefix: true,\n    fuzzy: 0.2,\n  },\n})\n\n// Add data to the MiniSearch instance\nminiSearch.addAll(toValue(data.value || []))\nconst result = computed(() => miniSearch.search(toValue(query)).slice(0, 10))\n</script>\n\n<template>\n  <UContainer class=\"p-4\">\n    <UCard>\n      <UInput v-model=\"query\" placeholder=\"Search...\" class=\"w-full\" />\n      <ul>\n        <li v-for=\"link of result\" :key=\"link.id\" class=\"mt-2\">\n          <UButton variant=\"ghost\" class=\"w-full\" :to=\"link.id\">\n            <div class=\"flex flex-col\">\n              <span class=\"text-black dark:text-white font-semibold\">{{ link.title }}</span>\n              <span class=\"text-gray-500 text-xs truncate\">{{ link.content?.slice(0, 100) }}...</span>\n            </div>\n          </UButton>\n        </li>\n      </ul>\n    </UCard>\n  </UContainer>\n</template>\n","<script setup lang=\"ts\">\nimport MiniSearch from 'minisearch'\nconst { version } = useDocsVersion()\nconst query = ref('')\nconst { data } = await useAsyncData('minisearch-data', () =>\n  queryCollectionSearchSections('nuxtcontent').then(data => data.filter(item => item.id.startsWith(version.value.path)))\n)\n\nconst miniSearch = new MiniSearch({\n  fields: ['title', 'content'],\n  storeFields: ['title', 'content'],\n  searchOptions: {\n    prefix: true,\n    fuzzy: 0.2,\n  },\n})\n\n// Add data to the MiniSearch instance\nminiSearch.addAll(toValue(data.value || []))\nconst result = computed(() => miniSearch.search(toValue(query)).slice(0, 10))\n</script>\n\n<template>\n  <UContainer class=\"p-4\">\n    <UCard>\n      <UInput v-model=\"query\" placeholder=\"Search...\" class=\"w-full\" />\n      <ul>\n        <li v-for=\"link of result\" :key=\"link.id\" class=\"mt-2\">\n          <UButton variant=\"ghost\" class=\"w-full\" :to=\"link.id\">\n            <div class=\"flex flex-col\">\n              <span class=\"text-black dark:text-white font-semibold\">{{ link.title }}</span>\n              <span class=\"text-gray-500 text-xs truncate\">{{ link.content?.slice(0, 100) }}...</span>\n            </div>\n          </UButton>\n        </li>\n      </ul>\n    </UCard>\n  </UContainer>\n</template>\n"],"x_google_ignoreList":[0],"mappings":"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"}