{"version":3,"mappings":";mgBAsBM,EAAQ,EAyDR,EAAM,MAAe,EAAM,UAAY,EAAW,EAAM,MAAM,CAAC,CAC/D,CAAE,OAAM,UAAS,UAAU,iBAAM,EAAa,EAAI,MAAO,SAAY,CACzE,GAAI,OAAO,EAAM,OAAU,SACzB,OAAO,EAAM,MAEf,GAAM,CAAE,sCAAF,CAAE,iBAAkB,MAAM,OAAO,wBAA/B,gFACR,OAAO,MAAM,EAAc,EAAM,MAAO,CACtC,GAAG,EAAM,cACT,IAAK,EAAM,QAAU,GAAQ,EAAM,eAAe,IAClD,eAAgB,EAAM,QAAU,GAAQ,EAAM,eAAe,eAC9D,CAAC,EACJ,cAAC,mBACK,EAAO,MAAe,EAAM,QAAU,EAAK,OAAO,QAAU,EAAK,OAAO,KAAK,CACnF,MAAY,EAAM,UAAa,CAC7B,GAAS,EACT,CACF,SAAS,EAAW,EAAK,CACnB,OAAO,GAAQ,WACjB,EAAM,KAAK,UAAU,GAAO,GAAG,EAEjC,IAAI,EAAO,EACX,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,OAAQ,IAAK,CACnC,IAAM,EAAO,EAAI,WAAW,EAAE,CAC9B,GAAQ,GAAQ,GAAK,EAAO,EAC5B,GAAc,EAEhB,MAAO,OAAO,IAAS,EAAI,OAAS,EAAK,SAAS,GAAG,CAAC,mCAxGtD,EAeO,oBAdJ,KAAM,IAAI,EAAE,KACZ,KAAM,IAAI,EAAE,KACZ,IAAK,IAAI,EAAE,IACX,QAAS,IAAI,EAAE,QACf,MAAO,UAUH,CAPG,aADR,EAOE,SALC,IAAK,EAAM,IACX,MAAK,EAAE,EAAM,MAAK,CAClB,KAAM,QACN,KAAM,IAAI,EAAE,KACZ,OAAQ,EAAM","names":[],"ignoreList":[0],"sources":["../../node_modules/.cache/.pnpm/@nuxtjs+mdc@0.17.4_magicast@0.3.5/node_modules/@nuxtjs/mdc/dist/runtime/components/MDC.vue"],"sourcesContent":["<template>\n  <slot\n    :data=\"data?.data\"\n    :body=\"data?.body\"\n    :toc=\"data?.toc\"\n    :excerpt=\"data?.excerpt\"\n    :error=\"error\"\n  >\n    <MDCRenderer\n      v-if=\"body\"\n      :tag=\"props.tag\"\n      :class=\"props.class\"\n      :body=\"body\"\n      :data=\"data?.data\"\n      :unwrap=\"props.unwrap\"\n    />\n  </slot>\n</template>\n\n<script setup>\nimport { useAsyncData } from \"nuxt/app\";\nimport { watch, computed } from \"vue\";\nconst props = defineProps({\n  tag: {\n    type: [String, Boolean],\n    default: \"div\"\n  },\n  /**\n   * Raw markdown string or parsed markdown object from `parseMarkdown`\n   */\n  value: {\n    type: [String, Object],\n    required: true\n  },\n  /**\n   * Render only the excerpt\n   */\n  excerpt: {\n    type: Boolean,\n    default: false\n  },\n  /**\n   * Options for `parseMarkdown`\n   */\n  parserOptions: {\n    type: Object,\n    default: () => ({})\n  },\n  /**\n   * Class to be applied to the root element\n   */\n  class: {\n    type: [String, Array, Object],\n    default: \"\"\n  },\n  /**\n   * Tags to unwrap separated by spaces\n   * Example: 'ul li'\n   */\n  unwrap: {\n    type: [Boolean, String],\n    default: false\n  },\n  /**\n   * Async Data Unique Key\n   * @default `hash(props.value)`\n   */\n  cacheKey: {\n    type: String,\n    default: void 0\n  },\n  /**\n   * Partial parsing (if partial is `true`, title and toc generation will not be generated)\n   */\n  partial: {\n    type: Boolean,\n    default: true\n  }\n});\nconst key = computed(() => props.cacheKey ?? hashString(props.value));\nconst { data, refresh, error } = await useAsyncData(key.value, async () => {\n  if (typeof props.value !== \"string\") {\n    return props.value;\n  }\n  const { parseMarkdown } = await import(\"@nuxtjs/mdc/runtime\");\n  return await parseMarkdown(props.value, {\n    ...props.parserOptions,\n    toc: props.partial ? false : props.parserOptions?.toc,\n    contentHeading: props.partial ? false : props.parserOptions?.contentHeading\n  });\n});\nconst body = computed(() => props.excerpt ? data.value?.excerpt : data.value?.body);\nwatch(() => props.value, () => {\n  refresh();\n});\nfunction hashString(str) {\n  if (typeof str !== \"string\") {\n    str = JSON.stringify(str || \"\");\n  }\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 6) - hash + char;\n    hash = hash & hash;\n  }\n  return `mdc-${hash === 0 ? \"0000\" : hash.toString(36)}-key`;\n}\n</script>\n"],"file":"_nuxt/D3aLZuRZ.js"}