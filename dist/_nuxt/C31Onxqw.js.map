{"version":3,"file":"C31Onxqw.js","names":[],"sources":["../../node_modules/.cache/.pnpm/twoslash-protocol@0.2.12/node_modules/twoslash-protocol/dist/index.mjs","../../node_modules/.cache/.pnpm/twoslash@0.2.12_typescript@5.6.3/node_modules/twoslash/dist/shared/twoslash.a8564bda.mjs"],"sourcesContent":["function isInRange(index, range, inclusive = true) {\n  if (inclusive)\n    return range[0] <= index && index <= range[1];\n  else\n    return range[0] < index && index < range[1];\n}\nfunction isInRanges(index, ranges, inclusive = true) {\n  return ranges.find((range) => isInRange(index, range, inclusive));\n}\nfunction mergeRanges(ranges) {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const merged = [];\n  for (const range of ranges) {\n    const last = merged[merged.length - 1];\n    if (last && last[1] >= range[0])\n      last[1] = Math.max(last[1], range[1]);\n    else\n      merged.push(range);\n  }\n  return merged;\n}\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\nfunction removeCodeRanges(code, removals, nodes) {\n  const ranges = mergeRanges(removals).sort((a, b) => b[0] - a[0]);\n  let outputCode = code;\n  for (const remove of ranges) {\n    const removalLength = remove[1] - remove[0];\n    outputCode = outputCode.slice(0, remove[0]) + outputCode.slice(remove[1]);\n    nodes?.forEach((node) => {\n      if (node.start + node.length <= remove[0])\n        return void 0;\n      else if (node.start < remove[1])\n        node.start = -1;\n      else\n        node.start -= removalLength;\n    });\n  }\n  return {\n    code: outputCode,\n    removals: ranges,\n    nodes\n  };\n}\nfunction resolveNodePositions(nodes, options) {\n  const indexToPos = typeof options === \"string\" ? createPositionConverter(options).indexToPos : options;\n  const resolved = nodes.filter((node) => node.start >= 0).sort((a, b) => a.start - b.start || a.type.localeCompare(b.type));\n  resolved.forEach((node) => Object.assign(node, indexToPos(node.start)));\n  return resolved;\n}\n\nexport { createPositionConverter, isInRange, isInRanges, mergeRanges, removeCodeRanges, resolveNodePositions, splitLines };\n","import { removeCodeRanges } from 'twoslash-protocol';\n\nconst defaultCompilerOptions = {\n  strict: true,\n  module: 99,\n  target: 99,\n  allowJs: true,\n  skipDefaultLibCheck: true,\n  skipLibCheck: true,\n  moduleDetection: 3\n};\nconst defaultHandbookOptions = {\n  errors: [],\n  noErrors: false,\n  noErrorsCutted: false,\n  noErrorValidation: false,\n  noStaticSemanticInfo: false,\n  showEmit: false,\n  showEmittedFile: void 0,\n  keepNotations: false\n};\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TwoslashError extends Error {\n  constructor(title, description, recommendation, code) {\n    let message = `\n## ${title}\n\n${description}\n`;\n    if (recommendation)\n      message += `\n${recommendation}`;\n    if (code)\n      message += `\n${code}`;\n    super(message);\n    __publicField(this, \"title\");\n    __publicField(this, \"description\");\n    __publicField(this, \"recommendation\");\n    __publicField(this, \"code\");\n    this.title = title;\n    this.description = description;\n    this.recommendation = recommendation;\n    this.code = code;\n  }\n}\n\nconst defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nconst reConfigBoolean = /^\\/\\/\\s?@(\\w+)$/gm;\nconst reConfigValue = /^\\/\\/\\s?@(\\w+):\\s?(.+)$/gm;\nconst reAnnonateMarkers = /^\\s*\\/\\/\\s*\\^(\\?|\\||\\^+)( .*)?$/gm;\nconst reCutBefore = /^[\\t\\v\\f ]*\\/\\/\\s?---cut(-before)?---\\r?\\n/gm;\nconst reCutAfter = /^[\\t\\v\\f ]*\\/\\/\\s?---cut-after---$/gm;\nconst reCutStart = /^[\\t\\v\\f ]*\\/\\/\\s?---cut-start---$/gm;\nconst reCutEnd = /^[\\t\\v\\f ]*\\/\\/\\s?---cut-end---\\r?\\n/gm;\nconst reFilenamesMakers = /^[\\t\\v\\f ]*\\/\\/\\s?@filename: (.+)$/gm;\n\nfunction getObjectHash(obj) {\n  return objectHash(obj);\n}\nfunction parsePrimitive(value, type) {\n  if (typeof value === type)\n    return value;\n  switch (type) {\n    case \"number\":\n      return +value;\n    case \"string\":\n      return value;\n    case \"boolean\":\n      return value.toLowerCase() === \"true\" || value.length === 0;\n  }\n  throw new TwoslashError(\n    `Unknown primitive value in compiler flag`,\n    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,\n    `This is likely a typo.`\n  );\n}\nfunction typesToExtension(types) {\n  const map = {\n    js: \"js\",\n    javascript: \"js\",\n    ts: \"ts\",\n    typescript: \"ts\",\n    tsx: \"tsx\",\n    jsx: \"jsx\",\n    json: \"json\",\n    jsn: \"json\",\n    map: \"json\",\n    mts: \"ts\",\n    cts: \"ts\",\n    mjs: \"js\",\n    cjs: \"js\"\n  };\n  if (map[types])\n    return map[types];\n  throw new TwoslashError(\n    `Unknown TypeScript extension given to Twoslash`,\n    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,\n    ``\n  );\n}\nfunction getIdentifierTextSpans(ts, sourceFile, fileOffset) {\n  const textSpans = [];\n  checkChildren(sourceFile);\n  return textSpans;\n  function checkChildren(node) {\n    ts.forEachChild(node, (child) => {\n      if (ts.isIdentifier(child)) {\n        const text = child.getText(sourceFile);\n        const start = child.getStart(sourceFile, false) + fileOffset;\n        const end = start + text.length;\n        textSpans.push([start, end, text]);\n      }\n      checkChildren(child);\n    });\n  }\n}\nfunction getOptionValueFromMap(name, key, optMap) {\n  const result = optMap.get(key.toLowerCase());\n  if (result === void 0) {\n    const keys = Array.from(optMap.keys());\n    throw new TwoslashError(\n      `Invalid inline compiler value`,\n      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,\n      `Allowed values: ${keys.join(\",\")}`\n    );\n  }\n  return result;\n}\nfunction splitFiles(code, defaultFileName, root) {\n  const matches = Array.from(code.matchAll(reFilenamesMakers));\n  const allFilenames = matches.map((match) => match[1].trimEnd());\n  let currentFileName = allFilenames.includes(defaultFileName) ? \"__index__.ts\" : defaultFileName;\n  const files = [];\n  let index = 0;\n  for (const match of matches) {\n    const offset = match.index;\n    const content = code.slice(index, offset);\n    if (content) {\n      files.push({\n        offset: index,\n        filename: currentFileName,\n        filepath: root + currentFileName,\n        content,\n        extension: getExtension(currentFileName)\n      });\n    }\n    currentFileName = match[1].trimEnd();\n    index = offset;\n  }\n  if (index < code.length) {\n    const content = code.slice(index);\n    files.push({\n      offset: index,\n      filename: currentFileName,\n      filepath: root + currentFileName,\n      content,\n      extension: getExtension(currentFileName)\n    });\n  }\n  return files;\n}\nfunction getExtension(fileName) {\n  return fileName.split(\".\").pop();\n}\nfunction parseFlag(name, value, start, end, customTags, tsOptionDeclarations) {\n  if (customTags.includes(name)) {\n    return {\n      type: \"tag\",\n      name,\n      value,\n      start,\n      end\n    };\n  }\n  const compilerDecl = tsOptionDeclarations.find((d) => d.name.toLocaleLowerCase() === name.toLocaleLowerCase());\n  if (compilerDecl) {\n    switch (compilerDecl.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: parsePrimitive(value, compilerDecl.type),\n          start,\n          end\n        };\n      case \"list\": {\n        const elementType = compilerDecl.element.type;\n        const strings = value.split(\",\");\n        const resolved = typeof elementType === \"string\" ? strings.map((v) => parsePrimitive(v, elementType)) : strings.map((v) => getOptionValueFromMap(compilerDecl.name, v, elementType));\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: resolved,\n          start,\n          end\n        };\n      }\n      case \"object\":\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: JSON.parse(value),\n          start,\n          end\n        };\n      default: {\n        return {\n          type: \"compilerOptions\",\n          name: compilerDecl.name,\n          value: getOptionValueFromMap(compilerDecl.name, value, compilerDecl.type),\n          start,\n          end\n        };\n      }\n    }\n  }\n  if (Object.keys(defaultHandbookOptions).includes(name)) {\n    if (name === \"errors\" && typeof value === \"string\")\n      value = value.split(\" \").map(Number);\n    if (name === \"noErrors\" && typeof value === \"string\") {\n      if (value === \"true\")\n        value = true;\n      else if (value === \"false\")\n        value = false;\n      else\n        value = value.split(\" \").map(Number);\n    }\n    return {\n      type: \"handbookOptions\",\n      name,\n      value,\n      start,\n      end\n    };\n  }\n  return {\n    type: \"unknown\",\n    name,\n    value,\n    start,\n    end\n  };\n}\nfunction findFlagNotations(code, customTags, tsOptionDeclarations) {\n  const flagNotations = [];\n  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {\n    const index = match.index;\n    const name = match[1];\n    flagNotations.push(\n      parseFlag(name, true, index, index + match[0].length + 1, customTags, tsOptionDeclarations)\n    );\n  });\n  Array.from(code.matchAll(reConfigValue)).forEach((match) => {\n    const name = match[1];\n    if (name === \"filename\")\n      return;\n    const index = match.index;\n    const value = match[2];\n    flagNotations.push(\n      parseFlag(name, value, index, index + match[0].length + 1, customTags, tsOptionDeclarations)\n    );\n  });\n  return flagNotations;\n}\nfunction findCutNotations(code, meta) {\n  const removals = [];\n  const cutBefore = [...code.matchAll(reCutBefore)];\n  const cutAfter = [...code.matchAll(reCutAfter)];\n  const cutStart = [...code.matchAll(reCutStart)];\n  const cutEnd = [...code.matchAll(reCutEnd)];\n  if (cutBefore.length) {\n    const last = cutBefore[cutBefore.length - 1];\n    removals.push([0, last.index + last[0].length]);\n  }\n  if (cutAfter.length) {\n    const first = cutAfter[0];\n    removals.push([first.index, code.length]);\n  }\n  if (cutStart.length !== cutEnd.length) {\n    throw new TwoslashError(\n      `Mismatched cut markers`,\n      `You have ${cutStart.length} cut-starts and ${cutEnd.length} cut-ends`,\n      `Make sure you have a matching pair for each.`\n    );\n  }\n  for (let i = 0; i < cutStart.length; i++) {\n    const start = cutStart[i];\n    const end = cutEnd[i];\n    if (start.index > end.index) {\n      throw new TwoslashError(\n        `Mismatched cut markers`,\n        `You have a cut-start at ${start.index} which is after the cut-end at ${end.index}`,\n        `Make sure you have a matching pair for each.`\n      );\n    }\n    removals.push([start.index, end.index + end[0].length]);\n  }\n  if (meta)\n    meta.removals.push(...removals);\n  return removals;\n}\nfunction findQueryMarkers(code, meta, pc) {\n  if (code.includes(\"//\")) {\n    const linesQuery = /* @__PURE__ */ new Set();\n    Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {\n      const type = match[1];\n      const index = match.index;\n      meta.removals.push([index, index + match[0].length + 1]);\n      const markerIndex = match[0].indexOf(\"^\");\n      const pos = pc.indexToPos(index + markerIndex);\n      let targetLine = pos.line - 1;\n      while (linesQuery.has(targetLine) && targetLine >= 0)\n        targetLine -= 1;\n      const targetIndex = pc.posToIndex(targetLine, pos.character);\n      if (type === \"?\") {\n        meta.positionQueries.push(targetIndex);\n      } else if (type === \"|\") {\n        meta.positionCompletions.push(targetIndex);\n      } else {\n        const markerLength = match[0].lastIndexOf(\"^\") - markerIndex + 1;\n        meta.positionHighlights.push([\n          targetIndex,\n          targetIndex + markerLength,\n          match[2]?.trim()\n        ]);\n      }\n      linesQuery.add(pos.line);\n    });\n  }\n  return meta;\n}\nfunction removeTsExtension(filename) {\n  const sansMapOrDTS = filename.replace(/\\.map$/, \"\").replace(/\\.d\\.ts$/, \".ts\").replace(/\\.map$/, \"\");\n  return sansMapOrDTS.replace(/\\.[^/.]+$/, \"\");\n}\n\nconst flagKeys = [\n  \"all\",\n  \"allowArbitraryExtensions\",\n  \"allowImportingTsExtensions\",\n  \"allowJs\",\n  \"allowSyntheticDefaultImports\",\n  \"allowUmdGlobalAccess\",\n  \"allowUnreachableCode\",\n  \"allowUnusedLabels\",\n  \"alwaysStrict\",\n  \"assumeChangesOnlyAffectDirectDependencies\",\n  \"baseUrl\",\n  \"build\",\n  \"charset\",\n  \"checkJs\",\n  \"composite\",\n  \"customConditions\",\n  \"declaration\",\n  \"declarationDir\",\n  \"declarationMap\",\n  \"diagnostics\",\n  \"disableReferencedProjectLoad\",\n  \"disableSizeLimit\",\n  \"disableSolutionSearching\",\n  \"disableSourceOfProjectReferenceRedirect\",\n  \"downlevelIteration\",\n  \"emitBOM\",\n  \"emitDeclarationOnly\",\n  \"emitDecoratorMetadata\",\n  \"errors\",\n  \"esModuleInterop\",\n  \"exactOptionalPropertyTypes\",\n  \"experimentalDecorators\",\n  \"explainFiles\",\n  \"extendedDiagnostics\",\n  \"forceConsistentCasingInFileNames\",\n  \"generateCpuProfile\",\n  \"generateTrace\",\n  \"help\",\n  \"help\",\n  \"ignoreDeprecations\",\n  \"importHelpers\",\n  \"importsNotUsedAsValues\",\n  \"incremental\",\n  \"init\",\n  \"inlineSourceMap\",\n  \"inlineSources\",\n  \"isolatedModules\",\n  \"jsx\",\n  \"jsxFactory\",\n  \"jsxFragmentFactory\",\n  \"jsxImportSource\",\n  \"keepNotations\",\n  \"keyofStringsOnly\",\n  \"lib\",\n  \"listEmittedFiles\",\n  \"listFiles\",\n  \"listFilesOnly\",\n  \"locale\",\n  \"mapRoot\",\n  \"maxNodeModuleJsDepth\",\n  \"module\",\n  \"moduleDetection\",\n  \"moduleResolution\",\n  \"moduleSuffixes\",\n  \"newLine\",\n  \"noEmit\",\n  \"noEmitHelpers\",\n  \"noEmitOnError\",\n  \"noErrorTruncation\",\n  \"noErrorValidation\",\n  \"noErrors\",\n  \"noErrorsCutted\",\n  \"noFallthroughCasesInSwitch\",\n  \"noImplicitAny\",\n  \"noImplicitOverride\",\n  \"noImplicitReturns\",\n  \"noImplicitThis\",\n  \"noImplicitUseStrict\",\n  \"noLib\",\n  \"noPropertyAccessFromIndexSignature\",\n  \"noResolve\",\n  \"noStaticSemanticInfo\",\n  \"noStrictGenericChecks\",\n  \"noUncheckedIndexedAccess\",\n  \"noUnusedLocals\",\n  \"noUnusedParameters\",\n  \"out\",\n  \"outDir\",\n  \"outFile\",\n  \"paths\",\n  \"plugins\",\n  \"preserveConstEnums\",\n  \"preserveSymlinks\",\n  \"preserveValueImports\",\n  \"preserveWatchOutput\",\n  \"pretty\",\n  \"project\",\n  \"reactNamespace\",\n  \"removeComments\",\n  \"resolveJsonModule\",\n  \"resolvePackageJsonExports\",\n  \"resolvePackageJsonImports\",\n  \"rootDir\",\n  \"rootDirs\",\n  \"showConfig\",\n  \"showEmit\",\n  \"showEmittedFile\",\n  \"skipDefaultLibCheck\",\n  \"skipLibCheck\",\n  \"sourceMap\",\n  \"sourceRoot\",\n  \"strict\",\n  \"strictBindCallApply\",\n  \"strictFunctionTypes\",\n  \"strictNullChecks\",\n  \"strictPropertyInitialization\",\n  \"stripInternal\",\n  \"suppressExcessPropertyErrors\",\n  \"suppressImplicitAnyIndexErrors\",\n  \"target\",\n  \"traceResolution\",\n  \"tsBuildInfoFile\",\n  \"typeRoots\",\n  \"types\",\n  \"useDefineForClassFields\",\n  \"useUnknownInCatchVariables\",\n  \"verbatimModuleSyntax\",\n  \"version\",\n  \"watch\"\n];\n\nfunction removeTwoslashNotations(code, customTags) {\n  const meta = {\n    removals: []\n  };\n  const tags = [\n    ...customTags ?? [],\n    ...flagKeys\n  ];\n  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {\n    if (!tags.includes(match[1]))\n      return;\n    meta.removals.push([match.index, match.index + match[0].length + 1]);\n  });\n  Array.from(code.matchAll(reConfigValue)).forEach((match) => {\n    if (!tags.includes(match[1]))\n      return;\n    meta.removals.push([match.index, match.index + match[0].length + 1]);\n  });\n  findCutNotations(code, meta);\n  Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {\n    const index = match.index;\n    meta.removals.push([index, index + match[0].length + 1]);\n  });\n  return removeCodeRanges(code, meta.removals).code;\n}\n\nexport { TwoslashError as T, findFlagNotations as a, findQueryMarkers as b, defaultHandbookOptions as c, defaultCompilerOptions as d, removeTsExtension as e, findCutNotations as f, getObjectHash as g, getExtension as h, getIdentifierTextSpans as i, removeTwoslashNotations as r, splitFiles as s, typesToExtension as t };\n"],"x_google_ignoreList":[0,1],"mappings":"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"}