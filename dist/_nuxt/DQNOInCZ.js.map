{"version":3,"file":"DQNOInCZ.js","names":["ShikiError$1","decorations","clone","ShikiError","Registry","Registry$1"],"sources":["../../node_modules/.cache/.pnpm/@shikijs+types@3.12.2/node_modules/@shikijs/types/dist/index.mjs","../../node_modules/.cache/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js","../../node_modules/.cache/.pnpm/@shikijs+core@3.12.2/node_modules/@shikijs/core/dist/index.mjs"],"sourcesContent":["class ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nexport { ShikiError };\n","// src/utils.ts\nfunction clone(something) {\n  return doClone(something);\n}\nfunction doClone(something) {\n  if (Array.isArray(something)) {\n    return cloneArray(something);\n  }\n  if (something instanceof RegExp) {\n    return something;\n  }\n  if (typeof something === \"object\") {\n    return cloneObj(something);\n  }\n  return something;\n}\nfunction cloneArray(arr) {\n  let r = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    r[i] = doClone(arr[i]);\n  }\n  return r;\n}\nfunction cloneObj(obj) {\n  let r = {};\n  for (let key in obj) {\n    r[key] = doClone(obj[key]);\n  }\n  return r;\n}\nfunction mergeObjects(target, ...sources) {\n  sources.forEach((source) => {\n    for (let key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\nfunction basename(path) {\n  const idx = ~path.lastIndexOf(\"/\") || ~path.lastIndexOf(\"\\\\\");\n  if (idx === 0) {\n    return path;\n  } else if (~idx === path.length - 1) {\n    return basename(path.substring(0, path.length - 1));\n  } else {\n    return path.substr(~idx + 1);\n  }\n}\nvar CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nvar RegexSource = class {\n  static hasCaptures(regexSource) {\n    if (regexSource === null) {\n      return false;\n    }\n    CAPTURING_REGEX_SOURCE.lastIndex = 0;\n    return CAPTURING_REGEX_SOURCE.test(regexSource);\n  }\n  static replaceCaptures(regexSource, captureSource, captureIndices) {\n    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n      let capture = captureIndices[parseInt(index || commandIndex, 10)];\n      if (capture) {\n        let result = captureSource.substring(capture.start, capture.end);\n        while (result[0] === \".\") {\n          result = result.substring(1);\n        }\n        switch (command) {\n          case \"downcase\":\n            return result.toLowerCase();\n          case \"upcase\":\n            return result.toUpperCase();\n          default:\n            return result;\n        }\n      } else {\n        return match;\n      }\n    });\n  }\n};\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction strArrCmp(a, b) {\n  if (a === null && b === null) {\n    return 0;\n  }\n  if (!a) {\n    return -1;\n  }\n  if (!b) {\n    return 1;\n  }\n  let len1 = a.length;\n  let len2 = b.length;\n  if (len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      let res = strcmp(a[i], b[i]);\n      if (res !== 0) {\n        return res;\n      }\n    }\n    return 0;\n  }\n  return len1 - len2;\n}\nfunction isValidHexColor(hex) {\n  if (/^#[0-9a-f]{6}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{8}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{3}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{4}$/i.test(hex)) {\n    return true;\n  }\n  return false;\n}\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, \"\\\\$&\");\n}\nvar CachedFn = class {\n  constructor(fn) {\n    this.fn = fn;\n  }\n  cache = /* @__PURE__ */ new Map();\n  get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    const value = this.fn(key);\n    this.cache.set(key, value);\n    return value;\n  }\n};\n\n// src/theme.ts\nvar Theme = class {\n  constructor(_colorMap, _defaults, _root) {\n    this._colorMap = _colorMap;\n    this._defaults = _defaults;\n    this._root = _root;\n  }\n  static createFromRawTheme(source, colorMap) {\n    return this.createFromParsedTheme(parseTheme(source), colorMap);\n  }\n  static createFromParsedTheme(source, colorMap) {\n    return resolveParsedThemeRules(source, colorMap);\n  }\n  _cachedMatchRoot = new CachedFn(\n    (scopeName) => this._root.match(scopeName)\n  );\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  getDefaults() {\n    return this._defaults;\n  }\n  match(scopePath) {\n    if (scopePath === null) {\n      return this._defaults;\n    }\n    const scopeName = scopePath.scopeName;\n    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n    const effectiveRule = matchingTrieElements.find(\n      (v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes)\n    );\n    if (!effectiveRule) {\n      return null;\n    }\n    return new StyleAttributes(\n      effectiveRule.fontStyle,\n      effectiveRule.foreground,\n      effectiveRule.background\n    );\n  }\n};\nvar ScopeStack = class _ScopeStack {\n  constructor(parent, scopeName) {\n    this.parent = parent;\n    this.scopeName = scopeName;\n  }\n  static push(path, scopeNames) {\n    for (const name of scopeNames) {\n      path = new _ScopeStack(path, name);\n    }\n    return path;\n  }\n  static from(...segments) {\n    let result = null;\n    for (let i = 0; i < segments.length; i++) {\n      result = new _ScopeStack(result, segments[i]);\n    }\n    return result;\n  }\n  push(scopeName) {\n    return new _ScopeStack(this, scopeName);\n  }\n  getSegments() {\n    let item = this;\n    const result = [];\n    while (item) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    result.reverse();\n    return result;\n  }\n  toString() {\n    return this.getSegments().join(\" \");\n  }\n  extends(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.parent === null) {\n      return false;\n    }\n    return this.parent.extends(other);\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let item = this;\n    while (item && item !== base) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    return item === base ? result.reverse() : void 0;\n  }\n};\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n  if (parentScopes.length === 0) {\n    return true;\n  }\n  for (let index = 0; index < parentScopes.length; index++) {\n    let scopePattern = parentScopes[index];\n    let scopeMustMatch = false;\n    if (scopePattern === \">\") {\n      if (index === parentScopes.length - 1) {\n        return false;\n      }\n      scopePattern = parentScopes[++index];\n      scopeMustMatch = true;\n    }\n    while (scopePath) {\n      if (_matchesScope(scopePath.scopeName, scopePattern)) {\n        break;\n      }\n      if (scopeMustMatch) {\n        return false;\n      }\n      scopePath = scopePath.parent;\n    }\n    if (!scopePath) {\n      return false;\n    }\n    scopePath = scopePath.parent;\n  }\n  return true;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === \".\";\n}\nvar StyleAttributes = class {\n  constructor(fontStyle, foregroundId, backgroundId) {\n    this.fontStyle = fontStyle;\n    this.foregroundId = foregroundId;\n    this.backgroundId = backgroundId;\n  }\n};\nfunction parseTheme(source) {\n  if (!source) {\n    return [];\n  }\n  if (!source.settings || !Array.isArray(source.settings)) {\n    return [];\n  }\n  let settings = source.settings;\n  let result = [], resultLen = 0;\n  for (let i = 0, len = settings.length; i < len; i++) {\n    let entry = settings[i];\n    if (!entry.settings) {\n      continue;\n    }\n    let scopes;\n    if (typeof entry.scope === \"string\") {\n      let _scope = entry.scope;\n      _scope = _scope.replace(/^[,]+/, \"\");\n      _scope = _scope.replace(/[,]+$/, \"\");\n      scopes = _scope.split(\",\");\n    } else if (Array.isArray(entry.scope)) {\n      scopes = entry.scope;\n    } else {\n      scopes = [\"\"];\n    }\n    let fontStyle = -1 /* NotSet */;\n    if (typeof entry.settings.fontStyle === \"string\") {\n      fontStyle = 0 /* None */;\n      let segments = entry.settings.fontStyle.split(\" \");\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        let segment = segments[j];\n        switch (segment) {\n          case \"italic\":\n            fontStyle = fontStyle | 1 /* Italic */;\n            break;\n          case \"bold\":\n            fontStyle = fontStyle | 2 /* Bold */;\n            break;\n          case \"underline\":\n            fontStyle = fontStyle | 4 /* Underline */;\n            break;\n          case \"strikethrough\":\n            fontStyle = fontStyle | 8 /* Strikethrough */;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.settings.foreground === \"string\" && isValidHexColor(entry.settings.foreground)) {\n      foreground = entry.settings.foreground;\n    }\n    let background = null;\n    if (typeof entry.settings.background === \"string\" && isValidHexColor(entry.settings.background)) {\n      background = entry.settings.background;\n    }\n    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n      let _scope = scopes[j].trim();\n      let segments = _scope.split(\" \");\n      let scope = segments[segments.length - 1];\n      let parentScopes = null;\n      if (segments.length > 1) {\n        parentScopes = segments.slice(0, segments.length - 1);\n        parentScopes.reverse();\n      }\n      result[resultLen++] = new ParsedThemeRule(\n        scope,\n        parentScopes,\n        i,\n        fontStyle,\n        foreground,\n        background\n      );\n    }\n  }\n  return result;\n}\nvar ParsedThemeRule = class {\n  constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n    this.scope = scope;\n    this.parentScopes = parentScopes;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n};\nvar FontStyle = /* @__PURE__ */ ((FontStyle2) => {\n  FontStyle2[FontStyle2[\"NotSet\"] = -1] = \"NotSet\";\n  FontStyle2[FontStyle2[\"None\"] = 0] = \"None\";\n  FontStyle2[FontStyle2[\"Italic\"] = 1] = \"Italic\";\n  FontStyle2[FontStyle2[\"Bold\"] = 2] = \"Bold\";\n  FontStyle2[FontStyle2[\"Underline\"] = 4] = \"Underline\";\n  FontStyle2[FontStyle2[\"Strikethrough\"] = 8] = \"Strikethrough\";\n  return FontStyle2;\n})(FontStyle || {});\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n  parsedThemeRules.sort((a, b) => {\n    let r = strcmp(a.scope, b.scope);\n    if (r !== 0) {\n      return r;\n    }\n    r = strArrCmp(a.parentScopes, b.parentScopes);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  let defaultFontStyle = 0 /* None */;\n  let defaultForeground = \"#000000\";\n  let defaultBackground = \"#ffffff\";\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === \"\") {\n    let incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  let colorMap = new ColorMap(_colorMap);\n  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n  let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */, 0, 0), []);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    let rule = parsedThemeRules[i];\n    root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new Theme(colorMap, defaults, root);\n}\nvar ColorMap = class {\n  _isFrozen;\n  _lastColorId;\n  _id2color;\n  _color2id;\n  constructor(_colorMap) {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = /* @__PURE__ */ Object.create(null);\n    if (Array.isArray(_colorMap)) {\n      this._isFrozen = true;\n      for (let i = 0, len = _colorMap.length; i < len; i++) {\n        this._color2id[_colorMap[i]] = i;\n        this._id2color[i] = _colorMap[i];\n      }\n    } else {\n      this._isFrozen = false;\n    }\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    color = color.toUpperCase();\n    let value = this._color2id[color];\n    if (value) {\n      return value;\n    }\n    if (this._isFrozen) {\n      throw new Error(`Missing color in color map - ${color}`);\n    }\n    value = ++this._lastColorId;\n    this._color2id[color] = value;\n    this._id2color[value] = color;\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n};\nvar emptyParentScopes = Object.freeze([]);\nvar ThemeTrieElementRule = class _ThemeTrieElementRule {\n  scopeDepth;\n  parentScopes;\n  fontStyle;\n  foreground;\n  background;\n  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    this.scopeDepth = scopeDepth;\n    this.parentScopes = parentScopes || emptyParentScopes;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n  clone() {\n    return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n  }\n  static cloneArr(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n      r[i] = arr[i].clone();\n    }\n    return r;\n  }\n  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n    if (this.scopeDepth > scopeDepth) {\n      console.log(\"how did this happen?\");\n    } else {\n      this.scopeDepth = scopeDepth;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      this.fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      this.foreground = foreground;\n    }\n    if (background !== 0) {\n      this.background = background;\n    }\n  }\n};\nvar ThemeTrieElement = class _ThemeTrieElement {\n  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n    this._mainRule = _mainRule;\n    this._children = _children;\n    this._rulesWithParentScopes = rulesWithParentScopes;\n  }\n  _rulesWithParentScopes;\n  static _cmpBySpecificity(a, b) {\n    if (a.scopeDepth !== b.scopeDepth) {\n      return b.scopeDepth - a.scopeDepth;\n    }\n    let aParentIndex = 0;\n    let bParentIndex = 0;\n    while (true) {\n      if (a.parentScopes[aParentIndex] === \">\") {\n        aParentIndex++;\n      }\n      if (b.parentScopes[bParentIndex] === \">\") {\n        bParentIndex++;\n      }\n      if (aParentIndex >= a.parentScopes.length || bParentIndex >= b.parentScopes.length) {\n        break;\n      }\n      const parentScopeLengthDiff = b.parentScopes[bParentIndex].length - a.parentScopes[aParentIndex].length;\n      if (parentScopeLengthDiff !== 0) {\n        return parentScopeLengthDiff;\n      }\n      aParentIndex++;\n      bParentIndex++;\n    }\n    return b.parentScopes.length - a.parentScopes.length;\n  }\n  match(scope) {\n    if (scope !== \"\") {\n      let dotIndex = scope.indexOf(\".\");\n      let head;\n      let tail;\n      if (dotIndex === -1) {\n        head = scope;\n        tail = \"\";\n      } else {\n        head = scope.substring(0, dotIndex);\n        tail = scope.substring(dotIndex + 1);\n      }\n      if (this._children.hasOwnProperty(head)) {\n        return this._children[head].match(tail);\n      }\n    }\n    const rules = this._rulesWithParentScopes.concat(this._mainRule);\n    rules.sort(_ThemeTrieElement._cmpBySpecificity);\n    return rules;\n  }\n  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n    if (scope === \"\") {\n      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n      return;\n    }\n    let dotIndex = scope.indexOf(\".\");\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = scope;\n      tail = \"\";\n    } else {\n      head = scope.substring(0, dotIndex);\n      tail = scope.substring(dotIndex + 1);\n    }\n    let child;\n    if (this._children.hasOwnProperty(head)) {\n      child = this._children[head];\n    } else {\n      child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n      this._children[head] = child;\n    }\n    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n  }\n  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    if (parentScopes === null) {\n      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n      return;\n    }\n    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n      let rule = this._rulesWithParentScopes[i];\n      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n        return;\n      }\n    }\n    if (fontStyle === -1 /* NotSet */) {\n      fontStyle = this._mainRule.fontStyle;\n    }\n    if (foreground === 0) {\n      foreground = this._mainRule.foreground;\n    }\n    if (background === 0) {\n      background = this._mainRule.background;\n    }\n    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n  }\n};\n\n// src/encodedTokenAttributes.ts\nvar EncodedTokenMetadata = class _EncodedTokenMetadata {\n  static toBinaryStr(encodedTokenAttributes) {\n    return encodedTokenAttributes.toString(2).padStart(32, \"0\");\n  }\n  static print(encodedTokenAttributes) {\n    const languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    const tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    const fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    const foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    const background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    console.log({\n      languageId,\n      tokenType,\n      fontStyle,\n      foreground,\n      background\n    });\n  }\n  static getLanguageId(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n  }\n  static getTokenType(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 768 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n  }\n  static containsBalancedBrackets(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 1024 /* BALANCED_BRACKETS_MASK */) !== 0;\n  }\n  static getFontStyle(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 30720 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;\n  }\n  static getForeground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 16744448 /* FOREGROUND_MASK */) >>> 15 /* FOREGROUND_OFFSET */;\n  }\n  static getBackground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 4278190080 /* BACKGROUND_MASK */) >>> 24 /* BACKGROUND_OFFSET */;\n  }\n  /**\n   * Updates the fields in `metadata`.\n   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.\n   */\n  static set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {\n    let _languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    let _tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    let _containsBalancedBracketsBit = _EncodedTokenMetadata.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n    let _fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    let _foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    let _background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    if (languageId !== 0) {\n      _languageId = languageId;\n    }\n    if (tokenType !== 8 /* NotSet */) {\n      _tokenType = fromOptionalTokenType(tokenType);\n    }\n    if (containsBalancedBrackets !== null) {\n      _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      _fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      _foreground = foreground;\n    }\n    if (background !== 0) {\n      _background = background;\n    }\n    return (_languageId << 0 /* LANGUAGEID_OFFSET */ | _tokenType << 8 /* TOKEN_TYPE_OFFSET */ | _containsBalancedBracketsBit << 10 /* BALANCED_BRACKETS_OFFSET */ | _fontStyle << 11 /* FONT_STYLE_OFFSET */ | _foreground << 15 /* FOREGROUND_OFFSET */ | _background << 24 /* BACKGROUND_OFFSET */) >>> 0;\n  }\n};\nfunction toOptionalTokenType(standardType) {\n  return standardType;\n}\nfunction fromOptionalTokenType(standardType) {\n  return standardType;\n}\n\n// src/matcher.ts\nfunction createMatchers(selector, matchesName) {\n  const results = [];\n  const tokenizer = newTokenizer(selector);\n  let token = tokenizer.next();\n  while (token !== null) {\n    let priority = 0;\n    if (token.length === 2 && token.charAt(1) === \":\") {\n      switch (token.charAt(0)) {\n        case \"R\":\n          priority = 1;\n          break;\n        case \"L\":\n          priority = -1;\n          break;\n        default:\n          console.log(`Unknown priority ${token} in scope selector`);\n      }\n      token = tokenizer.next();\n    }\n    let matcher = parseConjunction();\n    results.push({ matcher, priority });\n    if (token !== \",\") {\n      break;\n    }\n    token = tokenizer.next();\n  }\n  return results;\n  function parseOperand() {\n    if (token === \"-\") {\n      token = tokenizer.next();\n      const expressionToNegate = parseOperand();\n      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);\n    }\n    if (token === \"(\") {\n      token = tokenizer.next();\n      const expressionInParents = parseInnerExpression();\n      if (token === \")\") {\n        token = tokenizer.next();\n      }\n      return expressionInParents;\n    }\n    if (isIdentifier(token)) {\n      const identifiers = [];\n      do {\n        identifiers.push(token);\n        token = tokenizer.next();\n      } while (isIdentifier(token));\n      return (matcherInput) => matchesName(identifiers, matcherInput);\n    }\n    return null;\n  }\n  function parseConjunction() {\n    const matchers = [];\n    let matcher = parseOperand();\n    while (matcher) {\n      matchers.push(matcher);\n      matcher = parseOperand();\n    }\n    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));\n  }\n  function parseInnerExpression() {\n    const matchers = [];\n    let matcher = parseConjunction();\n    while (matcher) {\n      matchers.push(matcher);\n      if (token === \"|\" || token === \",\") {\n        do {\n          token = tokenizer.next();\n        } while (token === \"|\" || token === \",\");\n      } else {\n        break;\n      }\n      matcher = parseConjunction();\n    }\n    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));\n  }\n}\nfunction isIdentifier(token) {\n  return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n  let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n  let match = regex.exec(input);\n  return {\n    next: () => {\n      if (!match) {\n        return null;\n      }\n      const res = match[0];\n      match = regex.exec(input);\n      return res;\n    }\n  };\n}\n\n// src/onigLib.ts\nvar FindOption = /* @__PURE__ */ ((FindOption2) => {\n  FindOption2[FindOption2[\"None\"] = 0] = \"None\";\n  FindOption2[FindOption2[\"NotBeginString\"] = 1] = \"NotBeginString\";\n  FindOption2[FindOption2[\"NotEndString\"] = 2] = \"NotEndString\";\n  FindOption2[FindOption2[\"NotBeginPosition\"] = 4] = \"NotBeginPosition\";\n  FindOption2[FindOption2[\"DebugCall\"] = 8] = \"DebugCall\";\n  return FindOption2;\n})(FindOption || {});\nfunction disposeOnigString(str) {\n  if (typeof str.dispose === \"function\") {\n    str.dispose();\n  }\n}\n\n// src/grammar/grammarDependencies.ts\nvar TopLevelRuleReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  toKey() {\n    return this.scopeName;\n  }\n};\nvar TopLevelRepositoryRuleReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  toKey() {\n    return `${this.scopeName}#${this.ruleName}`;\n  }\n};\nvar ExternalReferenceCollector = class {\n  _references = [];\n  _seenReferenceKeys = /* @__PURE__ */ new Set();\n  get references() {\n    return this._references;\n  }\n  visitedRule = /* @__PURE__ */ new Set();\n  add(reference) {\n    const key = reference.toKey();\n    if (this._seenReferenceKeys.has(key)) {\n      return;\n    }\n    this._seenReferenceKeys.add(key);\n    this._references.push(reference);\n  }\n};\nvar ScopeDependencyProcessor = class {\n  constructor(repo, initialScopeName) {\n    this.repo = repo;\n    this.initialScopeName = initialScopeName;\n    this.seenFullScopeRequests.add(this.initialScopeName);\n    this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n  }\n  seenFullScopeRequests = /* @__PURE__ */ new Set();\n  seenPartialScopeRequests = /* @__PURE__ */ new Set();\n  Q;\n  processQueue() {\n    const q = this.Q;\n    this.Q = [];\n    const deps = new ExternalReferenceCollector();\n    for (const dep of q) {\n      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n    }\n    for (const dep of deps.references) {\n      if (dep instanceof TopLevelRuleReference) {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        this.seenFullScopeRequests.add(dep.scopeName);\n        this.Q.push(dep);\n      } else {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        if (this.seenPartialScopeRequests.has(dep.toKey())) {\n          continue;\n        }\n        this.seenPartialScopeRequests.add(dep.toKey());\n        this.Q.push(dep);\n      }\n    }\n  }\n};\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n  const selfGrammar = repo.lookup(reference.scopeName);\n  if (!selfGrammar) {\n    if (reference.scopeName === baseGrammarScopeName) {\n      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n    }\n    return;\n  }\n  const baseGrammar = repo.lookup(baseGrammarScopeName);\n  if (reference instanceof TopLevelRuleReference) {\n    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n  } else {\n    collectExternalReferencesInTopLevelRepositoryRule(\n      reference.ruleName,\n      { baseGrammar, selfGrammar, repository: selfGrammar.repository },\n      result\n    );\n  }\n  const injections = repo.injections(reference.scopeName);\n  if (injections) {\n    for (const injection of injections) {\n      result.add(new TopLevelRuleReference(injection));\n    }\n  }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n  if (context.repository && context.repository[ruleName]) {\n    const rule = context.repository[ruleName];\n    collectExternalReferencesInRules([rule], context, result);\n  }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n    collectExternalReferencesInRules(\n      context.selfGrammar.patterns,\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n  if (context.selfGrammar.injections) {\n    collectExternalReferencesInRules(\n      Object.values(context.selfGrammar.injections),\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n  for (const rule of rules) {\n    if (result.visitedRule.has(rule)) {\n      continue;\n    }\n    result.visitedRule.add(rule);\n    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;\n    if (Array.isArray(rule.patterns)) {\n      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n    }\n    const include = rule.include;\n    if (!include) {\n      continue;\n    }\n    const reference = parseInclude(include);\n    switch (reference.kind) {\n      case 0 /* Base */:\n        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n        break;\n      case 1 /* Self */:\n        collectExternalReferencesInTopLevelRule(context, result);\n        break;\n      case 2 /* RelativeReference */:\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n        break;\n      case 3 /* TopLevelReference */:\n      case 4 /* TopLevelRepositoryReference */:\n        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;\n        if (selfGrammar) {\n          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n          } else {\n            collectExternalReferencesInTopLevelRule(newContext, result);\n          }\n        } else {\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n          } else {\n            result.add(new TopLevelRuleReference(reference.scopeName));\n          }\n        }\n        break;\n    }\n  }\n}\nvar BaseReference = class {\n  kind = 0 /* Base */;\n};\nvar SelfReference = class {\n  kind = 1 /* Self */;\n};\nvar RelativeReference = class {\n  constructor(ruleName) {\n    this.ruleName = ruleName;\n  }\n  kind = 2 /* RelativeReference */;\n};\nvar TopLevelReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  kind = 3 /* TopLevelReference */;\n};\nvar TopLevelRepositoryReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  kind = 4 /* TopLevelRepositoryReference */;\n};\nfunction parseInclude(include) {\n  if (include === \"$base\") {\n    return new BaseReference();\n  } else if (include === \"$self\") {\n    return new SelfReference();\n  }\n  const indexOfSharp = include.indexOf(\"#\");\n  if (indexOfSharp === -1) {\n    return new TopLevelReference(include);\n  } else if (indexOfSharp === 0) {\n    return new RelativeReference(include.substring(1));\n  } else {\n    const scopeName = include.substring(0, indexOfSharp);\n    const ruleName = include.substring(indexOfSharp + 1);\n    return new TopLevelRepositoryReference(scopeName, ruleName);\n  }\n}\n\n// src/rule.ts\nvar HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nvar BACK_REFERENCING_END = /\\\\(\\d+)/g;\nvar ruleIdSymbol = Symbol(\"RuleId\");\nvar endRuleId = -1;\nvar whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n  return id;\n}\nfunction ruleIdToNumber(id) {\n  return id;\n}\nvar Rule = class {\n  $location;\n  id;\n  _nameIsCapturing;\n  _name;\n  _contentNameIsCapturing;\n  _contentName;\n  constructor($location, id, name, contentName) {\n    this.$location = $location;\n    this.id = id;\n    this._name = name || null;\n    this._nameIsCapturing = RegexSource.hasCaptures(this._name);\n    this._contentName = contentName || null;\n    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n  }\n  get debugName() {\n    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : \"unknown\";\n    return `${this.constructor.name}#${this.id} @ ${location}`;\n  }\n  getName(lineText, captureIndices) {\n    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n      return this._name;\n    }\n    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n  }\n  getContentName(lineText, captureIndices) {\n    if (!this._contentNameIsCapturing || this._contentName === null) {\n      return this._contentName;\n    }\n    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n  }\n};\nvar CaptureRule = class extends Rule {\n  retokenizeCapturedWithRuleId;\n  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n    super($location, id, name, contentName);\n    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n  }\n  dispose() {\n  }\n  collectPatterns(grammar, out) {\n    throw new Error(\"Not supported!\");\n  }\n  compile(grammar, endRegexSource) {\n    throw new Error(\"Not supported!\");\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    throw new Error(\"Not supported!\");\n  }\n};\nvar MatchRule = class extends Rule {\n  _match;\n  captures;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, match, captures) {\n    super($location, id, name, null);\n    this._match = new RegExpSource(match, this.id);\n    this.captures = captures;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugMatchRegExp() {\n    return `${this._match.source}`;\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._match);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar IncludeOnlyRule = class extends Rule {\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, patterns) {\n    super($location, id, name, contentName);\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  collectPatterns(grammar, out) {\n    for (const pattern of this.patterns) {\n      const rule = grammar.getRule(pattern);\n      rule.collectPatterns(grammar, out);\n    }\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginEndRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  _end;\n  endHasBackReferences;\n  endCaptures;\n  applyEndPatternLast;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this._end = new RegExpSource(end ? end : \"\\uFFFF\", -1);\n    this.endHasBackReferences = this._end.hasBackReferences;\n    this.endCaptures = endCaptures;\n    this.applyEndPatternLast = applyEndPatternLast || false;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugEndRegExp() {\n    return `${this._end.source}`;\n  }\n  getEndWithResolvedBackReferences(lineText, captureIndices) {\n    return this._end.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n      } else {\n        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n      }\n    }\n    if (this._end.hasBackReferences) {\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n      } else {\n        this._cachedCompiledPatterns.setSource(0, endRegexSource);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginWhileRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  whileCaptures;\n  _while;\n  whileHasBackReferences;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  _cachedCompiledWhilePatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this.whileCaptures = whileCaptures;\n    this._while = new RegExpSource(_while, whileRuleId);\n    this.whileHasBackReferences = this._while.hasBackReferences;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n    this._cachedCompiledWhilePatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n    if (this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns.dispose();\n      this._cachedCompiledWhilePatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugWhileRegExp() {\n    return `${this._while.source}`;\n  }\n  getWhileWithResolvedBackReferences(lineText, captureIndices) {\n    return this._while.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n  compileWhile(grammar, endRegexSource) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns = new RegExpSourceList();\n      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n    }\n    if (this._while.hasBackReferences) {\n      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : \"\\uFFFF\");\n    }\n    return this._cachedCompiledWhilePatterns;\n  }\n};\nvar RuleFactory = class _RuleFactory {\n  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n    return helper.registerRule((id) => {\n      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n    });\n  }\n  static getCompiledRuleId(desc, helper, repository) {\n    if (!desc.id) {\n      helper.registerRule((id) => {\n        desc.id = id;\n        if (desc.match) {\n          return new MatchRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.match,\n            _RuleFactory._compileCaptures(desc.captures, helper, repository)\n          );\n        }\n        if (typeof desc.begin === \"undefined\") {\n          if (desc.repository) {\n            repository = mergeObjects({}, repository, desc.repository);\n          }\n          let patterns = desc.patterns;\n          if (typeof patterns === \"undefined\" && desc.include) {\n            patterns = [{ include: desc.include }];\n          }\n          return new IncludeOnlyRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            _RuleFactory._compilePatterns(patterns, helper, repository)\n          );\n        }\n        if (desc.while) {\n          return new BeginWhileRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            desc.begin,\n            _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n            desc.while,\n            _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository),\n            _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n          );\n        }\n        return new BeginEndRule(\n          desc.$vscodeTextmateLocation,\n          desc.id,\n          desc.name,\n          desc.contentName,\n          desc.begin,\n          _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n          desc.end,\n          _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository),\n          desc.applyEndPatternLast,\n          _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n        );\n      });\n    }\n    return desc.id;\n  }\n  static _compileCaptures(captures, helper, repository) {\n    let r = [];\n    if (captures) {\n      let maximumCaptureId = 0;\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        if (numericCaptureId > maximumCaptureId) {\n          maximumCaptureId = numericCaptureId;\n        }\n      }\n      for (let i = 0; i <= maximumCaptureId; i++) {\n        r[i] = null;\n      }\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        let retokenizeCapturedWithRuleId = 0;\n        if (captures[captureId].patterns) {\n          retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n        }\n        r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n      }\n    }\n    return r;\n  }\n  static _compilePatterns(patterns, helper, repository) {\n    let r = [];\n    if (patterns) {\n      for (let i = 0, len = patterns.length; i < len; i++) {\n        const pattern = patterns[i];\n        let ruleId = -1;\n        if (pattern.include) {\n          const reference = parseInclude(pattern.include);\n          switch (reference.kind) {\n            case 0 /* Base */:\n            case 1 /* Self */:\n              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n              break;\n            case 2 /* RelativeReference */:\n              let localIncludedRule = repository[reference.ruleName];\n              if (localIncludedRule) {\n                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n              } else {\n              }\n              break;\n            case 3 /* TopLevelReference */:\n            case 4 /* TopLevelRepositoryReference */:\n              const externalGrammarName = reference.scopeName;\n              const externalGrammarInclude = reference.kind === 4 /* TopLevelRepositoryReference */ ? reference.ruleName : null;\n              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n              if (externalGrammar) {\n                if (externalGrammarInclude) {\n                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                  if (externalIncludedRule) {\n                    ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                  } else {\n                  }\n                } else {\n                  ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                }\n              } else {\n              }\n              break;\n          }\n        } else {\n          ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);\n        }\n        if (ruleId !== -1) {\n          const rule = helper.getRule(ruleId);\n          let skipRule = false;\n          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n            if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n              skipRule = true;\n            }\n          }\n          if (skipRule) {\n            continue;\n          }\n          r.push(ruleId);\n        }\n      }\n    }\n    return {\n      patterns: r,\n      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length\n    };\n  }\n};\nvar RegExpSource = class _RegExpSource {\n  source;\n  ruleId;\n  hasAnchor;\n  hasBackReferences;\n  _anchorCache;\n  constructor(regExpSource, ruleId) {\n    if (regExpSource && typeof regExpSource === \"string\") {\n      const len = regExpSource.length;\n      let lastPushedPos = 0;\n      let output = [];\n      let hasAnchor = false;\n      for (let pos = 0; pos < len; pos++) {\n        const ch = regExpSource.charAt(pos);\n        if (ch === \"\\\\\") {\n          if (pos + 1 < len) {\n            const nextCh = regExpSource.charAt(pos + 1);\n            if (nextCh === \"z\") {\n              output.push(regExpSource.substring(lastPushedPos, pos));\n              output.push(\"$(?!\\\\n)(?<!\\\\n)\");\n              lastPushedPos = pos + 2;\n            } else if (nextCh === \"A\" || nextCh === \"G\") {\n              hasAnchor = true;\n            }\n            pos++;\n          }\n        }\n      }\n      this.hasAnchor = hasAnchor;\n      if (lastPushedPos === 0) {\n        this.source = regExpSource;\n      } else {\n        output.push(regExpSource.substring(lastPushedPos, len));\n        this.source = output.join(\"\");\n      }\n    } else {\n      this.hasAnchor = false;\n      this.source = regExpSource;\n    }\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    } else {\n      this._anchorCache = null;\n    }\n    this.ruleId = ruleId;\n    if (typeof this.source === \"string\") {\n      this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n    } else {\n      this.hasBackReferences = false;\n    }\n  }\n  clone() {\n    return new _RegExpSource(this.source, this.ruleId);\n  }\n  setSource(newSource) {\n    if (this.source === newSource) {\n      return;\n    }\n    this.source = newSource;\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    }\n  }\n  resolveBackReferences(lineText, captureIndices) {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let capturedValues = captureIndices.map((capture) => {\n      return lineText.substring(capture.start, capture.end);\n    });\n    BACK_REFERENCING_END.lastIndex = 0;\n    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || \"\");\n    });\n  }\n  _buildAnchorCache() {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let A0_G0_result = [];\n    let A0_G1_result = [];\n    let A1_G0_result = [];\n    let A1_G1_result = [];\n    let pos, len, ch, nextCh;\n    for (pos = 0, len = this.source.length; pos < len; pos++) {\n      ch = this.source.charAt(pos);\n      A0_G0_result[pos] = ch;\n      A0_G1_result[pos] = ch;\n      A1_G0_result[pos] = ch;\n      A1_G1_result[pos] = ch;\n      if (ch === \"\\\\\") {\n        if (pos + 1 < len) {\n          nextCh = this.source.charAt(pos + 1);\n          if (nextCh === \"A\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"\\uFFFF\";\n            A1_G0_result[pos + 1] = \"A\";\n            A1_G1_result[pos + 1] = \"A\";\n          } else if (nextCh === \"G\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"G\";\n            A1_G0_result[pos + 1] = \"\\uFFFF\";\n            A1_G1_result[pos + 1] = \"G\";\n          } else {\n            A0_G0_result[pos + 1] = nextCh;\n            A0_G1_result[pos + 1] = nextCh;\n            A1_G0_result[pos + 1] = nextCh;\n            A1_G1_result[pos + 1] = nextCh;\n          }\n          pos++;\n        }\n      }\n    }\n    return {\n      A0_G0: A0_G0_result.join(\"\"),\n      A0_G1: A0_G1_result.join(\"\"),\n      A1_G0: A1_G0_result.join(\"\"),\n      A1_G1: A1_G1_result.join(\"\")\n    };\n  }\n  resolveAnchors(allowA, allowG) {\n    if (!this.hasAnchor || !this._anchorCache || typeof this.source !== \"string\") {\n      return this.source;\n    }\n    if (allowA) {\n      if (allowG) {\n        return this._anchorCache.A1_G1;\n      } else {\n        return this._anchorCache.A1_G0;\n      }\n    } else {\n      if (allowG) {\n        return this._anchorCache.A0_G1;\n      } else {\n        return this._anchorCache.A0_G0;\n      }\n    }\n  }\n};\nvar RegExpSourceList = class {\n  _items;\n  _hasAnchors;\n  _cached;\n  _anchorCache;\n  constructor() {\n    this._items = [];\n    this._hasAnchors = false;\n    this._cached = null;\n    this._anchorCache = {\n      A0_G0: null,\n      A0_G1: null,\n      A1_G0: null,\n      A1_G1: null\n    };\n  }\n  dispose() {\n    this._disposeCaches();\n  }\n  _disposeCaches() {\n    if (this._cached) {\n      this._cached.dispose();\n      this._cached = null;\n    }\n    if (this._anchorCache.A0_G0) {\n      this._anchorCache.A0_G0.dispose();\n      this._anchorCache.A0_G0 = null;\n    }\n    if (this._anchorCache.A0_G1) {\n      this._anchorCache.A0_G1.dispose();\n      this._anchorCache.A0_G1 = null;\n    }\n    if (this._anchorCache.A1_G0) {\n      this._anchorCache.A1_G0.dispose();\n      this._anchorCache.A1_G0 = null;\n    }\n    if (this._anchorCache.A1_G1) {\n      this._anchorCache.A1_G1.dispose();\n      this._anchorCache.A1_G1 = null;\n    }\n  }\n  push(item) {\n    this._items.push(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  unshift(item) {\n    this._items.unshift(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  length() {\n    return this._items.length;\n  }\n  setSource(index, newSource) {\n    if (this._items[index].source !== newSource) {\n      this._disposeCaches();\n      this._items[index].setSource(newSource);\n    }\n  }\n  compile(onigLib) {\n    if (!this._cached) {\n      let regExps = this._items.map((e) => e.source);\n      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n    }\n    return this._cached;\n  }\n  compileAG(onigLib, allowA, allowG) {\n    if (!this._hasAnchors) {\n      return this.compile(onigLib);\n    } else {\n      if (allowA) {\n        if (allowG) {\n          if (!this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G1;\n        } else {\n          if (!this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G0;\n        }\n      } else {\n        if (allowG) {\n          if (!this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G1;\n        } else {\n          if (!this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G0;\n        }\n      }\n    }\n  }\n  _resolveAnchors(onigLib, allowA, allowG) {\n    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));\n    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n  }\n};\nvar CompiledRule = class {\n  constructor(onigLib, regExps, rules) {\n    this.regExps = regExps;\n    this.rules = rules;\n    this.scanner = onigLib.createOnigScanner(regExps);\n  }\n  scanner;\n  dispose() {\n    if (typeof this.scanner.dispose === \"function\") {\n      this.scanner.dispose();\n    }\n  }\n  toString() {\n    const r = [];\n    for (let i = 0, len = this.rules.length; i < len; i++) {\n      r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n    }\n    return r.join(\"\\n\");\n  }\n  findNextMatchSync(string, startPosition, options) {\n    const result = this.scanner.findNextMatchSync(string, startPosition, options);\n    if (!result) {\n      return null;\n    }\n    return {\n      ruleId: this.rules[result.index],\n      captureIndices: result.captureIndices\n    };\n  }\n};\n\n// src/grammar/basicScopesAttributeProvider.ts\nvar BasicScopeAttributes = class {\n  constructor(languageId, tokenType) {\n    this.languageId = languageId;\n    this.tokenType = tokenType;\n  }\n};\nvar BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {\n  _defaultAttributes;\n  _embeddedLanguagesMatcher;\n  constructor(initialLanguageId, embeddedLanguages) {\n    this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* NotSet */);\n    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n  }\n  getDefaultAttributes() {\n    return this._defaultAttributes;\n  }\n  getBasicScopeAttributes(scopeName) {\n    if (scopeName === null) {\n      return _BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n    }\n    return this._getBasicScopeAttributes.get(scopeName);\n  }\n  static _NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\n  _getBasicScopeAttributes = new CachedFn((scopeName) => {\n    const languageId = this._scopeToLanguage(scopeName);\n    const standardTokenType = this._toStandardTokenType(scopeName);\n    return new BasicScopeAttributes(languageId, standardTokenType);\n  });\n  /**\n   * Given a produced TM scope, return the language that token describes or null if unknown.\n   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n   */\n  _scopeToLanguage(scope) {\n    return this._embeddedLanguagesMatcher.match(scope) || 0;\n  }\n  _toStandardTokenType(scopeName) {\n    const m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n      return 8 /* NotSet */;\n    }\n    switch (m[1]) {\n      case \"comment\":\n        return 1 /* Comment */;\n      case \"string\":\n        return 2 /* String */;\n      case \"regex\":\n        return 3 /* RegEx */;\n      case \"meta.embedded\":\n        return 0 /* Other */;\n    }\n    throw new Error(\"Unexpected match for standard token type!\");\n  }\n  static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n};\nvar ScopeMatcher = class {\n  values;\n  scopesRegExp;\n  constructor(values) {\n    if (values.length === 0) {\n      this.values = null;\n      this.scopesRegExp = null;\n    } else {\n      this.values = new Map(values);\n      const escapedScopes = values.map(\n        ([scopeName, value]) => escapeRegExpCharacters(scopeName)\n      );\n      escapedScopes.sort();\n      escapedScopes.reverse();\n      this.scopesRegExp = new RegExp(\n        `^((${escapedScopes.join(\")|(\")}))($|\\\\.)`,\n        \"\"\n      );\n    }\n  }\n  match(scope) {\n    if (!this.scopesRegExp) {\n      return void 0;\n    }\n    const m = scope.match(this.scopesRegExp);\n    if (!m) {\n      return void 0;\n    }\n    return this.values.get(m[1]);\n  }\n};\n\n// src/debug.ts\nvar DebugFlags = {\n  InDebugMode: typeof process !== \"undefined\" && !!process.env[\"VSCODE_TEXTMATE_DEBUG\"]\n};\nvar UseOnigurumaFindOptions = false;\n\n// src/grammar/tokenizeString.ts\nvar TokenizeStringResult = class {\n  constructor(stack, stoppedEarly) {\n    this.stack = stack;\n    this.stoppedEarly = stoppedEarly;\n  }\n};\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n  const lineLength = lineText.content.length;\n  let STOP = false;\n  let anchorPosition = -1;\n  if (checkWhileConditions) {\n    const whileCheckResult = _checkWhileConditions(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      lineTokens\n    );\n    stack = whileCheckResult.stack;\n    linePos = whileCheckResult.linePos;\n    isFirstLine = whileCheckResult.isFirstLine;\n    anchorPosition = whileCheckResult.anchorPosition;\n  }\n  const startTime = Date.now();\n  while (!STOP) {\n    if (timeLimit !== 0) {\n      const elapsedTime = Date.now() - startTime;\n      if (elapsedTime > timeLimit) {\n        return new TokenizeStringResult(stack, true);\n      }\n    }\n    scanNext();\n  }\n  return new TokenizeStringResult(stack, false);\n  function scanNext() {\n    if (false) {\n      console.log(\"\");\n      console.log(\n        `@@scanNext ${linePos}: |${lineText.content.substr(linePos).replace(/\\n$/, \"\\\\n\")}|`\n      );\n    }\n    const r = matchRuleOrInjections(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      anchorPosition\n    );\n    if (!r) {\n      lineTokens.produce(stack, lineLength);\n      STOP = true;\n      return;\n    }\n    const captureIndices = r.captureIndices;\n    const matchedRuleId = r.matchedRuleId;\n    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;\n    if (matchedRuleId === endRuleId) {\n      const poppedRule = stack.getRule(grammar);\n      if (false) {\n        console.log(\n          \"  popping \" + poppedRule.debugName + \" - \" + poppedRule.debugEndRegExp\n        );\n      }\n      lineTokens.produce(stack, captureIndices[0].start);\n      stack = stack.withContentNameScopesList(stack.nameScopesList);\n      handleCaptures(\n        grammar,\n        lineText,\n        isFirstLine,\n        stack,\n        lineTokens,\n        poppedRule.endCaptures,\n        captureIndices\n      );\n      lineTokens.produce(stack, captureIndices[0].end);\n      const popped = stack;\n      stack = stack.parent;\n      anchorPosition = popped.getAnchorPos();\n      if (!hasAdvanced && popped.getEnterPos() === linePos) {\n        if (false) {\n          console.error(\n            \"[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing\"\n          );\n        }\n        stack = popped;\n        lineTokens.produce(stack, lineLength);\n        STOP = true;\n        return;\n      }\n    } else {\n      const _rule = grammar.getRule(matchedRuleId);\n      lineTokens.produce(stack, captureIndices[0].start);\n      const beforePush = stack;\n      const scopeName = _rule.getName(lineText.content, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(\n        scopeName,\n        grammar\n      );\n      stack = stack.push(\n        matchedRuleId,\n        linePos,\n        anchorPosition,\n        captureIndices[0].end === lineLength,\n        null,\n        nameScopesList,\n        nameScopesList\n      );\n      if (_rule instanceof BeginEndRule) {\n        const pushedRule = _rule;\n        if (false) {\n          console.log(\n            \"  pushing \" + pushedRule.debugName + \" - \" + pushedRule.debugBeginRegExp\n          );\n        }\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.endHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getEndWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {\n            console.error(\n              \"[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing\"\n            );\n          }\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else if (_rule instanceof BeginWhileRule) {\n        const pushedRule = _rule;\n        if (false) {\n          console.log(\"  pushing \" + pushedRule.debugName);\n        }\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.whileHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getWhileWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {\n            console.error(\n              \"[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing\"\n            );\n          }\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else {\n        const matchingRule = _rule;\n        if (false) {\n          console.log(\n            \"  matched \" + matchingRule.debugName + \" - \" + matchingRule.debugMatchRegExp\n          );\n        }\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          matchingRule.captures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        stack = stack.pop();\n        if (!hasAdvanced) {\n          if (false) {\n            console.error(\n              \"[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping\"\n            );\n          }\n          stack = stack.safePop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      }\n    }\n    if (captureIndices[0].end > linePos) {\n      linePos = captureIndices[0].end;\n      isFirstLine = false;\n    }\n  }\n}\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;\n  const whileRules = [];\n  for (let node = stack; node; node = node.pop()) {\n    const nodeRule = node.getRule(grammar);\n    if (nodeRule instanceof BeginWhileRule) {\n      whileRules.push({\n        rule: nodeRule,\n        stack: node\n      });\n    }\n  }\n  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (false) {\n      console.log(\"  scanning for while rule\");\n      console.log(ruleScanner.toString());\n    }\n    if (r) {\n      const matchedRuleId = r.ruleId;\n      if (matchedRuleId !== whileRuleId) {\n        stack = whileRule.stack.pop();\n        break;\n      }\n      if (r.captureIndices && r.captureIndices.length) {\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n        anchorPosition = r.captureIndices[0].end;\n        if (r.captureIndices[0].end > linePos) {\n          linePos = r.captureIndices[0].end;\n          isFirstLine = false;\n        }\n      }\n    } else {\n      if (false) {\n        console.log(\"  popping \" + whileRule.rule.debugName + \" - \" + whileRule.rule.debugWhileRegExp);\n      }\n      stack = whileRule.stack.pop();\n      break;\n    }\n  }\n  return { stack, linePos, anchorPosition, isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  const injections = grammar.getInjections();\n  if (injections.length === 0) {\n    return matchResult;\n  }\n  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  if (!injectionResult) {\n    return matchResult;\n  }\n  if (!matchResult) {\n    return injectionResult;\n  }\n  const matchResultScore = matchResult.captureIndices[0].start;\n  const injectionResultScore = injectionResult.captureIndices[0].start;\n  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {\n    return injectionResult;\n  }\n  return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const rule = stack.getRule(grammar);\n  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n  if (r) {\n    return {\n      captureIndices: r.captureIndices,\n      matchedRuleId: r.ruleId\n    };\n  }\n  return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  let bestMatchRating = Number.MAX_VALUE;\n  let bestMatchCaptureIndices = null;\n  let bestMatchRuleId;\n  let bestMatchResultPriority = 0;\n  const scopes = stack.contentNameScopesList.getScopeNames();\n  for (let i = 0, len = injections.length; i < len; i++) {\n    const injection = injections[i];\n    if (!injection.matcher(scopes)) {\n      continue;\n    }\n    const rule = grammar.getRule(injection.ruleId);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (!matchResult) {\n      continue;\n    }\n    if (false) {\n      console.log(`  matched injection: ${injection.debugSelector}`);\n      console.log(ruleScanner.toString());\n    }\n    const matchRating = matchResult.captureIndices[0].start;\n    if (matchRating >= bestMatchRating) {\n      continue;\n    }\n    bestMatchRating = matchRating;\n    bestMatchCaptureIndices = matchResult.captureIndices;\n    bestMatchRuleId = matchResult.ruleId;\n    bestMatchResultPriority = injection.priority;\n    if (bestMatchRating === linePos) {\n      break;\n    }\n  }\n  if (bestMatchCaptureIndices) {\n    return {\n      priorityMatch: bestMatchResultPriority === -1,\n      captureIndices: bestMatchCaptureIndices,\n      matchedRuleId: bestMatchRuleId\n    };\n  }\n  return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compileWhile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction getFindOptions(allowA, allowG) {\n  let options = 0 /* None */;\n  if (!allowA) {\n    options |= 1 /* NotBeginString */;\n  }\n  if (!allowG) {\n    options |= 4 /* NotBeginPosition */;\n  }\n  return options;\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n  if (captures.length === 0) {\n    return;\n  }\n  const lineTextContent = lineText.content;\n  const len = Math.min(captures.length, captureIndices.length);\n  const localStack = [];\n  const maxEnd = captureIndices[0].end;\n  for (let i = 0; i < len; i++) {\n    const captureRule = captures[i];\n    if (captureRule === null) {\n      continue;\n    }\n    const captureIndex = captureIndices[i];\n    if (captureIndex.length === 0) {\n      continue;\n    }\n    if (captureIndex.start > maxEnd) {\n      break;\n    }\n    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n      localStack.pop();\n    }\n    if (localStack.length > 0) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n    } else {\n      lineTokens.produce(stack, captureIndex.start);\n    }\n    if (captureRule.retokenizeCapturedWithRuleId) {\n      const scopeName = captureRule.getName(lineTextContent, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n      const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n      _tokenizeString(\n        grammar,\n        onigSubStr,\n        isFirstLine && captureIndex.start === 0,\n        captureIndex.start,\n        stackClone,\n        lineTokens,\n        false,\n        /* no time limit */\n        0\n      );\n      disposeOnigString(onigSubStr);\n      continue;\n    }\n    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n    if (captureRuleScopeName !== null) {\n      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n    }\n  }\n  while (localStack.length > 0) {\n    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n    localStack.pop();\n  }\n}\nvar LocalStackElement = class {\n  scopes;\n  endPos;\n  constructor(scopes, endPos) {\n    this.scopes = scopes;\n    this.endPos = endPos;\n  }\n};\n\n// src/grammar/grammar.ts\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n  return new Grammar(\n    scopeName,\n    grammar,\n    initialLanguage,\n    embeddedLanguages,\n    tokenTypes,\n    balancedBracketSelectors,\n    grammarRepository,\n    onigLib\n  );\n}\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n  const matchers = createMatchers(selector, nameMatcher);\n  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n  for (const matcher of matchers) {\n    result.push({\n      debugSelector: selector,\n      matcher: matcher.matcher,\n      ruleId,\n      grammar,\n      priority: matcher.priority\n    });\n  }\n}\nfunction nameMatcher(identifers, scopes) {\n  if (scopes.length < identifers.length) {\n    return false;\n  }\n  let lastIndex = 0;\n  return identifers.every((identifier) => {\n    for (let i = lastIndex; i < scopes.length; i++) {\n      if (scopesAreMatching(scopes[i], identifier)) {\n        lastIndex = i + 1;\n        return true;\n      }\n    }\n    return false;\n  });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n  if (!thisScopeName) {\n    return false;\n  }\n  if (thisScopeName === scopeName) {\n    return true;\n  }\n  const len = scopeName.length;\n  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === \".\";\n}\nvar Grammar = class {\n  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n    this._rootScopeName = _rootScopeName;\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._onigLib = _onigLib;\n    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(\n      initialLanguage,\n      embeddedLanguages\n    );\n    this._rootId = -1;\n    this._lastRuleId = 0;\n    this._ruleId2desc = [null];\n    this._includedGrammars = {};\n    this._grammarRepository = grammarRepository;\n    this._grammar = initGrammar(grammar, null);\n    this._injections = null;\n    this._tokenTypeMatchers = [];\n    if (tokenTypes) {\n      for (const selector of Object.keys(tokenTypes)) {\n        const matchers = createMatchers(selector, nameMatcher);\n        for (const matcher of matchers) {\n          this._tokenTypeMatchers.push({\n            matcher: matcher.matcher,\n            type: tokenTypes[selector]\n          });\n        }\n      }\n    }\n  }\n  _rootId;\n  _lastRuleId;\n  _ruleId2desc;\n  _includedGrammars;\n  _grammarRepository;\n  _grammar;\n  _injections;\n  _basicScopeAttributesProvider;\n  _tokenTypeMatchers;\n  get themeProvider() {\n    return this._grammarRepository;\n  }\n  dispose() {\n    for (const rule of this._ruleId2desc) {\n      if (rule) {\n        rule.dispose();\n      }\n    }\n  }\n  createOnigScanner(sources) {\n    return this._onigLib.createOnigScanner(sources);\n  }\n  createOnigString(sources) {\n    return this._onigLib.createOnigString(sources);\n  }\n  getMetadataForScope(scope) {\n    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n  }\n  _collectInjections() {\n    const grammarRepository = {\n      lookup: (scopeName2) => {\n        if (scopeName2 === this._rootScopeName) {\n          return this._grammar;\n        }\n        return this.getExternalGrammar(scopeName2);\n      },\n      injections: (scopeName2) => {\n        return this._grammarRepository.injections(scopeName2);\n      }\n    };\n    const result = [];\n    const scopeName = this._rootScopeName;\n    const grammar = grammarRepository.lookup(scopeName);\n    if (grammar) {\n      const rawInjections = grammar.injections;\n      if (rawInjections) {\n        for (let expression in rawInjections) {\n          collectInjections(\n            result,\n            expression,\n            rawInjections[expression],\n            this,\n            grammar\n          );\n        }\n      }\n      const injectionScopeNames = this._grammarRepository.injections(scopeName);\n      if (injectionScopeNames) {\n        injectionScopeNames.forEach((injectionScopeName) => {\n          const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n          if (injectionGrammar) {\n            const selector = injectionGrammar.injectionSelector;\n            if (selector) {\n              collectInjections(\n                result,\n                selector,\n                injectionGrammar,\n                this,\n                injectionGrammar\n              );\n            }\n          }\n        });\n      }\n    }\n    result.sort((i1, i2) => i1.priority - i2.priority);\n    return result;\n  }\n  getInjections() {\n    if (this._injections === null) {\n      this._injections = this._collectInjections();\n    }\n    return this._injections;\n  }\n  registerRule(factory) {\n    const id = ++this._lastRuleId;\n    const result = factory(ruleIdFromNumber(id));\n    this._ruleId2desc[id] = result;\n    return result;\n  }\n  getRule(ruleId) {\n    return this._ruleId2desc[ruleIdToNumber(ruleId)];\n  }\n  getExternalGrammar(scopeName, repository) {\n    if (this._includedGrammars[scopeName]) {\n      return this._includedGrammars[scopeName];\n    } else if (this._grammarRepository) {\n      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n      if (rawIncludedGrammar) {\n        this._includedGrammars[scopeName] = initGrammar(\n          rawIncludedGrammar,\n          repository && repository.$base\n        );\n        return this._includedGrammars[scopeName];\n      }\n    }\n    return void 0;\n  }\n  tokenizeLine(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, false, timeLimit);\n    return {\n      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  tokenizeLine2(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, true, timeLimit);\n    return {\n      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n    if (this._rootId === -1) {\n      this._rootId = RuleFactory.getCompiledRuleId(\n        this._grammar.repository.$self,\n        this,\n        this._grammar.repository\n      );\n      this.getInjections();\n    }\n    let isFirstLine;\n    if (!prevState || prevState === StateStackImpl.NULL) {\n      isFirstLine = true;\n      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n      const defaultStyle = this.themeProvider.getDefaults();\n      const defaultMetadata = EncodedTokenMetadata.set(\n        0,\n        rawDefaultMetadata.languageId,\n        rawDefaultMetadata.tokenType,\n        null,\n        defaultStyle.fontStyle,\n        defaultStyle.foregroundId,\n        defaultStyle.backgroundId\n      );\n      const rootScopeName = this.getRule(this._rootId).getName(\n        null,\n        null\n      );\n      let scopeList;\n      if (rootScopeName) {\n        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(\n          rootScopeName,\n          defaultMetadata,\n          this\n        );\n      } else {\n        scopeList = AttributedScopeStack.createRoot(\n          \"unknown\",\n          defaultMetadata\n        );\n      }\n      prevState = new StateStackImpl(\n        null,\n        this._rootId,\n        -1,\n        -1,\n        false,\n        null,\n        scopeList,\n        scopeList\n      );\n    } else {\n      isFirstLine = false;\n      prevState.reset();\n    }\n    lineText = lineText + \"\\n\";\n    const onigLineText = this.createOnigString(lineText);\n    const lineLength = onigLineText.content.length;\n    const lineTokens = new LineTokens(\n      emitBinaryTokens,\n      lineText,\n      this._tokenTypeMatchers,\n      this.balancedBracketSelectors\n    );\n    const r = _tokenizeString(\n      this,\n      onigLineText,\n      isFirstLine,\n      0,\n      prevState,\n      lineTokens,\n      true,\n      timeLimit\n    );\n    disposeOnigString(onigLineText);\n    return {\n      lineLength,\n      lineTokens,\n      ruleStack: r.stack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n};\nfunction initGrammar(grammar, base) {\n  grammar = clone(grammar);\n  grammar.repository = grammar.repository || {};\n  grammar.repository.$self = {\n    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n    patterns: grammar.patterns,\n    name: grammar.scopeName\n  };\n  grammar.repository.$base = base || grammar.repository.$self;\n  return grammar;\n}\nvar AttributedScopeStack = class _AttributedScopeStack {\n  /**\n   * Invariant:\n   * ```\n   * if (parent && !scopePath.extends(parent.scopePath)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, scopePath, tokenAttributes) {\n    this.parent = parent;\n    this.scopePath = scopePath;\n    this.tokenAttributes = tokenAttributes;\n  }\n  static fromExtension(namesScopeList, contentNameScopesList) {\n    let current = namesScopeList;\n    let scopeNames = namesScopeList?.scopePath ?? null;\n    for (const frame of contentNameScopesList) {\n      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);\n      current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);\n    }\n    return current;\n  }\n  static createRoot(scopeName, tokenAttributes) {\n    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);\n  }\n  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n    const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n    const scopePath = new ScopeStack(null, scopeName);\n    const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n    const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(\n      tokenAttributes,\n      rawRootMetadata,\n      rootStyle\n    );\n    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n  }\n  get scopeName() {\n    return this.scopePath.scopeName;\n  }\n  toString() {\n    return this.getScopeNames().join(\" \");\n  }\n  equals(other) {\n    return _AttributedScopeStack.equals(this, other);\n  }\n  static equals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n    let fontStyle = -1 /* NotSet */;\n    let foreground = 0;\n    let background = 0;\n    if (styleAttributes !== null) {\n      fontStyle = styleAttributes.fontStyle;\n      foreground = styleAttributes.foregroundId;\n      background = styleAttributes.backgroundId;\n    }\n    return EncodedTokenMetadata.set(\n      existingTokenAttributes,\n      basicScopeAttributes.languageId,\n      basicScopeAttributes.tokenType,\n      null,\n      fontStyle,\n      foreground,\n      background\n    );\n  }\n  pushAttributed(scopePath, grammar) {\n    if (scopePath === null) {\n      return this;\n    }\n    if (scopePath.indexOf(\" \") === -1) {\n      return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n    }\n    const scopes = scopePath.split(/ /g);\n    let result = this;\n    for (const scope of scopes) {\n      result = _AttributedScopeStack._pushAttributed(result, scope, grammar);\n    }\n    return result;\n  }\n  static _pushAttributed(target, scopeName, grammar) {\n    const rawMetadata = grammar.getMetadataForScope(scopeName);\n    const newPath = target.scopePath.push(scopeName);\n    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n    const metadata = _AttributedScopeStack.mergeAttributes(\n      target.tokenAttributes,\n      rawMetadata,\n      scopeThemeMatchResult\n    );\n    return new _AttributedScopeStack(target, newPath, metadata);\n  }\n  getScopeNames() {\n    return this.scopePath.getSegments();\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let self = this;\n    while (self && self !== base) {\n      result.push({\n        encodedTokenAttributes: self.tokenAttributes,\n        scopeNames: self.scopePath.getExtensionIfDefined(self.parent?.scopePath ?? null)\n      });\n      self = self.parent;\n    }\n    return self === base ? result.reverse() : void 0;\n  }\n};\nvar StateStackImpl = class _StateStackImpl {\n  /**\n   * Invariant:\n   * ```\n   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {\n   * \tthrow new Error();\n   * }\n   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    this.parent = parent;\n    this.ruleId = ruleId;\n    this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n    this.endRule = endRule;\n    this.nameScopesList = nameScopesList;\n    this.contentNameScopesList = contentNameScopesList;\n    this.depth = this.parent ? this.parent.depth + 1 : 1;\n    this._enterPos = enterPos;\n    this._anchorPos = anchorPos;\n  }\n  _stackElementBrand = void 0;\n  // TODO remove me\n  static NULL = new _StateStackImpl(\n    null,\n    0,\n    0,\n    0,\n    false,\n    null,\n    null,\n    null\n  );\n  /**\n   * The position on the current line where this state was pushed.\n   * This is relevant only while tokenizing a line, to detect endless loops.\n   * Its value is meaningless across lines.\n   */\n  _enterPos;\n  /**\n   * The captured anchor position when this stack element was pushed.\n   * This is relevant only while tokenizing a line, to restore the anchor position when popping.\n   * Its value is meaningless across lines.\n   */\n  _anchorPos;\n  /**\n   * The depth of the stack.\n   */\n  depth;\n  equals(other) {\n    if (other === null) {\n      return false;\n    }\n    return _StateStackImpl._equals(this, other);\n  }\n  static _equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!this._structuralEquals(a, b)) {\n      return false;\n    }\n    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);\n  }\n  /**\n   * A structural equals check. Does not take into account `scopes`.\n   */\n  static _structuralEquals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  clone() {\n    return this;\n  }\n  static _reset(el) {\n    while (el) {\n      el._enterPos = -1;\n      el._anchorPos = -1;\n      el = el.parent;\n    }\n  }\n  reset() {\n    _StateStackImpl._reset(this);\n  }\n  pop() {\n    return this.parent;\n  }\n  safePop() {\n    if (this.parent) {\n      return this.parent;\n    }\n    return this;\n  }\n  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    return new _StateStackImpl(\n      this,\n      ruleId,\n      enterPos,\n      anchorPos,\n      beginRuleCapturedEOL,\n      endRule,\n      nameScopesList,\n      contentNameScopesList\n    );\n  }\n  getEnterPos() {\n    return this._enterPos;\n  }\n  getAnchorPos() {\n    return this._anchorPos;\n  }\n  getRule(grammar) {\n    return grammar.getRule(this.ruleId);\n  }\n  toString() {\n    const r = [];\n    this._writeString(r, 0);\n    return \"[\" + r.join(\",\") + \"]\";\n  }\n  _writeString(res, outIndex) {\n    if (this.parent) {\n      outIndex = this.parent._writeString(res, outIndex);\n    }\n    res[outIndex++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`;\n    return outIndex;\n  }\n  withContentNameScopesList(contentNameScopeStack) {\n    if (this.contentNameScopesList === contentNameScopeStack) {\n      return this;\n    }\n    return this.parent.push(\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      this.endRule,\n      this.nameScopesList,\n      contentNameScopeStack\n    );\n  }\n  withEndRule(endRule) {\n    if (this.endRule === endRule) {\n      return this;\n    }\n    return new _StateStackImpl(\n      this.parent,\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      endRule,\n      this.nameScopesList,\n      this.contentNameScopesList\n    );\n  }\n  // Used to warn of endless loops\n  hasSameRuleAs(other) {\n    let el = this;\n    while (el && el._enterPos === other._enterPos) {\n      if (el.ruleId === other.ruleId) {\n        return true;\n      }\n      el = el.parent;\n    }\n    return false;\n  }\n  toStateStackFrame() {\n    return {\n      ruleId: ruleIdToNumber(this.ruleId),\n      beginRuleCapturedEOL: this.beginRuleCapturedEOL,\n      endRule: this.endRule,\n      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],\n      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []\n    };\n  }\n  static pushFrame(self, frame) {\n    const namesScopeList = AttributedScopeStack.fromExtension(self?.nameScopesList ?? null, frame.nameScopesList);\n    return new _StateStackImpl(\n      self,\n      ruleIdFromNumber(frame.ruleId),\n      frame.enterPos ?? -1,\n      frame.anchorPos ?? -1,\n      frame.beginRuleCapturedEOL,\n      frame.endRule,\n      namesScopeList,\n      AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList)\n    );\n  }\n};\nvar BalancedBracketSelectors = class {\n  balancedBracketScopes;\n  unbalancedBracketScopes;\n  allowAny = false;\n  constructor(balancedBracketScopes, unbalancedBracketScopes) {\n    this.balancedBracketScopes = balancedBracketScopes.flatMap(\n      (selector) => {\n        if (selector === \"*\") {\n          this.allowAny = true;\n          return [];\n        }\n        return createMatchers(selector, nameMatcher).map((m) => m.matcher);\n      }\n    );\n    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap(\n      (selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher)\n    );\n  }\n  get matchesAlways() {\n    return this.allowAny && this.unbalancedBracketScopes.length === 0;\n  }\n  get matchesNever() {\n    return this.balancedBracketScopes.length === 0 && !this.allowAny;\n  }\n  match(scopes) {\n    for (const excluder of this.unbalancedBracketScopes) {\n      if (excluder(scopes)) {\n        return false;\n      }\n    }\n    for (const includer of this.balancedBracketScopes) {\n      if (includer(scopes)) {\n        return true;\n      }\n    }\n    return this.allowAny;\n  }\n};\nvar LineTokens = class {\n  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._emitBinaryTokens = emitBinaryTokens;\n    this._tokenTypeOverrides = tokenTypeOverrides;\n    if (false) {\n      this._lineText = lineText;\n    } else {\n      this._lineText = null;\n    }\n    this._tokens = [];\n    this._binaryTokens = [];\n    this._lastTokenEndIndex = 0;\n  }\n  _emitBinaryTokens;\n  /**\n   * defined only if `false`.\n   */\n  _lineText;\n  /**\n   * used only if `_emitBinaryTokens` is false.\n   */\n  _tokens;\n  /**\n   * used only if `_emitBinaryTokens` is true.\n   */\n  _binaryTokens;\n  _lastTokenEndIndex;\n  _tokenTypeOverrides;\n  produce(stack, endIndex) {\n    this.produceFromScopes(stack.contentNameScopesList, endIndex);\n  }\n  produceFromScopes(scopesList, endIndex) {\n    if (this._lastTokenEndIndex >= endIndex) {\n      return;\n    }\n    if (this._emitBinaryTokens) {\n      let metadata = scopesList?.tokenAttributes ?? 0;\n      let containsBalancedBrackets = false;\n      if (this.balancedBracketSelectors?.matchesAlways) {\n        containsBalancedBrackets = true;\n      }\n      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {\n        const scopes2 = scopesList?.getScopeNames() ?? [];\n        for (const tokenType of this._tokenTypeOverrides) {\n          if (tokenType.matcher(scopes2)) {\n            metadata = EncodedTokenMetadata.set(\n              metadata,\n              0,\n              toOptionalTokenType(tokenType.type),\n              null,\n              -1 /* NotSet */,\n              0,\n              0\n            );\n          }\n        }\n        if (this.balancedBracketSelectors) {\n          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);\n        }\n      }\n      if (containsBalancedBrackets) {\n        metadata = EncodedTokenMetadata.set(\n          metadata,\n          0,\n          8 /* NotSet */,\n          containsBalancedBrackets,\n          -1 /* NotSet */,\n          0,\n          0\n        );\n      }\n      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n        this._lastTokenEndIndex = endIndex;\n        return;\n      }\n      this._binaryTokens.push(this._lastTokenEndIndex);\n      this._binaryTokens.push(metadata);\n      this._lastTokenEndIndex = endIndex;\n      return;\n    }\n    const scopes = scopesList?.getScopeNames() ?? [];\n    this._tokens.push({\n      startIndex: this._lastTokenEndIndex,\n      endIndex,\n      // value: lineText.substring(lastTokenEndIndex, endIndex),\n      scopes\n    });\n    this._lastTokenEndIndex = endIndex;\n  }\n  getResult(stack, lineLength) {\n    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n      this._tokens.pop();\n    }\n    if (this._tokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._tokens[this._tokens.length - 1].startIndex = 0;\n    }\n    return this._tokens;\n  }\n  getBinaryResult(stack, lineLength) {\n    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n      this._binaryTokens.pop();\n      this._binaryTokens.pop();\n    }\n    if (this._binaryTokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._binaryTokens[this._binaryTokens.length - 2] = 0;\n    }\n    const result = new Uint32Array(this._binaryTokens.length);\n    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n      result[i] = this._binaryTokens[i];\n    }\n    return result;\n  }\n};\n\n// src/registry.ts\nvar SyncRegistry = class {\n  constructor(theme, _onigLib) {\n    this._onigLib = _onigLib;\n    this._theme = theme;\n  }\n  _grammars = /* @__PURE__ */ new Map();\n  _rawGrammars = /* @__PURE__ */ new Map();\n  _injectionGrammars = /* @__PURE__ */ new Map();\n  _theme;\n  dispose() {\n    for (const grammar of this._grammars.values()) {\n      grammar.dispose();\n    }\n  }\n  setTheme(theme) {\n    this._theme = theme;\n  }\n  getColorMap() {\n    return this._theme.getColorMap();\n  }\n  /**\n   * Add `grammar` to registry and return a list of referenced scope names\n   */\n  addGrammar(grammar, injectionScopeNames) {\n    this._rawGrammars.set(grammar.scopeName, grammar);\n    if (injectionScopeNames) {\n      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n    }\n  }\n  /**\n   * Lookup a raw grammar.\n   */\n  lookup(scopeName) {\n    return this._rawGrammars.get(scopeName);\n  }\n  /**\n   * Returns the injections for the given grammar\n   */\n  injections(targetScope) {\n    return this._injectionGrammars.get(targetScope);\n  }\n  /**\n   * Get the default theme settings\n   */\n  getDefaults() {\n    return this._theme.getDefaults();\n  }\n  /**\n   * Match a scope in the theme.\n   */\n  themeMatch(scopePath) {\n    return this._theme.match(scopePath);\n  }\n  /**\n   * Lookup a grammar.\n   */\n  grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    if (!this._grammars.has(scopeName)) {\n      let rawGrammar = this._rawGrammars.get(scopeName);\n      if (!rawGrammar) {\n        return null;\n      }\n      this._grammars.set(scopeName, createGrammar(\n        scopeName,\n        rawGrammar,\n        initialLanguage,\n        embeddedLanguages,\n        tokenTypes,\n        balancedBracketSelectors,\n        this,\n        this._onigLib\n      ));\n    }\n    return this._grammars.get(scopeName);\n  }\n};\n\n// src/index.ts\nvar Registry = class {\n  _options;\n  _syncRegistry;\n  _ensureGrammarCache;\n  constructor(options) {\n    this._options = options;\n    this._syncRegistry = new SyncRegistry(\n      Theme.createFromRawTheme(options.theme, options.colorMap),\n      options.onigLib\n    );\n    this._ensureGrammarCache = /* @__PURE__ */ new Map();\n  }\n  dispose() {\n    this._syncRegistry.dispose();\n  }\n  /**\n   * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n   */\n  setTheme(theme, colorMap) {\n    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));\n  }\n  /**\n   * Returns a lookup array for color ids.\n   */\n  getColorMap() {\n    return this._syncRegistry.getColorMap();\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n    return this._loadGrammar(\n      initialScopeName,\n      initialLanguage,\n      configuration.embeddedLanguages,\n      configuration.tokenTypes,\n      new BalancedBracketSelectors(\n        configuration.balancedBracketSelectors || [],\n        configuration.unbalancedBracketSelectors || []\n      )\n    );\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   */\n  loadGrammar(initialScopeName) {\n    return this._loadGrammar(initialScopeName, 0, null, null, null);\n  }\n  _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n    while (dependencyProcessor.Q.length > 0) {\n      dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName));\n      dependencyProcessor.processQueue();\n    }\n    return this._grammarForScopeName(\n      initialScopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n  _loadSingleGrammar(scopeName) {\n    if (!this._ensureGrammarCache.has(scopeName)) {\n      this._doLoadSingleGrammar(scopeName);\n      this._ensureGrammarCache.set(scopeName, true);\n    }\n  }\n  _doLoadSingleGrammar(scopeName) {\n    const grammar = this._options.loadGrammar(scopeName);\n    if (grammar) {\n      const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : void 0;\n      this._syncRegistry.addGrammar(grammar, injections);\n    }\n  }\n  /**\n   * Adds a rawGrammar.\n   */\n  addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n    this._syncRegistry.addGrammar(rawGrammar, injections);\n    return this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);\n  }\n  /**\n   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n   */\n  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n    return this._syncRegistry.grammarForScopeName(\n      scopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n};\nvar INITIAL = StateStackImpl.NULL;\nexport {\n  EncodedTokenMetadata,\n  FindOption,\n  FontStyle,\n  INITIAL,\n  Registry,\n  Theme,\n  disposeOnigString\n};\n","import { ShikiError as ShikiError$1 } from '@shikijs/types';\nexport * from '@shikijs/types';\nimport { FontStyle, INITIAL, EncodedTokenMetadata, Registry as Registry$1, Theme } from '@shikijs/vscode-textmate';\nimport { toHtml } from 'hast-util-to-html';\n\nfunction resolveColorReplacements(theme, options) {\n  const replacements = typeof theme === \"string\" ? {} : { ...theme.colorReplacements };\n  const themeName = typeof theme === \"string\" ? theme : theme.name;\n  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {\n    if (typeof value === \"string\")\n      replacements[key] = value;\n    else if (key === themeName)\n      Object.assign(replacements, value);\n  }\n  return replacements;\n}\nfunction applyColorReplacements(color, replacements) {\n  if (!color)\n    return color;\n  return replacements?.[color?.toLowerCase()] || color;\n}\n\nfunction toArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\nasync function normalizeGetter(p) {\n  return Promise.resolve(typeof p === \"function\" ? p() : p).then((r) => r.default || r);\n}\nfunction isPlainLang(lang) {\n  return !lang || [\"plaintext\", \"txt\", \"text\", \"plain\"].includes(lang);\n}\nfunction isSpecialLang(lang) {\n  return lang === \"ansi\" || isPlainLang(lang);\n}\nfunction isNoneTheme(theme) {\n  return theme === \"none\";\n}\nfunction isSpecialTheme(theme) {\n  return isNoneTheme(theme);\n}\n\nfunction addClassToHast(node, className) {\n  if (!className)\n    return node;\n  node.properties ||= {};\n  node.properties.class ||= [];\n  if (typeof node.properties.class === \"string\")\n    node.properties.class = node.properties.class.split(/\\s+/g);\n  if (!Array.isArray(node.properties.class))\n    node.properties.class = [];\n  const targets = Array.isArray(className) ? className : className.split(/\\s+/g);\n  for (const c of targets) {\n    if (c && !node.properties.class.includes(c))\n      node.properties.class.push(c);\n  }\n  return node;\n}\n\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    if (index === code.length) {\n      return {\n        line: lines.length - 1,\n        character: lines[lines.length - 1].length\n      };\n    }\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\nfunction guessEmbeddedLanguages(code, _lang, highlighter) {\n  const langs = /* @__PURE__ */ new Set();\n  for (const match of code.matchAll(/lang=[\"']([\\w-]+)[\"']/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/(?:```|~~~)([\\w-]+)/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/\\\\begin\\{([\\w-]+)\\}/g)) {\n    langs.add(match[1]);\n  }\n  if (!highlighter)\n    return Array.from(langs);\n  const bundle = highlighter.getBundledLanguages();\n  return Array.from(langs).filter((l) => l && bundle[l]);\n}\n\nconst DEFAULT_COLOR_LIGHT_DARK = \"light-dark()\";\nconst COLOR_KEYS = [\"color\", \"background-color\"];\n\nfunction splitToken(token, offsets) {\n  let lastOffset = 0;\n  const tokens = [];\n  for (const offset of offsets) {\n    if (offset > lastOffset) {\n      tokens.push({\n        ...token,\n        content: token.content.slice(lastOffset, offset),\n        offset: token.offset + lastOffset\n      });\n    }\n    lastOffset = offset;\n  }\n  if (lastOffset < token.content.length) {\n    tokens.push({\n      ...token,\n      content: token.content.slice(lastOffset),\n      offset: token.offset + lastOffset\n    });\n  }\n  return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);\n  if (!sorted.length)\n    return tokens;\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);\n      if (!breakpointsInToken.length)\n        return token;\n      return splitToken(token, breakpointsInToken);\n    });\n  });\n}\nfunction flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor, colorsRendering = \"css-vars\") {\n  const token = {\n    content: merged.content,\n    explanation: merged.explanation,\n    offset: merged.offset\n  };\n  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));\n  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));\n  const mergedStyles = {};\n  const varKey = (idx, key) => {\n    const keyName = key === \"color\" ? \"\" : key === \"background-color\" ? \"-bg\" : `-${key}`;\n    return cssVariablePrefix + variantsOrder[idx] + (key === \"color\" ? \"\" : keyName);\n  };\n  styles.forEach((cur, idx) => {\n    for (const key of styleKeys) {\n      const value = cur[key] || \"inherit\";\n      if (idx === 0 && defaultColor && COLOR_KEYS.includes(key)) {\n        if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && styles.length > 1) {\n          const lightIndex = variantsOrder.findIndex((t) => t === \"light\");\n          const darkIndex = variantsOrder.findIndex((t) => t === \"dark\");\n          if (lightIndex === -1 || darkIndex === -1)\n            throw new ShikiError$1('When using `defaultColor: \"light-dark()\"`, you must provide both `light` and `dark` themes');\n          const lightValue = styles[lightIndex][key] || \"inherit\";\n          const darkValue = styles[darkIndex][key] || \"inherit\";\n          mergedStyles[key] = `light-dark(${lightValue}, ${darkValue})`;\n          if (colorsRendering === \"css-vars\")\n            mergedStyles[varKey(idx, key)] = value;\n        } else {\n          mergedStyles[key] = value;\n        }\n      } else {\n        if (colorsRendering === \"css-vars\")\n          mergedStyles[varKey(idx, key)] = value;\n      }\n    }\n  });\n  token.htmlStyle = mergedStyles;\n  return token;\n}\nfunction getTokenStyleObject(token) {\n  const styles = {};\n  if (token.color)\n    styles.color = token.color;\n  if (token.bgColor)\n    styles[\"background-color\"] = token.bgColor;\n  if (token.fontStyle) {\n    if (token.fontStyle & FontStyle.Italic)\n      styles[\"font-style\"] = \"italic\";\n    if (token.fontStyle & FontStyle.Bold)\n      styles[\"font-weight\"] = \"bold\";\n    const decorations = [];\n    if (token.fontStyle & FontStyle.Underline)\n      decorations.push(\"underline\");\n    if (token.fontStyle & FontStyle.Strikethrough)\n      decorations.push(\"line-through\");\n    if (decorations.length)\n      styles[\"text-decoration\"] = decorations.join(\" \");\n  }\n  return styles;\n}\nfunction stringifyTokenStyle(token) {\n  if (typeof token === \"string\")\n    return token;\n  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(\";\");\n}\n\nconst _grammarStateMap = /* @__PURE__ */ new WeakMap();\nfunction setLastGrammarStateToMap(keys, state) {\n  _grammarStateMap.set(keys, state);\n}\nfunction getLastGrammarStateFromMap(keys) {\n  return _grammarStateMap.get(keys);\n}\nclass GrammarState {\n  /**\n   * Theme to Stack mapping\n   */\n  _stacks = {};\n  lang;\n  get themes() {\n    return Object.keys(this._stacks);\n  }\n  get theme() {\n    return this.themes[0];\n  }\n  get _stack() {\n    return this._stacks[this.theme];\n  }\n  /**\n   * Static method to create a initial grammar state.\n   */\n  static initial(lang, themes) {\n    return new GrammarState(\n      Object.fromEntries(toArray(themes).map((theme) => [theme, INITIAL])),\n      lang\n    );\n  }\n  constructor(...args) {\n    if (args.length === 2) {\n      const [stacksMap, lang] = args;\n      this.lang = lang;\n      this._stacks = stacksMap;\n    } else {\n      const [stack, lang, theme] = args;\n      this.lang = lang;\n      this._stacks = { [theme]: stack };\n    }\n  }\n  /**\n   * Get the internal stack object.\n   * @internal\n   */\n  getInternalStack(theme = this.theme) {\n    return this._stacks[theme];\n  }\n  getScopes(theme = this.theme) {\n    return getScopes(this._stacks[theme]);\n  }\n  toJSON() {\n    return {\n      lang: this.lang,\n      theme: this.theme,\n      themes: this.themes,\n      scopes: this.getScopes()\n    };\n  }\n}\nfunction getScopes(stack) {\n  const scopes = [];\n  const visited = /* @__PURE__ */ new Set();\n  function pushScope(stack2) {\n    if (visited.has(stack2))\n      return;\n    visited.add(stack2);\n    const name = stack2?.nameScopesList?.scopeName;\n    if (name)\n      scopes.push(name);\n    if (stack2.parent)\n      pushScope(stack2.parent);\n  }\n  pushScope(stack);\n  return scopes;\n}\nfunction getGrammarStack(state, theme) {\n  if (!(state instanceof GrammarState))\n    throw new ShikiError$1(\"Invalid grammar state\");\n  return state.getInternalStack(theme);\n}\n\nfunction transformerDecorations() {\n  const map = /* @__PURE__ */ new WeakMap();\n  function getContext(shiki) {\n    if (!map.has(shiki.meta)) {\n      let normalizePosition = function(p) {\n        if (typeof p === \"number\") {\n          if (p < 0 || p > shiki.source.length)\n            throw new ShikiError$1(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);\n          return {\n            ...converter.indexToPos(p),\n            offset: p\n          };\n        } else {\n          const line = converter.lines[p.line];\n          if (line === void 0)\n            throw new ShikiError$1(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);\n          let character = p.character;\n          if (character < 0)\n            character = line.length + character;\n          if (character < 0 || character > line.length)\n            throw new ShikiError$1(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);\n          return {\n            ...p,\n            character,\n            offset: converter.posToIndex(p.line, character)\n          };\n        }\n      };\n      const converter = createPositionConverter(shiki.source);\n      const decorations = (shiki.options.decorations || []).map((d) => ({\n        ...d,\n        start: normalizePosition(d.start),\n        end: normalizePosition(d.end)\n      }));\n      verifyIntersections(decorations);\n      map.set(shiki.meta, {\n        decorations,\n        converter,\n        source: shiki.source\n      });\n    }\n    return map.get(shiki.meta);\n  }\n  return {\n    name: \"shiki:decorations\",\n    tokens(tokens) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);\n      const splitted = splitTokens(tokens, breakpoints);\n      return splitted;\n    },\n    code(codeEl) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const lines = Array.from(codeEl.children).filter((i) => i.type === \"element\" && i.tagName === \"span\");\n      if (lines.length !== ctx.converter.lines.length)\n        throw new ShikiError$1(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);\n      function applyLineSection(line, start, end, decoration) {\n        const lineEl = lines[line];\n        let text = \"\";\n        let startIndex = -1;\n        let endIndex = -1;\n        if (start === 0)\n          startIndex = 0;\n        if (end === 0)\n          endIndex = 0;\n        if (end === Number.POSITIVE_INFINITY)\n          endIndex = lineEl.children.length;\n        if (startIndex === -1 || endIndex === -1) {\n          for (let i = 0; i < lineEl.children.length; i++) {\n            text += stringify(lineEl.children[i]);\n            if (startIndex === -1 && text.length === start)\n              startIndex = i + 1;\n            if (endIndex === -1 && text.length === end)\n              endIndex = i + 1;\n          }\n        }\n        if (startIndex === -1)\n          throw new ShikiError$1(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);\n        if (endIndex === -1)\n          throw new ShikiError$1(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);\n        const children = lineEl.children.slice(startIndex, endIndex);\n        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {\n          applyDecoration(lineEl, decoration, \"line\");\n        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === \"element\") {\n          applyDecoration(children[0], decoration, \"token\");\n        } else {\n          const wrapper = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {},\n            children\n          };\n          applyDecoration(wrapper, decoration, \"wrapper\");\n          lineEl.children.splice(startIndex, children.length, wrapper);\n        }\n      }\n      function applyLine(line, decoration) {\n        lines[line] = applyDecoration(lines[line], decoration, \"line\");\n      }\n      function applyDecoration(el, decoration, type) {\n        const properties = decoration.properties || {};\n        const transform = decoration.transform || ((i) => i);\n        el.tagName = decoration.tagName || \"span\";\n        el.properties = {\n          ...el.properties,\n          ...properties,\n          class: el.properties.class\n        };\n        if (decoration.properties?.class)\n          addClassToHast(el, decoration.properties.class);\n        el = transform(el, type) || el;\n        return el;\n      }\n      const lineApplies = [];\n      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset || a.end.offset - b.end.offset);\n      for (const decoration of sorted) {\n        const { start, end } = decoration;\n        if (start.line === end.line) {\n          applyLineSection(start.line, start.character, end.character, decoration);\n        } else if (start.line < end.line) {\n          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);\n          for (let i = start.line + 1; i < end.line; i++)\n            lineApplies.unshift(() => applyLine(i, decoration));\n          applyLineSection(end.line, 0, end.character, decoration);\n        }\n      }\n      lineApplies.forEach((i) => i());\n    }\n  };\n}\nfunction verifyIntersections(items) {\n  for (let i = 0; i < items.length; i++) {\n    const foo = items[i];\n    if (foo.start.offset > foo.end.offset)\n      throw new ShikiError$1(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);\n    for (let j = i + 1; j < items.length; j++) {\n      const bar = items[j];\n      const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;\n      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;\n      const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;\n      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;\n      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {\n        if (isFooHasBarStart && isFooHasBarEnd)\n          continue;\n        if (isBarHasFooStart && isBarHasFooEnd)\n          continue;\n        if (isBarHasFooStart && foo.start.offset === foo.end.offset)\n          continue;\n        if (isFooHasBarEnd && bar.start.offset === bar.end.offset)\n          continue;\n        throw new ShikiError$1(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);\n      }\n    }\n  }\n}\nfunction stringify(el) {\n  if (el.type === \"text\")\n    return el.value;\n  if (el.type === \"element\")\n    return el.children.map(stringify).join(\"\");\n  return \"\";\n}\n\nconst builtInTransformers = [\n  /* @__PURE__ */ transformerDecorations()\n];\nfunction getTransformers(options) {\n  const transformers = sortTransformersByEnforcement(options.transformers || []);\n  return [\n    ...transformers.pre,\n    ...transformers.normal,\n    ...transformers.post,\n    ...builtInTransformers\n  ];\n}\nfunction sortTransformersByEnforcement(transformers) {\n  const pre = [];\n  const post = [];\n  const normal = [];\n  for (const transformer of transformers) {\n    switch (transformer.enforce) {\n      case \"pre\":\n        pre.push(transformer);\n        break;\n      case \"post\":\n        post.push(transformer);\n        break;\n      default:\n        normal.push(transformer);\n    }\n  }\n  return { pre, post, normal };\n}\n\n// src/colors.ts\nvar namedColors = [\n  \"black\",\n  \"red\",\n  \"green\",\n  \"yellow\",\n  \"blue\",\n  \"magenta\",\n  \"cyan\",\n  \"white\",\n  \"brightBlack\",\n  \"brightRed\",\n  \"brightGreen\",\n  \"brightYellow\",\n  \"brightBlue\",\n  \"brightMagenta\",\n  \"brightCyan\",\n  \"brightWhite\"\n];\n\n// src/decorations.ts\nvar decorations = {\n  1: \"bold\",\n  2: \"dim\",\n  3: \"italic\",\n  4: \"underline\",\n  7: \"reverse\",\n  8: \"hidden\",\n  9: \"strikethrough\"\n};\n\n// src/parser.ts\nfunction findSequence(value, position) {\n  const nextEscape = value.indexOf(\"\\x1B\", position);\n  if (nextEscape !== -1) {\n    if (value[nextEscape + 1] === \"[\") {\n      const nextClose = value.indexOf(\"m\", nextEscape);\n      if (nextClose !== -1) {\n        return {\n          sequence: value.substring(nextEscape + 2, nextClose).split(\";\"),\n          startPosition: nextEscape,\n          position: nextClose + 1\n        };\n      }\n    }\n  }\n  return {\n    position: value.length\n  };\n}\nfunction parseColor(sequence) {\n  const colorMode = sequence.shift();\n  if (colorMode === \"2\") {\n    const rgb = sequence.splice(0, 3).map((x) => Number.parseInt(x));\n    if (rgb.length !== 3 || rgb.some((x) => Number.isNaN(x)))\n      return;\n    return {\n      type: \"rgb\",\n      rgb\n    };\n  } else if (colorMode === \"5\") {\n    const index = sequence.shift();\n    if (index) {\n      return { type: \"table\", index: Number(index) };\n    }\n  }\n}\nfunction parseSequence(sequence) {\n  const commands = [];\n  while (sequence.length > 0) {\n    const code = sequence.shift();\n    if (!code)\n      continue;\n    const codeInt = Number.parseInt(code);\n    if (Number.isNaN(codeInt))\n      continue;\n    if (codeInt === 0) {\n      commands.push({ type: \"resetAll\" });\n    } else if (codeInt <= 9) {\n      const decoration = decorations[codeInt];\n      if (decoration) {\n        commands.push({\n          type: \"setDecoration\",\n          value: decorations[codeInt]\n        });\n      }\n    } else if (codeInt <= 29) {\n      const decoration = decorations[codeInt - 20];\n      if (decoration) {\n        commands.push({\n          type: \"resetDecoration\",\n          value: decoration\n        });\n        if (decoration === \"dim\") {\n          commands.push({\n            type: \"resetDecoration\",\n            value: \"bold\"\n          });\n        }\n      }\n    } else if (codeInt <= 37) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 30] }\n      });\n    } else if (codeInt === 38) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setForegroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 39) {\n      commands.push({\n        type: \"resetForegroundColor\"\n      });\n    } else if (codeInt <= 47) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 40] }\n      });\n    } else if (codeInt === 48) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setBackgroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 49) {\n      commands.push({\n        type: \"resetBackgroundColor\"\n      });\n    } else if (codeInt === 53) {\n      commands.push({\n        type: \"setDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt === 55) {\n      commands.push({\n        type: \"resetDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt >= 90 && codeInt <= 97) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 90 + 8] }\n      });\n    } else if (codeInt >= 100 && codeInt <= 107) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 100 + 8] }\n      });\n    }\n  }\n  return commands;\n}\nfunction createAnsiSequenceParser() {\n  let foreground = null;\n  let background = null;\n  let decorations2 = /* @__PURE__ */ new Set();\n  return {\n    parse(value) {\n      const tokens = [];\n      let position = 0;\n      do {\n        const findResult = findSequence(value, position);\n        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);\n        if (text.length > 0) {\n          tokens.push({\n            value: text,\n            foreground,\n            background,\n            decorations: new Set(decorations2)\n          });\n        }\n        if (findResult.sequence) {\n          const commands = parseSequence(findResult.sequence);\n          for (const styleToken of commands) {\n            if (styleToken.type === \"resetAll\") {\n              foreground = null;\n              background = null;\n              decorations2.clear();\n            } else if (styleToken.type === \"resetForegroundColor\") {\n              foreground = null;\n            } else if (styleToken.type === \"resetBackgroundColor\") {\n              background = null;\n            } else if (styleToken.type === \"resetDecoration\") {\n              decorations2.delete(styleToken.value);\n            }\n          }\n          for (const styleToken of commands) {\n            if (styleToken.type === \"setForegroundColor\") {\n              foreground = styleToken.value;\n            } else if (styleToken.type === \"setBackgroundColor\") {\n              background = styleToken.value;\n            } else if (styleToken.type === \"setDecoration\") {\n              decorations2.add(styleToken.value);\n            }\n          }\n        }\n        position = findResult.position;\n      } while (position < value.length);\n      return tokens;\n    }\n  };\n}\n\n// src/palette.ts\nvar defaultNamedColorsMap = {\n  black: \"#000000\",\n  red: \"#bb0000\",\n  green: \"#00bb00\",\n  yellow: \"#bbbb00\",\n  blue: \"#0000bb\",\n  magenta: \"#ff00ff\",\n  cyan: \"#00bbbb\",\n  white: \"#eeeeee\",\n  brightBlack: \"#555555\",\n  brightRed: \"#ff5555\",\n  brightGreen: \"#00ff00\",\n  brightYellow: \"#ffff55\",\n  brightBlue: \"#5555ff\",\n  brightMagenta: \"#ff55ff\",\n  brightCyan: \"#55ffff\",\n  brightWhite: \"#ffffff\"\n};\nfunction createColorPalette(namedColorsMap = defaultNamedColorsMap) {\n  function namedColor(name) {\n    return namedColorsMap[name];\n  }\n  function rgbColor(rgb) {\n    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, \"0\")).join(\"\")}`;\n  }\n  let colorTable;\n  function getColorTable() {\n    if (colorTable) {\n      return colorTable;\n    }\n    colorTable = [];\n    for (let i = 0; i < namedColors.length; i++) {\n      colorTable.push(namedColor(namedColors[i]));\n    }\n    let levels = [0, 95, 135, 175, 215, 255];\n    for (let r = 0; r < 6; r++) {\n      for (let g = 0; g < 6; g++) {\n        for (let b = 0; b < 6; b++) {\n          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));\n        }\n      }\n    }\n    let level = 8;\n    for (let i = 0; i < 24; i++, level += 10) {\n      colorTable.push(rgbColor([level, level, level]));\n    }\n    return colorTable;\n  }\n  function tableColor(index) {\n    return getColorTable()[index];\n  }\n  function value(color) {\n    switch (color.type) {\n      case \"named\":\n        return namedColor(color.name);\n      case \"rgb\":\n        return rgbColor(color.rgb);\n      case \"table\":\n        return tableColor(color.index);\n    }\n  }\n  return {\n    value\n  };\n}\n\nfunction tokenizeAnsiWithTheme(theme, fileContents, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const lines = splitLines(fileContents);\n  const colorPalette = createColorPalette(\n    Object.fromEntries(\n      namedColors.map((name) => [\n        name,\n        theme.colors?.[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]\n      ])\n    )\n  );\n  const parser = createAnsiSequenceParser();\n  return lines.map(\n    (line) => parser.parse(line[0]).map((token) => {\n      let color;\n      let bgColor;\n      if (token.decorations.has(\"reverse\")) {\n        color = token.background ? colorPalette.value(token.background) : theme.bg;\n        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n      } else {\n        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n        bgColor = token.background ? colorPalette.value(token.background) : void 0;\n      }\n      color = applyColorReplacements(color, colorReplacements);\n      bgColor = applyColorReplacements(bgColor, colorReplacements);\n      if (token.decorations.has(\"dim\"))\n        color = dimColor(color);\n      let fontStyle = FontStyle.None;\n      if (token.decorations.has(\"bold\"))\n        fontStyle |= FontStyle.Bold;\n      if (token.decorations.has(\"italic\"))\n        fontStyle |= FontStyle.Italic;\n      if (token.decorations.has(\"underline\"))\n        fontStyle |= FontStyle.Underline;\n      if (token.decorations.has(\"strikethrough\"))\n        fontStyle |= FontStyle.Strikethrough;\n      return {\n        content: token.value,\n        offset: line[1],\n        // TODO: more accurate offset? might need to fork ansi-sequence-parser\n        color,\n        bgColor,\n        fontStyle\n      };\n    })\n  );\n}\nfunction dimColor(color) {\n  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);\n  if (hexMatch) {\n    if (hexMatch[3]) {\n      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, \"0\");\n      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;\n    } else if (hexMatch[2]) {\n      return `#${hexMatch[1]}${hexMatch[2]}80`;\n    } else {\n      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join(\"\")}80`;\n    }\n  }\n  const cssVarMatch = color.match(/var\\((--[\\w-]+-ansi-[\\w-]+)\\)/);\n  if (cssVarMatch)\n    return `var(${cssVarMatch[1]}-dim)`;\n  return color;\n}\n\nfunction codeToTokensBase(internal, code, options = {}) {\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);\n  const { theme, colorMap } = internal.setTheme(themeName);\n  if (lang === \"ansi\")\n    return tokenizeAnsiWithTheme(theme, code, options);\n  const _grammar = internal.getLanguage(lang);\n  if (options.grammarState) {\n    if (options.grammarState.lang !== _grammar.name) {\n      throw new ShikiError$1(`Grammar state language \"${options.grammarState.lang}\" does not match highlight language \"${_grammar.name}\"`);\n    }\n    if (!options.grammarState.themes.includes(theme.name)) {\n      throw new ShikiError$1(`Grammar state themes \"${options.grammarState.themes}\" do not contain highlight theme \"${theme.name}\"`);\n    }\n  }\n  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);\n}\nfunction getLastGrammarState(...args) {\n  if (args.length === 2) {\n    return getLastGrammarStateFromMap(args[1]);\n  }\n  const [internal, code, options = {}] = args;\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    throw new ShikiError$1(\"Plain language does not have grammar state\");\n  if (lang === \"ansi\")\n    throw new ShikiError$1(\"ANSI language does not have grammar state\");\n  const { theme, colorMap } = internal.setTheme(themeName);\n  const _grammar = internal.getLanguage(lang);\n  return new GrammarState(\n    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,\n    _grammar.name,\n    theme.name\n  );\n}\nfunction tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);\n  const grammarState = new GrammarState(\n    _tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack,\n    grammar.name,\n    theme.name\n  );\n  setLastGrammarStateToMap(result.tokens, grammarState);\n  return result.tokens;\n}\nfunction _tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const {\n    tokenizeMaxLineLength = 0,\n    tokenizeTimeLimit = 500\n  } = options;\n  const lines = splitLines(code);\n  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(\n    options.grammarContextCode,\n    grammar,\n    theme,\n    colorMap,\n    {\n      ...options,\n      grammarState: void 0,\n      grammarContextCode: void 0\n    }\n  ).stateStack : INITIAL;\n  let actual = [];\n  const final = [];\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const [line, lineOffset] = lines[i];\n    if (line === \"\") {\n      actual = [];\n      final.push([]);\n      continue;\n    }\n    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {\n      actual = [];\n      final.push([{\n        content: line,\n        offset: lineOffset,\n        color: \"\",\n        fontStyle: 0\n      }]);\n      continue;\n    }\n    let resultWithScopes;\n    let tokensWithScopes;\n    let tokensWithScopesIndex;\n    if (options.includeExplanation) {\n      resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);\n      tokensWithScopes = resultWithScopes.tokens;\n      tokensWithScopesIndex = 0;\n    }\n    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);\n    const tokensLength = result.tokens.length / 2;\n    for (let j = 0; j < tokensLength; j++) {\n      const startIndex = result.tokens[2 * j];\n      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n      if (startIndex === nextStartIndex)\n        continue;\n      const metadata = result.tokens[2 * j + 1];\n      const color = applyColorReplacements(\n        colorMap[EncodedTokenMetadata.getForeground(metadata)],\n        colorReplacements\n      );\n      const fontStyle = EncodedTokenMetadata.getFontStyle(metadata);\n      const token = {\n        content: line.substring(startIndex, nextStartIndex),\n        offset: lineOffset + startIndex,\n        color,\n        fontStyle\n      };\n      if (options.includeExplanation) {\n        const themeSettingsSelectors = [];\n        if (options.includeExplanation !== \"scopeName\") {\n          for (const setting of theme.settings) {\n            let selectors;\n            switch (typeof setting.scope) {\n              case \"string\":\n                selectors = setting.scope.split(/,/).map((scope) => scope.trim());\n                break;\n              case \"object\":\n                selectors = setting.scope;\n                break;\n              default:\n                continue;\n            }\n            themeSettingsSelectors.push({\n              settings: setting,\n              selectors: selectors.map((selector) => selector.split(/ /))\n            });\n          }\n        }\n        token.explanation = [];\n        let offset = 0;\n        while (startIndex + offset < nextStartIndex) {\n          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];\n          const tokenWithScopesText = line.substring(\n            tokenWithScopes.startIndex,\n            tokenWithScopes.endIndex\n          );\n          offset += tokenWithScopesText.length;\n          token.explanation.push({\n            content: tokenWithScopesText,\n            scopes: options.includeExplanation === \"scopeName\" ? explainThemeScopesNameOnly(\n              tokenWithScopes.scopes\n            ) : explainThemeScopesFull(\n              themeSettingsSelectors,\n              tokenWithScopes.scopes\n            )\n          });\n          tokensWithScopesIndex += 1;\n        }\n      }\n      actual.push(token);\n    }\n    final.push(actual);\n    actual = [];\n    stateStack = result.ruleStack;\n  }\n  return {\n    tokens: final,\n    stateStack\n  };\n}\nfunction explainThemeScopesNameOnly(scopes) {\n  return scopes.map((scope) => ({ scopeName: scope }));\n}\nfunction explainThemeScopesFull(themeSelectors, scopes) {\n  const result = [];\n  for (let i = 0, len = scopes.length; i < len; i++) {\n    const scope = scopes[i];\n    result[i] = {\n      scopeName: scope,\n      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))\n    };\n  }\n  return result;\n}\nfunction matchesOne(selector, scope) {\n  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === \".\";\n}\nfunction matches(selectors, scope, parentScopes) {\n  if (!matchesOne(selectors[selectors.length - 1], scope))\n    return false;\n  let selectorParentIndex = selectors.length - 2;\n  let parentIndex = parentScopes.length - 1;\n  while (selectorParentIndex >= 0 && parentIndex >= 0) {\n    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))\n      selectorParentIndex -= 1;\n    parentIndex -= 1;\n  }\n  if (selectorParentIndex === -1)\n    return true;\n  return false;\n}\nfunction explainThemeScope(themeSettingsSelectors, scope, parentScopes) {\n  const result = [];\n  for (const { selectors, settings } of themeSettingsSelectors) {\n    for (const selectorPieces of selectors) {\n      if (matches(selectorPieces, scope, parentScopes)) {\n        result.push(settings);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfunction codeToTokensWithThemes(internal, code, options) {\n  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));\n  const themedTokens = themes.map((t) => {\n    const tokens2 = codeToTokensBase(internal, code, {\n      ...options,\n      theme: t.theme\n    });\n    const state = getLastGrammarStateFromMap(tokens2);\n    const theme = typeof t.theme === \"string\" ? t.theme : t.theme.name;\n    return {\n      tokens: tokens2,\n      state,\n      theme\n    };\n  });\n  const tokens = syncThemesTokenization(\n    ...themedTokens.map((i) => i.tokens)\n  );\n  const mergedTokens = tokens[0].map(\n    (line, lineIdx) => line.map((_token, tokenIdx) => {\n      const mergedToken = {\n        content: _token.content,\n        variants: {},\n        offset: _token.offset\n      };\n      if (\"includeExplanation\" in options && options.includeExplanation) {\n        mergedToken.explanation = _token.explanation;\n      }\n      tokens.forEach((t, themeIdx) => {\n        const {\n          content: _,\n          explanation: __,\n          offset: ___,\n          ...styles\n        } = t[lineIdx][tokenIdx];\n        mergedToken.variants[themes[themeIdx].color] = styles;\n      });\n      return mergedToken;\n    })\n  );\n  const mergedGrammarState = themedTokens[0].state ? new GrammarState(\n    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),\n    themedTokens[0].state.lang\n  ) : void 0;\n  if (mergedGrammarState)\n    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);\n  return mergedTokens;\n}\nfunction syncThemesTokenization(...themes) {\n  const outThemes = themes.map(() => []);\n  const count = themes.length;\n  for (let i = 0; i < themes[0].length; i++) {\n    const lines = themes.map((t) => t[i]);\n    const outLines = outThemes.map(() => []);\n    outThemes.forEach((t, i2) => t.push(outLines[i2]));\n    const indexes = lines.map(() => 0);\n    const current = lines.map((l) => l[0]);\n    while (current.every((t) => t)) {\n      const minLength = Math.min(...current.map((t) => t.content.length));\n      for (let n = 0; n < count; n++) {\n        const token = current[n];\n        if (token.content.length === minLength) {\n          outLines[n].push(token);\n          indexes[n] += 1;\n          current[n] = lines[n][indexes[n]];\n        } else {\n          outLines[n].push({\n            ...token,\n            content: token.content.slice(0, minLength)\n          });\n          current[n] = {\n            ...token,\n            content: token.content.slice(minLength),\n            offset: token.offset + minLength\n          };\n        }\n      }\n    }\n  }\n  return outThemes;\n}\n\nfunction codeToTokens(internal, code, options) {\n  let bg;\n  let fg;\n  let tokens;\n  let themeName;\n  let rootStyle;\n  let grammarState;\n  if (\"themes\" in options) {\n    const {\n      defaultColor = \"light\",\n      cssVariablePrefix = \"--shiki-\",\n      colorsRendering = \"css-vars\"\n    } = options;\n    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);\n    if (themes.length === 0)\n      throw new ShikiError$1(\"`themes` option must not be empty\");\n    const themeTokens = codeToTokensWithThemes(\n      internal,\n      code,\n      options\n    );\n    grammarState = getLastGrammarStateFromMap(themeTokens);\n    if (defaultColor && DEFAULT_COLOR_LIGHT_DARK !== defaultColor && !themes.find((t) => t.color === defaultColor))\n      throw new ShikiError$1(`\\`themes\\` option must contain the defaultColor key \\`${defaultColor}\\``);\n    const themeRegs = themes.map((t) => internal.getTheme(t.theme));\n    const themesOrder = themes.map((t) => t.color);\n    tokens = themeTokens.map((line) => line.map((token) => flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor, colorsRendering)));\n    if (grammarState)\n      setLastGrammarStateToMap(tokens, grammarState);\n    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));\n    fg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, \"fg\", colorsRendering);\n    bg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, \"bg\", colorsRendering);\n    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(\" \")}`;\n    rootStyle = defaultColor ? void 0 : [fg, bg].join(\";\");\n  } else if (\"theme\" in options) {\n    const colorReplacements = resolveColorReplacements(options.theme, options);\n    tokens = codeToTokensBase(\n      internal,\n      code,\n      options\n    );\n    const _theme = internal.getTheme(options.theme);\n    bg = applyColorReplacements(_theme.bg, colorReplacements);\n    fg = applyColorReplacements(_theme.fg, colorReplacements);\n    themeName = _theme.name;\n    grammarState = getLastGrammarStateFromMap(tokens);\n  } else {\n    throw new ShikiError$1(\"Invalid options, either `theme` or `themes` must be provided\");\n  }\n  return {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  };\n}\nfunction mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, property, colorsRendering) {\n  return themes.map((t, idx) => {\n    const value = applyColorReplacements(themeRegs[idx][property], themeColorReplacements[idx]) || \"inherit\";\n    const cssVar = `${cssVariablePrefix + t.color}${property === \"bg\" ? \"-bg\" : \"\"}:${value}`;\n    if (idx === 0 && defaultColor) {\n      if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && themes.length > 1) {\n        const lightIndex = themes.findIndex((t2) => t2.color === \"light\");\n        const darkIndex = themes.findIndex((t2) => t2.color === \"dark\");\n        if (lightIndex === -1 || darkIndex === -1)\n          throw new ShikiError$1('When using `defaultColor: \"light-dark()\"`, you must provide both `light` and `dark` themes');\n        const lightValue = applyColorReplacements(themeRegs[lightIndex][property], themeColorReplacements[lightIndex]) || \"inherit\";\n        const darkValue = applyColorReplacements(themeRegs[darkIndex][property], themeColorReplacements[darkIndex]) || \"inherit\";\n        return `light-dark(${lightValue}, ${darkValue});${cssVar}`;\n      }\n      return value;\n    }\n    if (colorsRendering === \"css-vars\") {\n      return cssVar;\n    }\n    return null;\n  }).filter((i) => !!i).join(\";\");\n}\n\nfunction codeToHast(internal, code, options, transformerContext = {\n  meta: {},\n  options,\n  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n}) {\n  let input = code;\n  for (const transformer of getTransformers(options))\n    input = transformer.preprocess?.call(transformerContext, input, options) || input;\n  let {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  } = codeToTokens(internal, input, options);\n  const {\n    mergeWhitespaces = true,\n    mergeSameStyleTokens = false\n  } = options;\n  if (mergeWhitespaces === true)\n    tokens = mergeWhitespaceTokens(tokens);\n  else if (mergeWhitespaces === \"never\")\n    tokens = splitWhitespaceTokens(tokens);\n  if (mergeSameStyleTokens) {\n    tokens = mergeAdjacentStyledTokens(tokens);\n  }\n  const contextSource = {\n    ...transformerContext,\n    get source() {\n      return input;\n    }\n  };\n  for (const transformer of getTransformers(options))\n    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;\n  return tokensToHast(\n    tokens,\n    {\n      ...options,\n      fg,\n      bg,\n      themeName,\n      rootStyle\n    },\n    contextSource,\n    grammarState\n  );\n}\nfunction tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {\n  const transformers = getTransformers(options);\n  const lines = [];\n  const root = {\n    type: \"root\",\n    children: []\n  };\n  const {\n    structure = \"classic\",\n    tabindex = \"0\"\n  } = options;\n  let preNode = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {\n      class: `shiki ${options.themeName || \"\"}`,\n      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,\n      ...tabindex !== false && tabindex != null ? {\n        tabindex: tabindex.toString()\n      } : {},\n      ...Object.fromEntries(\n        Array.from(\n          Object.entries(options.meta || {})\n        ).filter(([key]) => !key.startsWith(\"_\"))\n      )\n    },\n    children: []\n  };\n  let codeNode = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: {},\n    children: lines\n  };\n  const lineNodes = [];\n  const context = {\n    ...transformerContext,\n    structure,\n    addClassToHast,\n    get source() {\n      return transformerContext.source;\n    },\n    get tokens() {\n      return tokens;\n    },\n    get options() {\n      return options;\n    },\n    get root() {\n      return root;\n    },\n    get pre() {\n      return preNode;\n    },\n    get code() {\n      return codeNode;\n    },\n    get lines() {\n      return lineNodes;\n    }\n  };\n  tokens.forEach((line, idx) => {\n    if (idx) {\n      if (structure === \"inline\")\n        root.children.push({ type: \"element\", tagName: \"br\", properties: {}, children: [] });\n      else if (structure === \"classic\")\n        lines.push({ type: \"text\", value: \"\\n\" });\n    }\n    let lineNode = {\n      type: \"element\",\n      tagName: \"span\",\n      properties: { class: \"line\" },\n      children: []\n    };\n    let col = 0;\n    for (const token of line) {\n      let tokenNode = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          ...token.htmlAttrs\n        },\n        children: [{ type: \"text\", value: token.content }]\n      };\n      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      if (style)\n        tokenNode.properties.style = style;\n      for (const transformer of transformers)\n        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;\n      if (structure === \"inline\")\n        root.children.push(tokenNode);\n      else if (structure === \"classic\")\n        lineNode.children.push(tokenNode);\n      col += token.content.length;\n    }\n    if (structure === \"classic\") {\n      for (const transformer of transformers)\n        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;\n      lineNodes.push(lineNode);\n      lines.push(lineNode);\n    }\n  });\n  if (structure === \"classic\") {\n    for (const transformer of transformers)\n      codeNode = transformer?.code?.call(context, codeNode) || codeNode;\n    preNode.children.push(codeNode);\n    for (const transformer of transformers)\n      preNode = transformer?.pre?.call(context, preNode) || preNode;\n    root.children.push(preNode);\n  }\n  let result = root;\n  for (const transformer of transformers)\n    result = transformer?.root?.call(context, result) || result;\n  if (grammarState)\n    setLastGrammarStateToMap(result, grammarState);\n  return result;\n}\nfunction mergeWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    let carryOnContent = \"\";\n    let firstOffset = 0;\n    line.forEach((token, idx) => {\n      const isDecorated = token.fontStyle && (token.fontStyle & FontStyle.Underline || token.fontStyle & FontStyle.Strikethrough);\n      const couldMerge = !isDecorated;\n      if (couldMerge && token.content.match(/^\\s+$/) && line[idx + 1]) {\n        if (!firstOffset)\n          firstOffset = token.offset;\n        carryOnContent += token.content;\n      } else {\n        if (carryOnContent) {\n          if (couldMerge) {\n            newLine.push({\n              ...token,\n              offset: firstOffset,\n              content: carryOnContent + token.content\n            });\n          } else {\n            newLine.push(\n              {\n                content: carryOnContent,\n                offset: firstOffset\n              },\n              token\n            );\n          }\n          firstOffset = 0;\n          carryOnContent = \"\";\n        } else {\n          newLine.push(token);\n        }\n      }\n    });\n    return newLine;\n  });\n}\nfunction splitWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      if (token.content.match(/^\\s+$/))\n        return token;\n      const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n      if (!match)\n        return token;\n      const [, leading, content, trailing] = match;\n      if (!leading && !trailing)\n        return token;\n      const expanded = [{\n        ...token,\n        offset: token.offset + leading.length,\n        content\n      }];\n      if (leading) {\n        expanded.unshift({\n          content: leading,\n          offset: token.offset\n        });\n      }\n      if (trailing) {\n        expanded.push({\n          content: trailing,\n          offset: token.offset + leading.length + content.length\n        });\n      }\n      return expanded;\n    });\n  });\n}\nfunction mergeAdjacentStyledTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    for (const token of line) {\n      if (newLine.length === 0) {\n        newLine.push({ ...token });\n        continue;\n      }\n      const prevToken = newLine[newLine.length - 1];\n      const prevStyle = stringifyTokenStyle(prevToken.htmlStyle || getTokenStyleObject(prevToken));\n      const currentStyle = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      const isPrevDecorated = prevToken.fontStyle && (prevToken.fontStyle & FontStyle.Underline || prevToken.fontStyle & FontStyle.Strikethrough);\n      const isDecorated = token.fontStyle && (token.fontStyle & FontStyle.Underline || token.fontStyle & FontStyle.Strikethrough);\n      if (!isPrevDecorated && !isDecorated && prevStyle === currentStyle) {\n        prevToken.content += token.content;\n      } else {\n        newLine.push({ ...token });\n      }\n    }\n    return newLine;\n  });\n}\n\nconst hastToHtml = toHtml;\nfunction codeToHtml(internal, code, options) {\n  const context = {\n    meta: {},\n    options,\n    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n  };\n  let result = hastToHtml(codeToHast(internal, code, options, context));\n  for (const transformer of getTransformers(options))\n    result = transformer.postprocess?.call(context, result, options) || result;\n  return result;\n}\n\nconst VSCODE_FALLBACK_EDITOR_FG = { light: \"#333333\", dark: \"#bbbbbb\" };\nconst VSCODE_FALLBACK_EDITOR_BG = { light: \"#fffffe\", dark: \"#1e1e1e\" };\nconst RESOLVED_KEY = \"__shiki_resolved\";\nfunction normalizeTheme(rawTheme) {\n  if (rawTheme?.[RESOLVED_KEY])\n    return rawTheme;\n  const theme = {\n    ...rawTheme\n  };\n  if (theme.tokenColors && !theme.settings) {\n    theme.settings = theme.tokenColors;\n    delete theme.tokenColors;\n  }\n  theme.type ||= \"dark\";\n  theme.colorReplacements = { ...theme.colorReplacements };\n  theme.settings ||= [];\n  let { bg, fg } = theme;\n  if (!bg || !fg) {\n    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;\n    if (globalSetting?.settings?.foreground)\n      fg = globalSetting.settings.foreground;\n    if (globalSetting?.settings?.background)\n      bg = globalSetting.settings.background;\n    if (!fg && theme?.colors?.[\"editor.foreground\"])\n      fg = theme.colors[\"editor.foreground\"];\n    if (!bg && theme?.colors?.[\"editor.background\"])\n      bg = theme.colors[\"editor.background\"];\n    if (!fg)\n      fg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;\n    if (!bg)\n      bg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;\n    theme.fg = fg;\n    theme.bg = bg;\n  }\n  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {\n    theme.settings.unshift({\n      settings: {\n        foreground: theme.fg,\n        background: theme.bg\n      }\n    });\n  }\n  let replacementCount = 0;\n  const replacementMap = /* @__PURE__ */ new Map();\n  function getReplacementColor(value) {\n    if (replacementMap.has(value))\n      return replacementMap.get(value);\n    replacementCount += 1;\n    const hex = `#${replacementCount.toString(16).padStart(8, \"0\").toLowerCase()}`;\n    if (theme.colorReplacements?.[`#${hex}`])\n      return getReplacementColor(value);\n    replacementMap.set(value, hex);\n    return hex;\n  }\n  theme.settings = theme.settings.map((setting) => {\n    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith(\"#\");\n    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith(\"#\");\n    if (!replaceFg && !replaceBg)\n      return setting;\n    const clone = {\n      ...setting,\n      settings: {\n        ...setting.settings\n      }\n    };\n    if (replaceFg) {\n      const replacement = getReplacementColor(setting.settings.foreground);\n      theme.colorReplacements[replacement] = setting.settings.foreground;\n      clone.settings.foreground = replacement;\n    }\n    if (replaceBg) {\n      const replacement = getReplacementColor(setting.settings.background);\n      theme.colorReplacements[replacement] = setting.settings.background;\n      clone.settings.background = replacement;\n    }\n    return clone;\n  });\n  for (const key of Object.keys(theme.colors || {})) {\n    if (key === \"editor.foreground\" || key === \"editor.background\" || key.startsWith(\"terminal.ansi\")) {\n      if (!theme.colors[key]?.startsWith(\"#\")) {\n        const replacement = getReplacementColor(theme.colors[key]);\n        theme.colorReplacements[replacement] = theme.colors[key];\n        theme.colors[key] = replacement;\n      }\n    }\n  }\n  Object.defineProperty(theme, RESOLVED_KEY, {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return theme;\n}\n\nasync function resolveLangs(langs) {\n  return Array.from(new Set((await Promise.all(\n    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))\n  )).flat()));\n}\nasync function resolveThemes(themes) {\n  const resolved = await Promise.all(\n    themes.map(\n      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))\n    )\n  );\n  return resolved.filter((i) => !!i);\n}\n\nlet _emitDeprecation = 3;\nlet _emitError = false;\nfunction enableDeprecationWarnings(emitDeprecation = true, emitError = false) {\n  _emitDeprecation = emitDeprecation;\n  _emitError = emitError;\n}\nfunction warnDeprecated(message, version = 3) {\n  if (!_emitDeprecation)\n    return;\n  if (typeof _emitDeprecation === \"number\" && version > _emitDeprecation)\n    return;\n  if (_emitError) {\n    throw new Error(`[SHIKI DEPRECATE]: ${message}`);\n  } else {\n    console.trace(`[SHIKI DEPRECATE]: ${message}`);\n  }\n}\n\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nclass Registry extends Registry$1 {\n  constructor(_resolver, _themes, _langs, _alias = {}) {\n    super(_resolver);\n    this._resolver = _resolver;\n    this._themes = _themes;\n    this._langs = _langs;\n    this._alias = _alias;\n    this._themes.map((t) => this.loadTheme(t));\n    this.loadLanguages(this._langs);\n  }\n  _resolvedThemes = /* @__PURE__ */ new Map();\n  _resolvedGrammars = /* @__PURE__ */ new Map();\n  _langMap = /* @__PURE__ */ new Map();\n  _langGraph = /* @__PURE__ */ new Map();\n  _textmateThemeCache = /* @__PURE__ */ new WeakMap();\n  _loadedThemesCache = null;\n  _loadedLanguagesCache = null;\n  getTheme(theme) {\n    if (typeof theme === \"string\")\n      return this._resolvedThemes.get(theme);\n    else\n      return this.loadTheme(theme);\n  }\n  loadTheme(theme) {\n    const _theme = normalizeTheme(theme);\n    if (_theme.name) {\n      this._resolvedThemes.set(_theme.name, _theme);\n      this._loadedThemesCache = null;\n    }\n    return _theme;\n  }\n  getLoadedThemes() {\n    if (!this._loadedThemesCache)\n      this._loadedThemesCache = [...this._resolvedThemes.keys()];\n    return this._loadedThemesCache;\n  }\n  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`\n  // is expensive. Themes can switch often especially for dual-theme support.\n  //\n  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,\n  // we omit here so it's easier to cache the themes.\n  setTheme(theme) {\n    let textmateTheme = this._textmateThemeCache.get(theme);\n    if (!textmateTheme) {\n      textmateTheme = Theme.createFromRawTheme(theme);\n      this._textmateThemeCache.set(theme, textmateTheme);\n    }\n    this._syncRegistry.setTheme(textmateTheme);\n  }\n  getGrammar(name) {\n    if (this._alias[name]) {\n      const resolved = /* @__PURE__ */ new Set([name]);\n      while (this._alias[name]) {\n        name = this._alias[name];\n        if (resolved.has(name))\n          throw new ShikiError(`Circular alias \\`${Array.from(resolved).join(\" -> \")} -> ${name}\\``);\n        resolved.add(name);\n      }\n    }\n    return this._resolvedGrammars.get(name);\n  }\n  loadLanguage(lang) {\n    if (this.getGrammar(lang.name))\n      return;\n    const embeddedLazilyBy = new Set(\n      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))\n    );\n    this._resolver.addLanguage(lang);\n    const grammarConfig = {\n      balancedBracketSelectors: lang.balancedBracketSelectors || [\"*\"],\n      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []\n    };\n    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);\n    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);\n    g.name = lang.name;\n    this._resolvedGrammars.set(lang.name, g);\n    if (lang.aliases) {\n      lang.aliases.forEach((alias) => {\n        this._alias[alias] = lang.name;\n      });\n    }\n    this._loadedLanguagesCache = null;\n    if (embeddedLazilyBy.size) {\n      for (const e of embeddedLazilyBy) {\n        this._resolvedGrammars.delete(e.name);\n        this._loadedLanguagesCache = null;\n        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);\n        this._syncRegistry?._grammars?.delete(e.scopeName);\n        this.loadLanguage(this._langMap.get(e.name));\n      }\n    }\n  }\n  dispose() {\n    super.dispose();\n    this._resolvedThemes.clear();\n    this._resolvedGrammars.clear();\n    this._langMap.clear();\n    this._langGraph.clear();\n    this._loadedThemesCache = null;\n  }\n  loadLanguages(langs) {\n    for (const lang of langs)\n      this.resolveEmbeddedLanguages(lang);\n    const langsGraphArray = Array.from(this._langGraph.entries());\n    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);\n    if (missingLangs.length) {\n      const dependents = langsGraphArray.filter(([_, lang]) => lang && lang.embeddedLangs?.some((l) => missingLangs.map(([name]) => name).includes(l))).filter((lang) => !missingLangs.includes(lang));\n      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\\`${name}\\``).join(\", \")}, required by ${dependents.map(([name]) => `\\`${name}\\``).join(\", \")}`);\n    }\n    for (const [_, lang] of langsGraphArray)\n      this._resolver.addLanguage(lang);\n    for (const [_, lang] of langsGraphArray)\n      this.loadLanguage(lang);\n  }\n  getLoadedLanguages() {\n    if (!this._loadedLanguagesCache) {\n      this._loadedLanguagesCache = [\n        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])\n      ];\n    }\n    return this._loadedLanguagesCache;\n  }\n  resolveEmbeddedLanguages(lang) {\n    this._langMap.set(lang.name, lang);\n    this._langGraph.set(lang.name, lang);\n    if (lang.embeddedLangs) {\n      for (const embeddedLang of lang.embeddedLangs)\n        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));\n    }\n  }\n}\n\nclass Resolver {\n  _langs = /* @__PURE__ */ new Map();\n  _scopeToLang = /* @__PURE__ */ new Map();\n  _injections = /* @__PURE__ */ new Map();\n  _onigLib;\n  constructor(engine, langs) {\n    this._onigLib = {\n      createOnigScanner: (patterns) => engine.createScanner(patterns),\n      createOnigString: (s) => engine.createString(s)\n    };\n    langs.forEach((i) => this.addLanguage(i));\n  }\n  get onigLib() {\n    return this._onigLib;\n  }\n  getLangRegistration(langIdOrAlias) {\n    return this._langs.get(langIdOrAlias);\n  }\n  loadGrammar(scopeName) {\n    return this._scopeToLang.get(scopeName);\n  }\n  addLanguage(l) {\n    this._langs.set(l.name, l);\n    if (l.aliases) {\n      l.aliases.forEach((a) => {\n        this._langs.set(a, l);\n      });\n    }\n    this._scopeToLang.set(l.scopeName, l);\n    if (l.injectTo) {\n      l.injectTo.forEach((i) => {\n        if (!this._injections.get(i))\n          this._injections.set(i, []);\n        this._injections.get(i).push(l.scopeName);\n      });\n    }\n  }\n  getInjections(scopeName) {\n    const scopeParts = scopeName.split(\".\");\n    let injections = [];\n    for (let i = 1; i <= scopeParts.length; i++) {\n      const subScopeName = scopeParts.slice(0, i).join(\".\");\n      injections = [...injections, ...this._injections.get(subScopeName) || []];\n    }\n    return injections;\n  }\n}\n\nlet instancesCount = 0;\nfunction createShikiInternalSync(options) {\n  instancesCount += 1;\n  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)\n    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \\`highlighter.dispose()\\` to release unused instances.`);\n  let isDisposed = false;\n  if (!options.engine)\n    throw new ShikiError(\"`engine` option is required for synchronous mode\");\n  const langs = (options.langs || []).flat(1);\n  const themes = (options.themes || []).flat(1).map(normalizeTheme);\n  const resolver = new Resolver(options.engine, langs);\n  const _registry = new Registry(resolver, themes, langs, options.langAlias);\n  let _lastTheme;\n  function getLanguage(name) {\n    ensureNotDisposed();\n    const _lang = _registry.getGrammar(typeof name === \"string\" ? name : name.name);\n    if (!_lang)\n      throw new ShikiError(`Language \\`${name}\\` not found, you may need to load it first`);\n    return _lang;\n  }\n  function getTheme(name) {\n    if (name === \"none\")\n      return { bg: \"\", fg: \"\", name: \"none\", settings: [], type: \"dark\" };\n    ensureNotDisposed();\n    const _theme = _registry.getTheme(name);\n    if (!_theme)\n      throw new ShikiError(`Theme \\`${name}\\` not found, you may need to load it first`);\n    return _theme;\n  }\n  function setTheme(name) {\n    ensureNotDisposed();\n    const theme = getTheme(name);\n    if (_lastTheme !== name) {\n      _registry.setTheme(theme);\n      _lastTheme = name;\n    }\n    const colorMap = _registry.getColorMap();\n    return {\n      theme,\n      colorMap\n    };\n  }\n  function getLoadedThemes() {\n    ensureNotDisposed();\n    return _registry.getLoadedThemes();\n  }\n  function getLoadedLanguages() {\n    ensureNotDisposed();\n    return _registry.getLoadedLanguages();\n  }\n  function loadLanguageSync(...langs2) {\n    ensureNotDisposed();\n    _registry.loadLanguages(langs2.flat(1));\n  }\n  async function loadLanguage(...langs2) {\n    return loadLanguageSync(await resolveLangs(langs2));\n  }\n  function loadThemeSync(...themes2) {\n    ensureNotDisposed();\n    for (const theme of themes2.flat(1)) {\n      _registry.loadTheme(theme);\n    }\n  }\n  async function loadTheme(...themes2) {\n    ensureNotDisposed();\n    return loadThemeSync(await resolveThemes(themes2));\n  }\n  function ensureNotDisposed() {\n    if (isDisposed)\n      throw new ShikiError(\"Shiki instance has been disposed\");\n  }\n  function dispose() {\n    if (isDisposed)\n      return;\n    isDisposed = true;\n    _registry.dispose();\n    instancesCount -= 1;\n  }\n  return {\n    setTheme,\n    getTheme,\n    getLanguage,\n    getLoadedThemes,\n    getLoadedLanguages,\n    loadLanguage,\n    loadLanguageSync,\n    loadTheme,\n    loadThemeSync,\n    dispose,\n    [Symbol.dispose]: dispose\n  };\n}\n\nasync function createShikiInternal(options) {\n  if (!options.engine) {\n    warnDeprecated(\"`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.\");\n  }\n  const [\n    themes,\n    langs,\n    engine\n  ] = await Promise.all([\n    resolveThemes(options.themes || []),\n    resolveLangs(options.langs || []),\n    options.engine\n  ]);\n  return createShikiInternalSync({\n    ...options,\n    themes,\n    langs,\n    engine\n  });\n}\n\nasync function createHighlighterCore(options) {\n  const internal = await createShikiInternal(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction createHighlighterCoreSync(options) {\n  const internal = createShikiInternalSync(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction makeSingletonHighlighterCore(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighterCore2(options) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighterCore2;\n}\nconst getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);\n\nfunction createdBundledHighlighter(options) {\n  const bundledLanguages = options.langs;\n  const bundledThemes = options.themes;\n  const engine = options.engine;\n  async function createHighlighter(options2) {\n    function resolveLang(lang) {\n      if (typeof lang === \"string\") {\n        if (isSpecialLang(lang))\n          return [];\n        lang = options2.langAlias?.[lang] || lang;\n        const bundle = bundledLanguages[lang];\n        if (!bundle)\n          throw new ShikiError$1(`Language \\`${lang}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return lang;\n    }\n    function resolveTheme(theme) {\n      if (isSpecialTheme(theme))\n        return \"none\";\n      if (typeof theme === \"string\") {\n        const bundle = bundledThemes[theme];\n        if (!bundle)\n          throw new ShikiError$1(`Theme \\`${theme}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return theme;\n    }\n    const _themes = (options2.themes ?? []).map((i) => resolveTheme(i));\n    const langs = (options2.langs ?? []).map((i) => resolveLang(i));\n    const core = await createHighlighterCore({\n      engine: options2.engine ?? engine(),\n      ...options2,\n      themes: _themes,\n      langs\n    });\n    return {\n      ...core,\n      loadLanguage(...langs2) {\n        return core.loadLanguage(...langs2.map(resolveLang));\n      },\n      loadTheme(...themes) {\n        return core.loadTheme(...themes.map(resolveTheme));\n      },\n      getBundledLanguages() {\n        return bundledLanguages;\n      },\n      getBundledThemes() {\n        return bundledThemes;\n      }\n    };\n  }\n  return createHighlighter;\n}\nfunction makeSingletonHighlighter(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighter(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighter;\n}\nfunction createSingletonShorthands(createHighlighter, config) {\n  const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);\n  async function get(code, options) {\n    const shiki = await getSingletonHighlighter({\n      langs: [options.lang],\n      themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n    });\n    const langs = await config?.guessEmbeddedLanguages?.(code, options.lang, shiki);\n    if (langs) {\n      await shiki.loadLanguage(...langs);\n    }\n    return shiki;\n  }\n  return {\n    getSingletonHighlighter(options) {\n      return getSingletonHighlighter(options);\n    },\n    async codeToHtml(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHtml(code, options);\n    },\n    async codeToHast(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHast(code, options);\n    },\n    async codeToTokens(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokens(code, options);\n    },\n    async codeToTokensBase(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensBase(code, options);\n    },\n    async codeToTokensWithThemes(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensWithThemes(code, options);\n    },\n    async getLastGrammarState(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.getLastGrammarState(code, options);\n    }\n  };\n}\n\nfunction createCssVariablesTheme(options = {}) {\n  const {\n    name = \"css-variables\",\n    variablePrefix = \"--shiki-\",\n    fontStyle = true\n  } = options;\n  const variable = (name2) => {\n    if (options.variableDefaults?.[name2])\n      return `var(${variablePrefix}${name2}, ${options.variableDefaults[name2]})`;\n    return `var(${variablePrefix}${name2})`;\n  };\n  const theme = {\n    name,\n    type: \"dark\",\n    colors: {\n      \"editor.foreground\": variable(\"foreground\"),\n      \"editor.background\": variable(\"background\"),\n      \"terminal.ansiBlack\": variable(\"ansi-black\"),\n      \"terminal.ansiRed\": variable(\"ansi-red\"),\n      \"terminal.ansiGreen\": variable(\"ansi-green\"),\n      \"terminal.ansiYellow\": variable(\"ansi-yellow\"),\n      \"terminal.ansiBlue\": variable(\"ansi-blue\"),\n      \"terminal.ansiMagenta\": variable(\"ansi-magenta\"),\n      \"terminal.ansiCyan\": variable(\"ansi-cyan\"),\n      \"terminal.ansiWhite\": variable(\"ansi-white\"),\n      \"terminal.ansiBrightBlack\": variable(\"ansi-bright-black\"),\n      \"terminal.ansiBrightRed\": variable(\"ansi-bright-red\"),\n      \"terminal.ansiBrightGreen\": variable(\"ansi-bright-green\"),\n      \"terminal.ansiBrightYellow\": variable(\"ansi-bright-yellow\"),\n      \"terminal.ansiBrightBlue\": variable(\"ansi-bright-blue\"),\n      \"terminal.ansiBrightMagenta\": variable(\"ansi-bright-magenta\"),\n      \"terminal.ansiBrightCyan\": variable(\"ansi-bright-cyan\"),\n      \"terminal.ansiBrightWhite\": variable(\"ansi-bright-white\")\n    },\n    tokenColors: [\n      {\n        scope: [\n          \"keyword.operator.accessor\",\n          \"meta.group.braces.round.function.arguments\",\n          \"meta.template.expression\",\n          \"markup.fenced_code meta.embedded.block\"\n        ],\n        settings: {\n          foreground: variable(\"foreground\")\n        }\n      },\n      {\n        scope: \"emphasis\",\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: [\"strong\", \"markup.heading.markdown\", \"markup.bold.markdown\"],\n        settings: {\n          fontStyle: \"bold\"\n        }\n      },\n      {\n        scope: [\"markup.italic.markdown\"],\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: \"meta.link.inline.markdown\",\n        settings: {\n          fontStyle: \"underline\",\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        scope: [\"string\", \"markup.fenced_code\", \"markup.inline\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        scope: [\"comment\", \"string.quoted.docstring.multi\"],\n        settings: {\n          foreground: variable(\"token-comment\")\n        }\n      },\n      {\n        scope: [\n          \"constant.numeric\",\n          \"constant.language\",\n          \"constant.other.placeholder\",\n          \"constant.character.format.placeholder\",\n          \"variable.language.this\",\n          \"variable.other.object\",\n          \"variable.other.class\",\n          \"variable.other.constant\",\n          \"meta.property-name\",\n          \"meta.property-value\",\n          \"support\"\n        ],\n        settings: {\n          foreground: variable(\"token-constant\")\n        }\n      },\n      {\n        scope: [\n          \"keyword\",\n          \"storage.modifier\",\n          \"storage.type\",\n          \"storage.control.clojure\",\n          \"entity.name.function.clojure\",\n          \"entity.name.tag.yaml\",\n          \"support.function.node\",\n          \"support.type.property-name.json\",\n          \"punctuation.separator.key-value\",\n          \"punctuation.definition.template-expression\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        scope: \"variable.parameter.function\",\n        settings: {\n          foreground: variable(\"token-parameter\")\n        }\n      },\n      {\n        scope: [\n          \"support.function\",\n          \"entity.name.type\",\n          \"entity.other.inherited-class\",\n          \"meta.function-call\",\n          \"meta.instance.constructor\",\n          \"entity.other.attribute-name\",\n          \"entity.name.function\",\n          \"constant.keyword.clojure\"\n        ],\n        settings: {\n          foreground: variable(\"token-function\")\n        }\n      },\n      {\n        scope: [\n          \"entity.name.tag\",\n          \"string.quoted\",\n          \"string.regexp\",\n          \"string.interpolated\",\n          \"string.template\",\n          \"string.unquoted.plain.out.yaml\",\n          \"keyword.other.template\"\n        ],\n        settings: {\n          foreground: variable(\"token-string-expression\")\n        }\n      },\n      {\n        scope: [\n          \"punctuation.definition.arguments\",\n          \"punctuation.definition.dict\",\n          \"punctuation.separator\",\n          \"meta.function-call.arguments\"\n        ],\n        settings: {\n          foreground: variable(\"token-punctuation\")\n        }\n      },\n      {\n        // [Custom] Markdown links\n        scope: [\n          \"markup.underline.link\",\n          \"punctuation.definition.metadata.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        // [Custom] Markdown list\n        scope: [\"beginning.punctuation.definition.list.markdown\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        // [Custom] Markdown punctuation definition brackets\n        scope: [\n          \"punctuation.definition.string.begin.markdown\",\n          \"punctuation.definition.string.end.markdown\",\n          \"string.other.link.title.markdown\",\n          \"string.other.link.description.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        // [Custom] Diff\n        scope: [\n          \"markup.inserted\",\n          \"meta.diff.header.to-file\",\n          \"punctuation.definition.inserted\"\n        ],\n        settings: {\n          foreground: variable(\"token-inserted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.deleted\",\n          \"meta.diff.header.from-file\",\n          \"punctuation.definition.deleted\"\n        ],\n        settings: {\n          foreground: variable(\"token-deleted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.changed\",\n          \"punctuation.definition.changed\"\n        ],\n        settings: {\n          foreground: variable(\"token-changed\")\n        }\n      }\n    ]\n  };\n  if (!fontStyle) {\n    theme.tokenColors = theme.tokenColors?.map((tokenColor) => {\n      if (tokenColor.settings?.fontStyle)\n        delete tokenColor.settings.fontStyle;\n      return tokenColor;\n    });\n  }\n  return theme;\n}\n\nexport { addClassToHast, applyColorReplacements, codeToHast, codeToHtml, codeToTokens, codeToTokensBase, codeToTokensWithThemes, createCssVariablesTheme, createHighlighterCore, createHighlighterCoreSync, createPositionConverter, createShikiInternal, createShikiInternalSync, createSingletonShorthands, createdBundledHighlighter, enableDeprecationWarnings, flatTokenVariants, getSingletonHighlighterCore, getTokenStyleObject, guessEmbeddedLanguages, hastToHtml, isNoneTheme, isPlainLang, isSpecialLang, isSpecialTheme, makeSingletonHighlighter, makeSingletonHighlighterCore, normalizeGetter, normalizeTheme, resolveColorReplacements, splitLines, splitToken, splitTokens, stringifyTokenStyle, toArray, tokenizeAnsiWithTheme, tokenizeWithTheme, tokensToHast, transformerDecorations, warnDeprecated };\n"],"x_google_ignoreList":[0,1,2],"mappings":"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"}