{"version":3,"mappings":"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","names":["own","base","list","handle","one","map","value","input","position","a","handlers","emptyOptions","all","content","skippable","contents","skippables","br","p","whitespace","prefix","join","code","create","properties","result","index","phrasing","nodes","hastPhrasing","mdastPhrasing","structuredClone","node","row","cell","eol","text","meta","defaultHandlers","root","gfm","mdc","stringify"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66],"sources":["../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/configure.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/join.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/unsafe.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/association.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/safe.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/track.js","../../node_modules/.cache/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/index.js","../../node_modules/.cache/.pnpm/remark-stringify@11.0.0/node_modules/remark-stringify/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-embedded@3.0.0/node_modules/hast-util-embedded/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/block.js","../../node_modules/.cache/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/content.js","../../node_modules/.cache/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/skippable.js","../../node_modules/.cache/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/index.js","../../node_modules/.cache/.pnpm/rehype-minify-whitespace@6.0.2/node_modules/rehype-minify-whitespace/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/a.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/base.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/blockquote.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/br.js","../../node_modules/.cache/.pnpm/unist-util-find-after@5.0.0/node_modules/unist-util-find-after/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-to-text@4.0.2/node_modules/hast-util-to-text/lib/index.js","../../node_modules/.cache/.pnpm/trim-trailing-lines@2.1.0/node_modules/trim-trailing-lines/index.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/code.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/comment.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/del.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/list-items-spread.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/dl.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/em.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/heading.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/hr.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/iframe.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/img.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/inline-code.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/find-selected-options.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/input.js","../../node_modules/.cache/.pnpm/hast-util-has-property@3.0.0/node_modules/hast-util-has-property/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-is-body-ok-link@3.0.1/node_modules/hast-util-is-body-ok-link/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-phrasing@3.0.1/node_modules/hast-util-phrasing/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/li.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/list.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/wrap.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/media.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/p.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/q.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/root.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/select.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/strong.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/table-cell.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/table-row.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/table.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/text.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/textarea.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/wbr.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/index.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/state.js","../../node_modules/.cache/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/index.js","../../node_modules/.cache/.pnpm/html-whitespace-sensitive-tag-names@3.0.1/node_modules/html-whitespace-sensitive-tag-names/lib/index.js","../../node_modules/.cache/.pnpm/hast-util-format@1.1.0/node_modules/hast-util-format/lib/index.js","../../node_modules/.cache/.pnpm/@nuxtjs+mdc@0.17.4_magicast@0.3.5/node_modules/@nuxtjs/mdc/dist/runtime/stringify/utils.js","../../node_modules/.cache/.pnpm/@nuxtjs+mdc@0.17.4_magicast@0.3.5/node_modules/@nuxtjs/mdc/dist/runtime/stringify/mdc-remark.js","../../node_modules/.cache/.pnpm/@nuxtjs+mdc@0.17.4_magicast@0.3.5/node_modules/@nuxtjs/mdc/dist/runtime/stringify/index.js","../../node_modules/.cache/.pnpm/@nuxtjs+mdc@0.17.4_magicast@0.3.5/node_modules/@nuxtjs/mdc/dist/runtime/highlighter/shiki.js","../../node_modules/.cache/.pnpm/@nuxtjs+mdc@0.17.4_magicast@0.3.5/node_modules/@nuxtjs/mdc/dist/runtime/parser/cached.js"],"sourcesContent":["/**\n * @import {Options, State} from './types.js'\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'extensions': {\n          // Empty.\n          break\n        }\n\n        /* c8 ignore next 4 */\n        case 'unsafe': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'join': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'handlers': {\n          map(base[key], extension[key])\n          break\n        }\n\n        default: {\n          // @ts-expect-error: matches.\n          base.options[key] = extension[key]\n        }\n      }\n    }\n  }\n\n  return base\n}\n\n/**\n * @template T\n * @param {Array<T>} left\n * @param {Array<T> | null | undefined} right\n */\nfunction list(left, right) {\n  if (right) {\n    left.push(...right)\n  }\n}\n\n/**\n * @template T\n * @param {Record<string, T>} left\n * @param {Record<string, T> | null | undefined} right\n */\nfunction map(left, right) {\n  if (right) {\n    Object.assign(left, right)\n  }\n}\n","/**\n * @import {Join} from 'mdast-util-to-markdown'\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @import {AssociationId} from '../types.js'\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @import {CompilePattern} from '../types.js'\n */\n\n/**\n * @type {CompilePattern}\n */\nexport function compilePattern(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\n * @import {PhrasingParents} from '../types.js'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n  /** @type {string | undefined} */\n  let encodeAfter\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    })\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value =\n        encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1)\n    }\n\n    const encodingInfo = state.attentionEncodeSurroundingInfo\n    state.attentionEncodeSurroundingInfo = undefined\n    encodeAfter = undefined\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (\n        results.length > 0 &&\n        encodingInfo.before &&\n        before === results[results.length - 1].slice(-1)\n      ) {\n        results[results.length - 1] =\n          results[results.length - 1].slice(0, -1) +\n          encodeCharacterReference(before.charCodeAt(0))\n      }\n\n      if (encodingInfo.after) encodeAfter = after\n    }\n\n    tracker.move(value)\n    results.push(value)\n    before = value.slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {FlowChildren, FlowParents, TrackFields} from '../types.js'\n */\n\n/**\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {FlowChildren} left\n * @param {FlowChildren} right\n * @param {FlowParents} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @import {IndentLines} from '../types.js'\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @import {SafeConfig, State} from 'mdast-util-to-markdown'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(encodeCharacterReference(value.charCodeAt(position)))\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @import {CreateTracker, TrackCurrent, TrackMove, TrackShift} from '../types.js'\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @import {Info, Join, Options, SafeConfig, State} from 'mdast-util-to-markdown'\n * @import {Nodes} from 'mdast'\n * @import {Enter, FlowParents, PhrasingParents, TrackFields} from './types.js'\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {compilePattern} from './util/compile-pattern.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Nodes} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options) {\n  const settings = options || {}\n  /** @type {State} */\n  const state = {\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    enter,\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {...handlers},\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined,\n    indentLines,\n    indexStack: [],\n    join: [...join],\n    options: {},\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe]\n  }\n\n  configure(state, settings)\n\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition)\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    /**\n     * @returns {undefined}\n     */\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */ (value)\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {import('unified').Compiler<Root, string>} Compiler\n * @typedef {import('unified').Processor<undefined, undefined, undefined, Root, string>} Processor\n */\n\n/**\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * Add support for serializing to markdown.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkStringify(options) {\n  /** @type {Processor} */\n  // @ts-expect-error: TS in JSDoc generates wrong types if `this` is typed regularly.\n  const self = this\n\n  self.compiler = compiler\n\n  /**\n   * @type {Compiler}\n   */\n  function compiler(tree) {\n    return toMarkdown(tree, {\n      ...self.data('settings'),\n      ...options,\n      // Note: this option is not in the readme.\n      // The goal is for it to be set by plugins on `data` instead of being\n      // passed by users.\n      extensions: self.data('toMarkdownExtensions') || []\n    })\n  }\n}\n","import {convertElement} from 'hast-util-is-element'\n\n/**\n * Check if a node is a *embedded content*.\n *\n * @param value\n *   Thing to check (typically `Node`).\n * @returns\n *   Whether `value` is an element considered embedded content.\n *\n *   The elements `audio`, `canvas`, `embed`, `iframe`, `img`, `math`,\n *   `object`, `picture`, `svg`, and `video` are embedded content.\n */\nexport const embedded = convertElement(\n  /**\n   * @param element\n   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}\n   */\n  function (element) {\n    return (\n      element.tagName === 'audio' ||\n      element.tagName === 'canvas' ||\n      element.tagName === 'embed' ||\n      element.tagName === 'iframe' ||\n      element.tagName === 'img' ||\n      element.tagName === 'math' ||\n      element.tagName === 'object' ||\n      element.tagName === 'picture' ||\n      element.tagName === 'svg' ||\n      element.tagName === 'video'\n    )\n  }\n)\n","// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nexport const blocks = [\n  'address', // Flow content.\n  'article', // Sections and headings.\n  'aside', // Sections and headings.\n  'blockquote', // Flow content.\n  'body', // Page.\n  'br', // Contribute whitespace intrinsically.\n  'caption', // Similar to block.\n  'center', // Flow content, legacy.\n  'col', // Similar to block.\n  'colgroup', // Similar to block.\n  'dd', // Lists.\n  'dialog', // Flow content.\n  'dir', // Lists, legacy.\n  'div', // Flow content.\n  'dl', // Lists.\n  'dt', // Lists.\n  'figcaption', // Flow content.\n  'figure', // Flow content.\n  'footer', // Flow content.\n  'form', // Flow content.\n  'h1', // Sections and headings.\n  'h2', // Sections and headings.\n  'h3', // Sections and headings.\n  'h4', // Sections and headings.\n  'h5', // Sections and headings.\n  'h6', // Sections and headings.\n  'head', // Page.\n  'header', // Flow content.\n  'hgroup', // Sections and headings.\n  'hr', // Flow content.\n  'html', // Page.\n  'legend', // Flow content.\n  'li', // Block-like.\n  'li', // Similar to block.\n  'listing', // Flow content, legacy\n  'main', // Flow content.\n  'menu', // Lists.\n  'nav', // Sections and headings.\n  'ol', // Lists.\n  'optgroup', // Similar to block.\n  'option', // Similar to block.\n  'p', // Flow content.\n  'plaintext', // Flow content, legacy\n  'pre', // Flow content.\n  'section', // Sections and headings.\n  'summary', // Similar to block.\n  'table', // Similar to block.\n  'tbody', // Similar to block.\n  'td', // Block-like.\n  'td', // Similar to block.\n  'tfoot', // Similar to block.\n  'th', // Block-like.\n  'th', // Similar to block.\n  'thead', // Similar to block.\n  'tr', // Similar to block.\n  'ul', // Lists.\n  'wbr', // Contribute whitespace intrinsically.\n  'xmp' // Flow content, legacy\n]\n","export const content = [\n  // Form.\n  'button',\n  'input',\n  'select',\n  'textarea'\n]\n","export const skippable = [\n  'area',\n  'base',\n  'basefont',\n  'dialog',\n  'datalist',\n  'head',\n  'link',\n  'meta',\n  'noembed',\n  'noframes',\n  'param',\n  'rp',\n  'script',\n  'source',\n  'style',\n  'template',\n  'track',\n  'title'\n]\n","/**\n * @import {Nodes, Parents, Text} from 'hast'\n */\n\n/**\n * @callback Collapse\n *   Collapse a string.\n * @param {string} value\n *   Value to collapse.\n * @returns {string}\n *   Collapsed value.\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [newlines=false]\n *   Collapse whitespace containing newlines to `'\\n'` instead of `' '`\n *   (default: `false`); the default is to collapse to a single space.\n *\n * @typedef Result\n *   Result.\n * @property {boolean} remove\n *   Whether to remove.\n * @property {boolean} ignore\n *   Whether to ignore.\n * @property {boolean} stripAtStart\n *   Whether to strip at the start.\n *\n * @typedef State\n *   Info passed around.\n * @property {Collapse} collapse\n *   Collapse.\n * @property {Whitespace} whitespace\n *   Current whitespace.\n * @property {boolean | undefined} [before]\n *   Whether there is a break before (default: `false`).\n * @property {boolean | undefined} [after]\n *   Whether there is a break after (default: `false`).\n *\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Whitespace setting.\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {isElement} from 'hast-util-is-element'\nimport {whitespace} from 'hast-util-whitespace'\nimport {convert} from 'unist-util-is'\nimport {blocks} from './block.js'\nimport {content as contents} from './content.js'\nimport {skippable as skippables} from './skippable.js'\n\n/** @type {Options} */\nconst emptyOptions = {}\nconst ignorableNode = convert(['comment', 'doctype'])\n\n/**\n * Minify whitespace.\n *\n * @param {Nodes} tree\n *   Tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport function minifyWhitespace(tree, options) {\n  const settings = options || emptyOptions\n\n  minify(tree, {\n    collapse: collapseFactory(\n      settings.newlines ? replaceNewlines : replaceWhitespace\n    ),\n    whitespace: 'normal'\n  })\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minify(node, state) {\n  if ('children' in node) {\n    const settings = {...state}\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true\n      settings.after = true\n    }\n\n    settings.whitespace = inferWhiteSpace(node, state)\n\n    return all(node, settings)\n  }\n\n  if (node.type === 'text') {\n    if (state.whitespace === 'normal') {\n      return minifyText(node, state)\n    }\n\n    // Naïve collapse, but no trimming:\n    if (state.whitespace === 'nowrap') {\n      node.value = state.collapse(node.value)\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {ignore: ignorableNode(node), stripAtStart: false, remove: false}\n}\n\n/**\n * @param {Text} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minifyText(node, state) {\n  const value = state.collapse(node.value)\n  const result = {ignore: false, stripAtStart: false, remove: false}\n  let start = 0\n  let end = value.length\n\n  if (state.before && removable(value.charAt(0))) {\n    start++\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (state.after) {\n      end--\n    } else {\n      result.stripAtStart = true\n    }\n  }\n\n  if (start === end) {\n    result.remove = true\n  } else {\n    node.value = value.slice(start, end)\n  }\n\n  return result\n}\n\n/**\n * @param {Parents} parent\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction all(parent, state) {\n  let before = state.before\n  const after = state.after\n  const children = parent.children\n  let length = children.length\n  let index = -1\n\n  while (++index < length) {\n    const result = minify(children[index], {\n      ...state,\n      after: collapsableAfter(children, index, after),\n      before\n    })\n\n    if (result.remove) {\n      children.splice(index, 1)\n      index--\n      length--\n    } else if (!result.ignore) {\n      before = result.stripAtStart\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false\n    }\n  }\n\n  return {ignore: false, stripAtStart: Boolean(before || after), remove: false}\n}\n\n/**\n * @param {Array<Nodes>} nodes\n *   Nodes.\n * @param {number} index\n *   Index.\n * @param {boolean | undefined} [after]\n *   Whether there is a break after `nodes` (default: `false`).\n * @returns {boolean | undefined}\n *   Whether there is a break after the node at `index`.\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index]\n    let result = inferBoundary(node)\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1)\n    }\n\n    if (typeof result === 'boolean') {\n      return result\n    }\n  }\n\n  return after\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean | undefined}\n *   Boundary.\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false\n    }\n\n    if (blocklike(node)) {\n      return true\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false\n    }\n  } else if (!ignorableNode(node)) {\n    return false\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents)\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is block-like.\n */\nfunction blocklike(node) {\n  return isElement(node, blocks)\n}\n\n/**\n * @param {Parents} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction skippable(node) {\n  return (\n    Boolean(node.type === 'element' && node.properties.hidden) ||\n    ignorableNode(node) ||\n    isElement(node, skippables)\n  )\n}\n\n/**\n * @param {string} character\n *   Character.\n * @returns {boolean}\n *   Whether `character` is removable.\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n'\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value)\n  return match ? match[0] : ' '\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceWhitespace() {\n  return ' '\n}\n\n/**\n * @param {Collapse} replace\n * @returns {Collapse}\n *   Collapse.\n */\nfunction collapseFactory(replace) {\n  return collapse\n\n  /**\n   * @type {Collapse}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\n  }\n}\n\n/**\n * We don’t need to support void elements here (so `nobr wbr` -> `normal` is\n * ignored).\n *\n * @param {Parents} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Whitespace}\n *   Whitespace.\n */\nfunction inferWhiteSpace(node, state) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      // Whitespace in script/style, while not displayed by CSS as significant,\n      // could have some meaning in JS/CSS, so we can’t touch them.\n      case 'listing':\n      case 'plaintext':\n      case 'script':\n      case 'style':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return node.properties.noWrap ? 'nowrap' : state.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return state.whitespace\n}\n","/**\n * @import {Options} from 'hast-util-minify-whitespace'\n * @import {Root} from 'hast'\n */\n\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\n\n/**\n * Minify whitespace.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeMinifyWhitespace(options) {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    minifyWhitespace(tree, options)\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link}\n *   mdast node.\n */\nexport function a(state, node) {\n  const properties = node.properties || {}\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    url: state.resolve(String(properties.href || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {undefined}\n *   Nothing.\n */\nexport function base(state, node) {\n  if (!state.baseFound) {\n    state.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || undefined\n    state.baseFound = true\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Blockquote} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Blockquote}\n *   mdast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Blockquote} */\n  const result = {type: 'blockquote', children: state.toFlow(state.all(node))}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Break} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Break}\n *   mdast node.\n */\nexport function br(state, node) {\n  /** @type {Break} */\n  const result = {type: 'break'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n","/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\n */\n\n/**\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n *\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0` — space\n *   *   `1` — line ending\n *   *   `2` — blank line\n *\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n *\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n *\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\n *   Any value for a break before.\n *\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use (default: `'normal'`).\n */\n\nimport {findAfter} from 'unist-util-find-after'\nimport {convertElement} from 'hast-util-is-element'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst cell = convertElement(isCell)\nconst p = convertElement('p')\nconst row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'li', // Lists (as `display: list-item`)\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * > 👉 **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > we’re a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), we’ll\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Nodes} tree\n *   Tree to turn into text.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\nexport function toText(tree, options) {\n  const options_ = options || {}\n  const children = 'children' in tree ? tree.children : []\n  const block = blockOrCaption(tree)\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options_.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n\n  /** @type {Array<BreakNumber | string>} */\n  const results = []\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    )\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(\n      ...renderedTextCollection(\n        children[index],\n        // @ts-expect-error: `tree` is a parent if we’re here.\n        tree,\n        {\n          whitespace,\n          breakBefore: index ? undefined : block,\n          breakAfter:\n            index < children.length - 1 ? br(children[index + 1]) : block\n        }\n      )\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {number | undefined} */\n  let count\n\n  index = -1\n\n  while (++index < results.length) {\n    const value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ')\n      }\n\n      count = -1\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\n *\n * @param {Nodes} node\n * @param {Parents} parent\n * @param {CollectionInfo} info\n * @returns {Array<BreakNumber | string>}\n */\nfunction renderedTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info)\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal'\n      ? collectText(node, info)\n      : collectPreText(node)\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parents} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array<BreakNumber | string>} */\n  let items = []\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix\n  /** @type {BreakForce | BreakNumber | undefined} */\n  let suffix\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (\n    row(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, row)\n  ) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      renderedTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  if (\n    cell(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, cell)\n  ) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Comment | Text} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectText(node, info) {\n  const value = String(node.value)\n  /** @type {Array<string>} */\n  const lines = []\n  /** @type {Array<BreakNumber | string>} */\n  const result = []\n  let start = 0\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start\n\n    const match = searchLineFeeds.exec(value)\n    const end = match && 'index' in match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // […] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1\n  /** @type {BreakNumber | undefined} */\n  let join\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x20_0b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = undefined\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join)\n      result.push(lines[index])\n      join = 0\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and it’s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // don’t worry about `pre`.\n      result.push(0)\n    }\n  }\n\n  return result\n}\n\n/**\n * Collect a text node as “pre” whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectPreText(node) {\n  return [String(node.value)]\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  /** @type {number | undefined} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    const match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * Figure out the whitespace of a node.\n *\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Nodes} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const properties = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return properties.noWrap ? 'nowrap' : info.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return info.whitespace\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {properties: {hidden: true}}}\n */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {tagName: 'td' | 'th'}}\n */\nfunction isCell(node) {\n  return node.tagName === 'td' || node.tagName === 'th'\n}\n\n/**\n * @type {TestFunction}\n */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * Remove final line endings from `value`\n *\n * @param {unknown} value\n *   Value with trailing line endings, coerced to string.\n * @return {string}\n *   Value without trailing line endings.\n */\nexport function trimTrailingLines(value) {\n  const input = String(value)\n  let end = input.length\n\n  while (end > 0) {\n    const code = input.codePointAt(end - 1)\n    if (code !== undefined && (code === 10 || code === 13)) {\n      end--\n    } else {\n      break\n    }\n  }\n\n  return input.slice(0, end)\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Code} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\n\nconst prefix = 'language-'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Code}\n *   mdast node.\n */\nexport function code(state, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<number | string> | undefined} */\n  let classList\n  /** @type {string | undefined} */\n  let lang\n\n  if (node.tagName === 'pre') {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        child.type === 'element' &&\n        child.tagName === 'code' &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  /** @type {Code} */\n  const result = {\n    type: 'code',\n    lang: lang || null,\n    meta: null,\n    value: trimTrailingLines(toText(node))\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Comment} from 'hast'\n * @import {Html} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Comment>} node\n *   hast element to transform.\n * @returns {Html}\n *   mdast node.\n */\nexport function comment(state, node) {\n  /** @type {Html} */\n  const result = {\n    type: 'html',\n    value: '<!--' + node.value + '-->'\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Delete, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Delete}\n *   mdast node.\n */\nexport function del(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n  /** @type {Delete} */\n  const result = {type: 'delete', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {ListContent} from 'mdast'\n */\n\n/**\n * Infer whether list items are spread.\n *\n * @param {Readonly<Array<Readonly<ListContent>>>} children\n *   List items.\n * @returns {boolean}\n *   Whether one or more list items are spread.\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {ElementContent, Element} from 'hast'\n * @import {BlockContent, DefinitionContent, ListContent, ListItem, List} from 'mdast'\n */\n\n/**\n * @typedef Group\n *   Title/definition group.\n * @property {Array<Element>} titles\n *   One or more titles.\n * @property {Array<ElementContent>} definitions\n *   One or more definitions.\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List | undefined}\n *   mdast node.\n */\nexport function dl(state, node) {\n  /** @type {Array<ElementContent>} */\n  const clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  let index = -1\n\n  // Unwrap `<div>`s\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element' && child.tagName === 'div') {\n      clean.push(...child.children)\n    } else {\n      clean.push(child)\n    }\n  }\n\n  /** @type {Group} */\n  let group = {definitions: [], titles: []}\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    const child = clean[index]\n\n    if (child.type === 'element' && child.tagName === 'dt') {\n      const previous = clean[index - 1]\n\n      if (\n        previous &&\n        previous.type === 'element' &&\n        previous.tagName === 'dd'\n      ) {\n        groups.push(group)\n        group = {definitions: [], titles: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<ListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    const result = [\n      ...handle(state, groups[index].titles),\n      ...handle(state, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    /** @type {List} */\n    const result = {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(content),\n      children: content\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Array<ElementContent>} children\n *   hast element children to transform.\n * @returns {Array<BlockContent | DefinitionContent>}\n *   mdast nodes.\n */\nfunction handle(state, children) {\n  const nodes = state.all({type: 'root', children})\n  const listItems = state.toSpecificContent(nodes, create)\n\n  if (listItems.length === 0) {\n    return []\n  }\n\n  if (listItems.length === 1) {\n    return listItems[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(listItems),\n      children: listItems\n    }\n  ]\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Emphasis, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Emphasis}\n *   mdast node.\n */\nexport function em(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Emphasis} */\n  const result = {type: 'emphasis', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {Nodes} from 'mdast'\n */\n\n/**\n * Drop trailing initial and final `br`s.\n *\n * @template {Nodes} Node\n *   Node type.\n * @param {Array<Node>} nodes\n *   List of nodes.\n * @returns {Array<Node>}\n *   List of nodes w/o `break`s.\n */\nexport function dropSurroundingBreaks(nodes) {\n  let start = 0\n  let end = nodes.length\n\n  while (start < end && nodes[start].type === 'break') start++\n  while (end > start && nodes[end - 1].type === 'break') end--\n\n  return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end)\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Heading, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Heading}\n *   mdast node.\n */\nexport function heading(state, node) {\n  const depth = /** @type {Heading['depth']} */ (\n    /* c8 ignore next */\n    Number(node.tagName.charAt(1)) || 1\n  )\n  const children = dropSurroundingBreaks(\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  /** @type {Heading} */\n  const result = {type: 'heading', depth, children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ThematicBreak} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ThematicBreak}\n *   mdast node.\n */\nexport function hr(state, node) {\n  /** @type {ThematicBreak} */\n  const result = {type: 'thematicBreak'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link | undefined}\n *   mdast node.\n */\nexport function iframe(state, node) {\n  const properties = node.properties || {}\n  const source = String(properties.src || '')\n  const title = String(properties.title || '')\n\n  // Only create a link if there is a title.\n  // We can’t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (source && title) {\n    /** @type {Link} */\n    const result = {\n      type: 'link',\n      title: null,\n      url: state.resolve(source),\n      children: [{type: 'text', value: title}]\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Image}\n *   mdast node.\n */\nexport function img(state, node) {\n  const properties = node.properties || {}\n\n  /** @type {Image} */\n  const result = {\n    type: 'image',\n    url: state.resolve(String(properties.src || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    alt: properties.alt ? String(properties.alt) : ''\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {InlineCode} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {InlineCode}\n *   mdast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {InlineCode} */\n  const result = {type: 'inlineCode', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {Element, Properties} from 'hast'\n */\n\n/**\n * @typedef {[string, Value]} Option\n *   Option, where the item at `0` is the label, the item at `1` the value.\n *\n * @typedef {Array<Option>} Options\n *   List of options.\n *\n * @typedef {string | undefined} Value\n *   `value` field of option.\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {Readonly<Element>} node\n *   hast element to inspect.\n * @param {Properties | undefined} [explicitProperties]\n *   Properties to use, normally taken from `node`, but can be changed.\n * @returns {Options}\n *   Options.\n */\nexport function findSelectedOptions(node, explicitProperties) {\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Options} */\n  const values = []\n  const properties = explicitProperties || node.properties || {}\n  const options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(properties.size), 10), 0) ||\n    (properties.multiple ? 4 : 1)\n  let index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n\n    if (option && option.properties && option.properties.selected) {\n      selectedOptions.push(option)\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  const max = Math.min(list.length, size)\n  index = -1\n\n  while (++index < max) {\n    const option = list[index]\n    const properties = option.properties || {}\n    const content = toText(option)\n    const label = content || String(properties.label || '')\n    const value = String(properties.value || '') || content\n    values.push([value, label === value ? undefined : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Element} node\n *   Parent to find in.\n * @returns {Array<Element>}\n *   Option elements.\n */\nfunction findOptions(node) {\n  /** @type {Array<Element>} */\n  const results = []\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if ('children' in child && Array.isArray(child.children)) {\n      results.push(...findOptions(child))\n    }\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'option' &&\n      (!child.properties || !child.properties.disabled)\n    ) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, Text} from 'mdast'\n * @import {Options} from '../util/find-selected-options.js'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\nconst defaultChecked = '[x]'\nconst defaultUnchecked = '[ ]'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<Link | Text> | Image | Text | undefined}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function input(state, node) {\n  const properties = node.properties || {}\n  const value = String(properties.value || properties.placeholder || '')\n\n  if (\n    properties.disabled ||\n    properties.type === 'hidden' ||\n    properties.type === 'file'\n  ) {\n    return\n  }\n\n  if (properties.type === 'checkbox' || properties.type === 'radio') {\n    /** @type {Text} */\n    const result = {\n      type: 'text',\n      value: properties.checked\n        ? state.options.checked || defaultChecked\n        : state.options.unchecked || defaultUnchecked\n    }\n    state.patch(node, result)\n    return result\n  }\n\n  if (properties.type === 'image') {\n    const alt = properties.alt || value\n\n    if (alt) {\n      /** @type {Image} */\n      const result = {\n        type: 'image',\n        url: state.resolve(String(properties.src || '') || null),\n        title: String(properties.title || '') || null,\n        alt: String(alt)\n      }\n      state.patch(node, result)\n      return result\n    }\n\n    return\n  }\n\n  /** @type {Options} */\n  let values = []\n\n  if (value) {\n    values = [[value, undefined]]\n  } else if (\n    // `list` is not supported on these types:\n    properties.type !== 'button' &&\n    properties.type !== 'file' &&\n    properties.type !== 'password' &&\n    properties.type !== 'reset' &&\n    properties.type !== 'submit' &&\n    properties.list\n  ) {\n    const list = String(properties.list)\n    const datalist = state.elementById.get(list)\n\n    if (datalist && datalist.tagName === 'datalist') {\n      values = findSelectedOptions(datalist, properties)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (properties.type === 'password') {\n    // Passwords don’t support `list`.\n    values[0] = ['•'.repeat(values[0][0].length), undefined]\n  }\n\n  if (properties.type === 'email' || properties.type === 'url') {\n    /** @type {Array<Link | Text>} */\n    const results = []\n    let index = -1\n\n    while (++index < values.length) {\n      const value = state.resolve(values[index][0])\n      /** @type {Link} */\n      const result = {\n        type: 'link',\n        title: null,\n        url: properties.type === 'email' ? 'mailto:' + value : value,\n        children: [{type: 'text', value: values[index][1] || value}]\n      }\n\n      results.push(result)\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  /** @type {Array<string>} */\n  const texts = []\n  let index = -1\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  /** @type {Text} */\n  const result = {type: 'text', value: texts.join(', ')}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Check if `node` is an element and has a `name` property.\n *\n * @template {string} Key\n *   Type of key.\n * @param {Nodes} node\n *   Node to check (typically `Element`).\n * @param {Key} name\n *   Property name to check.\n * @returns {node is Element & {properties: Record<Key, Array<number | string> | number | string | true>}}}\n *   Whether `node` is an element that has a `name` property.\n *\n *   Note: see <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/27c9274/types/hast/index.d.ts#L37C29-L37C98>.\n */\nexport function hasProperty(node, name) {\n  const value =\n    node.type === 'element' &&\n    own.call(node.properties, name) &&\n    node.properties[name]\n\n  return value !== null && value !== undefined && value !== false\n}\n","/**\n * @import {Nodes} from 'hast'\n */\n\nconst list = new Set(['pingback', 'prefetch', 'stylesheet'])\n\n/**\n * Checks whether a node is a “body OK” link.\n *\n * @param {Nodes} node\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is a “body OK” link.\n */\nexport function isBodyOkLink(node) {\n  if (node.type !== 'element' || node.tagName !== 'link') {\n    return false\n  }\n\n  if (node.properties.itemProp) {\n    return true\n  }\n\n  const value = node.properties.rel\n  let index = -1\n\n  if (!Array.isArray(value) || value.length === 0) {\n    return false\n  }\n\n  while (++index < value.length) {\n    if (!list.has(String(value[index]))) {\n      return false\n    }\n  }\n\n  return true\n}\n","/**\n * @typedef {import('hast').Nodes} Nodes\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {hasProperty} from 'hast-util-has-property'\nimport {isBodyOkLink} from 'hast-util-is-body-ok-link'\nimport {convertElement} from 'hast-util-is-element'\n\nconst basic = convertElement([\n  'a',\n  'abbr',\n  // `area` is in fact only phrasing if it is inside a `map` element.\n  // However, since `area`s are required to be inside a `map` element, and it’s\n  // a rather involved check, it’s ignored here for now.\n  'area',\n  'b',\n  'bdi',\n  'bdo',\n  'br',\n  'button',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'i',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'output',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'var',\n  'wbr'\n])\n\nconst meta = convertElement('meta')\n\n/**\n * Check if the given value is *phrasing* content.\n *\n * @param {Nodes} value\n *   Node to check.\n * @returns {boolean}\n *   Whether `value` is phrasing content.\n */\nexport function phrasing(value) {\n  return Boolean(\n    value.type === 'text' ||\n      basic(value) ||\n      embedded(value) ||\n      isBodyOkLink(value) ||\n      (meta(value) && hasProperty(value, 'itemProp'))\n  )\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem} from 'mdast'\n */\n\n/**\n * @typedef ExtractResult\n *   Result of extracting a leading checkbox.\n * @property {Element | undefined} checkbox\n *   The checkbox that was removed, if any.\n * @property {Element} rest\n *   If there was a leading checkbox, a deep clone of the node w/o the leading\n *   checkbox; otherwise a reference to the given, untouched, node.\n */\n\nimport {phrasing} from 'hast-util-phrasing'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ListItem}\n *   mdast node.\n */\nexport function li(state, node) {\n  // If the list item starts with a checkbox, remove the checkbox and mark the\n  // list item as a GFM task list item.\n  const {rest, checkbox} = extractLeadingCheckbox(node)\n  const checked = checkbox ? Boolean(checkbox.properties.checked) : null\n  const spread = spreadout(rest)\n  const children = state.toFlow(state.all(rest))\n\n  /** @type {ListItem} */\n  const result = {type: 'listItem', spread, checked, children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Check if an element should spread out.\n *\n * The reason to spread out a markdown list item is primarily whether writing\n * the equivalent in markdown, would yield a spread out item.\n *\n * A spread out item results in `<p>` and `</p>` tags.\n * Otherwise, the phrasing would be output directly.\n * We can check for that: if there’s a `<p>` element, spread it out.\n *\n * But what if there are no paragraphs?\n * In that case, we can also assume that if two “block” things were written in\n * an item, that it is spread out, because blocks are typically joined by blank\n * lines, which also means a spread item.\n *\n * Lastly, because in HTML things can be wrapped in a `<div>` or similar, we\n * delve into non-phrasing elements here to figure out if they themselves\n * contain paragraphs or 2 or more flow non-phrasing elements.\n *\n * @param {Readonly<Element>} node\n * @returns {boolean}\n */\nfunction spreadout(node) {\n  let index = -1\n  let seenFlow = false\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element') {\n      if (phrasing(child)) continue\n\n      if (child.tagName === 'p' || seenFlow || spreadout(child)) {\n        return true\n      }\n\n      seenFlow = true\n    }\n  }\n\n  return false\n}\n\n/**\n * Extract a leading checkbox from a list item.\n *\n * If there was a leading checkbox, makes a deep clone of the node w/o the\n * leading checkbox; otherwise a reference to the given, untouched, node is\n * given back.\n *\n * So for example:\n *\n * ```html\n * <li><input type=\"checkbox\">Text</li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li>Text</li>\n * ```\n *\n * ```html\n * <li><p><input type=\"checkbox\">Text</p></li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li><p>Text</p></li>\n * ```\n *\n * @param {Readonly<Element>} node\n * @returns {ExtractResult}\n */\nfunction extractLeadingCheckbox(node) {\n  const head = node.children[0]\n\n  if (\n    head &&\n    head.type === 'element' &&\n    head.tagName === 'input' &&\n    head.properties &&\n    (head.properties.type === 'checkbox' || head.properties.type === 'radio')\n  ) {\n    const rest = {...node, children: node.children.slice(1)}\n    return {checkbox: head, rest}\n  }\n\n  // The checkbox may be nested in another element.\n  // If the first element has children, look for a leading checkbox inside it.\n  //\n  // This only handles nesting in `<p>` elements, which is most common.\n  // It’s possible a leading checkbox might be nested in other types of flow or\n  // phrasing elements (and *deeply* nested, which is not possible with `<p>`).\n  // Limiting things to `<p>` elements keeps this simpler for now.\n  if (head && head.type === 'element' && head.tagName === 'p') {\n    const {checkbox, rest: restHead} = extractLeadingCheckbox(head)\n\n    if (checkbox) {\n      const rest = {...node, children: [restHead, ...node.children.slice(1)]}\n      return {checkbox, rest}\n    }\n  }\n\n  return {checkbox: undefined, rest: node}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem, List} from 'mdast'\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List}\n *   mdast node.\n */\nexport function list(state, node) {\n  const ordered = node.tagName === 'ol'\n  const children = state.toSpecificContent(state.all(node), create)\n  /** @type {number | null} */\n  let start = null\n\n  if (ordered) {\n    start =\n      node.properties && node.properties.start\n        ? Number.parseInt(String(node.properties.start), 10)\n        : 1\n  }\n\n  /** @type {List} */\n  const result = {\n    type: 'list',\n    ordered,\n    start,\n    spread: listItemsSpread(children),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n","/**\n * @import {} from 'mdast-util-to-hast'\n * @import {\n *   BlockContent,\n *   Delete,\n *   Link,\n *   Nodes,\n *   Paragraph,\n *   Parents,\n *   PhrasingContent,\n *   RootContent\n * } from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\nimport {dropSurroundingBreaks} from './drop-surrounding-breaks.js'\n\n/**\n * Check if there are phrasing mdast nodes.\n *\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesn’t need a wrapper paragraph.\n *\n * @param {Array<Nodes>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap runs of phrasing content into paragraphs, leaving the non-phrasing\n * content as-is.\n *\n * @param {Array<RootContent>} nodes\n *   Content.\n * @returns {Array<BlockContent>}\n *   Content where phrasing is wrapped in paragraphs.\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing, function (d) {\n    return d\n  })\n\n  /**\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<Paragraph>}\n   */\n  function onphrasing(nodes) {\n    return nodes.every(function (d) {\n      return d.type === 'text' ? whitespace(d.value) : false\n    })\n      ? []\n      : [{type: 'paragraph', children: dropSurroundingBreaks(nodes)}]\n  }\n}\n\n/**\n * @param {Delete | Link} node\n * @returns {Array<BlockContent>}\n */\nfunction split(node) {\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<BlockContent>}\n   */\n  function onphrasing(nodes) {\n    const newParent = cloneWithoutChildren(node)\n    newParent.children = nodes\n    // @ts-expect-error Assume fine.\n    return [newParent]\n  }\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {BlockContent} child\n   * @returns {BlockContent}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const newParent = cloneWithoutChildren(node)\n      const newChild = cloneWithoutChildren(child)\n      // @ts-expect-error Assume fine.\n      newParent.children = child.children\n      // @ts-expect-error Assume fine.\n      newChild.children.push(newParent)\n      return newChild\n    }\n\n    return {...child}\n  }\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of input nodes.\n * @param {(nodes: Array<PhrasingContent>) => Array<BlockContent>} onphrasing\n *   Turn phrasing content into block content.\n * @param {(node: BlockContent) => BlockContent} onnonphrasing\n *   Map block content (defaults to keeping them as-is).\n * @returns {Array<BlockContent>}\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const flattened = flatten(nodes)\n  /** @type {Array<BlockContent>} */\n  const result = []\n  /** @type {Array<PhrasingContent>} */\n  let queue = []\n  let index = -1\n\n  while (++index < flattened.length) {\n    const node = flattened[index]\n\n    if (phrasing(node)) {\n      queue.push(node)\n    } else {\n      if (queue.length > 0) {\n        result.push(...onphrasing(queue))\n        queue = []\n      }\n\n      // @ts-expect-error Assume non-phrasing.\n      result.push(onnonphrasing(node))\n    }\n  }\n\n  if (queue.length > 0) {\n    result.push(...onphrasing(queue))\n    queue = []\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of nodes, will unravel `delete` and `link`.\n * @returns {Array<RootContent>}\n *   Unraveled nodes.\n */\nfunction flatten(nodes) {\n  /** @type {Array<RootContent>} */\n  const flattened = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we don’t need to worry about that.\n    // `map` maps to its content, so we don’t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What we’ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened.push(...split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {Nodes} node\n *   mdast node to check.\n * @returns {node is PhrasingContent}\n *   Whether `node` is phrasing content (includes nodes with `hName` fields\n *   set to phrasing hast element names).\n */\nfunction phrasing(node) {\n  const tagName = node.data && node.data.hName\n  return tagName\n    ? hastPhrasing({type: 'element', tagName, properties: {}, children: []})\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {Parents} ParentType\n *   Parent type.\n * @param {ParentType} node\n *   Node to clone.\n * @returns {ParentType}\n *   Cloned node, without children.\n */\nfunction cloneWithoutChildren(node) {\n  return structuredClone({...node, children: []})\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, PhrasingContent, RootContent as MdastRootContent, Root} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\nimport {EXIT, visit} from 'unist-util-visit'\nimport {wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent> | Link}\n *   mdast node.\n */\nexport function media(state, node) {\n  const properties = node.properties || {}\n  const poster = node.tagName === 'video' ? String(properties.poster || '') : ''\n  let source = String(properties.src || '')\n  let index = -1\n  let linkInFallbackContent = false\n  let nodes = state.all(node)\n\n  /** @type {Root} */\n  const fragment = {type: 'root', children: nodes}\n\n  visit(fragment, function (node) {\n    if (node.type === 'link') {\n      linkInFallbackContent = true\n      return EXIT\n    }\n  })\n\n  // If the content links to something, or if it’s not phrasing…\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!source && ++index < node.children.length) {\n    const child = node.children[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'source' &&\n      child.properties\n    ) {\n      source = String(child.properties.src || '')\n    }\n  }\n\n  // If there’s a poster defined on the video, create an image.\n  if (poster) {\n    /** @type {Image} */\n    const image = {\n      type: 'image',\n      title: null,\n      url: state.resolve(poster),\n      alt: toString(nodes)\n    }\n    state.patch(node, image)\n    nodes = [image]\n  }\n\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (nodes)\n\n  // Link to the media resource.\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: properties.title ? String(properties.title) : null,\n    url: state.resolve(source),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Paragraph, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Paragraph | undefined}\n *   mdast node.\n */\nexport function p(state, node) {\n  const children = dropSurroundingBreaks(\n    // Allow potentially “invalid” nodes, they might be unknown.\n    // We also support straddling later.\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  if (children.length > 0) {\n    /** @type {Paragraph} */\n    const result = {type: 'paragraph', children}\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RootContent as MdastRootContent} from 'mdast'\n */\n\nconst defaultQuotes = ['\"']\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent>}\n *   mdast nodes.\n */\nexport function q(state, node) {\n  const quotes = state.options.quotes || defaultQuotes\n\n  state.qNesting++\n  const contents = state.all(node)\n  state.qNesting--\n\n  const quote = quotes[state.qNesting % quotes.length]\n  const head = contents[0]\n  const tail = contents[contents.length - 1]\n  const open = quote.charAt(0)\n  const close = quote.length > 1 ? quote.charAt(1) : quote\n\n  if (head && head.type === 'text') {\n    head.value = open + head.value\n  } else {\n    contents.unshift({type: 'text', value: open})\n  }\n\n  if (tail && tail.type === 'text') {\n    tail.value += close\n  } else {\n    contents.push({type: 'text', value: close})\n  }\n\n  return contents\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n */\n\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastRoot>} node\n *   hast root to transform.\n * @returns {MdastRoot}\n *   mdast node.\n */\nexport function root(state, node) {\n  let children = state.all(node)\n\n  if (state.options.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  /** @type {MdastRoot} */\n  const result = {type: 'root', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text | undefined}\n *   mdast node.\n */\nexport function select(state, node) {\n  const values = findSelectedOptions(node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < values.length) {\n    const value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    /** @type {Text} */\n    const result = {type: 'text', value: results.join(', ')}\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, Strong} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Strong}\n *   mdast node.\n */\nexport function strong(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Strong} */\n  const result = {type: 'strong', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, TableCell} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableCell}\n *   mdast node.\n */\nexport function tableCell(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {TableCell} */\n  const result = {type: 'tableCell', children}\n  state.patch(node, result)\n\n  if (node.properties) {\n    const rowSpan = node.properties.rowSpan\n    const colSpan = node.properties.colSpan\n\n    if (rowSpan || colSpan) {\n      const data = /** @type {Record<string, unknown>} */ (\n        result.data || (result.data = {})\n      )\n      if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan\n      if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan\n    }\n  }\n\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RowContent, TableRow} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableRow}\n *   mdast node.\n */\nexport function tableRow(state, node) {\n  const children = state.toSpecificContent(state.all(node), create)\n\n  /** @type {TableRow} */\n  const result = {type: 'tableRow', children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {RowContent}\n */\nfunction create() {\n  return {type: 'tableCell', children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {AlignType, RowContent, TableContent, Table, Text} from 'mdast'\n */\n\n/**\n * @typedef Info\n *   Inferred info on a table.\n * @property {Array<AlignType>} align\n *   Alignment.\n * @property {boolean} headless\n *   Whether a `thead` is missing.\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Table | Text}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function table(state, node) {\n  // Ignore nested tables.\n  if (state.inTable) {\n    /** @type {Text} */\n    const result = {type: 'text', value: toText(node)}\n    state.patch(node, result)\n    return result\n  }\n\n  state.inTable = true\n\n  const {align, headless} = inspect(node)\n  const rows = state.toSpecificContent(state.all(node), createRow)\n\n  // Add an empty header row.\n  if (headless) {\n    rows.unshift(createRow())\n  }\n\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const row = rows[rowIndex]\n    const cells = state.toSpecificContent(row.children, createCell)\n    row.children = cells\n  }\n\n  let columns = 1\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const data = /** @type {Record<string, unknown>} */ (cell.data)\n        const colSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1\n        const rowSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Don’t add rows that don’t exist.\n                // Browsers don’t render them either.\n                break\n              }\n\n              /** @type {Array<RowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('hastUtilToMdastTemporaryColSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryColSpan\n        if ('hastUtilToMdastTemporaryRowSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryRowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  state.inTable = false\n\n  /** @type {Table} */\n  const result = {type: 'table', align, children: rows}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Readonly<Element>} node\n *   Table element to check.\n * @returns {Info}\n *   Info.\n */\nfunction inspect(node) {\n  /** @type {Info} */\n  const info = {align: [null], headless: true}\n  let rowIndex = 0\n  let cellIndex = 0\n\n  visit(node, function (child) {\n    if (child.type === 'element') {\n      // Don’t enter nested tables.\n      if (child.tagName === 'table' && node !== child) {\n        return SKIP\n      }\n\n      if (\n        (child.tagName === 'th' || child.tagName === 'td') &&\n        child.properties\n      ) {\n        if (!info.align[cellIndex]) {\n          const value = String(child.properties.align || '') || null\n\n          if (\n            value === 'center' ||\n            value === 'left' ||\n            value === 'right' ||\n            value === null\n          ) {\n            info.align[cellIndex] = value\n          }\n        }\n\n        // If there is a `th` in the first row, assume there is a header row.\n        if (info.headless && rowIndex < 2 && child.tagName === 'th') {\n          info.headless = false\n        }\n\n        cellIndex++\n      }\n      // If there is a `thead`, assume there is a header row.\n      else if (child.tagName === 'thead') {\n        info.headless = false\n      } else if (child.tagName === 'tr') {\n        rowIndex++\n        cellIndex = 0\n      }\n    }\n  })\n\n  return info\n}\n\n/**\n * @returns {RowContent}\n */\nfunction createCell() {\n  return {type: 'tableCell', children: []}\n}\n\n/**\n * @returns {TableContent}\n */\nfunction createRow() {\n  return {type: 'tableRow', children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Text as HastText} from 'hast'\n * @import {Text as MdastText} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastText>} node\n *   hast element to transform.\n * @returns {MdastText}\n *   mdast node.\n */\nexport function text(state, node) {\n  /** @type {MdastText} */\n  const result = {type: 'text', value: node.value}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function textarea(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function wbr(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: '\\u200B'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Parents} from 'hast'\n */\n\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\n/**\n * Default handlers for nodes.\n *\n * Each key is a node type, each value is a `NodeHandler`.\n */\nexport const nodeHandlers = {\n  comment,\n  doctype: ignore,\n  root,\n  text\n}\n\n/**\n * Default handlers for elements.\n *\n * Each key is an element name, each value is a `Handler`.\n */\nexport const handlers = {\n  // Ignore:\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  // Use children:\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  // Use children as flow.\n  address: flow,\n  article: flow,\n  aside: flow,\n  body: flow,\n  center: flow,\n  div: flow,\n  fieldset: flow,\n  figcaption: flow,\n  figure: flow,\n  form: flow,\n  footer: flow,\n  header: flow,\n  hgroup: flow,\n  html: flow,\n  legend: flow,\n  main: flow,\n  multicol: flow,\n  nav: flow,\n  picture: flow,\n  section: flow,\n\n  // Handle.\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction all(state, node) {\n  return state.all(node)\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction flow(state, node) {\n  return state.toFlow(state.all(node))\n}\n\n/**\n * @returns {undefined}\n */\nfunction ignore() {}\n","/**\n * @import {Element, Nodes, Parents} from 'hast'\n * @import {\n *   BlockContent as MdastBlockContent,\n *   DefinitionContent as MdastDefinitionContent,\n *   Nodes as MdastNodes,\n *   Parents as MdastParents,\n *   RootContent as MdastRootContent\n * } from 'mdast'\n */\n\n/**\n * @typedef {MdastBlockContent | MdastDefinitionContent} MdastFlowContent\n */\n\n/**\n * @callback All\n *   Transform the children of a hast parent to mdast.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n *\n * @callback Handle\n *   Handle a particular element.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Element} element\n *   Element to transform.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback NodeHandle\n *   Handle a particular node.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {any} node\n *   Node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback One\n *   Transform a hast node to mdast.\n * @param {Nodes} node\n *   Expected hast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n *\n * @typedef Options\n *   Configuration.\n * @property {string | null | undefined} [checked='[x]']\n *   Value to use for a checked checkbox or radio input (default: `'[x]'`)\n * @property {boolean | null | undefined} [document]\n *   Whether the given tree represents a complete document (optional).\n *\n *   Applies when the `tree` is a `root` node.\n *   When the tree represents a complete document, then things are wrapped in\n *   paragraphs when needed, and otherwise they’re left as-is.\n *   The default checks for whether there’s mixed content: some phrasing nodes\n *   *and* some non-phrasing nodes.\n * @property {Record<string, Handle | null | undefined> | null | undefined} [handlers]\n *   Object mapping tag names to functions handling the corresponding elements\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {boolean | null | undefined} [newlines=false]\n *   Keep line endings when collapsing whitespace (default: `false`).\n *\n *   The default collapses to a single space.\n * @property {Record<string, NodeHandle | null | undefined> | null | undefined} [nodeHandlers]\n *   Object mapping node types to functions handling the corresponding nodes\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {Array<string> | null | undefined} [quotes=['\"']]\n *   List of quotes to use (default: `['\"']`).\n *\n *   Each value can be one or two characters.\n *   When two, the first character determines the opening quote and the second\n *   the closing quote at that level.\n *   When one, both the opening and closing quote are that character.\n *\n *   The order in which the preferred quotes appear determines which quotes to\n *   use at which level of nesting.\n *   So, to prefer `‘’` at the first level of nesting, and `“”` at the second,\n *   pass `['‘’', '“”']`.\n *   If `<q>`s are nested deeper than the given amount of quotes, the markers\n *   wrap around: a third level of nesting when using `['«»', '‹›']` should\n *   have double guillemets, a fourth single, a fifth double again, etc.\n * @property {string | null | undefined} [unchecked='[ ]']\n *   Value to use for an unchecked checkbox or radio input (default: `'[ ]'`).\n *\n * @callback Patch\n *   Copy a node’s positional info.\n * @param {Nodes} from\n *   hast node to copy from.\n * @param {MdastNodes} to\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback Resolve\n *   Resolve a URL relative to a base.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {All} all\n *   Transform the children of a hast parent to mdast.\n * @property {boolean} baseFound\n *   Whether a `<base>` element was seen.\n * @property {Map<string, Element>} elementById\n *   Elements by their `id`.\n * @property {string | undefined} frozenBaseUrl\n *   `href` of `<base>`, if any.\n * @property {Record<string, Handle>} handlers\n *   Applied element handlers.\n * @property {boolean} inTable\n *   Whether we’re in a table.\n * @property {Record<string, NodeHandle>} nodeHandlers\n *   Applied node handlers.\n * @property {One} one\n *   Transform a hast node to mdast.\n * @property {Options} options\n *   User configuration.\n * @property {Patch} patch\n *   Copy a node’s positional info.\n * @property {number} qNesting\n *   Non-negative finite integer representing how deep we’re in `<q>`s.\n * @property {Resolve} resolve\n *   Resolve a URL relative to a base.\n * @property {ToFlow} toFlow\n *   Transform a list of mdast nodes to flow.\n * @property {<ChildType extends MdastNodes, ParentType extends MdastParents & {'children': Array<ChildType>}>(nodes: Array<MdastRootContent>, build: (() => ParentType)) => Array<ParentType>} toSpecificContent\n *   Turn arbitrary content into a list of a particular node type.\n *\n *   This is useful for example for lists, which must have list items as\n *   content.\n *   in this example, when non-items are found, they will be queued, and\n *   inserted into an adjacent item.\n *   When no actual items exist, one will be made with `build`.\n *\n * @callback ToFlow\n *   Transform a list of mdast nodes to flow.\n * @param {Array<MdastRootContent>} nodes\n *   mdast nodes.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\n\nimport {position} from 'unist-util-position'\nimport {handlers, nodeHandlers} from './handlers/index.js'\nimport {wrap} from './util/wrap.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a state.\n *\n * @param {Readonly<Options>} options\n *   User configuration.\n * @returns {State}\n *   State.\n */\nexport function createState(options) {\n  return {\n    all,\n    baseFound: false,\n    elementById: new Map(),\n    frozenBaseUrl: undefined,\n    handlers: {...handlers, ...options.handlers},\n    inTable: false,\n    nodeHandlers: {...nodeHandlers, ...options.nodeHandlers},\n    one,\n    options,\n    patch,\n    qNesting: 0,\n    resolve,\n    toFlow,\n    toSpecificContent\n  }\n}\n\n/**\n * Transform the children of a hast parent to mdast.\n *\n * You might want to combine this with `toFlow` or `toSpecificContent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n */\nfunction all(parent) {\n  const children = parent.children || []\n  /** @type {Array<MdastRootContent>} */\n  const results = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Content -> content.\n    const result =\n      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */ (\n        this.one(child, parent)\n      )\n\n    if (Array.isArray(result)) {\n      results.push(...result)\n    } else if (result) {\n      results.push(result)\n    }\n  }\n\n  return results\n}\n\n/**\n * Transform a hast node to mdast.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n */\nfunction one(node, parent) {\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(this.handlers, node.tagName)) {\n      return this.handlers[node.tagName](this, node, parent) || undefined\n    }\n  } else if (own.call(this.nodeHandlers, node.type)) {\n    return this.nodeHandlers[node.type](this, node, parent) || undefined\n  }\n\n  // Unknown literal.\n  if ('value' in node && typeof node.value === 'string') {\n    /** @type {MdastRootContent} */\n    const result = {type: 'text', value: node.value}\n    this.patch(node, result)\n    return result\n  }\n\n  // Unknown parent.\n  if ('children' in node) {\n    return this.all(node)\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {Nodes} origin\n *   hast node to copy from.\n * @param {MdastNodes} node\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(origin, node) {\n  if (origin.position) node.position = position(origin)\n}\n\n/**\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n */\nfunction resolve(url) {\n  const base = this.frozenBaseUrl\n\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (base) {\n    return String(new URL(url, base))\n  }\n\n  return url\n}\n\n/**\n * Transform a list of mdast nodes to flow.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Array<MdastRootContent>} nodes\n *   Parent.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\nfunction toFlow(nodes) {\n  return wrap(nodes)\n}\n\n/**\n * Turn arbitrary content into a particular node type.\n *\n * This is useful for example for lists, which must have list items as content.\n * in this example, when non-items are found, they will be queued, and\n * inserted into an adjacent item.\n * When no actual items exist, one will be made with `build`.\n *\n * @template {MdastNodes} ChildType\n *   Node type of children.\n * @template {MdastParents & {'children': Array<ChildType>}} ParentType\n *   Node type of parent.\n * @param {Array<MdastRootContent>} nodes\n *   Nodes, which are either `ParentType`, or will be wrapped in one.\n * @param {() => ParentType} build\n *   Build a parent if needed (must have empty `children`).\n * @returns {Array<ParentType>}\n *   List of parents.\n */\nfunction toSpecificContent(nodes, build) {\n  const reference = build()\n  /** @type {Array<ParentType>} */\n  const results = []\n  /** @type {Array<ChildType>} */\n  let queue = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (expectedParent(node)) {\n      if (queue.length > 0) {\n        node.children.unshift(...queue)\n        queue = []\n      }\n\n      results.push(node)\n    } else {\n      // Assume `node` can be a child of `ParentType`.\n      // If we start checking nodes, we’d run into problems with unknown nodes,\n      // which we do want to support.\n      const child = /** @type {ChildType} */ (node)\n      queue.push(child)\n    }\n  }\n\n  if (queue.length > 0) {\n    let node = results[results.length - 1]\n\n    if (!node) {\n      node = build()\n      results.push(node)\n    }\n\n    node.children.push(...queue)\n    queue = []\n  }\n\n  return results\n\n  /**\n   * @param {MdastNodes} node\n   * @returns {node is ParentType}\n   */\n  function expectedParent(node) {\n    return node.type === reference.type\n  }\n}\n","/**\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Nodes} from 'hast'\n * @import {Nodes as MdastNodes, RootContent as MdastRootContent} from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visit} from 'unist-util-visit'\nimport {createState} from './state.js'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Transform hast to mdast.\n *\n * @param {Readonly<Nodes>} tree\n *   hast tree to transform.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {MdastNodes}\n *   mdast tree.\n */\nexport function toMdast(tree, options) {\n  // We have to clone, cause we’ll use `rehype-minify-whitespace` on the tree,\n  // which modifies.\n  const cleanTree = structuredClone(tree)\n  const settings = options || emptyOptions\n  const transformWhitespace = rehypeMinifyWhitespace({\n    newlines: settings.newlines === true\n  })\n  const state = createState(settings)\n  /** @type {MdastNodes} */\n  let mdast\n\n  // @ts-expect-error: fine to pass an arbitrary node.\n  transformWhitespace(cleanTree)\n\n  visit(cleanTree, function (node) {\n    if (node && node.type === 'element' && node.properties) {\n      const id = String(node.properties.id || '') || undefined\n\n      if (id && !state.elementById.has(id)) {\n        state.elementById.set(id, node)\n      }\n    }\n  })\n\n  const result = state.one(cleanTree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    // Assume content.\n    const children = /** @type {Array<MdastRootContent>} */ (result)\n    mdast = {type: 'root', children}\n  } else {\n    mdast = result\n  }\n\n  // Collapse text nodes, and fix whitespace.\n  //\n  // Most of this is taken care of by `rehype-minify-whitespace`, but\n  // we’re generating some whitespace too, and some nodes are in the end\n  // ignored.\n  // So clean up.\n  visit(mdast, function (node, index, parent) {\n    if (node.type === 'text' && index !== undefined && parent) {\n      const previous = parent.children[index - 1]\n\n      if (previous && previous.type === node.type) {\n        previous.value += node.value\n        parent.children.splice(index, 1)\n\n        if (previous.position && node.position) {\n          previous.position.end = node.position.end\n        }\n\n        // Iterate over the previous node again, to handle its total value.\n        return index - 1\n      }\n\n      node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n      // We don’t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n      // as there the whitespace matters.\n      if (\n        parent &&\n        (parent.type === 'heading' ||\n          parent.type === 'paragraph' ||\n          parent.type === 'root')\n      ) {\n        if (!index) {\n          node.value = node.value.replace(/^[\\t ]+/, '')\n        }\n\n        if (index === parent.children.length - 1) {\n          node.value = node.value.replace(/[\\t ]+$/, '')\n        }\n      }\n\n      if (!node.value) {\n        parent.children.splice(index, 1)\n        return index\n      }\n    }\n  })\n\n  return mdast\n}\n","/**\n * List of HTML tag names that are whitespace sensitive.\n */\nexport const whitespaceSensitiveTagNames = [\n  'pre',\n  'script',\n  'style',\n  'textarea'\n]\n","/**\n * @import {Nodes, RootContent, Root} from 'hast'\n * @import {BuildVisitor} from 'unist-util-visit-parents'\n * @import {Options, State} from './types.js'\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Root} tree\n *   Tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport function format(tree, options) {\n  const settings = options || emptyOptions\n\n  /** @type {State} */\n  const state = {\n    blanks: settings.blanks || [],\n    head: false,\n    indentInitial: settings.indentInitial !== false,\n    indent:\n      typeof settings.indent === 'number'\n        ? ' '.repeat(settings.indent)\n        : typeof settings.indent === 'string'\n          ? settings.indent\n          : '  '\n  }\n\n  minifyWhitespace(tree, {newlines: true})\n\n  visitParents(tree, visitor)\n\n  /**\n   * @type {BuildVisitor<Root>}\n   */\n  function visitor(node, parents) {\n    if (!('children' in node)) {\n      return\n    }\n\n    if (node.type === 'element' && node.tagName === 'head') {\n      state.head = true\n    }\n\n    if (state.head && node.type === 'element' && node.tagName === 'body') {\n      state.head = false\n    }\n\n    if (\n      node.type === 'element' &&\n      whitespaceSensitiveTagNames.includes(node.tagName)\n    ) {\n      return SKIP\n    }\n\n    // Don’t indent content of whitespace-sensitive nodes / inlines.\n    if (node.children.length === 0 || !padding(state, node)) {\n      return\n    }\n\n    let level = parents.length\n\n    if (!state.indentInitial) {\n      level--\n    }\n\n    let eol = false\n\n    // Indent newlines in `text`.\n    for (const child of node.children) {\n      if (child.type === 'comment' || child.type === 'text') {\n        if (child.value.includes('\\n')) {\n          eol = true\n        }\n\n        child.value = child.value.replace(\n          / *\\n/g,\n          '$&' + state.indent.repeat(level)\n        )\n      }\n    }\n\n    /** @type {Array<RootContent>} */\n    const result = []\n    /** @type {RootContent | undefined} */\n    let previous\n\n    for (const child of node.children) {\n      if (padding(state, child) || (eol && !previous)) {\n        addBreak(result, level, child)\n        eol = true\n      }\n\n      previous = child\n      result.push(child)\n    }\n\n    if (previous && (eol || padding(state, previous))) {\n      // Ignore trailing whitespace (if that already existed), as we’ll add\n      // properly indented whitespace.\n      if (whitespace(previous)) {\n        result.pop()\n        previous = result[result.length - 1]\n      }\n\n      addBreak(result, level - 1)\n    }\n\n    node.children = result\n  }\n\n  /**\n   * @param {Array<RootContent>} list\n   *   Nodes.\n   * @param {number} level\n   *   Indentation level.\n   * @param {RootContent | undefined} [next]\n   *   Next node.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = tail && whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(state, previous) && blank(state, next) ? '\\n\\n' : '\\n') +\n      state.indent.repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes | undefined} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is a blank.\n */\nfunction blank(state, node) {\n  return Boolean(\n    node &&\n      node.type === 'element' &&\n      state.blanks.length > 0 &&\n      state.blanks.includes(node.tagName)\n  )\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` should be padded.\n */\nfunction padding(state, node) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? state.head ||\n        node.tagName === 'script' ||\n        embedded(node) ||\n        !phrasing(node)\n      : false)\n  )\n}\n","export function computeHighlightRanges(input) {\n  const numbers = Array.isArray(input) ? input.map(Number) : input.split(\",\").map(Number);\n  const ranges = [];\n  let start = numbers[0];\n  for (let i = 1; i <= numbers.length; i++) {\n    if (numbers[i] !== numbers[i - 1] + 1) {\n      if (start === numbers[i - 1]) {\n        ranges.push(`${start}`);\n      } else {\n        ranges.push(`${start}-${numbers[i - 1]}`);\n      }\n      start = numbers[i];\n    }\n  }\n  return ranges.join(\",\");\n}\nexport function refineCodeLanguage(language) {\n  return String(language || \"\").trim();\n}\n","import { defaultHandlers, toMdast } from \"hast-util-to-mdast\";\nimport { nodeTextContent } from \"@nuxtjs/mdc/runtime/utils/node\";\nimport { hasProtocol } from \"ufo\";\nimport { toHtml } from \"hast-util-to-html\";\nimport { visit } from \"unist-util-visit\";\nimport { format } from \"hast-util-format\";\nimport { computeHighlightRanges, refineCodeLanguage } from \"./utils.js\";\nconst mdcRemarkElementType = \"mdc-element\";\nconst mdastTextComponentType = \"textDirective\";\nconst mdcTextComponentType = \"textComponent\";\nconst own = {}.hasOwnProperty;\nexport function mdcRemark(options) {\n  return function(node, _file) {\n    const tree = preProcessElementNodes(node);\n    const mdast = toMdast(tree, {\n      /**\n       * Default to true in rehype-remark\n       * @see https://github.com/rehypejs/rehype-remark/blob/main/lib/index.js#L37ckages/remark/lib/index.js#L100\n       */\n      document: true,\n      newlines: true,\n      ...options,\n      handlers: {\n        ...mdcRemarkHandlers,\n        ...options?.handlers\n      },\n      nodeHandlers: {\n        ...mdcRemarkNodeHandlers,\n        ...options?.nodeHandlers\n      }\n    });\n    visit(mdast, (node2) => node2.type === mdastTextComponentType, (node2, index, parent) => {\n      node2.type = mdcTextComponentType;\n      if (node2.name === \"binding\") {\n        return;\n      }\n      if (index && parent && parent.children) {\n        if (index > 0 && parent.children[index - 1]?.type === \"text\") {\n          const text = parent.children[index - 1];\n          if (![\"\\n\", \" \", \"\t\"].includes(text.value.slice(-1))) {\n            text.value += \" \";\n          }\n        }\n        if (index && index < parent.children.length - 1 && parent.children[index + 1]?.type === \"text\") {\n          const text = parent.children[index + 1];\n          if (![\"\\n\", \" \", \"\t\", \",\", \".\"].includes(text.value.slice(0, 1))) {\n            text.value = \" \" + text.value;\n          }\n        }\n      }\n    });\n    return mdast;\n  };\n}\nfunction preProcessElementNodes(node) {\n  if (node.type === \"element\") {\n    if (node.children?.length && (node.children || []).every((child) => child.tag === \"template\")) {\n      node.children = node.children.flatMap((child) => {\n        if (typeof child.props?.[\"v-slot:default\"] !== \"undefined\" && Object.keys(child.props).length === 1) {\n          return child.children || [];\n        }\n        return child;\n      });\n    }\n    const result = {\n      type: mdcRemarkElementType,\n      tagName: node.tag,\n      properties: node.props,\n      children: (node.children || []).map(preProcessElementNodes)\n    };\n    if (!node.children?.length) {\n      delete result.children;\n    }\n    return result;\n  }\n  if (node?.children) {\n    return {\n      ...node,\n      children: (node.children || []).map(preProcessElementNodes)\n    };\n  }\n  return node;\n}\nconst mdcRemarkNodeHandlers = {\n  [mdcRemarkElementType]: (state, node, parent) => {\n    if (node.properties && node.properties.dataMdast === \"ignore\") {\n      return;\n    }\n    if (node.properties && (node.properties.className || node.properties[\"class-name\"])) {\n      const pascal = Array.isArray(node.properties.className || \"\") ? node.properties.className : String(node.properties.className || \"\").split(\" \");\n      const kebab = Array.isArray(node.properties[\"class-name\"] || \"\") ? node.properties[\"class-name\"] : String(node.properties[\"class-name\"] || \"\").split(\" \");\n      node.properties.class = [node.properties.class || \"\", ...pascal, ...kebab].filter(Boolean).join(\" \");\n      Reflect.deleteProperty(node.properties, \"className\");\n      Reflect.deleteProperty(node.properties, \"class-name\");\n    }\n    if (own.call(state.handlers, node.tagName)) {\n      return state.handlers[node.tagName](state, node, parent) || void 0;\n    }\n    if (\"value\" in node && typeof node.value === \"string\") {\n      const result = { type: \"text\", value: node.value };\n      state.patch(node, result);\n      return result;\n    }\n    const isInlineElement = (parent?.children || []).some((child) => child.type === \"text\") || [\"p\", \"li\", \"strong\", \"em\", \"span\"].includes(parent?.tagName);\n    if (isInlineElement) {\n      return {\n        type: mdastTextComponentType,\n        name: node.tagName,\n        attributes: node.properties,\n        children: state.all(node)\n      };\n    }\n    return {\n      type: \"containerComponent\",\n      name: node.tagName,\n      attributes: node.properties,\n      children: state.all(node)\n    };\n  }\n};\nconst mdcRemarkHandlers = {\n  template: (state, node) => {\n    const vSlot = Object.keys(node.properties || {}).find((prop) => prop?.startsWith(\"v-slot:\"))?.replace(\"v-slot:\", \"\") || \"default\";\n    const attributes = Object.fromEntries(Object.entries(node.properties || {}).filter(([key]) => !key.startsWith(\"v-slot:\")));\n    return {\n      type: \"componentContainerSection\",\n      name: vSlot,\n      attributes,\n      children: state.toFlow(state.all(node))\n    };\n  },\n  div: (state, node) => {\n    return {\n      type: \"containerComponent\",\n      name: \"div\",\n      attributes: node.properties,\n      children: state.toFlow(state.all(node))\n    };\n  },\n  code: (state, node) => {\n    const attributes = { ...node.properties };\n    if (\"style\" in attributes && !attributes.style) {\n      delete attributes.style;\n    }\n    if (\"class\" in attributes) {\n      attributes.className = String(attributes.class).split(\" \").filter(Boolean);\n      delete attributes.class;\n    }\n    if (Array.isArray(attributes.className)) {\n      attributes.className = attributes.className.filter((name) => !name.startsWith(\"language-\"));\n      if (Array.isArray(attributes.className) && !attributes.className.length) {\n        delete attributes.className;\n      }\n    }\n    if (attributes.language) {\n      attributes.lang = refineCodeLanguage(attributes.language);\n      delete attributes.language;\n    }\n    const result = { type: \"inlineCode\", value: nodeTextContent(node), attributes };\n    state.patch(node, result);\n    return result;\n  },\n  pre: (_state, node) => {\n    const meta = [\n      node.properties.filename ? `[${String(node.properties.filename).replace(/\\]/g, \"\\\\]\")}]` : \"\",\n      node.properties.highlights?.length ? `{${computeHighlightRanges(node.properties.highlights)}}` : \"\",\n      node.properties.meta\n    ].filter(Boolean).join(\" \");\n    const value = String(node.properties.code || \"\").replace(/\\n$/, \"\");\n    return {\n      type: \"code\",\n      value,\n      lang: refineCodeLanguage(node.properties.language),\n      meta\n    };\n  },\n  button: (state, node) => {\n    if (\n      // @ts-expect-error: custom type\n      node.children?.find((child) => child.type === mdcRemarkElementType) || node.children?.find((child) => child.type === \"text\" && child.value.includes(\"\\n\"))\n    ) {\n      return {\n        type: \"containerComponent\",\n        name: \"button\",\n        children: state.all(node),\n        attributes: node.properties\n      };\n    }\n    return createTextComponent(\"button\")(state, node);\n  },\n  span: createTextComponent(\"span\"),\n  binding: createTextComponent(\"binding\"),\n  iframe: createTextComponent(\"iframe\"),\n  video: createTextComponent(\"video\"),\n  \"nuxt-img\": createTextComponent(\"nuxt-img\"),\n  \"nuxt-picture\": createTextComponent(\"nuxt-picture\"),\n  br: createTextComponent(\"br\"),\n  table: (state, node) => {\n    visit(node, (node2) => {\n      if (node2.type === mdcRemarkElementType) {\n        node2.type = \"element\";\n      }\n    });\n    if (Object.keys(node.properties).length) {\n      format({ type: \"root\", children: [node] });\n      return {\n        type: \"html\",\n        value: toHtml(node)\n      };\n    }\n    return defaultHandlers.table(state, node);\n  },\n  img: (state, node) => {\n    const { src, title, alt, ...attributes } = node.properties || {};\n    const result = {\n      type: \"image\",\n      url: state.resolve(String(src || \"\") || null),\n      title: title ? String(title) : null,\n      alt: alt ? String(alt) : \"\",\n      attributes\n    };\n    state.patch(node, result);\n    return result;\n  },\n  em: (state, node) => {\n    const result = { type: \"emphasis\", children: state.all(node), attributes: node.properties };\n    state.patch(node, result);\n    return result;\n  },\n  strong: (state, node) => {\n    const result = { type: \"strong\", children: state.all(node), attributes: node.properties };\n    state.patch(node, result);\n    return result;\n  },\n  a(state, node) {\n    const { href, title, ...attributes } = node.properties || {};\n    if (hasProtocol(String(href || \"\"))) {\n      if (attributes.target === \"_blank\") {\n        delete attributes.target;\n      }\n      if ([\"nofollow,noopener,noreferrer\"].includes(String(attributes.rel))) {\n        delete attributes.rel;\n      }\n    }\n    const result = {\n      type: \"link\",\n      url: state.resolve(String(href || \"\") || null),\n      title: title ? String(title) : null,\n      children: state.all(node),\n      attributes\n    };\n    state.patch(node, result);\n    return result;\n  }\n};\nfunction createTextComponent(name) {\n  return (state, node) => {\n    const result = {\n      type: mdastTextComponentType,\n      name,\n      attributes: node.properties,\n      children: state.all(node)\n    };\n    state.patch(node, result);\n    return result;\n  };\n}\n","import { unified } from \"unified\";\nimport gfm from \"remark-gfm\";\nimport mdc, { stringifyFrontMatter } from \"remark-mdc\";\nimport stringify from \"remark-stringify\";\nimport { mdcRemark } from \"./mdc-remark.js\";\nexport function createStringifyProcessor(options = {}) {\n  return unified().use(function jsonParser() {\n    this.parser = function(root) {\n      return JSON.parse(root);\n    };\n  }).use(mdcRemark).use(gfm).use(mdc).use(stringify, {\n    bullet: \"-\",\n    emphasis: \"*\",\n    rule: \"-\",\n    listItemIndent: \"one\",\n    fence: \"`\",\n    fences: true,\n    ...options?.plugins?.remarkStringify?.options\n  });\n}\nexport function createMarkdownStringifier(options = {}) {\n  const processor = createStringifyProcessor(options);\n  async function stringify2(value, data = {}) {\n    const result = await processor.process({ value: JSON.stringify(value) });\n    if (Object.keys(data).length) {\n      return stringifyFrontMatter(data, result.value);\n    }\n    return result.value;\n  }\n  return stringify2;\n}\nexport async function stringifyMarkdown(MDCAst, data, options = {}) {\n  const processor = createMarkdownStringifier(options);\n  if (!MDCAst) return null;\n  return await processor(MDCAst, data);\n}\n","import { createJavaScriptRegexEngine } from \"shiki/engine/javascript\";\nexport function createShikiHighlighter({\n  langs = [],\n  themes = [],\n  bundledLangs = {},\n  bundledThemes = {},\n  getMdcConfigs,\n  options: shikiOptions,\n  engine\n} = {}) {\n  let shiki;\n  let configs;\n  async function _getShiki() {\n    const { createHighlighterCore, addClassToHast, isSpecialLang, isSpecialTheme } = await import(\"@shikijs/core\");\n    const { transformerNotationDiff, transformerNotationErrorLevel, transformerNotationFocus, transformerNotationHighlight } = await import(\"@shikijs/transformers\");\n    const shiki2 = await createHighlighterCore({\n      langs,\n      themes,\n      engine: engine || createJavaScriptRegexEngine()\n    });\n    for await (const config of await getConfigs()) {\n      await config.shiki?.setup?.(shiki2);\n    }\n    return {\n      shiki: shiki2,\n      addClassToHast,\n      isSpecialLang,\n      isSpecialTheme,\n      transformers: [\n        transformerNotationDiff(),\n        transformerNotationErrorLevel(),\n        transformerNotationFocus(),\n        transformerNotationHighlight()\n      ]\n    };\n  }\n  async function getShiki() {\n    if (!shiki) {\n      shiki = _getShiki();\n    }\n    return shiki;\n  }\n  async function getConfigs() {\n    if (!configs) {\n      configs = Promise.resolve(getMdcConfigs?.() || []);\n    }\n    return configs;\n  }\n  const highlighter = async (code, lang, theme, options = {}) => {\n    const {\n      shiki: shiki2,\n      addClassToHast,\n      isSpecialLang,\n      isSpecialTheme,\n      transformers: baseTransformers\n    } = await getShiki();\n    const codeToHastOptions = {\n      defaultColor: false,\n      meta: {\n        __raw: options.meta\n      }\n    };\n    if (lang === \"ts-type\" || lang === \"typescript-type\") {\n      lang = \"typescript\";\n      codeToHastOptions.grammarContextCode = \"let a:\";\n    } else if (lang === \"vue-html\" || lang === \"vue-template\") {\n      lang = \"vue\";\n      codeToHastOptions.grammarContextCode = \"<template>\";\n    }\n    const themesObject = { ...typeof theme === \"string\" ? { default: theme } : theme || {} };\n    const loadedThemes = shiki2.getLoadedThemes();\n    const loadedLanguages = shiki2.getLoadedLanguages();\n    if (typeof lang === \"string\" && !loadedLanguages.includes(lang) && !isSpecialLang(lang)) {\n      if (bundledLangs[lang]) {\n        await shiki2.loadLanguage(bundledLangs[lang]);\n      } else {\n        if (process.dev) {\n          console.warn(`[@nuxtjs/mdc] Language \"${lang}\" is not loaded to the Shiki highlighter, fallback to plain text. Add the language to \"mdc.highlight.langs\" to fix this.`);\n        }\n        lang = \"text\";\n      }\n    }\n    for (const [color, theme2] of Object.entries(themesObject)) {\n      if (typeof theme2 === \"string\" && !loadedThemes.includes(theme2) && !isSpecialTheme(theme2)) {\n        if (bundledThemes[theme2]) {\n          await shiki2.loadTheme(bundledThemes[theme2]);\n        } else {\n          if (process.dev) {\n            console.warn(`[@nuxtjs/mdc] Theme \"${theme2}\" is not loaded to the Shiki highlighter. Add the theme to \"mdc.highlight.themes\" to fix this.`);\n          }\n          themesObject[color] = \"none\";\n        }\n      }\n    }\n    const transformersMap = /* @__PURE__ */ new Map();\n    for (const transformer of baseTransformers) {\n      transformersMap.set(transformer.name || `transformer:${Math.random()}-${transformer.constructor.name}`, transformer);\n    }\n    for (const config of await getConfigs()) {\n      const newTransformers = typeof config.shiki?.transformers === \"function\" ? await config.shiki?.transformers(code, lang, theme, options) : config.shiki?.transformers || [];\n      for (const transformer of newTransformers) {\n        transformersMap.set(transformer.name || `transformer:${Math.random()}-${transformer.constructor.name}`, transformer);\n      }\n    }\n    const root = shiki2.codeToHast(code.trimEnd(), {\n      lang,\n      ...codeToHastOptions,\n      themes: themesObject,\n      transformers: [\n        ...transformersMap.values(),\n        {\n          name: \"mdc:highlight\",\n          line(node, line) {\n            if (options.highlights?.includes(line))\n              addClassToHast(node, \"highlight\");\n            node.properties.line = line;\n          }\n        },\n        {\n          name: \"mdc:newline\",\n          line(node) {\n            if (code?.includes(\"\\n\")) {\n              if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === \"element\" && node.children[0].children.length === 1 && node.children[0].children[0].type === \"text\" && node.children[0].children[0].value === \"\") {\n                node.children = [{\n                  type: \"element\",\n                  tagName: \"span\",\n                  properties: {\n                    emptyLinePlaceholder: true\n                  },\n                  children: [{ type: \"text\", value: \"\\n\" }]\n                }];\n                return;\n              }\n              const last = node.children.at(-1);\n              if (last?.type === \"element\" && last.tagName === \"span\") {\n                const text = last.children.at(-1);\n                if (text?.type === \"text\")\n                  text.value += \"\\n\";\n              }\n            }\n          }\n        }\n      ]\n    });\n    const preEl = root.children[0];\n    const codeEl = preEl.children[0];\n    const wrapperStyle = shikiOptions?.wrapperStyle;\n    preEl.properties.style = wrapperStyle ? typeof wrapperStyle === \"string\" ? wrapperStyle : preEl.properties.style : \"\";\n    const styles = [];\n    Object.keys(themesObject).forEach((color) => {\n      const colorScheme = color !== \"default\" ? `.${color}` : \"\";\n      styles.push(\n        wrapperStyle ? `${colorScheme} .shiki,` : \"\",\n        `html .${color} .shiki span {`,\n        `color: var(--shiki-${color});`,\n        `background: var(--shiki-${color}-bg);`,\n        `font-style: var(--shiki-${color}-font-style);`,\n        `font-weight: var(--shiki-${color}-font-weight);`,\n        `text-decoration: var(--shiki-${color}-text-decoration);`,\n        \"}\"\n      );\n      styles.push(\n        `html${colorScheme} .shiki span {`,\n        `color: var(--shiki-${color});`,\n        `background: var(--shiki-${color}-bg);`,\n        `font-style: var(--shiki-${color}-font-style);`,\n        `font-weight: var(--shiki-${color}-font-weight);`,\n        `text-decoration: var(--shiki-${color}-text-decoration);`,\n        \"}\"\n      );\n    });\n    return {\n      tree: codeEl.children,\n      className: Array.isArray(preEl.properties.class) ? preEl.properties.class.join(\" \") : preEl.properties.class,\n      inlineStyle: preEl.properties.style,\n      style: styles.join(\"\")\n    };\n  };\n  return highlighter;\n}\n","export function createCachedParser(parserOptions) {\n  let processor;\n  let lastValue = \"\";\n  let lastParse;\n  return async function parse(value) {\n    if (!processor) {\n      processor = await import(\"@nuxtjs/mdc/runtime\").then((m) => m.createParseProcessor({\n        ...parserOptions,\n        keepPosition: true\n      }));\n    }\n    if (!value.startsWith(lastValue)) {\n      lastValue = \"\";\n      lastParse = void 0;\n    }\n    let startOffset = 0;\n    if (lastParse?.body?.children.length && lastParse.body.children.length > 1) {\n      const lastCompleteNode = lastParse.body.children[lastParse.body.children.length - 2];\n      if (lastCompleteNode?.position?.end) {\n        startOffset = lastCompleteNode.position.end;\n      }\n    }\n    const processorResult = await processor.process({ value: value.slice(startOffset) });\n    const result = processorResult?.result;\n    if (result) {\n      const body = {\n        type: \"root\",\n        children: [\n          ...startOffset > 0 ? lastParse?.body?.children.slice(0, -1) || [] : [],\n          ...result.body.children.map((child) => ({\n            ...child,\n            position: child.position && {\n              start: child.position.start + startOffset,\n              end: child.position.end + startOffset\n            }\n          }))\n        ]\n      };\n      lastParse = { ...result, body };\n      lastValue = value;\n      return lastParse;\n    }\n  };\n}\n"],"file":"_nuxt/Bx_jB_uy.js"}