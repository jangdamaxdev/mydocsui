{"version":3,"file":"_ErfU1uW.js","names":["projection","clamp","observe","unobserve","clampAxisDelta","__DEV__","feedWheel","updateOptions","publishWheel","shouldPreventDefault","processWheelEventData","mergeScrollPointsCalcVelocity","updateStartVelocity","updateVelocity","updateWillEndTimeout","accelerationFactorInMomentumRange","detectMomentum","recognizedMomentum","start","end","cleanup","WheelGestures"],"sources":["../../node_modules/.cache/.pnpm/wheel-gestures@2.2.48/node_modules/wheel-gestures/dist/wheel-gestures.esm.js","../../node_modules/.cache/.pnpm/embla-carousel-wheel-gestures@8.1.0_embla-carousel@8.6.0/node_modules/embla-carousel-wheel-gestures/dist/embla-carousel-wheel-gestures.esm.js"],"sourcesContent":["function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar DECAY = 0.996;\n/**\n * movement projection based on velocity\n * @param velocityPxMs\n * @param decay\n */\n\nvar projection = function projection(velocityPxMs, decay) {\n  if (decay === void 0) {\n    decay = DECAY;\n  }\n\n  return velocityPxMs * decay / (1 - decay);\n};\n\nfunction lastOf(array) {\n  return array[array.length - 1];\n}\nfunction average(numbers) {\n  return numbers.reduce(function (a, b) {\n    return a + b;\n  }) / numbers.length;\n}\nvar clamp = function clamp(value, min, max) {\n  return Math.min(Math.max(min, value), max);\n};\nfunction addVectors(v1, v2) {\n  if (v1.length !== v2.length) {\n    throw new Error('vectors must be same length');\n  }\n\n  return v1.map(function (val, i) {\n    return val + v2[i];\n  });\n}\nfunction absMax(numbers) {\n  return Math.max.apply(Math, numbers.map(Math.abs));\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction deepFreeze(o) {\n  Object.freeze(o);\n  Object.values(o).forEach(function (value) {\n    if (value !== null && typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  });\n  return o;\n}\n\nfunction EventBus() {\n  var listeners = {};\n\n  function on(type, listener) {\n    listeners[type] = (listeners[type] || []).concat(listener);\n    return function () {\n      return off(type, listener);\n    };\n  }\n\n  function off(type, listener) {\n    listeners[type] = (listeners[type] || []).filter(function (l) {\n      return l !== listener;\n    });\n  }\n\n  function dispatch(type, data) {\n    if (!(type in listeners)) return;\n    listeners[type].forEach(function (l) {\n      return l(data);\n    });\n  }\n\n  return deepFreeze({\n    on: on,\n    off: off,\n    dispatch: dispatch\n  });\n}\n\nfunction WheelTargetObserver(eventListener) {\n  var targets = []; // add event listener to target element\n\n  var observe = function observe(target) {\n    target.addEventListener('wheel', eventListener, {\n      passive: false\n    });\n    targets.push(target);\n    return function () {\n      return unobserve(target);\n    };\n  }; /// remove event listener from target element\n\n\n  var unobserve = function unobserve(target) {\n    target.removeEventListener('wheel', eventListener);\n    targets = targets.filter(function (t) {\n      return t !== target;\n    });\n  }; // stops watching all of its target elements for visibility changes.\n\n\n  var disconnect = function disconnect() {\n    targets.forEach(unobserve);\n  };\n\n  return deepFreeze({\n    observe: observe,\n    unobserve: unobserve,\n    disconnect: disconnect\n  });\n}\n\nvar LINE_HEIGHT = 16 * 1.125;\nvar PAGE_HEIGHT = typeof window !== 'undefined' && window.innerHeight || 800;\nvar DELTA_MODE_UNIT = [1, LINE_HEIGHT, PAGE_HEIGHT];\nfunction normalizeWheel(e) {\n  var deltaX = e.deltaX * DELTA_MODE_UNIT[e.deltaMode];\n  var deltaY = e.deltaY * DELTA_MODE_UNIT[e.deltaMode];\n  var deltaZ = (e.deltaZ || 0) * DELTA_MODE_UNIT[e.deltaMode];\n  return {\n    timeStamp: e.timeStamp,\n    axisDelta: [deltaX, deltaY, deltaZ]\n  };\n}\nvar reverseAll = [-1, -1, -1];\nfunction reverseAxisDeltaSign(wheel, reverseSign) {\n  if (!reverseSign) {\n    return wheel;\n  }\n\n  var multipliers = reverseSign === true ? reverseAll : reverseSign.map(function (shouldReverse) {\n    return shouldReverse ? -1 : 1;\n  });\n  return _extends({}, wheel, {\n    axisDelta: wheel.axisDelta.map(function (delta, i) {\n      return delta * multipliers[i];\n    })\n  });\n}\nvar DELTA_MAX_ABS = 700;\nvar clampAxisDelta = function clampAxisDelta(wheel) {\n  return _extends({}, wheel, {\n    axisDelta: wheel.axisDelta.map(function (delta) {\n      return clamp(delta, -DELTA_MAX_ABS, DELTA_MAX_ABS);\n    })\n  });\n};\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\nvar ACC_FACTOR_MIN = 0.6;\nvar ACC_FACTOR_MAX = 0.96;\nvar WHEELEVENTS_TO_MERGE = 2;\nvar WHEELEVENTS_TO_ANALAZE = 5;\n\nvar configDefaults = /*#__PURE__*/deepFreeze({\n  preventWheelAction: true,\n  reverseSign: [true, true, false]\n});\n\nvar WILL_END_TIMEOUT_DEFAULT = 400;\nfunction createWheelGesturesState() {\n  return {\n    isStarted: false,\n    isStartPublished: false,\n    isMomentum: false,\n    startTime: 0,\n    lastAbsDelta: Infinity,\n    axisMovement: [0, 0, 0],\n    axisVelocity: [0, 0, 0],\n    accelerationFactors: [],\n    scrollPoints: [],\n    scrollPointsToMerge: [],\n    willEndTimeout: WILL_END_TIMEOUT_DEFAULT\n  };\n}\n\nfunction WheelGestures(optionsParam) {\n  if (optionsParam === void 0) {\n    optionsParam = {};\n  }\n\n  var _EventBus = EventBus(),\n      on = _EventBus.on,\n      off = _EventBus.off,\n      dispatch = _EventBus.dispatch;\n\n  var config = configDefaults;\n  var state = createWheelGesturesState();\n  var currentEvent;\n  var negativeZeroFingerUpSpecialEvent = false;\n  var prevWheelEventState;\n\n  var feedWheel = function feedWheel(wheelEvents) {\n    if (Array.isArray(wheelEvents)) {\n      wheelEvents.forEach(function (wheelEvent) {\n        return processWheelEventData(wheelEvent);\n      });\n    } else {\n      processWheelEventData(wheelEvents);\n    }\n  };\n\n  var updateOptions = function updateOptions(newOptions) {\n    if (newOptions === void 0) {\n      newOptions = {};\n    }\n\n    if (Object.values(newOptions).some(function (option) {\n      return option === undefined || option === null;\n    })) {\n      __DEV__ && console.error('updateOptions ignored! undefined & null options not allowed');\n      return config;\n    }\n\n    return config = deepFreeze(_extends({}, configDefaults, config, newOptions));\n  };\n\n  var publishWheel = function publishWheel(additionalData) {\n    var wheelEventState = _extends({\n      event: currentEvent,\n      isStart: false,\n      isEnding: false,\n      isMomentumCancel: false,\n      isMomentum: state.isMomentum,\n      axisDelta: [0, 0, 0],\n      axisVelocity: state.axisVelocity,\n      axisMovement: state.axisMovement,\n\n      get axisMovementProjection() {\n        return addVectors(wheelEventState.axisMovement, wheelEventState.axisVelocity.map(function (velocity) {\n          return projection(velocity);\n        }));\n      }\n\n    }, additionalData);\n\n    dispatch('wheel', _extends({}, wheelEventState, {\n      previous: prevWheelEventState\n    })); // keep reference without previous, otherwise we would create a long chain\n\n    prevWheelEventState = wheelEventState;\n  }; // should prevent when there is mainly movement on the desired axis\n\n\n  var shouldPreventDefault = function shouldPreventDefault(deltaMaxAbs, axisDelta) {\n    var _config = config,\n        preventWheelAction = _config.preventWheelAction;\n    var deltaX = axisDelta[0],\n        deltaY = axisDelta[1],\n        deltaZ = axisDelta[2];\n    if (typeof preventWheelAction === 'boolean') return preventWheelAction;\n\n    switch (preventWheelAction) {\n      case 'x':\n        return Math.abs(deltaX) >= deltaMaxAbs;\n\n      case 'y':\n        return Math.abs(deltaY) >= deltaMaxAbs;\n\n      case 'z':\n        return Math.abs(deltaZ) >= deltaMaxAbs;\n\n      default:\n        __DEV__ && console.warn('unsupported preventWheelAction value: ' + preventWheelAction, 'warn');\n        return false;\n    }\n  };\n\n  var processWheelEventData = function processWheelEventData(wheelEvent) {\n    var _clampAxisDelta = clampAxisDelta(reverseAxisDeltaSign(normalizeWheel(wheelEvent), config.reverseSign)),\n        axisDelta = _clampAxisDelta.axisDelta,\n        timeStamp = _clampAxisDelta.timeStamp;\n\n    var deltaMaxAbs = absMax(axisDelta);\n\n    if (wheelEvent.preventDefault && shouldPreventDefault(deltaMaxAbs, axisDelta)) {\n      wheelEvent.preventDefault();\n    }\n\n    if (!state.isStarted) {\n      start();\n    } // check if user started scrolling again -> cancel\n    else if (state.isMomentum && deltaMaxAbs > Math.max(2, state.lastAbsDelta * 2)) {\n        end(true);\n        start();\n      } // special finger up event on windows + blink\n\n\n    if (deltaMaxAbs === 0 && Object.is && Object.is(wheelEvent.deltaX, -0)) {\n      negativeZeroFingerUpSpecialEvent = true; // return -> zero delta event should not influence velocity\n\n      return;\n    }\n\n    currentEvent = wheelEvent;\n    state.axisMovement = addVectors(state.axisMovement, axisDelta);\n    state.lastAbsDelta = deltaMaxAbs;\n    state.scrollPointsToMerge.push({\n      axisDelta: axisDelta,\n      timeStamp: timeStamp\n    });\n    mergeScrollPointsCalcVelocity(); // only wheel event (move) and not start/end get the delta values\n\n    publishWheel({\n      axisDelta: axisDelta,\n      isStart: !state.isStartPublished\n    }); // state.isMomentum ? MOMENTUM_WHEEL : WHEEL, { axisDelta })\n    // publish start after velocity etc. have been updated\n\n    state.isStartPublished = true; // calc debounced end function, to recognize end of wheel event stream\n\n    willEnd();\n  };\n\n  var mergeScrollPointsCalcVelocity = function mergeScrollPointsCalcVelocity() {\n    if (state.scrollPointsToMerge.length === WHEELEVENTS_TO_MERGE) {\n      state.scrollPoints.unshift({\n        axisDeltaSum: state.scrollPointsToMerge.map(function (b) {\n          return b.axisDelta;\n        }).reduce(addVectors),\n        timeStamp: average(state.scrollPointsToMerge.map(function (b) {\n          return b.timeStamp;\n        }))\n      }); // only update velocity after a merged scrollpoint was generated\n\n      updateVelocity(); // reset toMerge array\n\n      state.scrollPointsToMerge.length = 0; // after calculation of velocity only keep the most recent merged scrollPoint\n\n      state.scrollPoints.length = 1;\n\n      if (!state.isMomentum) {\n        detectMomentum();\n      }\n    } else if (!state.isStartPublished) {\n      updateStartVelocity();\n    }\n  };\n\n  var updateStartVelocity = function updateStartVelocity() {\n    state.axisVelocity = lastOf(state.scrollPointsToMerge).axisDelta.map(function (d) {\n      return d / state.willEndTimeout;\n    });\n  };\n\n  var updateVelocity = function updateVelocity() {\n    // need to have two recent points to calc velocity\n    var _state$scrollPoints = state.scrollPoints,\n        latestScrollPoint = _state$scrollPoints[0],\n        prevScrollPoint = _state$scrollPoints[1];\n\n    if (!prevScrollPoint || !latestScrollPoint) {\n      return;\n    } // time delta\n\n\n    var deltaTime = latestScrollPoint.timeStamp - prevScrollPoint.timeStamp;\n\n    if (deltaTime <= 0) {\n      __DEV__ && console.warn('invalid deltaTime');\n      return;\n    } // calc the velocity per axes\n\n\n    var velocity = latestScrollPoint.axisDeltaSum.map(function (d) {\n      return d / deltaTime;\n    }); // calc the acceleration factor per axis\n\n    var accelerationFactor = velocity.map(function (v, i) {\n      return v / (state.axisVelocity[i] || 1);\n    });\n    state.axisVelocity = velocity;\n    state.accelerationFactors.push(accelerationFactor);\n    updateWillEndTimeout(deltaTime);\n  };\n\n  var updateWillEndTimeout = function updateWillEndTimeout(deltaTime) {\n    // use current time between events rounded up and increased by a bit as timeout\n    var newTimeout = Math.ceil(deltaTime / 10) * 10 * 1.2; // double the timeout, when momentum was not detected yet\n\n    if (!state.isMomentum) {\n      newTimeout = Math.max(100, newTimeout * 2);\n    }\n\n    state.willEndTimeout = Math.min(1000, Math.round(newTimeout));\n  };\n\n  var accelerationFactorInMomentumRange = function accelerationFactorInMomentumRange(accFactor) {\n    // when main axis is the the other one and there is no movement/change on the current one\n    if (accFactor === 0) return true;\n    return accFactor <= ACC_FACTOR_MAX && accFactor >= ACC_FACTOR_MIN;\n  };\n\n  var detectMomentum = function detectMomentum() {\n    if (state.accelerationFactors.length >= WHEELEVENTS_TO_ANALAZE) {\n      if (negativeZeroFingerUpSpecialEvent) {\n        negativeZeroFingerUpSpecialEvent = false;\n\n        if (absMax(state.axisVelocity) >= 0.2) {\n          recognizedMomentum();\n          return;\n        }\n      }\n\n      var recentAccelerationFactors = state.accelerationFactors.slice(WHEELEVENTS_TO_ANALAZE * -1); // check recent acceleration / deceleration factors\n      // all recent need to match, if any did not match\n\n      var detectedMomentum = recentAccelerationFactors.every(function (accFac) {\n        // when both axis decelerate exactly in the same rate it is very likely caused by momentum\n        var sameAccFac = !!accFac.reduce(function (f1, f2) {\n          return f1 && f1 < 1 && f1 === f2 ? 1 : 0;\n        }); // check if acceleration factor is within momentum range\n\n        var bothAreInRangeOrZero = accFac.filter(accelerationFactorInMomentumRange).length === accFac.length; // one the requirements must be fulfilled\n\n        return sameAccFac || bothAreInRangeOrZero;\n      });\n\n      if (detectedMomentum) {\n        recognizedMomentum();\n      } // only keep the most recent events\n\n\n      state.accelerationFactors = recentAccelerationFactors;\n    }\n  };\n\n  var recognizedMomentum = function recognizedMomentum() {\n    state.isMomentum = true;\n  };\n\n  var start = function start() {\n    state = createWheelGesturesState();\n    state.isStarted = true;\n    state.startTime = Date.now();\n    prevWheelEventState = undefined;\n    negativeZeroFingerUpSpecialEvent = false;\n  };\n\n  var willEnd = function () {\n    var willEndId;\n    return function () {\n      clearTimeout(willEndId);\n      willEndId = setTimeout(end, state.willEndTimeout);\n    };\n  }();\n\n  var end = function end(isMomentumCancel) {\n    if (isMomentumCancel === void 0) {\n      isMomentumCancel = false;\n    }\n\n    if (!state.isStarted) return;\n\n    if (state.isMomentum && isMomentumCancel) {\n      publishWheel({\n        isEnding: true,\n        isMomentumCancel: true\n      });\n    } else {\n      publishWheel({\n        isEnding: true\n      });\n    }\n\n    state.isMomentum = false;\n    state.isStarted = false;\n  };\n\n  var _WheelTargetObserver = WheelTargetObserver(feedWheel),\n      observe = _WheelTargetObserver.observe,\n      unobserve = _WheelTargetObserver.unobserve,\n      disconnect = _WheelTargetObserver.disconnect;\n\n  updateOptions(optionsParam);\n  return deepFreeze({\n    on: on,\n    off: off,\n    observe: observe,\n    unobserve: unobserve,\n    disconnect: disconnect,\n    feedWheel: feedWheel,\n    updateOptions: updateOptions\n  });\n}\n\nexport default WheelGestures;\nexport { WheelGestures, absMax, addVectors, average, clamp, configDefaults, deepFreeze, lastOf, projection };\n//# sourceMappingURL=wheel-gestures.esm.js.map\n","import WheelGestures from 'wheel-gestures';\n\nvar defaultOptions = {\n  active: true,\n  breakpoints: {},\n  wheelDraggingClass: 'is-wheel-dragging',\n  forceWheelAxis: undefined,\n  target: undefined\n};\nWheelGesturesPlugin.globalOptions = undefined;\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nfunction WheelGesturesPlugin(userOptions) {\n  if (userOptions === void 0) {\n    userOptions = {};\n  }\n\n  var options;\n\n  var cleanup = function cleanup() {};\n\n  function init(embla, optionsHandler) {\n    var _options$target, _options$forceWheelAx;\n\n    var mergeOptions = optionsHandler.mergeOptions,\n        optionsAtMedia = optionsHandler.optionsAtMedia;\n    var optionsBase = mergeOptions(defaultOptions, WheelGesturesPlugin.globalOptions);\n    var allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    var engine = embla.internalEngine();\n    var targetNode = (_options$target = options.target) != null ? _options$target : embla.containerNode().parentNode;\n    var wheelAxis = (_options$forceWheelAx = options.forceWheelAxis) != null ? _options$forceWheelAx : engine.options.axis;\n    var wheelGestures = WheelGestures({\n      preventWheelAction: wheelAxis,\n      reverseSign: [true, true, false]\n    });\n\n    function updateSizeRelatedVariables() {\n      scrollBoundaryThreshold = (wheelAxis === 'x' ? engine.containerRect.width : engine.containerRect.height) / 2;\n    }\n\n    var unobserveTargetNode = wheelGestures.observe(targetNode);\n    var offWheel = wheelGestures.on('wheel', handleWheel);\n    var isStarted = false;\n    var startEvent;\n    var overBoundaryAccumulation = 0;\n    var scrollBoundaryThreshold = 0;\n    var blockedWaitUntilGestureEnd = false;\n    updateSizeRelatedVariables();\n    embla.on('resize', updateSizeRelatedVariables);\n\n    function wheelGestureStarted(state) {\n      try {\n        startEvent = new MouseEvent('mousedown', state.event);\n        dispatchEvent(startEvent);\n      } catch (e) {\n        // Legacy Browsers like IE 10 & 11 will throw when attempting to create the Event\n        if (__DEV__) {\n          console.warn('Legacy browser requires events-polyfill (https://github.com/xiel/embla-carousel-wheel-gestures#legacy-browsers)');\n        }\n\n        return cleanup();\n      }\n\n      isStarted = true;\n      overBoundaryAccumulation = 0;\n      addNativeMouseEventListeners();\n\n      if (options.wheelDraggingClass) {\n        targetNode.classList.add(options.wheelDraggingClass);\n      }\n    }\n\n    function wheelGestureEnded(state) {\n      isStarted = false;\n      dispatchEvent(createRelativeMouseEvent('mouseup', state));\n      removeNativeMouseEventListeners();\n\n      if (options.wheelDraggingClass) {\n        targetNode.classList.remove(options.wheelDraggingClass);\n      }\n    }\n\n    function addNativeMouseEventListeners() {\n      document.documentElement.addEventListener('mousemove', preventNativeMouseHandler, true);\n      document.documentElement.addEventListener('mouseup', preventNativeMouseHandler, true);\n      document.documentElement.addEventListener('mousedown', preventNativeMouseHandler, true);\n    }\n\n    function removeNativeMouseEventListeners() {\n      document.documentElement.removeEventListener('mousemove', preventNativeMouseHandler, true);\n      document.documentElement.removeEventListener('mouseup', preventNativeMouseHandler, true);\n      document.documentElement.removeEventListener('mousedown', preventNativeMouseHandler, true);\n    }\n\n    function preventNativeMouseHandler(e) {\n      if (isStarted && e.isTrusted) {\n        e.stopImmediatePropagation();\n      }\n    }\n\n    function createRelativeMouseEvent(type, state) {\n      var moveX, moveY;\n\n      if (wheelAxis === engine.options.axis) {\n        var _state$axisMovement = state.axisMovement;\n        moveX = _state$axisMovement[0];\n        moveY = _state$axisMovement[1];\n      } else {\n        var _state$axisMovement2 = state.axisMovement;\n        moveY = _state$axisMovement2[0];\n        moveX = _state$axisMovement2[1];\n      }\n\n      var _checkIfAtBoundary = checkIfAtBoundary(state),\n          isAtBoundary = _checkIfAtBoundary.isAtBoundary; // Apply progressive rubber band damping when at boundaries\n\n\n      if (isAtBoundary) {\n        // Calculate progressive damping factor based on how far over boundary we are\n        var progressRatio = Math.min(overBoundaryAccumulation / scrollBoundaryThreshold, 1);\n        var dampingFactor = 0.25 + progressRatio * 0.5;\n        var counterMoveSign = moveX > 0 ? -1 : 1;\n        var counterMovement = overBoundaryAccumulation * counterMoveSign;\n        var dampingMovement = counterMovement * dampingFactor;\n        moveX += dampingMovement;\n        moveY += dampingMovement;\n      } // prevent skipping slides\n\n\n      if (!engine.options.skipSnaps && !engine.options.dragFree) {\n        var maxX = engine.containerRect.width;\n        var maxY = engine.containerRect.height;\n        moveX = moveX < 0 ? Math.max(moveX, -maxX) : Math.min(moveX, maxX);\n        moveY = moveY < 0 ? Math.max(moveY, -maxY) : Math.min(moveY, maxY);\n      }\n\n      return new MouseEvent(type, {\n        clientX: startEvent.clientX + moveX,\n        clientY: startEvent.clientY + moveY,\n        screenX: startEvent.screenX + moveX,\n        screenY: startEvent.screenY + moveY,\n        movementX: moveX,\n        movementY: moveY,\n        button: 0,\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n    }\n\n    function dispatchEvent(event) {\n      embla.containerNode().dispatchEvent(event);\n    }\n\n    function checkIfAtBoundary(state) {\n      var _state$axisDelta = state.axisDelta,\n          deltaX = _state$axisDelta[0],\n          deltaY = _state$axisDelta[1];\n      var scrollProgress = embla.scrollProgress();\n      var canScrollNext = scrollProgress < 1;\n      var canScrollPrev = scrollProgress > 0;\n      var primaryAxisDelta = wheelAxis === 'x' ? deltaX : deltaY;\n      var isScrollingNext = primaryAxisDelta < 0;\n      var isScrollingPrev = primaryAxisDelta > 0;\n      var isAtBoundary = isScrollingNext && !canScrollNext || isScrollingPrev && !canScrollPrev;\n      return {\n        isAtBoundary: isAtBoundary,\n        primaryAxisDelta: primaryAxisDelta\n      };\n    }\n\n    function isBoundaryThresholdReached(state) {\n      var _checkIfAtBoundary2 = checkIfAtBoundary(state),\n          isAtBoundary = _checkIfAtBoundary2.isAtBoundary,\n          primaryAxisDelta = _checkIfAtBoundary2.primaryAxisDelta;\n\n      if (isAtBoundary && !state.isMomentum) {\n        overBoundaryAccumulation += Math.abs(primaryAxisDelta); // End gesture if we exceed the threshold\n\n        if (overBoundaryAccumulation > scrollBoundaryThreshold) {\n          blockedWaitUntilGestureEnd = true;\n          wheelGestureEnded(state);\n          return true;\n        }\n      } else {\n        // Reset accumulation when we can scroll or when not at boundary\n        overBoundaryAccumulation = 0;\n      }\n\n      return false;\n    }\n\n    function handleWheel(state) {\n      var _state$axisDelta2 = state.axisDelta,\n          deltaX = _state$axisDelta2[0],\n          deltaY = _state$axisDelta2[1];\n      var primaryAxisDelta = wheelAxis === 'x' ? deltaX : deltaY;\n      var crossAxisDelta = wheelAxis === 'x' ? deltaY : deltaX;\n      var isRelease = state.isMomentum && state.previous && !state.previous.isMomentum;\n      var isEndingOrRelease = state.isEnding && !state.isMomentum || isRelease;\n      var primaryAxisDeltaIsDominant = Math.abs(primaryAxisDelta) > Math.abs(crossAxisDelta);\n\n      if (primaryAxisDeltaIsDominant && !isStarted && !state.isMomentum && !blockedWaitUntilGestureEnd) {\n        wheelGestureStarted(state);\n      }\n\n      if (blockedWaitUntilGestureEnd && state.isEnding) {\n        blockedWaitUntilGestureEnd = false;\n      }\n\n      if (!isStarted) return;\n      if (isBoundaryThresholdReached(state)) return;\n\n      if (isEndingOrRelease) {\n        wheelGestureEnded(state);\n      } else {\n        dispatchEvent(createRelativeMouseEvent('mousemove', state));\n      }\n    }\n\n    cleanup = function cleanup() {\n      unobserveTargetNode();\n      offWheel();\n      embla.off('resize', updateSizeRelatedVariables);\n      removeNativeMouseEventListeners();\n    };\n  }\n\n  var self = {\n    name: 'wheelGestures',\n    options: userOptions,\n    init: init,\n    destroy: function destroy() {\n      return cleanup();\n    }\n  };\n  return self;\n}\n\nexport default WheelGesturesPlugin;\nexport { WheelGesturesPlugin };\n//# sourceMappingURL=embla-carousel-wheel-gestures.esm.js.map\n"],"x_google_ignoreList":[0,1],"mappings":"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"}